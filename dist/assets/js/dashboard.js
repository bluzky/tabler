/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/ 		return result;
/******/ 	}
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadUpdateChunk(chunkId) {
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		;
/******/ 		head.appendChild(script);
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadManifest(requestTimeout) {
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if (typeof XMLHttpRequest === "undefined")
/******/ 				return reject(new Error("No browser support"));
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch (err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if (request.readyState !== 4) return;
/******/ 				if (request.status === 0) {
/******/ 					// timeout
/******/ 					reject(
/******/ 						new Error("Manifest request to " + requestPath + " timed out.")
/******/ 					);
/******/ 				} else if (request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if (request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch (e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "e3651290256c72799b45"; // eslint-disable-line no-unused-vars
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if (!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if (me.hot.active) {
/******/ 				if (installedModules[request]) {
/******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if (me.children.indexOf(request) === -1) me.children.push(request);
/******/ 			} else {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" +
/******/ 						request +
/******/ 						") from disposed module " +
/******/ 						moduleId
/******/ 				);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for (var name in __webpack_require__) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
/******/ 				name !== "e"
/******/ 			) {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if (hotStatus === "prepare") {
/******/ 					if (!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if (typeof dep === "undefined") hot._selfAccepted = true;
/******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if (typeof dep === "undefined") hot._selfDeclined = true;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if (!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = +id + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if (hotStatus !== "idle")
/******/ 			throw new Error("check() is only allowed in idle status");
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if (!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			for(var chunkId in installedChunks)
/******/ 			{
/******/ 				// eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if (
/******/ 				hotStatus === "prepare" &&
/******/ 				hotChunksLoading === 0 &&
/******/ 				hotWaitingFiles === 0
/******/ 			) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for (var moduleId in moreModules) {
/******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if (!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if (!deferred) return;
/******/ 		if (hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve()
/******/ 				.then(function() {
/******/ 					return hotApply(hotApplyOnUpdate);
/******/ 				})
/******/ 				.then(
/******/ 					function(result) {
/******/ 						deferred.resolve(result);
/******/ 					},
/******/ 					function(err) {
/******/ 						deferred.reject(err);
/******/ 					}
/******/ 				);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for (var id in hotUpdate) {
/******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if (hotStatus !== "ready")
/******/ 			throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while (queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if (!module || module.hot._selfAccepted) continue;
/******/ 				if (module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if (module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for (var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if (!parent) continue;
/******/ 					if (parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if (!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for (var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if (a.indexOf(item) === -1) a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn(
/******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
/******/ 			);
/******/ 		};
/******/
/******/ 		for (var id in hotUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				/** @type {TODO} */
/******/ 				var result;
/******/ 				if (hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				/** @type {Error|false} */
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if (result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch (result.type) {
/******/ 					case "self-declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of self decline: " +
/******/ 									result.moduleId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of declined dependency: " +
/******/ 									result.moduleId +
/******/ 									" in " +
/******/ 									result.parentId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 						if (!options.ignoreUnaccepted)
/******/ 							abortError = new Error(
/******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if (options.onAccepted) options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if (options.onDisposed) options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if (abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if (doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for (moduleId in result.outdatedDependencies) {
/******/ 						if (
/******/ 							Object.prototype.hasOwnProperty.call(
/******/ 								result.outdatedDependencies,
/******/ 								moduleId
/******/ 							)
/******/ 						) {
/******/ 							if (!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(
/******/ 								outdatedDependencies[moduleId],
/******/ 								result.outdatedDependencies[moduleId]
/******/ 							);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if (doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for (i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if (
/******/ 				installedModules[moduleId] &&
/******/ 				installedModules[moduleId].hot._selfAccepted
/******/ 			)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if (hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while (queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if (!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for (j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for (j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if (!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if (idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if (idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/
/******/ 		// insert new code
/******/ 		for (moduleId in appliedUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if (cb) {
/******/ 							if (callbacks.indexOf(cb) !== -1) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for (i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch (err) {
/******/ 							if (options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if (!options.ignoreErrored) {
/******/ 								if (!error) error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch (err) {
/******/ 				if (typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch (err2) {
/******/ 						if (options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if (!options.ignoreErrored) {
/******/ 							if (!error) error = err2;
/******/ 						}
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if (options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if (!options.ignoreErrored) {
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if (error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"dashboard": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/assets/";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push(["./dashboard.js","vendor"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../node_modules/bootstrap/dist/js/bootstrap.js":
/*!**************************************************************************!*\
  !*** /Users/flex/Lab/tabler/node_modules/bootstrap/dist/js/bootstrap.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
  * Bootstrap v4.1.1 (https://getbootstrap.com/)
  * Copyright 2011-2018 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  */
(function (global, factory) {
   true ? factory(exports, __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! popper.js */ "../../../node_modules/popper.js/dist/esm/popper.js")) :
  undefined;
}(this, (function (exports,$,Popper) { 'use strict';

  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;
  Popper = Popper && Popper.hasOwnProperty('default') ? Popper['default'] : Popper;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.1.1): util.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Util = function ($$$1) {
    /**
     * ------------------------------------------------------------------------
     * Private TransitionEnd Helpers
     * ------------------------------------------------------------------------
     */
    var TRANSITION_END = 'transitionend';
    var MAX_UID = 1000000;
    var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

    function toType(obj) {
      return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
    }

    function getSpecialTransitionEndEvent() {
      return {
        bindType: TRANSITION_END,
        delegateType: TRANSITION_END,
        handle: function handle(event) {
          if ($$$1(event.target).is(this)) {
            return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
          }

          return undefined; // eslint-disable-line no-undefined
        }
      };
    }

    function transitionEndEmulator(duration) {
      var _this = this;

      var called = false;
      $$$1(this).one(Util.TRANSITION_END, function () {
        called = true;
      });
      setTimeout(function () {
        if (!called) {
          Util.triggerTransitionEnd(_this);
        }
      }, duration);
      return this;
    }

    function setTransitionEndSupport() {
      $$$1.fn.emulateTransitionEnd = transitionEndEmulator;
      $$$1.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
    }
    /**
     * --------------------------------------------------------------------------
     * Public Util Api
     * --------------------------------------------------------------------------
     */


    var Util = {
      TRANSITION_END: 'bsTransitionEnd',
      getUID: function getUID(prefix) {
        do {
          // eslint-disable-next-line no-bitwise
          prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
        } while (document.getElementById(prefix));

        return prefix;
      },
      getSelectorFromElement: function getSelectorFromElement(element) {
        var selector = element.getAttribute('data-target');

        if (!selector || selector === '#') {
          selector = element.getAttribute('href') || '';
        }

        try {
          var $selector = $$$1(document).find(selector);
          return $selector.length > 0 ? selector : null;
        } catch (err) {
          return null;
        }
      },
      getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
        if (!element) {
          return 0;
        } // Get transition-duration of the element


        var transitionDuration = $$$1(element).css('transition-duration');
        var floatTransitionDuration = parseFloat(transitionDuration); // Return 0 if element or transition duration is not found

        if (!floatTransitionDuration) {
          return 0;
        } // If multiple durations are defined, take the first


        transitionDuration = transitionDuration.split(',')[0];
        return parseFloat(transitionDuration) * MILLISECONDS_MULTIPLIER;
      },
      reflow: function reflow(element) {
        return element.offsetHeight;
      },
      triggerTransitionEnd: function triggerTransitionEnd(element) {
        $$$1(element).trigger(TRANSITION_END);
      },
      // TODO: Remove in v5
      supportsTransitionEnd: function supportsTransitionEnd() {
        return Boolean(TRANSITION_END);
      },
      isElement: function isElement(obj) {
        return (obj[0] || obj).nodeType;
      },
      typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
        for (var property in configTypes) {
          if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
            var expectedTypes = configTypes[property];
            var value = config[property];
            var valueType = value && Util.isElement(value) ? 'element' : toType(value);

            if (!new RegExp(expectedTypes).test(valueType)) {
              throw new Error(componentName.toUpperCase() + ": " + ("Option \"" + property + "\" provided type \"" + valueType + "\" ") + ("but expected type \"" + expectedTypes + "\"."));
            }
          }
        }
      }
    };
    setTransitionEndSupport();
    return Util;
  }($);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.1.1): alert.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Alert = function ($$$1) {
    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */
    var NAME = 'alert';
    var VERSION = '4.1.1';
    var DATA_KEY = 'bs.alert';
    var EVENT_KEY = "." + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
    var Selector = {
      DISMISS: '[data-dismiss="alert"]'
    };
    var Event = {
      CLOSE: "close" + EVENT_KEY,
      CLOSED: "closed" + EVENT_KEY,
      CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
    };
    var ClassName = {
      ALERT: 'alert',
      FADE: 'fade',
      SHOW: 'show'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Alert =
    /*#__PURE__*/
    function () {
      function Alert(element) {
        this._element = element;
      } // Getters


      var _proto = Alert.prototype;

      // Public
      _proto.close = function close(element) {
        var rootElement = this._element;

        if (element) {
          rootElement = this._getRootElement(element);
        }

        var customEvent = this._triggerCloseEvent(rootElement);

        if (customEvent.isDefaultPrevented()) {
          return;
        }

        this._removeElement(rootElement);
      };

      _proto.dispose = function dispose() {
        $$$1.removeData(this._element, DATA_KEY);
        this._element = null;
      }; // Private


      _proto._getRootElement = function _getRootElement(element) {
        var selector = Util.getSelectorFromElement(element);
        var parent = false;

        if (selector) {
          parent = $$$1(selector)[0];
        }

        if (!parent) {
          parent = $$$1(element).closest("." + ClassName.ALERT)[0];
        }

        return parent;
      };

      _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
        var closeEvent = $$$1.Event(Event.CLOSE);
        $$$1(element).trigger(closeEvent);
        return closeEvent;
      };

      _proto._removeElement = function _removeElement(element) {
        var _this = this;

        $$$1(element).removeClass(ClassName.SHOW);

        if (!$$$1(element).hasClass(ClassName.FADE)) {
          this._destroyElement(element);

          return;
        }

        var transitionDuration = Util.getTransitionDurationFromElement(element);
        $$$1(element).one(Util.TRANSITION_END, function (event) {
          return _this._destroyElement(element, event);
        }).emulateTransitionEnd(transitionDuration);
      };

      _proto._destroyElement = function _destroyElement(element) {
        $$$1(element).detach().trigger(Event.CLOSED).remove();
      }; // Static


      Alert._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var $element = $$$1(this);
          var data = $element.data(DATA_KEY);

          if (!data) {
            data = new Alert(this);
            $element.data(DATA_KEY, data);
          }

          if (config === 'close') {
            data[config](this);
          }
        });
      };

      Alert._handleDismiss = function _handleDismiss(alertInstance) {
        return function (event) {
          if (event) {
            event.preventDefault();
          }

          alertInstance.close(this);
        };
      };

      _createClass(Alert, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION;
        }
      }]);

      return Alert;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $$$1(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $$$1.fn[NAME] = Alert._jQueryInterface;
    $$$1.fn[NAME].Constructor = Alert;

    $$$1.fn[NAME].noConflict = function () {
      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
      return Alert._jQueryInterface;
    };

    return Alert;
  }($);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.1.1): button.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Button = function ($$$1) {
    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */
    var NAME = 'button';
    var VERSION = '4.1.1';
    var DATA_KEY = 'bs.button';
    var EVENT_KEY = "." + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
    var ClassName = {
      ACTIVE: 'active',
      BUTTON: 'btn',
      FOCUS: 'focus'
    };
    var Selector = {
      DATA_TOGGLE_CARROT: '[data-toggle^="button"]',
      DATA_TOGGLE: '[data-toggle="buttons"]',
      INPUT: 'input',
      ACTIVE: '.active',
      BUTTON: '.btn'
    };
    var Event = {
      CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY,
      FOCUS_BLUR_DATA_API: "focus" + EVENT_KEY + DATA_API_KEY + " " + ("blur" + EVENT_KEY + DATA_API_KEY)
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Button =
    /*#__PURE__*/
    function () {
      function Button(element) {
        this._element = element;
      } // Getters


      var _proto = Button.prototype;

      // Public
      _proto.toggle = function toggle() {
        var triggerChangeEvent = true;
        var addAriaPressed = true;
        var rootElement = $$$1(this._element).closest(Selector.DATA_TOGGLE)[0];

        if (rootElement) {
          var input = $$$1(this._element).find(Selector.INPUT)[0];

          if (input) {
            if (input.type === 'radio') {
              if (input.checked && $$$1(this._element).hasClass(ClassName.ACTIVE)) {
                triggerChangeEvent = false;
              } else {
                var activeElement = $$$1(rootElement).find(Selector.ACTIVE)[0];

                if (activeElement) {
                  $$$1(activeElement).removeClass(ClassName.ACTIVE);
                }
              }
            }

            if (triggerChangeEvent) {
              if (input.hasAttribute('disabled') || rootElement.hasAttribute('disabled') || input.classList.contains('disabled') || rootElement.classList.contains('disabled')) {
                return;
              }

              input.checked = !$$$1(this._element).hasClass(ClassName.ACTIVE);
              $$$1(input).trigger('change');
            }

            input.focus();
            addAriaPressed = false;
          }
        }

        if (addAriaPressed) {
          this._element.setAttribute('aria-pressed', !$$$1(this._element).hasClass(ClassName.ACTIVE));
        }

        if (triggerChangeEvent) {
          $$$1(this._element).toggleClass(ClassName.ACTIVE);
        }
      };

      _proto.dispose = function dispose() {
        $$$1.removeData(this._element, DATA_KEY);
        this._element = null;
      }; // Static


      Button._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $$$1(this).data(DATA_KEY);

          if (!data) {
            data = new Button(this);
            $$$1(this).data(DATA_KEY, data);
          }

          if (config === 'toggle') {
            data[config]();
          }
        });
      };

      _createClass(Button, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION;
        }
      }]);

      return Button;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
      event.preventDefault();
      var button = event.target;

      if (!$$$1(button).hasClass(ClassName.BUTTON)) {
        button = $$$1(button).closest(Selector.BUTTON);
      }

      Button._jQueryInterface.call($$$1(button), 'toggle');
    }).on(Event.FOCUS_BLUR_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
      var button = $$$1(event.target).closest(Selector.BUTTON)[0];
      $$$1(button).toggleClass(ClassName.FOCUS, /^focus(in)?$/.test(event.type));
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $$$1.fn[NAME] = Button._jQueryInterface;
    $$$1.fn[NAME].Constructor = Button;

    $$$1.fn[NAME].noConflict = function () {
      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
      return Button._jQueryInterface;
    };

    return Button;
  }($);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.1.1): carousel.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Carousel = function ($$$1) {
    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */
    var NAME = 'carousel';
    var VERSION = '4.1.1';
    var DATA_KEY = 'bs.carousel';
    var EVENT_KEY = "." + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
    var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key

    var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key

    var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

    var Default = {
      interval: 5000,
      keyboard: true,
      slide: false,
      pause: 'hover',
      wrap: true
    };
    var DefaultType = {
      interval: '(number|boolean)',
      keyboard: 'boolean',
      slide: '(boolean|string)',
      pause: '(string|boolean)',
      wrap: 'boolean'
    };
    var Direction = {
      NEXT: 'next',
      PREV: 'prev',
      LEFT: 'left',
      RIGHT: 'right'
    };
    var Event = {
      SLIDE: "slide" + EVENT_KEY,
      SLID: "slid" + EVENT_KEY,
      KEYDOWN: "keydown" + EVENT_KEY,
      MOUSEENTER: "mouseenter" + EVENT_KEY,
      MOUSELEAVE: "mouseleave" + EVENT_KEY,
      TOUCHEND: "touchend" + EVENT_KEY,
      LOAD_DATA_API: "load" + EVENT_KEY + DATA_API_KEY,
      CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
    };
    var ClassName = {
      CAROUSEL: 'carousel',
      ACTIVE: 'active',
      SLIDE: 'slide',
      RIGHT: 'carousel-item-right',
      LEFT: 'carousel-item-left',
      NEXT: 'carousel-item-next',
      PREV: 'carousel-item-prev',
      ITEM: 'carousel-item'
    };
    var Selector = {
      ACTIVE: '.active',
      ACTIVE_ITEM: '.active.carousel-item',
      ITEM: '.carousel-item',
      NEXT_PREV: '.carousel-item-next, .carousel-item-prev',
      INDICATORS: '.carousel-indicators',
      DATA_SLIDE: '[data-slide], [data-slide-to]',
      DATA_RIDE: '[data-ride="carousel"]'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Carousel =
    /*#__PURE__*/
    function () {
      function Carousel(element, config) {
        this._items = null;
        this._interval = null;
        this._activeElement = null;
        this._isPaused = false;
        this._isSliding = false;
        this.touchTimeout = null;
        this._config = this._getConfig(config);
        this._element = $$$1(element)[0];
        this._indicatorsElement = $$$1(this._element).find(Selector.INDICATORS)[0];

        this._addEventListeners();
      } // Getters


      var _proto = Carousel.prototype;

      // Public
      _proto.next = function next() {
        if (!this._isSliding) {
          this._slide(Direction.NEXT);
        }
      };

      _proto.nextWhenVisible = function nextWhenVisible() {
        // Don't call next when the page isn't visible
        // or the carousel or its parent isn't visible
        if (!document.hidden && $$$1(this._element).is(':visible') && $$$1(this._element).css('visibility') !== 'hidden') {
          this.next();
        }
      };

      _proto.prev = function prev() {
        if (!this._isSliding) {
          this._slide(Direction.PREV);
        }
      };

      _proto.pause = function pause(event) {
        if (!event) {
          this._isPaused = true;
        }

        if ($$$1(this._element).find(Selector.NEXT_PREV)[0]) {
          Util.triggerTransitionEnd(this._element);
          this.cycle(true);
        }

        clearInterval(this._interval);
        this._interval = null;
      };

      _proto.cycle = function cycle(event) {
        if (!event) {
          this._isPaused = false;
        }

        if (this._interval) {
          clearInterval(this._interval);
          this._interval = null;
        }

        if (this._config.interval && !this._isPaused) {
          this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
        }
      };

      _proto.to = function to(index) {
        var _this = this;

        this._activeElement = $$$1(this._element).find(Selector.ACTIVE_ITEM)[0];

        var activeIndex = this._getItemIndex(this._activeElement);

        if (index > this._items.length - 1 || index < 0) {
          return;
        }

        if (this._isSliding) {
          $$$1(this._element).one(Event.SLID, function () {
            return _this.to(index);
          });
          return;
        }

        if (activeIndex === index) {
          this.pause();
          this.cycle();
          return;
        }

        var direction = index > activeIndex ? Direction.NEXT : Direction.PREV;

        this._slide(direction, this._items[index]);
      };

      _proto.dispose = function dispose() {
        $$$1(this._element).off(EVENT_KEY);
        $$$1.removeData(this._element, DATA_KEY);
        this._items = null;
        this._config = null;
        this._element = null;
        this._interval = null;
        this._isPaused = null;
        this._isSliding = null;
        this._activeElement = null;
        this._indicatorsElement = null;
      }; // Private


      _proto._getConfig = function _getConfig(config) {
        config = _objectSpread({}, Default, config);
        Util.typeCheckConfig(NAME, config, DefaultType);
        return config;
      };

      _proto._addEventListeners = function _addEventListeners() {
        var _this2 = this;

        if (this._config.keyboard) {
          $$$1(this._element).on(Event.KEYDOWN, function (event) {
            return _this2._keydown(event);
          });
        }

        if (this._config.pause === 'hover') {
          $$$1(this._element).on(Event.MOUSEENTER, function (event) {
            return _this2.pause(event);
          }).on(Event.MOUSELEAVE, function (event) {
            return _this2.cycle(event);
          });

          if ('ontouchstart' in document.documentElement) {
            // If it's a touch-enabled device, mouseenter/leave are fired as
            // part of the mouse compatibility events on first tap - the carousel
            // would stop cycling until user tapped out of it;
            // here, we listen for touchend, explicitly pause the carousel
            // (as if it's the second time we tap on it, mouseenter compat event
            // is NOT fired) and after a timeout (to allow for mouse compatibility
            // events to fire) we explicitly restart cycling
            $$$1(this._element).on(Event.TOUCHEND, function () {
              _this2.pause();

              if (_this2.touchTimeout) {
                clearTimeout(_this2.touchTimeout);
              }

              _this2.touchTimeout = setTimeout(function (event) {
                return _this2.cycle(event);
              }, TOUCHEVENT_COMPAT_WAIT + _this2._config.interval);
            });
          }
        }
      };

      _proto._keydown = function _keydown(event) {
        if (/input|textarea/i.test(event.target.tagName)) {
          return;
        }

        switch (event.which) {
          case ARROW_LEFT_KEYCODE:
            event.preventDefault();
            this.prev();
            break;

          case ARROW_RIGHT_KEYCODE:
            event.preventDefault();
            this.next();
            break;

          default:
        }
      };

      _proto._getItemIndex = function _getItemIndex(element) {
        this._items = $$$1.makeArray($$$1(element).parent().find(Selector.ITEM));
        return this._items.indexOf(element);
      };

      _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
        var isNextDirection = direction === Direction.NEXT;
        var isPrevDirection = direction === Direction.PREV;

        var activeIndex = this._getItemIndex(activeElement);

        var lastItemIndex = this._items.length - 1;
        var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;

        if (isGoingToWrap && !this._config.wrap) {
          return activeElement;
        }

        var delta = direction === Direction.PREV ? -1 : 1;
        var itemIndex = (activeIndex + delta) % this._items.length;
        return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
      };

      _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
        var targetIndex = this._getItemIndex(relatedTarget);

        var fromIndex = this._getItemIndex($$$1(this._element).find(Selector.ACTIVE_ITEM)[0]);

        var slideEvent = $$$1.Event(Event.SLIDE, {
          relatedTarget: relatedTarget,
          direction: eventDirectionName,
          from: fromIndex,
          to: targetIndex
        });
        $$$1(this._element).trigger(slideEvent);
        return slideEvent;
      };

      _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
        if (this._indicatorsElement) {
          $$$1(this._indicatorsElement).find(Selector.ACTIVE).removeClass(ClassName.ACTIVE);

          var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];

          if (nextIndicator) {
            $$$1(nextIndicator).addClass(ClassName.ACTIVE);
          }
        }
      };

      _proto._slide = function _slide(direction, element) {
        var _this3 = this;

        var activeElement = $$$1(this._element).find(Selector.ACTIVE_ITEM)[0];

        var activeElementIndex = this._getItemIndex(activeElement);

        var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);

        var nextElementIndex = this._getItemIndex(nextElement);

        var isCycling = Boolean(this._interval);
        var directionalClassName;
        var orderClassName;
        var eventDirectionName;

        if (direction === Direction.NEXT) {
          directionalClassName = ClassName.LEFT;
          orderClassName = ClassName.NEXT;
          eventDirectionName = Direction.LEFT;
        } else {
          directionalClassName = ClassName.RIGHT;
          orderClassName = ClassName.PREV;
          eventDirectionName = Direction.RIGHT;
        }

        if (nextElement && $$$1(nextElement).hasClass(ClassName.ACTIVE)) {
          this._isSliding = false;
          return;
        }

        var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);

        if (slideEvent.isDefaultPrevented()) {
          return;
        }

        if (!activeElement || !nextElement) {
          // Some weirdness is happening, so we bail
          return;
        }

        this._isSliding = true;

        if (isCycling) {
          this.pause();
        }

        this._setActiveIndicatorElement(nextElement);

        var slidEvent = $$$1.Event(Event.SLID, {
          relatedTarget: nextElement,
          direction: eventDirectionName,
          from: activeElementIndex,
          to: nextElementIndex
        });

        if ($$$1(this._element).hasClass(ClassName.SLIDE)) {
          $$$1(nextElement).addClass(orderClassName);
          Util.reflow(nextElement);
          $$$1(activeElement).addClass(directionalClassName);
          $$$1(nextElement).addClass(directionalClassName);
          var transitionDuration = Util.getTransitionDurationFromElement(activeElement);
          $$$1(activeElement).one(Util.TRANSITION_END, function () {
            $$$1(nextElement).removeClass(directionalClassName + " " + orderClassName).addClass(ClassName.ACTIVE);
            $$$1(activeElement).removeClass(ClassName.ACTIVE + " " + orderClassName + " " + directionalClassName);
            _this3._isSliding = false;
            setTimeout(function () {
              return $$$1(_this3._element).trigger(slidEvent);
            }, 0);
          }).emulateTransitionEnd(transitionDuration);
        } else {
          $$$1(activeElement).removeClass(ClassName.ACTIVE);
          $$$1(nextElement).addClass(ClassName.ACTIVE);
          this._isSliding = false;
          $$$1(this._element).trigger(slidEvent);
        }

        if (isCycling) {
          this.cycle();
        }
      }; // Static


      Carousel._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $$$1(this).data(DATA_KEY);

          var _config = _objectSpread({}, Default, $$$1(this).data());

          if (typeof config === 'object') {
            _config = _objectSpread({}, _config, config);
          }

          var action = typeof config === 'string' ? config : _config.slide;

          if (!data) {
            data = new Carousel(this, _config);
            $$$1(this).data(DATA_KEY, data);
          }

          if (typeof config === 'number') {
            data.to(config);
          } else if (typeof action === 'string') {
            if (typeof data[action] === 'undefined') {
              throw new TypeError("No method named \"" + action + "\"");
            }

            data[action]();
          } else if (_config.interval) {
            data.pause();
            data.cycle();
          }
        });
      };

      Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
        var selector = Util.getSelectorFromElement(this);

        if (!selector) {
          return;
        }

        var target = $$$1(selector)[0];

        if (!target || !$$$1(target).hasClass(ClassName.CAROUSEL)) {
          return;
        }

        var config = _objectSpread({}, $$$1(target).data(), $$$1(this).data());

        var slideIndex = this.getAttribute('data-slide-to');

        if (slideIndex) {
          config.interval = false;
        }

        Carousel._jQueryInterface.call($$$1(target), config);

        if (slideIndex) {
          $$$1(target).data(DATA_KEY).to(slideIndex);
        }

        event.preventDefault();
      };

      _createClass(Carousel, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION;
        }
      }, {
        key: "Default",
        get: function get() {
          return Default;
        }
      }]);

      return Carousel;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_SLIDE, Carousel._dataApiClickHandler);
    $$$1(window).on(Event.LOAD_DATA_API, function () {
      $$$1(Selector.DATA_RIDE).each(function () {
        var $carousel = $$$1(this);

        Carousel._jQueryInterface.call($carousel, $carousel.data());
      });
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $$$1.fn[NAME] = Carousel._jQueryInterface;
    $$$1.fn[NAME].Constructor = Carousel;

    $$$1.fn[NAME].noConflict = function () {
      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
      return Carousel._jQueryInterface;
    };

    return Carousel;
  }($);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.1.1): collapse.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Collapse = function ($$$1) {
    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */
    var NAME = 'collapse';
    var VERSION = '4.1.1';
    var DATA_KEY = 'bs.collapse';
    var EVENT_KEY = "." + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
    var Default = {
      toggle: true,
      parent: ''
    };
    var DefaultType = {
      toggle: 'boolean',
      parent: '(string|element)'
    };
    var Event = {
      SHOW: "show" + EVENT_KEY,
      SHOWN: "shown" + EVENT_KEY,
      HIDE: "hide" + EVENT_KEY,
      HIDDEN: "hidden" + EVENT_KEY,
      CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
    };
    var ClassName = {
      SHOW: 'show',
      COLLAPSE: 'collapse',
      COLLAPSING: 'collapsing',
      COLLAPSED: 'collapsed'
    };
    var Dimension = {
      WIDTH: 'width',
      HEIGHT: 'height'
    };
    var Selector = {
      ACTIVES: '.show, .collapsing',
      DATA_TOGGLE: '[data-toggle="collapse"]'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Collapse =
    /*#__PURE__*/
    function () {
      function Collapse(element, config) {
        this._isTransitioning = false;
        this._element = element;
        this._config = this._getConfig(config);
        this._triggerArray = $$$1.makeArray($$$1("[data-toggle=\"collapse\"][href=\"#" + element.id + "\"]," + ("[data-toggle=\"collapse\"][data-target=\"#" + element.id + "\"]")));
        var tabToggles = $$$1(Selector.DATA_TOGGLE);

        for (var i = 0; i < tabToggles.length; i++) {
          var elem = tabToggles[i];
          var selector = Util.getSelectorFromElement(elem);

          if (selector !== null && $$$1(selector).filter(element).length > 0) {
            this._selector = selector;

            this._triggerArray.push(elem);
          }
        }

        this._parent = this._config.parent ? this._getParent() : null;

        if (!this._config.parent) {
          this._addAriaAndCollapsedClass(this._element, this._triggerArray);
        }

        if (this._config.toggle) {
          this.toggle();
        }
      } // Getters


      var _proto = Collapse.prototype;

      // Public
      _proto.toggle = function toggle() {
        if ($$$1(this._element).hasClass(ClassName.SHOW)) {
          this.hide();
        } else {
          this.show();
        }
      };

      _proto.show = function show() {
        var _this = this;

        if (this._isTransitioning || $$$1(this._element).hasClass(ClassName.SHOW)) {
          return;
        }

        var actives;
        var activesData;

        if (this._parent) {
          actives = $$$1.makeArray($$$1(this._parent).find(Selector.ACTIVES).filter("[data-parent=\"" + this._config.parent + "\"]"));

          if (actives.length === 0) {
            actives = null;
          }
        }

        if (actives) {
          activesData = $$$1(actives).not(this._selector).data(DATA_KEY);

          if (activesData && activesData._isTransitioning) {
            return;
          }
        }

        var startEvent = $$$1.Event(Event.SHOW);
        $$$1(this._element).trigger(startEvent);

        if (startEvent.isDefaultPrevented()) {
          return;
        }

        if (actives) {
          Collapse._jQueryInterface.call($$$1(actives).not(this._selector), 'hide');

          if (!activesData) {
            $$$1(actives).data(DATA_KEY, null);
          }
        }

        var dimension = this._getDimension();

        $$$1(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);
        this._element.style[dimension] = 0;

        if (this._triggerArray.length > 0) {
          $$$1(this._triggerArray).removeClass(ClassName.COLLAPSED).attr('aria-expanded', true);
        }

        this.setTransitioning(true);

        var complete = function complete() {
          $$$1(_this._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);
          _this._element.style[dimension] = '';

          _this.setTransitioning(false);

          $$$1(_this._element).trigger(Event.SHOWN);
        };

        var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
        var scrollSize = "scroll" + capitalizedDimension;
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $$$1(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        this._element.style[dimension] = this._element[scrollSize] + "px";
      };

      _proto.hide = function hide() {
        var _this2 = this;

        if (this._isTransitioning || !$$$1(this._element).hasClass(ClassName.SHOW)) {
          return;
        }

        var startEvent = $$$1.Event(Event.HIDE);
        $$$1(this._element).trigger(startEvent);

        if (startEvent.isDefaultPrevented()) {
          return;
        }

        var dimension = this._getDimension();

        this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px";
        Util.reflow(this._element);
        $$$1(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);

        if (this._triggerArray.length > 0) {
          for (var i = 0; i < this._triggerArray.length; i++) {
            var trigger = this._triggerArray[i];
            var selector = Util.getSelectorFromElement(trigger);

            if (selector !== null) {
              var $elem = $$$1(selector);

              if (!$elem.hasClass(ClassName.SHOW)) {
                $$$1(trigger).addClass(ClassName.COLLAPSED).attr('aria-expanded', false);
              }
            }
          }
        }

        this.setTransitioning(true);

        var complete = function complete() {
          _this2.setTransitioning(false);

          $$$1(_this2._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);
        };

        this._element.style[dimension] = '';
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $$$1(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      };

      _proto.setTransitioning = function setTransitioning(isTransitioning) {
        this._isTransitioning = isTransitioning;
      };

      _proto.dispose = function dispose() {
        $$$1.removeData(this._element, DATA_KEY);
        this._config = null;
        this._parent = null;
        this._element = null;
        this._triggerArray = null;
        this._isTransitioning = null;
      }; // Private


      _proto._getConfig = function _getConfig(config) {
        config = _objectSpread({}, Default, config);
        config.toggle = Boolean(config.toggle); // Coerce string values

        Util.typeCheckConfig(NAME, config, DefaultType);
        return config;
      };

      _proto._getDimension = function _getDimension() {
        var hasWidth = $$$1(this._element).hasClass(Dimension.WIDTH);
        return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
      };

      _proto._getParent = function _getParent() {
        var _this3 = this;

        var parent = null;

        if (Util.isElement(this._config.parent)) {
          parent = this._config.parent; // It's a jQuery object

          if (typeof this._config.parent.jquery !== 'undefined') {
            parent = this._config.parent[0];
          }
        } else {
          parent = $$$1(this._config.parent)[0];
        }

        var selector = "[data-toggle=\"collapse\"][data-parent=\"" + this._config.parent + "\"]";
        $$$1(parent).find(selector).each(function (i, element) {
          _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
        });
        return parent;
      };

      _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
        if (element) {
          var isOpen = $$$1(element).hasClass(ClassName.SHOW);

          if (triggerArray.length > 0) {
            $$$1(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
          }
        }
      }; // Static


      Collapse._getTargetFromElement = function _getTargetFromElement(element) {
        var selector = Util.getSelectorFromElement(element);
        return selector ? $$$1(selector)[0] : null;
      };

      Collapse._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var $this = $$$1(this);
          var data = $this.data(DATA_KEY);

          var _config = _objectSpread({}, Default, $this.data(), typeof config === 'object' && config ? config : {});

          if (!data && _config.toggle && /show|hide/.test(config)) {
            _config.toggle = false;
          }

          if (!data) {
            data = new Collapse(this, _config);
            $this.data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"" + config + "\"");
            }

            data[config]();
          }
        });
      };

      _createClass(Collapse, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION;
        }
      }, {
        key: "Default",
        get: function get() {
          return Default;
        }
      }]);

      return Collapse;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
      // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
      if (event.currentTarget.tagName === 'A') {
        event.preventDefault();
      }

      var $trigger = $$$1(this);
      var selector = Util.getSelectorFromElement(this);
      $$$1(selector).each(function () {
        var $target = $$$1(this);
        var data = $target.data(DATA_KEY);
        var config = data ? 'toggle' : $trigger.data();

        Collapse._jQueryInterface.call($target, config);
      });
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $$$1.fn[NAME] = Collapse._jQueryInterface;
    $$$1.fn[NAME].Constructor = Collapse;

    $$$1.fn[NAME].noConflict = function () {
      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
      return Collapse._jQueryInterface;
    };

    return Collapse;
  }($);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.1.1): dropdown.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Dropdown = function ($$$1) {
    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */
    var NAME = 'dropdown';
    var VERSION = '4.1.1';
    var DATA_KEY = 'bs.dropdown';
    var EVENT_KEY = "." + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
    var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

    var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key

    var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key

    var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key

    var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key

    var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)

    var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + "|" + ARROW_DOWN_KEYCODE + "|" + ESCAPE_KEYCODE);
    var Event = {
      HIDE: "hide" + EVENT_KEY,
      HIDDEN: "hidden" + EVENT_KEY,
      SHOW: "show" + EVENT_KEY,
      SHOWN: "shown" + EVENT_KEY,
      CLICK: "click" + EVENT_KEY,
      CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY,
      KEYDOWN_DATA_API: "keydown" + EVENT_KEY + DATA_API_KEY,
      KEYUP_DATA_API: "keyup" + EVENT_KEY + DATA_API_KEY
    };
    var ClassName = {
      DISABLED: 'disabled',
      SHOW: 'show',
      DROPUP: 'dropup',
      DROPRIGHT: 'dropright',
      DROPLEFT: 'dropleft',
      MENURIGHT: 'dropdown-menu-right',
      MENULEFT: 'dropdown-menu-left',
      POSITION_STATIC: 'position-static'
    };
    var Selector = {
      DATA_TOGGLE: '[data-toggle="dropdown"]',
      FORM_CHILD: '.dropdown form',
      MENU: '.dropdown-menu',
      NAVBAR_NAV: '.navbar-nav',
      VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'
    };
    var AttachmentMap = {
      TOP: 'top-start',
      TOPEND: 'top-end',
      BOTTOM: 'bottom-start',
      BOTTOMEND: 'bottom-end',
      RIGHT: 'right-start',
      RIGHTEND: 'right-end',
      LEFT: 'left-start',
      LEFTEND: 'left-end'
    };
    var Default = {
      offset: 0,
      flip: true,
      boundary: 'scrollParent',
      reference: 'toggle',
      display: 'dynamic'
    };
    var DefaultType = {
      offset: '(number|string|function)',
      flip: 'boolean',
      boundary: '(string|element)',
      reference: '(string|element)',
      display: 'string'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Dropdown =
    /*#__PURE__*/
    function () {
      function Dropdown(element, config) {
        this._element = element;
        this._popper = null;
        this._config = this._getConfig(config);
        this._menu = this._getMenuElement();
        this._inNavbar = this._detectNavbar();

        this._addEventListeners();
      } // Getters


      var _proto = Dropdown.prototype;

      // Public
      _proto.toggle = function toggle() {
        if (this._element.disabled || $$$1(this._element).hasClass(ClassName.DISABLED)) {
          return;
        }

        var parent = Dropdown._getParentFromElement(this._element);

        var isActive = $$$1(this._menu).hasClass(ClassName.SHOW);

        Dropdown._clearMenus();

        if (isActive) {
          return;
        }

        var relatedTarget = {
          relatedTarget: this._element
        };
        var showEvent = $$$1.Event(Event.SHOW, relatedTarget);
        $$$1(parent).trigger(showEvent);

        if (showEvent.isDefaultPrevented()) {
          return;
        } // Disable totally Popper.js for Dropdown in Navbar


        if (!this._inNavbar) {
          /**
           * Check for Popper dependency
           * Popper - https://popper.js.org
           */
          if (typeof Popper === 'undefined') {
            throw new TypeError('Bootstrap dropdown require Popper.js (https://popper.js.org)');
          }

          var referenceElement = this._element;

          if (this._config.reference === 'parent') {
            referenceElement = parent;
          } else if (Util.isElement(this._config.reference)) {
            referenceElement = this._config.reference; // Check if it's jQuery element

            if (typeof this._config.reference.jquery !== 'undefined') {
              referenceElement = this._config.reference[0];
            }
          } // If boundary is not `scrollParent`, then set position to `static`
          // to allow the menu to "escape" the scroll parent's boundaries
          // https://github.com/twbs/bootstrap/issues/24251


          if (this._config.boundary !== 'scrollParent') {
            $$$1(parent).addClass(ClassName.POSITION_STATIC);
          }

          this._popper = new Popper(referenceElement, this._menu, this._getPopperConfig());
        } // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


        if ('ontouchstart' in document.documentElement && $$$1(parent).closest(Selector.NAVBAR_NAV).length === 0) {
          $$$1(document.body).children().on('mouseover', null, $$$1.noop);
        }

        this._element.focus();

        this._element.setAttribute('aria-expanded', true);

        $$$1(this._menu).toggleClass(ClassName.SHOW);
        $$$1(parent).toggleClass(ClassName.SHOW).trigger($$$1.Event(Event.SHOWN, relatedTarget));
      };

      _proto.dispose = function dispose() {
        $$$1.removeData(this._element, DATA_KEY);
        $$$1(this._element).off(EVENT_KEY);
        this._element = null;
        this._menu = null;

        if (this._popper !== null) {
          this._popper.destroy();

          this._popper = null;
        }
      };

      _proto.update = function update() {
        this._inNavbar = this._detectNavbar();

        if (this._popper !== null) {
          this._popper.scheduleUpdate();
        }
      }; // Private


      _proto._addEventListeners = function _addEventListeners() {
        var _this = this;

        $$$1(this._element).on(Event.CLICK, function (event) {
          event.preventDefault();
          event.stopPropagation();

          _this.toggle();
        });
      };

      _proto._getConfig = function _getConfig(config) {
        config = _objectSpread({}, this.constructor.Default, $$$1(this._element).data(), config);
        Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
        return config;
      };

      _proto._getMenuElement = function _getMenuElement() {
        if (!this._menu) {
          var parent = Dropdown._getParentFromElement(this._element);

          this._menu = $$$1(parent).find(Selector.MENU)[0];
        }

        return this._menu;
      };

      _proto._getPlacement = function _getPlacement() {
        var $parentDropdown = $$$1(this._element).parent();
        var placement = AttachmentMap.BOTTOM; // Handle dropup

        if ($parentDropdown.hasClass(ClassName.DROPUP)) {
          placement = AttachmentMap.TOP;

          if ($$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
            placement = AttachmentMap.TOPEND;
          }
        } else if ($parentDropdown.hasClass(ClassName.DROPRIGHT)) {
          placement = AttachmentMap.RIGHT;
        } else if ($parentDropdown.hasClass(ClassName.DROPLEFT)) {
          placement = AttachmentMap.LEFT;
        } else if ($$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
          placement = AttachmentMap.BOTTOMEND;
        }

        return placement;
      };

      _proto._detectNavbar = function _detectNavbar() {
        return $$$1(this._element).closest('.navbar').length > 0;
      };

      _proto._getPopperConfig = function _getPopperConfig() {
        var _this2 = this;

        var offsetConf = {};

        if (typeof this._config.offset === 'function') {
          offsetConf.fn = function (data) {
            data.offsets = _objectSpread({}, data.offsets, _this2._config.offset(data.offsets) || {});
            return data;
          };
        } else {
          offsetConf.offset = this._config.offset;
        }

        var popperConfig = {
          placement: this._getPlacement(),
          modifiers: {
            offset: offsetConf,
            flip: {
              enabled: this._config.flip
            },
            preventOverflow: {
              boundariesElement: this._config.boundary
            }
          } // Disable Popper.js if we have a static display

        };

        if (this._config.display === 'static') {
          popperConfig.modifiers.applyStyle = {
            enabled: false
          };
        }

        return popperConfig;
      }; // Static


      Dropdown._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $$$1(this).data(DATA_KEY);

          var _config = typeof config === 'object' ? config : null;

          if (!data) {
            data = new Dropdown(this, _config);
            $$$1(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"" + config + "\"");
            }

            data[config]();
          }
        });
      };

      Dropdown._clearMenus = function _clearMenus(event) {
        if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {
          return;
        }

        var toggles = $$$1.makeArray($$$1(Selector.DATA_TOGGLE));

        for (var i = 0; i < toggles.length; i++) {
          var parent = Dropdown._getParentFromElement(toggles[i]);

          var context = $$$1(toggles[i]).data(DATA_KEY);
          var relatedTarget = {
            relatedTarget: toggles[i]
          };

          if (!context) {
            continue;
          }

          var dropdownMenu = context._menu;

          if (!$$$1(parent).hasClass(ClassName.SHOW)) {
            continue;
          }

          if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $$$1.contains(parent, event.target)) {
            continue;
          }

          var hideEvent = $$$1.Event(Event.HIDE, relatedTarget);
          $$$1(parent).trigger(hideEvent);

          if (hideEvent.isDefaultPrevented()) {
            continue;
          } // If this is a touch-enabled device we remove the extra
          // empty mouseover listeners we added for iOS support


          if ('ontouchstart' in document.documentElement) {
            $$$1(document.body).children().off('mouseover', null, $$$1.noop);
          }

          toggles[i].setAttribute('aria-expanded', 'false');
          $$$1(dropdownMenu).removeClass(ClassName.SHOW);
          $$$1(parent).removeClass(ClassName.SHOW).trigger($$$1.Event(Event.HIDDEN, relatedTarget));
        }
      };

      Dropdown._getParentFromElement = function _getParentFromElement(element) {
        var parent;
        var selector = Util.getSelectorFromElement(element);

        if (selector) {
          parent = $$$1(selector)[0];
        }

        return parent || element.parentNode;
      }; // eslint-disable-next-line complexity


      Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
        // If not input/textarea:
        //  - And not a key in REGEXP_KEYDOWN => not a dropdown command
        // If input/textarea:
        //  - If space key => not a dropdown command
        //  - If key is other than escape
        //    - If key is not up or down => not a dropdown command
        //    - If trigger inside the menu => not a dropdown command
        if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $$$1(event.target).closest(Selector.MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
          return;
        }

        event.preventDefault();
        event.stopPropagation();

        if (this.disabled || $$$1(this).hasClass(ClassName.DISABLED)) {
          return;
        }

        var parent = Dropdown._getParentFromElement(this);

        var isActive = $$$1(parent).hasClass(ClassName.SHOW);

        if (!isActive && (event.which !== ESCAPE_KEYCODE || event.which !== SPACE_KEYCODE) || isActive && (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {
          if (event.which === ESCAPE_KEYCODE) {
            var toggle = $$$1(parent).find(Selector.DATA_TOGGLE)[0];
            $$$1(toggle).trigger('focus');
          }

          $$$1(this).trigger('click');
          return;
        }

        var items = $$$1(parent).find(Selector.VISIBLE_ITEMS).get();

        if (items.length === 0) {
          return;
        }

        var index = items.indexOf(event.target);

        if (event.which === ARROW_UP_KEYCODE && index > 0) {
          // Up
          index--;
        }

        if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {
          // Down
          index++;
        }

        if (index < 0) {
          index = 0;
        }

        items[index].focus();
      };

      _createClass(Dropdown, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION;
        }
      }, {
        key: "Default",
        get: function get() {
          return Default;
        }
      }, {
        key: "DefaultType",
        get: function get() {
          return DefaultType;
        }
      }]);

      return Dropdown;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $$$1(document).on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.MENU, Dropdown._dataApiKeydownHandler).on(Event.CLICK_DATA_API + " " + Event.KEYUP_DATA_API, Dropdown._clearMenus).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
      event.preventDefault();
      event.stopPropagation();

      Dropdown._jQueryInterface.call($$$1(this), 'toggle');
    }).on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function (e) {
      e.stopPropagation();
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $$$1.fn[NAME] = Dropdown._jQueryInterface;
    $$$1.fn[NAME].Constructor = Dropdown;

    $$$1.fn[NAME].noConflict = function () {
      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
      return Dropdown._jQueryInterface;
    };

    return Dropdown;
  }($, Popper);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.1.1): modal.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Modal = function ($$$1) {
    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */
    var NAME = 'modal';
    var VERSION = '4.1.1';
    var DATA_KEY = 'bs.modal';
    var EVENT_KEY = "." + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
    var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

    var Default = {
      backdrop: true,
      keyboard: true,
      focus: true,
      show: true
    };
    var DefaultType = {
      backdrop: '(boolean|string)',
      keyboard: 'boolean',
      focus: 'boolean',
      show: 'boolean'
    };
    var Event = {
      HIDE: "hide" + EVENT_KEY,
      HIDDEN: "hidden" + EVENT_KEY,
      SHOW: "show" + EVENT_KEY,
      SHOWN: "shown" + EVENT_KEY,
      FOCUSIN: "focusin" + EVENT_KEY,
      RESIZE: "resize" + EVENT_KEY,
      CLICK_DISMISS: "click.dismiss" + EVENT_KEY,
      KEYDOWN_DISMISS: "keydown.dismiss" + EVENT_KEY,
      MOUSEUP_DISMISS: "mouseup.dismiss" + EVENT_KEY,
      MOUSEDOWN_DISMISS: "mousedown.dismiss" + EVENT_KEY,
      CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
    };
    var ClassName = {
      SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
      BACKDROP: 'modal-backdrop',
      OPEN: 'modal-open',
      FADE: 'fade',
      SHOW: 'show'
    };
    var Selector = {
      DIALOG: '.modal-dialog',
      DATA_TOGGLE: '[data-toggle="modal"]',
      DATA_DISMISS: '[data-dismiss="modal"]',
      FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
      STICKY_CONTENT: '.sticky-top',
      NAVBAR_TOGGLER: '.navbar-toggler'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Modal =
    /*#__PURE__*/
    function () {
      function Modal(element, config) {
        this._config = this._getConfig(config);
        this._element = element;
        this._dialog = $$$1(element).find(Selector.DIALOG)[0];
        this._backdrop = null;
        this._isShown = false;
        this._isBodyOverflowing = false;
        this._ignoreBackdropClick = false;
        this._scrollbarWidth = 0;
      } // Getters


      var _proto = Modal.prototype;

      // Public
      _proto.toggle = function toggle(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
      };

      _proto.show = function show(relatedTarget) {
        var _this = this;

        if (this._isTransitioning || this._isShown) {
          return;
        }

        if ($$$1(this._element).hasClass(ClassName.FADE)) {
          this._isTransitioning = true;
        }

        var showEvent = $$$1.Event(Event.SHOW, {
          relatedTarget: relatedTarget
        });
        $$$1(this._element).trigger(showEvent);

        if (this._isShown || showEvent.isDefaultPrevented()) {
          return;
        }

        this._isShown = true;

        this._checkScrollbar();

        this._setScrollbar();

        this._adjustDialog();

        $$$1(document.body).addClass(ClassName.OPEN);

        this._setEscapeEvent();

        this._setResizeEvent();

        $$$1(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function (event) {
          return _this.hide(event);
        });
        $$$1(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {
          $$$1(_this._element).one(Event.MOUSEUP_DISMISS, function (event) {
            if ($$$1(event.target).is(_this._element)) {
              _this._ignoreBackdropClick = true;
            }
          });
        });

        this._showBackdrop(function () {
          return _this._showElement(relatedTarget);
        });
      };

      _proto.hide = function hide(event) {
        var _this2 = this;

        if (event) {
          event.preventDefault();
        }

        if (this._isTransitioning || !this._isShown) {
          return;
        }

        var hideEvent = $$$1.Event(Event.HIDE);
        $$$1(this._element).trigger(hideEvent);

        if (!this._isShown || hideEvent.isDefaultPrevented()) {
          return;
        }

        this._isShown = false;
        var transition = $$$1(this._element).hasClass(ClassName.FADE);

        if (transition) {
          this._isTransitioning = true;
        }

        this._setEscapeEvent();

        this._setResizeEvent();

        $$$1(document).off(Event.FOCUSIN);
        $$$1(this._element).removeClass(ClassName.SHOW);
        $$$1(this._element).off(Event.CLICK_DISMISS);
        $$$1(this._dialog).off(Event.MOUSEDOWN_DISMISS);

        if (transition) {
          var transitionDuration = Util.getTransitionDurationFromElement(this._element);
          $$$1(this._element).one(Util.TRANSITION_END, function (event) {
            return _this2._hideModal(event);
          }).emulateTransitionEnd(transitionDuration);
        } else {
          this._hideModal();
        }
      };

      _proto.dispose = function dispose() {
        $$$1.removeData(this._element, DATA_KEY);
        $$$1(window, document, this._element, this._backdrop).off(EVENT_KEY);
        this._config = null;
        this._element = null;
        this._dialog = null;
        this._backdrop = null;
        this._isShown = null;
        this._isBodyOverflowing = null;
        this._ignoreBackdropClick = null;
        this._scrollbarWidth = null;
      };

      _proto.handleUpdate = function handleUpdate() {
        this._adjustDialog();
      }; // Private


      _proto._getConfig = function _getConfig(config) {
        config = _objectSpread({}, Default, config);
        Util.typeCheckConfig(NAME, config, DefaultType);
        return config;
      };

      _proto._showElement = function _showElement(relatedTarget) {
        var _this3 = this;

        var transition = $$$1(this._element).hasClass(ClassName.FADE);

        if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
          // Don't move modal's DOM position
          document.body.appendChild(this._element);
        }

        this._element.style.display = 'block';

        this._element.removeAttribute('aria-hidden');

        this._element.scrollTop = 0;

        if (transition) {
          Util.reflow(this._element);
        }

        $$$1(this._element).addClass(ClassName.SHOW);

        if (this._config.focus) {
          this._enforceFocus();
        }

        var shownEvent = $$$1.Event(Event.SHOWN, {
          relatedTarget: relatedTarget
        });

        var transitionComplete = function transitionComplete() {
          if (_this3._config.focus) {
            _this3._element.focus();
          }

          _this3._isTransitioning = false;
          $$$1(_this3._element).trigger(shownEvent);
        };

        if (transition) {
          var transitionDuration = Util.getTransitionDurationFromElement(this._element);
          $$$1(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
        } else {
          transitionComplete();
        }
      };

      _proto._enforceFocus = function _enforceFocus() {
        var _this4 = this;

        $$$1(document).off(Event.FOCUSIN) // Guard against infinite focus loop
        .on(Event.FOCUSIN, function (event) {
          if (document !== event.target && _this4._element !== event.target && $$$1(_this4._element).has(event.target).length === 0) {
            _this4._element.focus();
          }
        });
      };

      _proto._setEscapeEvent = function _setEscapeEvent() {
        var _this5 = this;

        if (this._isShown && this._config.keyboard) {
          $$$1(this._element).on(Event.KEYDOWN_DISMISS, function (event) {
            if (event.which === ESCAPE_KEYCODE) {
              event.preventDefault();

              _this5.hide();
            }
          });
        } else if (!this._isShown) {
          $$$1(this._element).off(Event.KEYDOWN_DISMISS);
        }
      };

      _proto._setResizeEvent = function _setResizeEvent() {
        var _this6 = this;

        if (this._isShown) {
          $$$1(window).on(Event.RESIZE, function (event) {
            return _this6.handleUpdate(event);
          });
        } else {
          $$$1(window).off(Event.RESIZE);
        }
      };

      _proto._hideModal = function _hideModal() {
        var _this7 = this;

        this._element.style.display = 'none';

        this._element.setAttribute('aria-hidden', true);

        this._isTransitioning = false;

        this._showBackdrop(function () {
          $$$1(document.body).removeClass(ClassName.OPEN);

          _this7._resetAdjustments();

          _this7._resetScrollbar();

          $$$1(_this7._element).trigger(Event.HIDDEN);
        });
      };

      _proto._removeBackdrop = function _removeBackdrop() {
        if (this._backdrop) {
          $$$1(this._backdrop).remove();
          this._backdrop = null;
        }
      };

      _proto._showBackdrop = function _showBackdrop(callback) {
        var _this8 = this;

        var animate = $$$1(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : '';

        if (this._isShown && this._config.backdrop) {
          this._backdrop = document.createElement('div');
          this._backdrop.className = ClassName.BACKDROP;

          if (animate) {
            $$$1(this._backdrop).addClass(animate);
          }

          $$$1(this._backdrop).appendTo(document.body);
          $$$1(this._element).on(Event.CLICK_DISMISS, function (event) {
            if (_this8._ignoreBackdropClick) {
              _this8._ignoreBackdropClick = false;
              return;
            }

            if (event.target !== event.currentTarget) {
              return;
            }

            if (_this8._config.backdrop === 'static') {
              _this8._element.focus();
            } else {
              _this8.hide();
            }
          });

          if (animate) {
            Util.reflow(this._backdrop);
          }

          $$$1(this._backdrop).addClass(ClassName.SHOW);

          if (!callback) {
            return;
          }

          if (!animate) {
            callback();
            return;
          }

          var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
          $$$1(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
        } else if (!this._isShown && this._backdrop) {
          $$$1(this._backdrop).removeClass(ClassName.SHOW);

          var callbackRemove = function callbackRemove() {
            _this8._removeBackdrop();

            if (callback) {
              callback();
            }
          };

          if ($$$1(this._element).hasClass(ClassName.FADE)) {
            var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);

            $$$1(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
          } else {
            callbackRemove();
          }
        } else if (callback) {
          callback();
        }
      }; // ----------------------------------------------------------------------
      // the following methods are used to handle overflowing modals
      // todo (fat): these should probably be refactored out of modal.js
      // ----------------------------------------------------------------------


      _proto._adjustDialog = function _adjustDialog() {
        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

        if (!this._isBodyOverflowing && isModalOverflowing) {
          this._element.style.paddingLeft = this._scrollbarWidth + "px";
        }

        if (this._isBodyOverflowing && !isModalOverflowing) {
          this._element.style.paddingRight = this._scrollbarWidth + "px";
        }
      };

      _proto._resetAdjustments = function _resetAdjustments() {
        this._element.style.paddingLeft = '';
        this._element.style.paddingRight = '';
      };

      _proto._checkScrollbar = function _checkScrollbar() {
        var rect = document.body.getBoundingClientRect();
        this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;
        this._scrollbarWidth = this._getScrollbarWidth();
      };

      _proto._setScrollbar = function _setScrollbar() {
        var _this9 = this;

        if (this._isBodyOverflowing) {
          // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
          //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
          // Adjust fixed content padding
          $$$1(Selector.FIXED_CONTENT).each(function (index, element) {
            var actualPadding = $$$1(element)[0].style.paddingRight;
            var calculatedPadding = $$$1(element).css('padding-right');
            $$$1(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this9._scrollbarWidth + "px");
          }); // Adjust sticky content margin

          $$$1(Selector.STICKY_CONTENT).each(function (index, element) {
            var actualMargin = $$$1(element)[0].style.marginRight;
            var calculatedMargin = $$$1(element).css('margin-right');
            $$$1(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this9._scrollbarWidth + "px");
          }); // Adjust navbar-toggler margin

          $$$1(Selector.NAVBAR_TOGGLER).each(function (index, element) {
            var actualMargin = $$$1(element)[0].style.marginRight;
            var calculatedMargin = $$$1(element).css('margin-right');
            $$$1(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) + _this9._scrollbarWidth + "px");
          }); // Adjust body padding

          var actualPadding = document.body.style.paddingRight;
          var calculatedPadding = $$$1(document.body).css('padding-right');
          $$$1(document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + "px");
        }
      };

      _proto._resetScrollbar = function _resetScrollbar() {
        // Restore fixed content padding
        $$$1(Selector.FIXED_CONTENT).each(function (index, element) {
          var padding = $$$1(element).data('padding-right');

          if (typeof padding !== 'undefined') {
            $$$1(element).css('padding-right', padding).removeData('padding-right');
          }
        }); // Restore sticky content and navbar-toggler margin

        $$$1(Selector.STICKY_CONTENT + ", " + Selector.NAVBAR_TOGGLER).each(function (index, element) {
          var margin = $$$1(element).data('margin-right');

          if (typeof margin !== 'undefined') {
            $$$1(element).css('margin-right', margin).removeData('margin-right');
          }
        }); // Restore body padding

        var padding = $$$1(document.body).data('padding-right');

        if (typeof padding !== 'undefined') {
          $$$1(document.body).css('padding-right', padding).removeData('padding-right');
        }
      };

      _proto._getScrollbarWidth = function _getScrollbarWidth() {
        // thx d.walsh
        var scrollDiv = document.createElement('div');
        scrollDiv.className = ClassName.SCROLLBAR_MEASURER;
        document.body.appendChild(scrollDiv);
        var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        return scrollbarWidth;
      }; // Static


      Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
        return this.each(function () {
          var data = $$$1(this).data(DATA_KEY);

          var _config = _objectSpread({}, Default, $$$1(this).data(), typeof config === 'object' && config ? config : {});

          if (!data) {
            data = new Modal(this, _config);
            $$$1(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"" + config + "\"");
            }

            data[config](relatedTarget);
          } else if (_config.show) {
            data.show(relatedTarget);
          }
        });
      };

      _createClass(Modal, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION;
        }
      }, {
        key: "Default",
        get: function get() {
          return Default;
        }
      }]);

      return Modal;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
      var _this10 = this;

      var target;
      var selector = Util.getSelectorFromElement(this);

      if (selector) {
        target = $$$1(selector)[0];
      }

      var config = $$$1(target).data(DATA_KEY) ? 'toggle' : _objectSpread({}, $$$1(target).data(), $$$1(this).data());

      if (this.tagName === 'A' || this.tagName === 'AREA') {
        event.preventDefault();
      }

      var $target = $$$1(target).one(Event.SHOW, function (showEvent) {
        if (showEvent.isDefaultPrevented()) {
          // Only register focus restorer if modal will actually get shown
          return;
        }

        $target.one(Event.HIDDEN, function () {
          if ($$$1(_this10).is(':visible')) {
            _this10.focus();
          }
        });
      });

      Modal._jQueryInterface.call($$$1(target), config, this);
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $$$1.fn[NAME] = Modal._jQueryInterface;
    $$$1.fn[NAME].Constructor = Modal;

    $$$1.fn[NAME].noConflict = function () {
      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
      return Modal._jQueryInterface;
    };

    return Modal;
  }($);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.1.1): tooltip.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Tooltip = function ($$$1) {
    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */
    var NAME = 'tooltip';
    var VERSION = '4.1.1';
    var DATA_KEY = 'bs.tooltip';
    var EVENT_KEY = "." + DATA_KEY;
    var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
    var CLASS_PREFIX = 'bs-tooltip';
    var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", 'g');
    var DefaultType = {
      animation: 'boolean',
      template: 'string',
      title: '(string|element|function)',
      trigger: 'string',
      delay: '(number|object)',
      html: 'boolean',
      selector: '(string|boolean)',
      placement: '(string|function)',
      offset: '(number|string)',
      container: '(string|element|boolean)',
      fallbackPlacement: '(string|array)',
      boundary: '(string|element)'
    };
    var AttachmentMap = {
      AUTO: 'auto',
      TOP: 'top',
      RIGHT: 'right',
      BOTTOM: 'bottom',
      LEFT: 'left'
    };
    var Default = {
      animation: true,
      template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
      trigger: 'hover focus',
      title: '',
      delay: 0,
      html: false,
      selector: false,
      placement: 'top',
      offset: 0,
      container: false,
      fallbackPlacement: 'flip',
      boundary: 'scrollParent'
    };
    var HoverState = {
      SHOW: 'show',
      OUT: 'out'
    };
    var Event = {
      HIDE: "hide" + EVENT_KEY,
      HIDDEN: "hidden" + EVENT_KEY,
      SHOW: "show" + EVENT_KEY,
      SHOWN: "shown" + EVENT_KEY,
      INSERTED: "inserted" + EVENT_KEY,
      CLICK: "click" + EVENT_KEY,
      FOCUSIN: "focusin" + EVENT_KEY,
      FOCUSOUT: "focusout" + EVENT_KEY,
      MOUSEENTER: "mouseenter" + EVENT_KEY,
      MOUSELEAVE: "mouseleave" + EVENT_KEY
    };
    var ClassName = {
      FADE: 'fade',
      SHOW: 'show'
    };
    var Selector = {
      TOOLTIP: '.tooltip',
      TOOLTIP_INNER: '.tooltip-inner',
      ARROW: '.arrow'
    };
    var Trigger = {
      HOVER: 'hover',
      FOCUS: 'focus',
      CLICK: 'click',
      MANUAL: 'manual'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Tooltip =
    /*#__PURE__*/
    function () {
      function Tooltip(element, config) {
        /**
         * Check for Popper dependency
         * Popper - https://popper.js.org
         */
        if (typeof Popper === 'undefined') {
          throw new TypeError('Bootstrap tooltips require Popper.js (https://popper.js.org)');
        } // private


        this._isEnabled = true;
        this._timeout = 0;
        this._hoverState = '';
        this._activeTrigger = {};
        this._popper = null; // Protected

        this.element = element;
        this.config = this._getConfig(config);
        this.tip = null;

        this._setListeners();
      } // Getters


      var _proto = Tooltip.prototype;

      // Public
      _proto.enable = function enable() {
        this._isEnabled = true;
      };

      _proto.disable = function disable() {
        this._isEnabled = false;
      };

      _proto.toggleEnabled = function toggleEnabled() {
        this._isEnabled = !this._isEnabled;
      };

      _proto.toggle = function toggle(event) {
        if (!this._isEnabled) {
          return;
        }

        if (event) {
          var dataKey = this.constructor.DATA_KEY;
          var context = $$$1(event.currentTarget).data(dataKey);

          if (!context) {
            context = new this.constructor(event.currentTarget, this._getDelegateConfig());
            $$$1(event.currentTarget).data(dataKey, context);
          }

          context._activeTrigger.click = !context._activeTrigger.click;

          if (context._isWithActiveTrigger()) {
            context._enter(null, context);
          } else {
            context._leave(null, context);
          }
        } else {
          if ($$$1(this.getTipElement()).hasClass(ClassName.SHOW)) {
            this._leave(null, this);

            return;
          }

          this._enter(null, this);
        }
      };

      _proto.dispose = function dispose() {
        clearTimeout(this._timeout);
        $$$1.removeData(this.element, this.constructor.DATA_KEY);
        $$$1(this.element).off(this.constructor.EVENT_KEY);
        $$$1(this.element).closest('.modal').off('hide.bs.modal');

        if (this.tip) {
          $$$1(this.tip).remove();
        }

        this._isEnabled = null;
        this._timeout = null;
        this._hoverState = null;
        this._activeTrigger = null;

        if (this._popper !== null) {
          this._popper.destroy();
        }

        this._popper = null;
        this.element = null;
        this.config = null;
        this.tip = null;
      };

      _proto.show = function show() {
        var _this = this;

        if ($$$1(this.element).css('display') === 'none') {
          throw new Error('Please use show on visible elements');
        }

        var showEvent = $$$1.Event(this.constructor.Event.SHOW);

        if (this.isWithContent() && this._isEnabled) {
          $$$1(this.element).trigger(showEvent);
          var isInTheDom = $$$1.contains(this.element.ownerDocument.documentElement, this.element);

          if (showEvent.isDefaultPrevented() || !isInTheDom) {
            return;
          }

          var tip = this.getTipElement();
          var tipId = Util.getUID(this.constructor.NAME);
          tip.setAttribute('id', tipId);
          this.element.setAttribute('aria-describedby', tipId);
          this.setContent();

          if (this.config.animation) {
            $$$1(tip).addClass(ClassName.FADE);
          }

          var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;

          var attachment = this._getAttachment(placement);

          this.addAttachmentClass(attachment);
          var container = this.config.container === false ? document.body : $$$1(this.config.container);
          $$$1(tip).data(this.constructor.DATA_KEY, this);

          if (!$$$1.contains(this.element.ownerDocument.documentElement, this.tip)) {
            $$$1(tip).appendTo(container);
          }

          $$$1(this.element).trigger(this.constructor.Event.INSERTED);
          this._popper = new Popper(this.element, tip, {
            placement: attachment,
            modifiers: {
              offset: {
                offset: this.config.offset
              },
              flip: {
                behavior: this.config.fallbackPlacement
              },
              arrow: {
                element: Selector.ARROW
              },
              preventOverflow: {
                boundariesElement: this.config.boundary
              }
            },
            onCreate: function onCreate(data) {
              if (data.originalPlacement !== data.placement) {
                _this._handlePopperPlacementChange(data);
              }
            },
            onUpdate: function onUpdate(data) {
              _this._handlePopperPlacementChange(data);
            }
          });
          $$$1(tip).addClass(ClassName.SHOW); // If this is a touch-enabled device we add extra
          // empty mouseover listeners to the body's immediate children;
          // only needed because of broken event delegation on iOS
          // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

          if ('ontouchstart' in document.documentElement) {
            $$$1(document.body).children().on('mouseover', null, $$$1.noop);
          }

          var complete = function complete() {
            if (_this.config.animation) {
              _this._fixTransition();
            }

            var prevHoverState = _this._hoverState;
            _this._hoverState = null;
            $$$1(_this.element).trigger(_this.constructor.Event.SHOWN);

            if (prevHoverState === HoverState.OUT) {
              _this._leave(null, _this);
            }
          };

          if ($$$1(this.tip).hasClass(ClassName.FADE)) {
            var transitionDuration = Util.getTransitionDurationFromElement(this.tip);
            $$$1(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
          } else {
            complete();
          }
        }
      };

      _proto.hide = function hide(callback) {
        var _this2 = this;

        var tip = this.getTipElement();
        var hideEvent = $$$1.Event(this.constructor.Event.HIDE);

        var complete = function complete() {
          if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {
            tip.parentNode.removeChild(tip);
          }

          _this2._cleanTipClass();

          _this2.element.removeAttribute('aria-describedby');

          $$$1(_this2.element).trigger(_this2.constructor.Event.HIDDEN);

          if (_this2._popper !== null) {
            _this2._popper.destroy();
          }

          if (callback) {
            callback();
          }
        };

        $$$1(this.element).trigger(hideEvent);

        if (hideEvent.isDefaultPrevented()) {
          return;
        }

        $$$1(tip).removeClass(ClassName.SHOW); // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support

        if ('ontouchstart' in document.documentElement) {
          $$$1(document.body).children().off('mouseover', null, $$$1.noop);
        }

        this._activeTrigger[Trigger.CLICK] = false;
        this._activeTrigger[Trigger.FOCUS] = false;
        this._activeTrigger[Trigger.HOVER] = false;

        if ($$$1(this.tip).hasClass(ClassName.FADE)) {
          var transitionDuration = Util.getTransitionDurationFromElement(tip);
          $$$1(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }

        this._hoverState = '';
      };

      _proto.update = function update() {
        if (this._popper !== null) {
          this._popper.scheduleUpdate();
        }
      }; // Protected


      _proto.isWithContent = function isWithContent() {
        return Boolean(this.getTitle());
      };

      _proto.addAttachmentClass = function addAttachmentClass(attachment) {
        $$$1(this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
      };

      _proto.getTipElement = function getTipElement() {
        this.tip = this.tip || $$$1(this.config.template)[0];
        return this.tip;
      };

      _proto.setContent = function setContent() {
        var $tip = $$$1(this.getTipElement());
        this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());
        $tip.removeClass(ClassName.FADE + " " + ClassName.SHOW);
      };

      _proto.setElementContent = function setElementContent($element, content) {
        var html = this.config.html;

        if (typeof content === 'object' && (content.nodeType || content.jquery)) {
          // Content is a DOM node or a jQuery
          if (html) {
            if (!$$$1(content).parent().is($element)) {
              $element.empty().append(content);
            }
          } else {
            $element.text($$$1(content).text());
          }
        } else {
          $element[html ? 'html' : 'text'](content);
        }
      };

      _proto.getTitle = function getTitle() {
        var title = this.element.getAttribute('data-original-title');

        if (!title) {
          title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
        }

        return title;
      }; // Private


      _proto._getAttachment = function _getAttachment(placement) {
        return AttachmentMap[placement.toUpperCase()];
      };

      _proto._setListeners = function _setListeners() {
        var _this3 = this;

        var triggers = this.config.trigger.split(' ');
        triggers.forEach(function (trigger) {
          if (trigger === 'click') {
            $$$1(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function (event) {
              return _this3.toggle(event);
            });
          } else if (trigger !== Trigger.MANUAL) {
            var eventIn = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;
            var eventOut = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;
            $$$1(_this3.element).on(eventIn, _this3.config.selector, function (event) {
              return _this3._enter(event);
            }).on(eventOut, _this3.config.selector, function (event) {
              return _this3._leave(event);
            });
          }

          $$$1(_this3.element).closest('.modal').on('hide.bs.modal', function () {
            return _this3.hide();
          });
        });

        if (this.config.selector) {
          this.config = _objectSpread({}, this.config, {
            trigger: 'manual',
            selector: ''
          });
        } else {
          this._fixTitle();
        }
      };

      _proto._fixTitle = function _fixTitle() {
        var titleType = typeof this.element.getAttribute('data-original-title');

        if (this.element.getAttribute('title') || titleType !== 'string') {
          this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
          this.element.setAttribute('title', '');
        }
      };

      _proto._enter = function _enter(event, context) {
        var dataKey = this.constructor.DATA_KEY;
        context = context || $$$1(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $$$1(event.currentTarget).data(dataKey, context);
        }

        if (event) {
          context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
        }

        if ($$$1(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {
          context._hoverState = HoverState.SHOW;
          return;
        }

        clearTimeout(context._timeout);
        context._hoverState = HoverState.SHOW;

        if (!context.config.delay || !context.config.delay.show) {
          context.show();
          return;
        }

        context._timeout = setTimeout(function () {
          if (context._hoverState === HoverState.SHOW) {
            context.show();
          }
        }, context.config.delay.show);
      };

      _proto._leave = function _leave(event, context) {
        var dataKey = this.constructor.DATA_KEY;
        context = context || $$$1(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $$$1(event.currentTarget).data(dataKey, context);
        }

        if (event) {
          context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
        }

        if (context._isWithActiveTrigger()) {
          return;
        }

        clearTimeout(context._timeout);
        context._hoverState = HoverState.OUT;

        if (!context.config.delay || !context.config.delay.hide) {
          context.hide();
          return;
        }

        context._timeout = setTimeout(function () {
          if (context._hoverState === HoverState.OUT) {
            context.hide();
          }
        }, context.config.delay.hide);
      };

      _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
        for (var trigger in this._activeTrigger) {
          if (this._activeTrigger[trigger]) {
            return true;
          }
        }

        return false;
      };

      _proto._getConfig = function _getConfig(config) {
        config = _objectSpread({}, this.constructor.Default, $$$1(this.element).data(), typeof config === 'object' && config ? config : {});

        if (typeof config.delay === 'number') {
          config.delay = {
            show: config.delay,
            hide: config.delay
          };
        }

        if (typeof config.title === 'number') {
          config.title = config.title.toString();
        }

        if (typeof config.content === 'number') {
          config.content = config.content.toString();
        }

        Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
        return config;
      };

      _proto._getDelegateConfig = function _getDelegateConfig() {
        var config = {};

        if (this.config) {
          for (var key in this.config) {
            if (this.constructor.Default[key] !== this.config[key]) {
              config[key] = this.config[key];
            }
          }
        }

        return config;
      };

      _proto._cleanTipClass = function _cleanTipClass() {
        var $tip = $$$1(this.getTipElement());
        var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

        if (tabClass !== null && tabClass.length > 0) {
          $tip.removeClass(tabClass.join(''));
        }
      };

      _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(data) {
        this._cleanTipClass();

        this.addAttachmentClass(this._getAttachment(data.placement));
      };

      _proto._fixTransition = function _fixTransition() {
        var tip = this.getTipElement();
        var initConfigAnimation = this.config.animation;

        if (tip.getAttribute('x-placement') !== null) {
          return;
        }

        $$$1(tip).removeClass(ClassName.FADE);
        this.config.animation = false;
        this.hide();
        this.show();
        this.config.animation = initConfigAnimation;
      }; // Static


      Tooltip._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $$$1(this).data(DATA_KEY);

          var _config = typeof config === 'object' && config;

          if (!data && /dispose|hide/.test(config)) {
            return;
          }

          if (!data) {
            data = new Tooltip(this, _config);
            $$$1(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"" + config + "\"");
            }

            data[config]();
          }
        });
      };

      _createClass(Tooltip, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION;
        }
      }, {
        key: "Default",
        get: function get() {
          return Default;
        }
      }, {
        key: "NAME",
        get: function get() {
          return NAME;
        }
      }, {
        key: "DATA_KEY",
        get: function get() {
          return DATA_KEY;
        }
      }, {
        key: "Event",
        get: function get() {
          return Event;
        }
      }, {
        key: "EVENT_KEY",
        get: function get() {
          return EVENT_KEY;
        }
      }, {
        key: "DefaultType",
        get: function get() {
          return DefaultType;
        }
      }]);

      return Tooltip;
    }();
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */


    $$$1.fn[NAME] = Tooltip._jQueryInterface;
    $$$1.fn[NAME].Constructor = Tooltip;

    $$$1.fn[NAME].noConflict = function () {
      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
      return Tooltip._jQueryInterface;
    };

    return Tooltip;
  }($, Popper);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.1.1): popover.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Popover = function ($$$1) {
    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */
    var NAME = 'popover';
    var VERSION = '4.1.1';
    var DATA_KEY = 'bs.popover';
    var EVENT_KEY = "." + DATA_KEY;
    var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
    var CLASS_PREFIX = 'bs-popover';
    var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", 'g');

    var Default = _objectSpread({}, Tooltip.Default, {
      placement: 'right',
      trigger: 'click',
      content: '',
      template: '<div class="popover" role="tooltip">' + '<div class="arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div></div>'
    });

    var DefaultType = _objectSpread({}, Tooltip.DefaultType, {
      content: '(string|element|function)'
    });

    var ClassName = {
      FADE: 'fade',
      SHOW: 'show'
    };
    var Selector = {
      TITLE: '.popover-header',
      CONTENT: '.popover-body'
    };
    var Event = {
      HIDE: "hide" + EVENT_KEY,
      HIDDEN: "hidden" + EVENT_KEY,
      SHOW: "show" + EVENT_KEY,
      SHOWN: "shown" + EVENT_KEY,
      INSERTED: "inserted" + EVENT_KEY,
      CLICK: "click" + EVENT_KEY,
      FOCUSIN: "focusin" + EVENT_KEY,
      FOCUSOUT: "focusout" + EVENT_KEY,
      MOUSEENTER: "mouseenter" + EVENT_KEY,
      MOUSELEAVE: "mouseleave" + EVENT_KEY
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Popover =
    /*#__PURE__*/
    function (_Tooltip) {
      _inheritsLoose(Popover, _Tooltip);

      function Popover() {
        return _Tooltip.apply(this, arguments) || this;
      }

      var _proto = Popover.prototype;

      // Overrides
      _proto.isWithContent = function isWithContent() {
        return this.getTitle() || this._getContent();
      };

      _proto.addAttachmentClass = function addAttachmentClass(attachment) {
        $$$1(this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
      };

      _proto.getTipElement = function getTipElement() {
        this.tip = this.tip || $$$1(this.config.template)[0];
        return this.tip;
      };

      _proto.setContent = function setContent() {
        var $tip = $$$1(this.getTipElement()); // We use append for html objects to maintain js events

        this.setElementContent($tip.find(Selector.TITLE), this.getTitle());

        var content = this._getContent();

        if (typeof content === 'function') {
          content = content.call(this.element);
        }

        this.setElementContent($tip.find(Selector.CONTENT), content);
        $tip.removeClass(ClassName.FADE + " " + ClassName.SHOW);
      }; // Private


      _proto._getContent = function _getContent() {
        return this.element.getAttribute('data-content') || this.config.content;
      };

      _proto._cleanTipClass = function _cleanTipClass() {
        var $tip = $$$1(this.getTipElement());
        var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

        if (tabClass !== null && tabClass.length > 0) {
          $tip.removeClass(tabClass.join(''));
        }
      }; // Static


      Popover._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $$$1(this).data(DATA_KEY);

          var _config = typeof config === 'object' ? config : null;

          if (!data && /destroy|hide/.test(config)) {
            return;
          }

          if (!data) {
            data = new Popover(this, _config);
            $$$1(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"" + config + "\"");
            }

            data[config]();
          }
        });
      };

      _createClass(Popover, null, [{
        key: "VERSION",
        // Getters
        get: function get() {
          return VERSION;
        }
      }, {
        key: "Default",
        get: function get() {
          return Default;
        }
      }, {
        key: "NAME",
        get: function get() {
          return NAME;
        }
      }, {
        key: "DATA_KEY",
        get: function get() {
          return DATA_KEY;
        }
      }, {
        key: "Event",
        get: function get() {
          return Event;
        }
      }, {
        key: "EVENT_KEY",
        get: function get() {
          return EVENT_KEY;
        }
      }, {
        key: "DefaultType",
        get: function get() {
          return DefaultType;
        }
      }]);

      return Popover;
    }(Tooltip);
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */


    $$$1.fn[NAME] = Popover._jQueryInterface;
    $$$1.fn[NAME].Constructor = Popover;

    $$$1.fn[NAME].noConflict = function () {
      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
      return Popover._jQueryInterface;
    };

    return Popover;
  }($);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.1.1): scrollspy.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var ScrollSpy = function ($$$1) {
    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */
    var NAME = 'scrollspy';
    var VERSION = '4.1.1';
    var DATA_KEY = 'bs.scrollspy';
    var EVENT_KEY = "." + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
    var Default = {
      offset: 10,
      method: 'auto',
      target: ''
    };
    var DefaultType = {
      offset: 'number',
      method: 'string',
      target: '(string|element)'
    };
    var Event = {
      ACTIVATE: "activate" + EVENT_KEY,
      SCROLL: "scroll" + EVENT_KEY,
      LOAD_DATA_API: "load" + EVENT_KEY + DATA_API_KEY
    };
    var ClassName = {
      DROPDOWN_ITEM: 'dropdown-item',
      DROPDOWN_MENU: 'dropdown-menu',
      ACTIVE: 'active'
    };
    var Selector = {
      DATA_SPY: '[data-spy="scroll"]',
      ACTIVE: '.active',
      NAV_LIST_GROUP: '.nav, .list-group',
      NAV_LINKS: '.nav-link',
      NAV_ITEMS: '.nav-item',
      LIST_ITEMS: '.list-group-item',
      DROPDOWN: '.dropdown',
      DROPDOWN_ITEMS: '.dropdown-item',
      DROPDOWN_TOGGLE: '.dropdown-toggle'
    };
    var OffsetMethod = {
      OFFSET: 'offset',
      POSITION: 'position'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var ScrollSpy =
    /*#__PURE__*/
    function () {
      function ScrollSpy(element, config) {
        var _this = this;

        this._element = element;
        this._scrollElement = element.tagName === 'BODY' ? window : element;
        this._config = this._getConfig(config);
        this._selector = this._config.target + " " + Selector.NAV_LINKS + "," + (this._config.target + " " + Selector.LIST_ITEMS + ",") + (this._config.target + " " + Selector.DROPDOWN_ITEMS);
        this._offsets = [];
        this._targets = [];
        this._activeTarget = null;
        this._scrollHeight = 0;
        $$$1(this._scrollElement).on(Event.SCROLL, function (event) {
          return _this._process(event);
        });
        this.refresh();

        this._process();
      } // Getters


      var _proto = ScrollSpy.prototype;

      // Public
      _proto.refresh = function refresh() {
        var _this2 = this;

        var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;
        var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
        var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;
        this._offsets = [];
        this._targets = [];
        this._scrollHeight = this._getScrollHeight();
        var targets = $$$1.makeArray($$$1(this._selector));
        targets.map(function (element) {
          var target;
          var targetSelector = Util.getSelectorFromElement(element);

          if (targetSelector) {
            target = $$$1(targetSelector)[0];
          }

          if (target) {
            var targetBCR = target.getBoundingClientRect();

            if (targetBCR.width || targetBCR.height) {
              // TODO (fat): remove sketch reliance on jQuery position/offset
              return [$$$1(target)[offsetMethod]().top + offsetBase, targetSelector];
            }
          }

          return null;
        }).filter(function (item) {
          return item;
        }).sort(function (a, b) {
          return a[0] - b[0];
        }).forEach(function (item) {
          _this2._offsets.push(item[0]);

          _this2._targets.push(item[1]);
        });
      };

      _proto.dispose = function dispose() {
        $$$1.removeData(this._element, DATA_KEY);
        $$$1(this._scrollElement).off(EVENT_KEY);
        this._element = null;
        this._scrollElement = null;
        this._config = null;
        this._selector = null;
        this._offsets = null;
        this._targets = null;
        this._activeTarget = null;
        this._scrollHeight = null;
      }; // Private


      _proto._getConfig = function _getConfig(config) {
        config = _objectSpread({}, Default, typeof config === 'object' && config ? config : {});

        if (typeof config.target !== 'string') {
          var id = $$$1(config.target).attr('id');

          if (!id) {
            id = Util.getUID(NAME);
            $$$1(config.target).attr('id', id);
          }

          config.target = "#" + id;
        }

        Util.typeCheckConfig(NAME, config, DefaultType);
        return config;
      };

      _proto._getScrollTop = function _getScrollTop() {
        return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
      };

      _proto._getScrollHeight = function _getScrollHeight() {
        return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
      };

      _proto._getOffsetHeight = function _getOffsetHeight() {
        return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
      };

      _proto._process = function _process() {
        var scrollTop = this._getScrollTop() + this._config.offset;

        var scrollHeight = this._getScrollHeight();

        var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

        if (this._scrollHeight !== scrollHeight) {
          this.refresh();
        }

        if (scrollTop >= maxScroll) {
          var target = this._targets[this._targets.length - 1];

          if (this._activeTarget !== target) {
            this._activate(target);
          }

          return;
        }

        if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
          this._activeTarget = null;

          this._clear();

          return;
        }

        for (var i = this._offsets.length; i--;) {
          var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);

          if (isActiveTarget) {
            this._activate(this._targets[i]);
          }
        }
      };

      _proto._activate = function _activate(target) {
        this._activeTarget = target;

        this._clear();

        var queries = this._selector.split(','); // eslint-disable-next-line arrow-body-style


        queries = queries.map(function (selector) {
          return selector + "[data-target=\"" + target + "\"]," + (selector + "[href=\"" + target + "\"]");
        });
        var $link = $$$1(queries.join(','));

        if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {
          $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
          $link.addClass(ClassName.ACTIVE);
        } else {
          // Set triggered link as active
          $link.addClass(ClassName.ACTIVE); // Set triggered links parents as active
          // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor

          $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_LINKS + ", " + Selector.LIST_ITEMS).addClass(ClassName.ACTIVE); // Handle special case when .nav-link is inside .nav-item

          $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_ITEMS).children(Selector.NAV_LINKS).addClass(ClassName.ACTIVE);
        }

        $$$1(this._scrollElement).trigger(Event.ACTIVATE, {
          relatedTarget: target
        });
      };

      _proto._clear = function _clear() {
        $$$1(this._selector).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);
      }; // Static


      ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $$$1(this).data(DATA_KEY);

          var _config = typeof config === 'object' && config;

          if (!data) {
            data = new ScrollSpy(this, _config);
            $$$1(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"" + config + "\"");
            }

            data[config]();
          }
        });
      };

      _createClass(ScrollSpy, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION;
        }
      }, {
        key: "Default",
        get: function get() {
          return Default;
        }
      }]);

      return ScrollSpy;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $$$1(window).on(Event.LOAD_DATA_API, function () {
      var scrollSpys = $$$1.makeArray($$$1(Selector.DATA_SPY));

      for (var i = scrollSpys.length; i--;) {
        var $spy = $$$1(scrollSpys[i]);

        ScrollSpy._jQueryInterface.call($spy, $spy.data());
      }
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $$$1.fn[NAME] = ScrollSpy._jQueryInterface;
    $$$1.fn[NAME].Constructor = ScrollSpy;

    $$$1.fn[NAME].noConflict = function () {
      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
      return ScrollSpy._jQueryInterface;
    };

    return ScrollSpy;
  }($);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.1.1): tab.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  var Tab = function ($$$1) {
    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */
    var NAME = 'tab';
    var VERSION = '4.1.1';
    var DATA_KEY = 'bs.tab';
    var EVENT_KEY = "." + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
    var Event = {
      HIDE: "hide" + EVENT_KEY,
      HIDDEN: "hidden" + EVENT_KEY,
      SHOW: "show" + EVENT_KEY,
      SHOWN: "shown" + EVENT_KEY,
      CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
    };
    var ClassName = {
      DROPDOWN_MENU: 'dropdown-menu',
      ACTIVE: 'active',
      DISABLED: 'disabled',
      FADE: 'fade',
      SHOW: 'show'
    };
    var Selector = {
      DROPDOWN: '.dropdown',
      NAV_LIST_GROUP: '.nav, .list-group',
      ACTIVE: '.active',
      ACTIVE_UL: '> li > .active',
      DATA_TOGGLE: '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
      DROPDOWN_TOGGLE: '.dropdown-toggle',
      DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Tab =
    /*#__PURE__*/
    function () {
      function Tab(element) {
        this._element = element;
      } // Getters


      var _proto = Tab.prototype;

      // Public
      _proto.show = function show() {
        var _this = this;

        if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $$$1(this._element).hasClass(ClassName.ACTIVE) || $$$1(this._element).hasClass(ClassName.DISABLED)) {
          return;
        }

        var target;
        var previous;
        var listElement = $$$1(this._element).closest(Selector.NAV_LIST_GROUP)[0];
        var selector = Util.getSelectorFromElement(this._element);

        if (listElement) {
          var itemSelector = listElement.nodeName === 'UL' ? Selector.ACTIVE_UL : Selector.ACTIVE;
          previous = $$$1.makeArray($$$1(listElement).find(itemSelector));
          previous = previous[previous.length - 1];
        }

        var hideEvent = $$$1.Event(Event.HIDE, {
          relatedTarget: this._element
        });
        var showEvent = $$$1.Event(Event.SHOW, {
          relatedTarget: previous
        });

        if (previous) {
          $$$1(previous).trigger(hideEvent);
        }

        $$$1(this._element).trigger(showEvent);

        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
          return;
        }

        if (selector) {
          target = $$$1(selector)[0];
        }

        this._activate(this._element, listElement);

        var complete = function complete() {
          var hiddenEvent = $$$1.Event(Event.HIDDEN, {
            relatedTarget: _this._element
          });
          var shownEvent = $$$1.Event(Event.SHOWN, {
            relatedTarget: previous
          });
          $$$1(previous).trigger(hiddenEvent);
          $$$1(_this._element).trigger(shownEvent);
        };

        if (target) {
          this._activate(target, target.parentNode, complete);
        } else {
          complete();
        }
      };

      _proto.dispose = function dispose() {
        $$$1.removeData(this._element, DATA_KEY);
        this._element = null;
      }; // Private


      _proto._activate = function _activate(element, container, callback) {
        var _this2 = this;

        var activeElements;

        if (container.nodeName === 'UL') {
          activeElements = $$$1(container).find(Selector.ACTIVE_UL);
        } else {
          activeElements = $$$1(container).children(Selector.ACTIVE);
        }

        var active = activeElements[0];
        var isTransitioning = callback && active && $$$1(active).hasClass(ClassName.FADE);

        var complete = function complete() {
          return _this2._transitionComplete(element, active, callback);
        };

        if (active && isTransitioning) {
          var transitionDuration = Util.getTransitionDurationFromElement(active);
          $$$1(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }
      };

      _proto._transitionComplete = function _transitionComplete(element, active, callback) {
        if (active) {
          $$$1(active).removeClass(ClassName.SHOW + " " + ClassName.ACTIVE);
          var dropdownChild = $$$1(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];

          if (dropdownChild) {
            $$$1(dropdownChild).removeClass(ClassName.ACTIVE);
          }

          if (active.getAttribute('role') === 'tab') {
            active.setAttribute('aria-selected', false);
          }
        }

        $$$1(element).addClass(ClassName.ACTIVE);

        if (element.getAttribute('role') === 'tab') {
          element.setAttribute('aria-selected', true);
        }

        Util.reflow(element);
        $$$1(element).addClass(ClassName.SHOW);

        if (element.parentNode && $$$1(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {
          var dropdownElement = $$$1(element).closest(Selector.DROPDOWN)[0];

          if (dropdownElement) {
            $$$1(dropdownElement).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
          }

          element.setAttribute('aria-expanded', true);
        }

        if (callback) {
          callback();
        }
      }; // Static


      Tab._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var $this = $$$1(this);
          var data = $this.data(DATA_KEY);

          if (!data) {
            data = new Tab(this);
            $this.data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"" + config + "\"");
            }

            data[config]();
          }
        });
      };

      _createClass(Tab, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION;
        }
      }]);

      return Tab;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
      event.preventDefault();

      Tab._jQueryInterface.call($$$1(this), 'show');
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $$$1.fn[NAME] = Tab._jQueryInterface;
    $$$1.fn[NAME].Constructor = Tab;

    $$$1.fn[NAME].noConflict = function () {
      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
      return Tab._jQueryInterface;
    };

    return Tab;
  }($);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.1.1): index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  (function ($$$1) {
    if (typeof $$$1 === 'undefined') {
      throw new TypeError('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
    }

    var version = $$$1.fn.jquery.split(' ')[0].split('.');
    var minMajor = 1;
    var ltMajor = 2;
    var minMinor = 9;
    var minPatch = 1;
    var maxMajor = 4;

    if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {
      throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
    }
  })($);

  exports.Util = Util;
  exports.Alert = Alert;
  exports.Button = Button;
  exports.Carousel = Carousel;
  exports.Collapse = Collapse;
  exports.Dropdown = Dropdown;
  exports.Modal = Modal;
  exports.Popover = Popover;
  exports.Scrollspy = ScrollSpy;
  exports.Tab = Tab;
  exports.Tooltip = Tooltip;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=bootstrap.js.map


/***/ }),

/***/ "../../../node_modules/c3/c3.js":
/*!****************************************************!*\
  !*** /Users/flex/Lab/tabler/node_modules/c3/c3.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* @license C3.js v0.4.23 | (c) C3 Team and other contributors | http://c3js.org/ */
(function (global, factory) {
     true ? module.exports = factory() :
    undefined;
}(this, (function () { 'use strict';

    var CLASS = {
        target: 'c3-target',
        chart: 'c3-chart',
        chartLine: 'c3-chart-line',
        chartLines: 'c3-chart-lines',
        chartBar: 'c3-chart-bar',
        chartBars: 'c3-chart-bars',
        chartText: 'c3-chart-text',
        chartTexts: 'c3-chart-texts',
        chartArc: 'c3-chart-arc',
        chartArcs: 'c3-chart-arcs',
        chartArcsTitle: 'c3-chart-arcs-title',
        chartArcsBackground: 'c3-chart-arcs-background',
        chartArcsGaugeUnit: 'c3-chart-arcs-gauge-unit',
        chartArcsGaugeMax: 'c3-chart-arcs-gauge-max',
        chartArcsGaugeMin: 'c3-chart-arcs-gauge-min',
        selectedCircle: 'c3-selected-circle',
        selectedCircles: 'c3-selected-circles',
        eventRect: 'c3-event-rect',
        eventRects: 'c3-event-rects',
        eventRectsSingle: 'c3-event-rects-single',
        eventRectsMultiple: 'c3-event-rects-multiple',
        zoomRect: 'c3-zoom-rect',
        brush: 'c3-brush',
        focused: 'c3-focused',
        defocused: 'c3-defocused',
        region: 'c3-region',
        regions: 'c3-regions',
        title: 'c3-title',
        tooltipContainer: 'c3-tooltip-container',
        tooltip: 'c3-tooltip',
        tooltipName: 'c3-tooltip-name',
        shape: 'c3-shape',
        shapes: 'c3-shapes',
        line: 'c3-line',
        lines: 'c3-lines',
        bar: 'c3-bar',
        bars: 'c3-bars',
        circle: 'c3-circle',
        circles: 'c3-circles',
        arc: 'c3-arc',
        arcLabelLine: 'c3-arc-label-line',
        arcs: 'c3-arcs',
        area: 'c3-area',
        areas: 'c3-areas',
        empty: 'c3-empty',
        text: 'c3-text',
        texts: 'c3-texts',
        gaugeValue: 'c3-gauge-value',
        grid: 'c3-grid',
        gridLines: 'c3-grid-lines',
        xgrid: 'c3-xgrid',
        xgrids: 'c3-xgrids',
        xgridLine: 'c3-xgrid-line',
        xgridLines: 'c3-xgrid-lines',
        xgridFocus: 'c3-xgrid-focus',
        ygrid: 'c3-ygrid',
        ygrids: 'c3-ygrids',
        ygridLine: 'c3-ygrid-line',
        ygridLines: 'c3-ygrid-lines',
        axis: 'c3-axis',
        axisX: 'c3-axis-x',
        axisXLabel: 'c3-axis-x-label',
        axisY: 'c3-axis-y',
        axisYLabel: 'c3-axis-y-label',
        axisY2: 'c3-axis-y2',
        axisY2Label: 'c3-axis-y2-label',
        legendBackground: 'c3-legend-background',
        legendItem: 'c3-legend-item',
        legendItemEvent: 'c3-legend-item-event',
        legendItemTile: 'c3-legend-item-tile',
        legendItemHidden: 'c3-legend-item-hidden',
        legendItemFocused: 'c3-legend-item-focused',
        dragarea: 'c3-dragarea',
        EXPANDED: '_expanded_',
        SELECTED: '_selected_',
        INCLUDED: '_included_'
    };

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var inherits = function (subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    };

    var possibleConstructorReturn = function (self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    };

    var isValue = function isValue(v) {
        return v || v === 0;
    };
    var isFunction = function isFunction(o) {
        return typeof o === 'function';
    };
    var isArray = function isArray(o) {
        return Array.isArray(o);
    };
    var isString = function isString(o) {
        return typeof o === 'string';
    };
    var isUndefined = function isUndefined(v) {
        return typeof v === 'undefined';
    };
    var isDefined = function isDefined(v) {
        return typeof v !== 'undefined';
    };
    var ceil10 = function ceil10(v) {
        return Math.ceil(v / 10) * 10;
    };
    var asHalfPixel = function asHalfPixel(n) {
        return Math.ceil(n) + 0.5;
    };
    var diffDomain = function diffDomain(d) {
        return d[1] - d[0];
    };
    var isEmpty = function isEmpty(o) {
        return typeof o === 'undefined' || o === null || isString(o) && o.length === 0 || (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && Object.keys(o).length === 0;
    };
    var notEmpty = function notEmpty(o) {
        return !c3_chart_internal_fn.isEmpty(o);
    };
    var getOption = function getOption(options, key, defaultValue) {
        return isDefined(options[key]) ? options[key] : defaultValue;
    };
    var hasValue = function hasValue(dict, value) {
        var found = false;
        Object.keys(dict).forEach(function (key) {
            if (dict[key] === value) {
                found = true;
            }
        });
        return found;
    };
    var sanitise = function sanitise(str) {
        return typeof str === 'string' ? str.replace(/</g, '&lt;').replace(/>/g, '&gt;') : str;
    };
    var getPathBox = function getPathBox(path) {
        var box = path.getBoundingClientRect(),
            items = [path.pathSegList.getItem(0), path.pathSegList.getItem(1)],
            minX = items[0].x,
            minY = Math.min(items[0].y, items[1].y);
        return { x: minX, y: minY, width: box.width, height: box.height };
    };

    var c3_axis_fn;
    var c3_axis_internal_fn;

    function AxisInternal(component, params) {
        var internal = this;
        internal.component = component;
        internal.params = params || {};

        internal.d3 = component.d3;
        internal.scale = internal.d3.scale.linear();
        internal.range;
        internal.orient = "bottom";
        internal.innerTickSize = 6;
        internal.outerTickSize = this.params.withOuterTick ? 6 : 0;
        internal.tickPadding = 3;
        internal.tickValues = null;
        internal.tickFormat;
        internal.tickArguments;

        internal.tickOffset = 0;
        internal.tickCulling = true;
        internal.tickCentered;
        internal.tickTextCharSize;
        internal.tickTextRotate = internal.params.tickTextRotate;
        internal.tickLength;

        internal.axis = internal.generateAxis();
    }
    c3_axis_internal_fn = AxisInternal.prototype;

    c3_axis_internal_fn.axisX = function (selection, x, tickOffset) {
        selection.attr("transform", function (d) {
            return "translate(" + Math.ceil(x(d) + tickOffset) + ", 0)";
        });
    };
    c3_axis_internal_fn.axisY = function (selection, y) {
        selection.attr("transform", function (d) {
            return "translate(0," + Math.ceil(y(d)) + ")";
        });
    };
    c3_axis_internal_fn.scaleExtent = function (domain) {
        var start = domain[0],
            stop = domain[domain.length - 1];
        return start < stop ? [start, stop] : [stop, start];
    };
    c3_axis_internal_fn.generateTicks = function (scale) {
        var internal = this;
        var i,
            domain,
            ticks = [];
        if (scale.ticks) {
            return scale.ticks.apply(scale, internal.tickArguments);
        }
        domain = scale.domain();
        for (i = Math.ceil(domain[0]); i < domain[1]; i++) {
            ticks.push(i);
        }
        if (ticks.length > 0 && ticks[0] > 0) {
            ticks.unshift(ticks[0] - (ticks[1] - ticks[0]));
        }
        return ticks;
    };
    c3_axis_internal_fn.copyScale = function () {
        var internal = this;
        var newScale = internal.scale.copy(),
            domain;
        if (internal.params.isCategory) {
            domain = internal.scale.domain();
            newScale.domain([domain[0], domain[1] - 1]);
        }
        return newScale;
    };
    c3_axis_internal_fn.textFormatted = function (v) {
        var internal = this,
            formatted = internal.tickFormat ? internal.tickFormat(v) : v;
        return typeof formatted !== 'undefined' ? formatted : '';
    };
    c3_axis_internal_fn.updateRange = function () {
        var internal = this;
        internal.range = internal.scale.rangeExtent ? internal.scale.rangeExtent() : internal.scaleExtent(internal.scale.range());
        return internal.range;
    };
    c3_axis_internal_fn.updateTickTextCharSize = function (tick) {
        var internal = this;
        if (internal.tickTextCharSize) {
            return internal.tickTextCharSize;
        }
        var size = {
            h: 11.5,
            w: 5.5
        };
        tick.select('text').text(function (d) {
            return internal.textFormatted(d);
        }).each(function (d) {
            var box = this.getBoundingClientRect(),
                text = internal.textFormatted(d),
                h = box.height,
                w = text ? box.width / text.length : undefined;
            if (h && w) {
                size.h = h;
                size.w = w;
            }
        }).text('');
        internal.tickTextCharSize = size;
        return size;
    };
    c3_axis_internal_fn.transitionise = function (selection) {
        return this.params.withoutTransition ? selection : this.d3.transition(selection);
    };
    c3_axis_internal_fn.isVertical = function () {
        return this.orient === 'left' || this.orient === 'right';
    };
    c3_axis_internal_fn.tspanData = function (d, i, ticks, scale) {
        var internal = this;
        var splitted = internal.params.tickMultiline ? internal.splitTickText(d, ticks, scale) : [].concat(internal.textFormatted(d));

        if (internal.params.tickMultiline && internal.params.tickMultilineMax > 0) {
            splitted = internal.ellipsify(splitted, internal.params.tickMultilineMax);
        }

        return splitted.map(function (s) {
            return { index: i, splitted: s, length: splitted.length };
        });
    };
    c3_axis_internal_fn.splitTickText = function (d, ticks, scale) {
        var internal = this,
            tickText = internal.textFormatted(d),
            maxWidth = internal.params.tickWidth,
            subtext,
            spaceIndex,
            textWidth,
            splitted = [];

        if (Object.prototype.toString.call(tickText) === "[object Array]") {
            return tickText;
        }

        if (!maxWidth || maxWidth <= 0) {
            maxWidth = internal.isVertical() ? 95 : internal.params.isCategory ? Math.ceil(scale(ticks[1]) - scale(ticks[0])) - 12 : 110;
        }

        function split(splitted, text) {
            spaceIndex = undefined;
            for (var i = 1; i < text.length; i++) {
                if (text.charAt(i) === ' ') {
                    spaceIndex = i;
                }
                subtext = text.substr(0, i + 1);
                textWidth = internal.tickTextCharSize.w * subtext.length;
                // if text width gets over tick width, split by space index or crrent index
                if (maxWidth < textWidth) {
                    return split(splitted.concat(text.substr(0, spaceIndex ? spaceIndex : i)), text.slice(spaceIndex ? spaceIndex + 1 : i));
                }
            }
            return splitted.concat(text);
        }

        return split(splitted, tickText + "");
    };
    c3_axis_internal_fn.ellipsify = function (splitted, max) {
        if (splitted.length <= max) {
            return splitted;
        }

        var ellipsified = splitted.slice(0, max);
        var remaining = 3;
        for (var i = max - 1; i >= 0; i--) {
            var available = ellipsified[i].length;

            ellipsified[i] = ellipsified[i].substr(0, available - remaining).padEnd(available, '.');

            remaining -= available;

            if (remaining <= 0) {
                break;
            }
        }

        return ellipsified;
    };
    c3_axis_internal_fn.updateTickLength = function () {
        var internal = this;
        internal.tickLength = Math.max(internal.innerTickSize, 0) + internal.tickPadding;
    };
    c3_axis_internal_fn.lineY2 = function (d) {
        var internal = this,
            tickPosition = internal.scale(d) + (internal.tickCentered ? 0 : internal.tickOffset);
        return internal.range[0] < tickPosition && tickPosition < internal.range[1] ? internal.innerTickSize : 0;
    };
    c3_axis_internal_fn.textY = function () {
        var internal = this,
            rotate = internal.tickTextRotate;
        return rotate ? 11.5 - 2.5 * (rotate / 15) * (rotate > 0 ? 1 : -1) : internal.tickLength;
    };
    c3_axis_internal_fn.textTransform = function () {
        var internal = this,
            rotate = internal.tickTextRotate;
        return rotate ? "rotate(" + rotate + ")" : "";
    };
    c3_axis_internal_fn.textTextAnchor = function () {
        var internal = this,
            rotate = internal.tickTextRotate;
        return rotate ? rotate > 0 ? "start" : "end" : "middle";
    };
    c3_axis_internal_fn.tspanDx = function () {
        var internal = this,
            rotate = internal.tickTextRotate;
        return rotate ? 8 * Math.sin(Math.PI * (rotate / 180)) : 0;
    };
    c3_axis_internal_fn.tspanDy = function (d, i) {
        var internal = this,
            dy = internal.tickTextCharSize.h;
        if (i === 0) {
            if (internal.isVertical()) {
                dy = -((d.length - 1) * (internal.tickTextCharSize.h / 2) - 3);
            } else {
                dy = ".71em";
            }
        }
        return dy;
    };

    c3_axis_internal_fn.generateAxis = function () {
        var internal = this,
            d3 = internal.d3,
            params = internal.params;
        function axis(g) {
            g.each(function () {
                var g = axis.g = d3.select(this);

                var scale0 = this.__chart__ || internal.scale,
                    scale1 = this.__chart__ = internal.copyScale();

                var ticks = internal.tickValues ? internal.tickValues : internal.generateTicks(scale1),
                    tick = g.selectAll(".tick").data(ticks, scale1),
                    tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", 1e-6),

                // MEMO: No exit transition. The reason is this transition affects max tick width calculation because old tick will be included in the ticks.
                tickExit = tick.exit().remove(),
                    tickUpdate = internal.transitionise(tick).style("opacity", 1),
                    tickTransform,
                    tickX,
                    tickY;

                if (params.isCategory) {
                    internal.tickOffset = Math.ceil((scale1(1) - scale1(0)) / 2);
                    tickX = internal.tickCentered ? 0 : internal.tickOffset;
                    tickY = internal.tickCentered ? internal.tickOffset : 0;
                } else {
                    internal.tickOffset = tickX = 0;
                }

                tickEnter.append("line");
                tickEnter.append("text");

                internal.updateRange();
                internal.updateTickLength();
                internal.updateTickTextCharSize(g.select('.tick'));

                var lineUpdate = tickUpdate.select("line"),
                    textUpdate = tickUpdate.select("text"),
                    tspanUpdate = tick.select("text").selectAll('tspan').data(function (d, i) {
                    return internal.tspanData(d, i, ticks, scale1);
                });

                tspanUpdate.enter().append('tspan');
                tspanUpdate.exit().remove();
                tspanUpdate.text(function (d) {
                    return d.splitted;
                });

                var path = g.selectAll(".domain").data([0]),
                    pathUpdate = (path.enter().append("path").attr("class", "domain"), internal.transitionise(path));

                // TODO: each attr should be one function and change its behavior by internal.orient, probably
                switch (internal.orient) {
                    case "bottom":
                        {
                            tickTransform = internal.axisX;
                            lineUpdate.attr("x1", tickX).attr("x2", tickX).attr("y2", function (d, i) {
                                return internal.lineY2(d, i);
                            });
                            textUpdate.attr("x", 0).attr("y", function (d, i) {
                                return internal.textY(d, i);
                            }).attr("transform", function (d, i) {
                                return internal.textTransform(d, i);
                            }).style("text-anchor", function (d, i) {
                                return internal.textTextAnchor(d, i);
                            });
                            tspanUpdate.attr('x', 0).attr("dy", function (d, i) {
                                return internal.tspanDy(d, i);
                            }).attr('dx', function (d, i) {
                                return internal.tspanDx(d, i);
                            });
                            pathUpdate.attr("d", "M" + internal.range[0] + "," + internal.outerTickSize + "V0H" + internal.range[1] + "V" + internal.outerTickSize);
                            break;
                        }
                    case "top":
                        {
                            // TODO: rotated tick text
                            tickTransform = internal.axisX;
                            lineUpdate.attr("x1", tickX).attr("x2", tickX).attr("y2", function (d, i) {
                                return -1 * internal.lineY2(d, i);
                            });
                            textUpdate.attr("x", 0).attr("y", function (d, i) {
                                return -1 * internal.textY(d, i) - (params.isCategory ? 2 : internal.tickLength - 2);
                            }).attr("transform", function (d, i) {
                                return internal.textTransform(d, i);
                            }).style("text-anchor", function (d, i) {
                                return internal.textTextAnchor(d, i);
                            });
                            tspanUpdate.attr('x', 0).attr("dy", function (d, i) {
                                return internal.tspanDy(d, i);
                            }).attr('dx', function (d, i) {
                                return internal.tspanDx(d, i);
                            });
                            pathUpdate.attr("d", "M" + internal.range[0] + "," + -internal.outerTickSize + "V0H" + internal.range[1] + "V" + -internal.outerTickSize);
                            break;
                        }
                    case "left":
                        {
                            tickTransform = internal.axisY;
                            lineUpdate.attr("x2", -internal.innerTickSize).attr("y1", tickY).attr("y2", tickY);
                            textUpdate.attr("x", -internal.tickLength).attr("y", internal.tickOffset).style("text-anchor", "end");
                            tspanUpdate.attr('x', -internal.tickLength).attr("dy", function (d, i) {
                                return internal.tspanDy(d, i);
                            });
                            pathUpdate.attr("d", "M" + -internal.outerTickSize + "," + internal.range[0] + "H0V" + internal.range[1] + "H" + -internal.outerTickSize);
                            break;
                        }
                    case "right":
                        {
                            tickTransform = internal.axisY;
                            lineUpdate.attr("x2", internal.innerTickSize).attr("y1", tickY).attr("y2", tickY);
                            textUpdate.attr("x", internal.tickLength).attr("y", internal.tickOffset).style("text-anchor", "start");
                            tspanUpdate.attr('x', internal.tickLength).attr("dy", function (d, i) {
                                return internal.tspanDy(d, i);
                            });
                            pathUpdate.attr("d", "M" + internal.outerTickSize + "," + internal.range[0] + "H0V" + internal.range[1] + "H" + internal.outerTickSize);
                            break;
                        }
                }
                if (scale1.rangeBand) {
                    var x = scale1,
                        dx = x.rangeBand() / 2;
                    scale0 = scale1 = function scale1(d) {
                        return x(d) + dx;
                    };
                } else if (scale0.rangeBand) {
                    scale0 = scale1;
                } else {
                    tickExit.call(tickTransform, scale1, internal.tickOffset);
                }
                tickEnter.call(tickTransform, scale0, internal.tickOffset);
                tickUpdate.call(tickTransform, scale1, internal.tickOffset);
            });
        }
        axis.scale = function (x) {
            if (!arguments.length) {
                return internal.scale;
            }
            internal.scale = x;
            return axis;
        };
        axis.orient = function (x) {
            if (!arguments.length) {
                return internal.orient;
            }
            internal.orient = x in { top: 1, right: 1, bottom: 1, left: 1 } ? x + "" : "bottom";
            return axis;
        };
        axis.tickFormat = function (format) {
            if (!arguments.length) {
                return internal.tickFormat;
            }
            internal.tickFormat = format;
            return axis;
        };
        axis.tickCentered = function (isCentered) {
            if (!arguments.length) {
                return internal.tickCentered;
            }
            internal.tickCentered = isCentered;
            return axis;
        };
        axis.tickOffset = function () {
            return internal.tickOffset;
        };
        axis.tickInterval = function () {
            var interval, length;
            if (params.isCategory) {
                interval = internal.tickOffset * 2;
            } else {
                length = axis.g.select('path.domain').node().getTotalLength() - internal.outerTickSize * 2;
                interval = length / axis.g.selectAll('line').size();
            }
            return interval === Infinity ? 0 : interval;
        };
        axis.ticks = function () {
            if (!arguments.length) {
                return internal.tickArguments;
            }
            internal.tickArguments = arguments;
            return axis;
        };
        axis.tickCulling = function (culling) {
            if (!arguments.length) {
                return internal.tickCulling;
            }
            internal.tickCulling = culling;
            return axis;
        };
        axis.tickValues = function (x) {
            if (typeof x === 'function') {
                internal.tickValues = function () {
                    return x(internal.scale.domain());
                };
            } else {
                if (!arguments.length) {
                    return internal.tickValues;
                }
                internal.tickValues = x;
            }
            return axis;
        };
        return axis;
    };

    var Axis = function (_Component) {
        inherits(Axis, _Component);

        function Axis(owner) {
            classCallCheck(this, Axis);

            var fn = {
                fn: c3_axis_fn,
                internal: {
                    fn: c3_axis_internal_fn
                }
            };

            var _this = possibleConstructorReturn(this, (Axis.__proto__ || Object.getPrototypeOf(Axis)).call(this, owner, 'axis', fn));

            _this.d3 = owner.d3;
            _this.internal = AxisInternal;
            return _this;
        }

        return Axis;
    }(Component);

    c3_axis_fn = Axis.prototype;

    c3_axis_fn.init = function init() {
        var $$ = this.owner,
            config = $$.config,
            main = $$.main;
        $$.axes.x = main.append("g").attr("class", CLASS.axis + ' ' + CLASS.axisX).attr("clip-path", config.axis_x_inner ? "" : $$.clipPathForXAxis).attr("transform", $$.getTranslate('x')).style("visibility", config.axis_x_show ? 'visible' : 'hidden');
        $$.axes.x.append("text").attr("class", CLASS.axisXLabel).attr("transform", config.axis_rotated ? "rotate(-90)" : "").style("text-anchor", this.textAnchorForXAxisLabel.bind(this));
        $$.axes.y = main.append("g").attr("class", CLASS.axis + ' ' + CLASS.axisY).attr("clip-path", config.axis_y_inner ? "" : $$.clipPathForYAxis).attr("transform", $$.getTranslate('y')).style("visibility", config.axis_y_show ? 'visible' : 'hidden');
        $$.axes.y.append("text").attr("class", CLASS.axisYLabel).attr("transform", config.axis_rotated ? "" : "rotate(-90)").style("text-anchor", this.textAnchorForYAxisLabel.bind(this));

        $$.axes.y2 = main.append("g").attr("class", CLASS.axis + ' ' + CLASS.axisY2)
        // clip-path?
        .attr("transform", $$.getTranslate('y2')).style("visibility", config.axis_y2_show ? 'visible' : 'hidden');
        $$.axes.y2.append("text").attr("class", CLASS.axisY2Label).attr("transform", config.axis_rotated ? "" : "rotate(-90)").style("text-anchor", this.textAnchorForY2AxisLabel.bind(this));
    };
    c3_axis_fn.getXAxis = function getXAxis(scale, orient, tickFormat, tickValues, withOuterTick, withoutTransition, withoutRotateTickText) {
        var $$ = this.owner,
            config = $$.config,
            axisParams = {
            isCategory: $$.isCategorized(),
            withOuterTick: withOuterTick,
            tickMultiline: config.axis_x_tick_multiline,
            tickMultilineMax: config.axis_x_tick_multiline ? Number(config.axis_x_tick_multilineMax) : 0,
            tickWidth: config.axis_x_tick_width,
            tickTextRotate: withoutRotateTickText ? 0 : config.axis_x_tick_rotate,
            withoutTransition: withoutTransition
        },
            axis = new this.internal(this, axisParams).axis.scale(scale).orient(orient);

        if ($$.isTimeSeries() && tickValues && typeof tickValues !== "function") {
            tickValues = tickValues.map(function (v) {
                return $$.parseDate(v);
            });
        }

        // Set tick
        axis.tickFormat(tickFormat).tickValues(tickValues);
        if ($$.isCategorized()) {
            axis.tickCentered(config.axis_x_tick_centered);
            if (isEmpty(config.axis_x_tick_culling)) {
                config.axis_x_tick_culling = false;
            }
        }

        return axis;
    };
    c3_axis_fn.updateXAxisTickValues = function updateXAxisTickValues(targets, axis) {
        var $$ = this.owner,
            config = $$.config,
            tickValues;
        if (config.axis_x_tick_fit || config.axis_x_tick_count) {
            tickValues = this.generateTickValues($$.mapTargetsToUniqueXs(targets), config.axis_x_tick_count, $$.isTimeSeries());
        }
        if (axis) {
            axis.tickValues(tickValues);
        } else {
            $$.xAxis.tickValues(tickValues);
            $$.subXAxis.tickValues(tickValues);
        }
        return tickValues;
    };
    c3_axis_fn.getYAxis = function getYAxis(scale, orient, tickFormat, tickValues, withOuterTick, withoutTransition, withoutRotateTickText) {
        var $$ = this.owner,
            config = $$.config,
            axisParams = {
            withOuterTick: withOuterTick,
            withoutTransition: withoutTransition,
            tickTextRotate: withoutRotateTickText ? 0 : config.axis_y_tick_rotate
        },
            axis = new this.internal(this, axisParams).axis.scale(scale).orient(orient).tickFormat(tickFormat);
        if ($$.isTimeSeriesY()) {
            axis.ticks($$.d3.time[config.axis_y_tick_time_value], config.axis_y_tick_time_interval);
        } else {
            axis.tickValues(tickValues);
        }
        return axis;
    };
    c3_axis_fn.getId = function getId(id) {
        var config = this.owner.config;
        return id in config.data_axes ? config.data_axes[id] : 'y';
    };
    c3_axis_fn.getXAxisTickFormat = function getXAxisTickFormat() {
        var $$ = this.owner,
            config = $$.config,
            format = $$.isTimeSeries() ? $$.defaultAxisTimeFormat : $$.isCategorized() ? $$.categoryName : function (v) {
            return v < 0 ? v.toFixed(0) : v;
        };
        if (config.axis_x_tick_format) {
            if (isFunction(config.axis_x_tick_format)) {
                format = config.axis_x_tick_format;
            } else if ($$.isTimeSeries()) {
                format = function format(date) {
                    return date ? $$.axisTimeFormat(config.axis_x_tick_format)(date) : "";
                };
            }
        }
        return isFunction(format) ? function (v) {
            return format.call($$, v);
        } : format;
    };
    c3_axis_fn.getTickValues = function getTickValues(tickValues, axis) {
        return tickValues ? tickValues : axis ? axis.tickValues() : undefined;
    };
    c3_axis_fn.getXAxisTickValues = function getXAxisTickValues() {
        return this.getTickValues(this.owner.config.axis_x_tick_values, this.owner.xAxis);
    };
    c3_axis_fn.getYAxisTickValues = function getYAxisTickValues() {
        return this.getTickValues(this.owner.config.axis_y_tick_values, this.owner.yAxis);
    };
    c3_axis_fn.getY2AxisTickValues = function getY2AxisTickValues() {
        return this.getTickValues(this.owner.config.axis_y2_tick_values, this.owner.y2Axis);
    };
    c3_axis_fn.getLabelOptionByAxisId = function getLabelOptionByAxisId(axisId) {
        var $$ = this.owner,
            config = $$.config,
            option;
        if (axisId === 'y') {
            option = config.axis_y_label;
        } else if (axisId === 'y2') {
            option = config.axis_y2_label;
        } else if (axisId === 'x') {
            option = config.axis_x_label;
        }
        return option;
    };
    c3_axis_fn.getLabelText = function getLabelText(axisId) {
        var option = this.getLabelOptionByAxisId(axisId);
        return isString(option) ? option : option ? option.text : null;
    };
    c3_axis_fn.setLabelText = function setLabelText(axisId, text) {
        var $$ = this.owner,
            config = $$.config,
            option = this.getLabelOptionByAxisId(axisId);
        if (isString(option)) {
            if (axisId === 'y') {
                config.axis_y_label = text;
            } else if (axisId === 'y2') {
                config.axis_y2_label = text;
            } else if (axisId === 'x') {
                config.axis_x_label = text;
            }
        } else if (option) {
            option.text = text;
        }
    };
    c3_axis_fn.getLabelPosition = function getLabelPosition(axisId, defaultPosition) {
        var option = this.getLabelOptionByAxisId(axisId),
            position = option && (typeof option === 'undefined' ? 'undefined' : _typeof(option)) === 'object' && option.position ? option.position : defaultPosition;
        return {
            isInner: position.indexOf('inner') >= 0,
            isOuter: position.indexOf('outer') >= 0,
            isLeft: position.indexOf('left') >= 0,
            isCenter: position.indexOf('center') >= 0,
            isRight: position.indexOf('right') >= 0,
            isTop: position.indexOf('top') >= 0,
            isMiddle: position.indexOf('middle') >= 0,
            isBottom: position.indexOf('bottom') >= 0
        };
    };
    c3_axis_fn.getXAxisLabelPosition = function getXAxisLabelPosition() {
        return this.getLabelPosition('x', this.owner.config.axis_rotated ? 'inner-top' : 'inner-right');
    };
    c3_axis_fn.getYAxisLabelPosition = function getYAxisLabelPosition() {
        return this.getLabelPosition('y', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top');
    };
    c3_axis_fn.getY2AxisLabelPosition = function getY2AxisLabelPosition() {
        return this.getLabelPosition('y2', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top');
    };
    c3_axis_fn.getLabelPositionById = function getLabelPositionById(id) {
        return id === 'y2' ? this.getY2AxisLabelPosition() : id === 'y' ? this.getYAxisLabelPosition() : this.getXAxisLabelPosition();
    };
    c3_axis_fn.textForXAxisLabel = function textForXAxisLabel() {
        return this.getLabelText('x');
    };
    c3_axis_fn.textForYAxisLabel = function textForYAxisLabel() {
        return this.getLabelText('y');
    };
    c3_axis_fn.textForY2AxisLabel = function textForY2AxisLabel() {
        return this.getLabelText('y2');
    };
    c3_axis_fn.xForAxisLabel = function xForAxisLabel(forHorizontal, position) {
        var $$ = this.owner;
        if (forHorizontal) {
            return position.isLeft ? 0 : position.isCenter ? $$.width / 2 : $$.width;
        } else {
            return position.isBottom ? -$$.height : position.isMiddle ? -$$.height / 2 : 0;
        }
    };
    c3_axis_fn.dxForAxisLabel = function dxForAxisLabel(forHorizontal, position) {
        if (forHorizontal) {
            return position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0";
        } else {
            return position.isTop ? "-0.5em" : position.isBottom ? "0.5em" : "0";
        }
    };
    c3_axis_fn.textAnchorForAxisLabel = function textAnchorForAxisLabel(forHorizontal, position) {
        if (forHorizontal) {
            return position.isLeft ? 'start' : position.isCenter ? 'middle' : 'end';
        } else {
            return position.isBottom ? 'start' : position.isMiddle ? 'middle' : 'end';
        }
    };
    c3_axis_fn.xForXAxisLabel = function xForXAxisLabel() {
        return this.xForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());
    };
    c3_axis_fn.xForYAxisLabel = function xForYAxisLabel() {
        return this.xForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());
    };
    c3_axis_fn.xForY2AxisLabel = function xForY2AxisLabel() {
        return this.xForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());
    };
    c3_axis_fn.dxForXAxisLabel = function dxForXAxisLabel() {
        return this.dxForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());
    };
    c3_axis_fn.dxForYAxisLabel = function dxForYAxisLabel() {
        return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());
    };
    c3_axis_fn.dxForY2AxisLabel = function dxForY2AxisLabel() {
        return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());
    };
    c3_axis_fn.dyForXAxisLabel = function dyForXAxisLabel() {
        var $$ = this.owner,
            config = $$.config,
            position = this.getXAxisLabelPosition();
        if (config.axis_rotated) {
            return position.isInner ? "1.2em" : -25 - ($$.config.axis_x_inner ? 0 : this.getMaxTickWidth('x'));
        } else {
            return position.isInner ? "-0.5em" : config.axis_x_height ? config.axis_x_height - 10 : "3em";
        }
    };
    c3_axis_fn.dyForYAxisLabel = function dyForYAxisLabel() {
        var $$ = this.owner,
            position = this.getYAxisLabelPosition();
        if ($$.config.axis_rotated) {
            return position.isInner ? "-0.5em" : "3em";
        } else {
            return position.isInner ? "1.2em" : -10 - ($$.config.axis_y_inner ? 0 : this.getMaxTickWidth('y') + 10);
        }
    };
    c3_axis_fn.dyForY2AxisLabel = function dyForY2AxisLabel() {
        var $$ = this.owner,
            position = this.getY2AxisLabelPosition();
        if ($$.config.axis_rotated) {
            return position.isInner ? "1.2em" : "-2.2em";
        } else {
            return position.isInner ? "-0.5em" : 15 + ($$.config.axis_y2_inner ? 0 : this.getMaxTickWidth('y2') + 15);
        }
    };
    c3_axis_fn.textAnchorForXAxisLabel = function textAnchorForXAxisLabel() {
        var $$ = this.owner;
        return this.textAnchorForAxisLabel(!$$.config.axis_rotated, this.getXAxisLabelPosition());
    };
    c3_axis_fn.textAnchorForYAxisLabel = function textAnchorForYAxisLabel() {
        var $$ = this.owner;
        return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getYAxisLabelPosition());
    };
    c3_axis_fn.textAnchorForY2AxisLabel = function textAnchorForY2AxisLabel() {
        var $$ = this.owner;
        return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getY2AxisLabelPosition());
    };
    c3_axis_fn.getMaxTickWidth = function getMaxTickWidth(id, withoutRecompute) {
        var $$ = this.owner,
            config = $$.config,
            maxWidth = 0,
            targetsToShow,
            scale,
            axis,
            dummy,
            svg;
        if (withoutRecompute && $$.currentMaxTickWidths[id]) {
            return $$.currentMaxTickWidths[id];
        }
        if ($$.svg) {
            targetsToShow = $$.filterTargetsToShow($$.data.targets);
            if (id === 'y') {
                scale = $$.y.copy().domain($$.getYDomain(targetsToShow, 'y'));
                axis = this.getYAxis(scale, $$.yOrient, config.axis_y_tick_format, $$.yAxisTickValues, false, true, true);
            } else if (id === 'y2') {
                scale = $$.y2.copy().domain($$.getYDomain(targetsToShow, 'y2'));
                axis = this.getYAxis(scale, $$.y2Orient, config.axis_y2_tick_format, $$.y2AxisTickValues, false, true, true);
            } else {
                scale = $$.x.copy().domain($$.getXDomain(targetsToShow));
                axis = this.getXAxis(scale, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, false, true, true);
                this.updateXAxisTickValues(targetsToShow, axis);
            }
            dummy = $$.d3.select('body').append('div').classed('c3', true);
            svg = dummy.append("svg").style('visibility', 'hidden').style('position', 'fixed').style('top', 0).style('left', 0), svg.append('g').call(axis).each(function () {
                $$.d3.select(this).selectAll('text').each(function () {
                    var box = this.getBoundingClientRect();
                    if (maxWidth < box.width) {
                        maxWidth = box.width;
                    }
                });
                dummy.remove();
            });
        }
        $$.currentMaxTickWidths[id] = maxWidth <= 0 ? $$.currentMaxTickWidths[id] : maxWidth;
        return $$.currentMaxTickWidths[id];
    };

    c3_axis_fn.updateLabels = function updateLabels(withTransition) {
        var $$ = this.owner;
        var axisXLabel = $$.main.select('.' + CLASS.axisX + ' .' + CLASS.axisXLabel),
            axisYLabel = $$.main.select('.' + CLASS.axisY + ' .' + CLASS.axisYLabel),
            axisY2Label = $$.main.select('.' + CLASS.axisY2 + ' .' + CLASS.axisY2Label);
        (withTransition ? axisXLabel.transition() : axisXLabel).attr("x", this.xForXAxisLabel.bind(this)).attr("dx", this.dxForXAxisLabel.bind(this)).attr("dy", this.dyForXAxisLabel.bind(this)).text(this.textForXAxisLabel.bind(this));
        (withTransition ? axisYLabel.transition() : axisYLabel).attr("x", this.xForYAxisLabel.bind(this)).attr("dx", this.dxForYAxisLabel.bind(this)).attr("dy", this.dyForYAxisLabel.bind(this)).text(this.textForYAxisLabel.bind(this));
        (withTransition ? axisY2Label.transition() : axisY2Label).attr("x", this.xForY2AxisLabel.bind(this)).attr("dx", this.dxForY2AxisLabel.bind(this)).attr("dy", this.dyForY2AxisLabel.bind(this)).text(this.textForY2AxisLabel.bind(this));
    };
    c3_axis_fn.getPadding = function getPadding(padding, key, defaultValue, domainLength) {
        var p = typeof padding === 'number' ? padding : padding[key];
        if (!isValue(p)) {
            return defaultValue;
        }
        if (padding.unit === 'ratio') {
            return padding[key] * domainLength;
        }
        // assume padding is pixels if unit is not specified
        return this.convertPixelsToAxisPadding(p, domainLength);
    };
    c3_axis_fn.convertPixelsToAxisPadding = function convertPixelsToAxisPadding(pixels, domainLength) {
        var $$ = this.owner,
            length = $$.config.axis_rotated ? $$.width : $$.height;
        return domainLength * (pixels / length);
    };
    c3_axis_fn.generateTickValues = function generateTickValues(values, tickCount, forTimeSeries) {
        var tickValues = values,
            targetCount,
            start,
            end,
            count,
            interval,
            i,
            tickValue;
        if (tickCount) {
            targetCount = isFunction(tickCount) ? tickCount() : tickCount;
            // compute ticks according to tickCount
            if (targetCount === 1) {
                tickValues = [values[0]];
            } else if (targetCount === 2) {
                tickValues = [values[0], values[values.length - 1]];
            } else if (targetCount > 2) {
                count = targetCount - 2;
                start = values[0];
                end = values[values.length - 1];
                interval = (end - start) / (count + 1);
                // re-construct unique values
                tickValues = [start];
                for (i = 0; i < count; i++) {
                    tickValue = +start + interval * (i + 1);
                    tickValues.push(forTimeSeries ? new Date(tickValue) : tickValue);
                }
                tickValues.push(end);
            }
        }
        if (!forTimeSeries) {
            tickValues = tickValues.sort(function (a, b) {
                return a - b;
            });
        }
        return tickValues;
    };
    c3_axis_fn.generateTransitions = function generateTransitions(duration) {
        var $$ = this.owner,
            axes = $$.axes;
        return {
            axisX: duration ? axes.x.transition().duration(duration) : axes.x,
            axisY: duration ? axes.y.transition().duration(duration) : axes.y,
            axisY2: duration ? axes.y2.transition().duration(duration) : axes.y2,
            axisSubX: duration ? axes.subx.transition().duration(duration) : axes.subx
        };
    };
    c3_axis_fn.redraw = function redraw(transitions, isHidden) {
        var $$ = this.owner;
        $$.axes.x.style("opacity", isHidden ? 0 : 1);
        $$.axes.y.style("opacity", isHidden ? 0 : 1);
        $$.axes.y2.style("opacity", isHidden ? 0 : 1);
        $$.axes.subx.style("opacity", isHidden ? 0 : 1);
        transitions.axisX.call($$.xAxis);
        transitions.axisY.call($$.yAxis);
        transitions.axisY2.call($$.y2Axis);
        transitions.axisSubX.call($$.subXAxis);
    };

    var c3 = { version: "0.4.23" };

    var c3_chart_fn;
    var c3_chart_internal_fn;

    function Component(owner, componentKey, fn) {
        this.owner = owner;
        c3.chart.internal[componentKey] = fn;
    }

    function Chart(config) {
        var $$ = this.internal = new ChartInternal(this);
        $$.loadConfig(config);

        $$.beforeInit(config);
        $$.init();
        $$.afterInit(config);

        // bind "this" to nested API
        (function bindThis(fn, target, argThis) {
            Object.keys(fn).forEach(function (key) {
                target[key] = fn[key].bind(argThis);
                if (Object.keys(fn[key]).length > 0) {
                    bindThis(fn[key], target[key], argThis);
                }
            });
        })(c3_chart_fn, this, this);
    }

    function ChartInternal(api) {
        var $$ = this;
        $$.d3 = window.d3 ? window.d3 :  true ? __webpack_require__(/*! d3 */ "../../../node_modules/d3/d3.js") : undefined;
        $$.api = api;
        $$.config = $$.getDefaultConfig();
        $$.data = {};
        $$.cache = {};
        $$.axes = {};
    }

    c3.generate = function (config) {
        return new Chart(config);
    };

    c3.chart = {
        fn: Chart.prototype,
        internal: {
            fn: ChartInternal.prototype
        }
    };
    c3_chart_fn = c3.chart.fn;
    c3_chart_internal_fn = c3.chart.internal.fn;

    c3_chart_internal_fn.beforeInit = function () {
        // can do something
    };
    c3_chart_internal_fn.afterInit = function () {
        // can do something
    };
    c3_chart_internal_fn.init = function () {
        var $$ = this,
            config = $$.config;

        $$.initParams();

        if (config.data_url) {
            $$.convertUrlToData(config.data_url, config.data_mimeType, config.data_headers, config.data_keys, $$.initWithData);
        } else if (config.data_json) {
            $$.initWithData($$.convertJsonToData(config.data_json, config.data_keys));
        } else if (config.data_rows) {
            $$.initWithData($$.convertRowsToData(config.data_rows));
        } else if (config.data_columns) {
            $$.initWithData($$.convertColumnsToData(config.data_columns));
        } else {
            throw Error('url or json or rows or columns is required.');
        }
    };

    c3_chart_internal_fn.initParams = function () {
        var $$ = this,
            d3 = $$.d3,
            config = $$.config;

        // MEMO: clipId needs to be unique because it conflicts when multiple charts exist
        $$.clipId = "c3-" + +new Date() + '-clip', $$.clipIdForXAxis = $$.clipId + '-xaxis', $$.clipIdForYAxis = $$.clipId + '-yaxis', $$.clipIdForGrid = $$.clipId + '-grid', $$.clipIdForSubchart = $$.clipId + '-subchart', $$.clipPath = $$.getClipPath($$.clipId), $$.clipPathForXAxis = $$.getClipPath($$.clipIdForXAxis), $$.clipPathForYAxis = $$.getClipPath($$.clipIdForYAxis);
        $$.clipPathForGrid = $$.getClipPath($$.clipIdForGrid), $$.clipPathForSubchart = $$.getClipPath($$.clipIdForSubchart), $$.dragStart = null;
        $$.dragging = false;
        $$.flowing = false;
        $$.cancelClick = false;
        $$.mouseover = false;
        $$.transiting = false;

        $$.color = $$.generateColor();
        $$.levelColor = $$.generateLevelColor();

        $$.dataTimeFormat = config.data_xLocaltime ? d3.time.format : d3.time.format.utc;
        $$.axisTimeFormat = config.axis_x_localtime ? d3.time.format : d3.time.format.utc;
        $$.defaultAxisTimeFormat = $$.axisTimeFormat.multi([[".%L", function (d) {
            return d.getMilliseconds();
        }], [":%S", function (d) {
            return d.getSeconds();
        }], ["%I:%M", function (d) {
            return d.getMinutes();
        }], ["%I %p", function (d) {
            return d.getHours();
        }], ["%-m/%-d", function (d) {
            return d.getDay() && d.getDate() !== 1;
        }], ["%-m/%-d", function (d) {
            return d.getDate() !== 1;
        }], ["%-m/%-d", function (d) {
            return d.getMonth();
        }], ["%Y/%-m/%-d", function () {
            return true;
        }]]);

        $$.hiddenTargetIds = [];
        $$.hiddenLegendIds = [];
        $$.focusedTargetIds = [];
        $$.defocusedTargetIds = [];

        $$.xOrient = config.axis_rotated ? config.axis_x_inner ? "right" : "left" : config.axis_x_inner ? "top" : "bottom";
        $$.yOrient = config.axis_rotated ? config.axis_y_inner ? "top" : "bottom" : config.axis_y_inner ? "right" : "left";
        $$.y2Orient = config.axis_rotated ? config.axis_y2_inner ? "bottom" : "top" : config.axis_y2_inner ? "left" : "right";
        $$.subXOrient = config.axis_rotated ? "left" : "bottom";

        $$.isLegendRight = config.legend_position === 'right';
        $$.isLegendInset = config.legend_position === 'inset';
        $$.isLegendTop = config.legend_inset_anchor === 'top-left' || config.legend_inset_anchor === 'top-right';
        $$.isLegendLeft = config.legend_inset_anchor === 'top-left' || config.legend_inset_anchor === 'bottom-left';
        $$.legendStep = 0;
        $$.legendItemWidth = 0;
        $$.legendItemHeight = 0;

        $$.currentMaxTickWidths = {
            x: 0,
            y: 0,
            y2: 0
        };

        $$.rotated_padding_left = 30;
        $$.rotated_padding_right = config.axis_rotated && !config.axis_x_show ? 0 : 30;
        $$.rotated_padding_top = 5;

        $$.withoutFadeIn = {};

        $$.intervalForObserveInserted = undefined;

        $$.axes.subx = d3.selectAll([]); // needs when excluding subchart.js
    };

    c3_chart_internal_fn.initChartElements = function () {
        if (this.initBar) {
            this.initBar();
        }
        if (this.initLine) {
            this.initLine();
        }
        if (this.initArc) {
            this.initArc();
        }
        if (this.initGauge) {
            this.initGauge();
        }
        if (this.initText) {
            this.initText();
        }
    };

    c3_chart_internal_fn.initWithData = function (data) {
        var $$ = this,
            d3 = $$.d3,
            config = $$.config;
        var defs,
            main,
            binding = true;

        $$.axis = new Axis($$);

        if ($$.initPie) {
            $$.initPie();
        }
        if ($$.initBrush) {
            $$.initBrush();
        }
        if ($$.initZoom) {
            $$.initZoom();
        }

        if (!config.bindto) {
            $$.selectChart = d3.selectAll([]);
        } else if (typeof config.bindto.node === 'function') {
            $$.selectChart = config.bindto;
        } else {
            $$.selectChart = d3.select(config.bindto);
        }
        if ($$.selectChart.empty()) {
            $$.selectChart = d3.select(document.createElement('div')).style('opacity', 0);
            $$.observeInserted($$.selectChart);
            binding = false;
        }
        $$.selectChart.html("").classed("c3", true);

        // Init data as targets
        $$.data.xs = {};
        $$.data.targets = $$.convertDataToTargets(data);

        if (config.data_filter) {
            $$.data.targets = $$.data.targets.filter(config.data_filter);
        }

        // Set targets to hide if needed
        if (config.data_hide) {
            $$.addHiddenTargetIds(config.data_hide === true ? $$.mapToIds($$.data.targets) : config.data_hide);
        }
        if (config.legend_hide) {
            $$.addHiddenLegendIds(config.legend_hide === true ? $$.mapToIds($$.data.targets) : config.legend_hide);
        }

        // Init sizes and scales
        $$.updateSizes();
        $$.updateScales();

        // Set domains for each scale
        $$.x.domain(d3.extent($$.getXDomain($$.data.targets)));
        $$.y.domain($$.getYDomain($$.data.targets, 'y'));
        $$.y2.domain($$.getYDomain($$.data.targets, 'y2'));
        $$.subX.domain($$.x.domain());
        $$.subY.domain($$.y.domain());
        $$.subY2.domain($$.y2.domain());

        // Save original x domain for zoom update
        $$.orgXDomain = $$.x.domain();

        // Set initialized scales to brush and zoom
        if ($$.brush) {
            $$.brush.scale($$.subX);
        }
        if (config.zoom_enabled) {
            $$.zoom.scale($$.x);
        }

        /*-- Basic Elements --*/

        // Define svgs
        $$.svg = $$.selectChart.append("svg").style("overflow", "hidden").on('mouseenter', function () {
            return config.onmouseover.call($$);
        }).on('mouseleave', function () {
            return config.onmouseout.call($$);
        });

        if ($$.config.svg_classname) {
            $$.svg.attr('class', $$.config.svg_classname);
        }

        // Define defs
        defs = $$.svg.append("defs");
        $$.clipChart = $$.appendClip(defs, $$.clipId);
        $$.clipXAxis = $$.appendClip(defs, $$.clipIdForXAxis);
        $$.clipYAxis = $$.appendClip(defs, $$.clipIdForYAxis);
        $$.clipGrid = $$.appendClip(defs, $$.clipIdForGrid);
        $$.clipSubchart = $$.appendClip(defs, $$.clipIdForSubchart);
        $$.updateSvgSize();

        // Define regions
        main = $$.main = $$.svg.append("g").attr("transform", $$.getTranslate('main'));

        if ($$.initSubchart) {
            $$.initSubchart();
        }
        if ($$.initTooltip) {
            $$.initTooltip();
        }
        if ($$.initLegend) {
            $$.initLegend();
        }
        if ($$.initTitle) {
            $$.initTitle();
        }

        /*-- Main Region --*/

        // text when empty
        main.append("text").attr("class", CLASS.text + ' ' + CLASS.empty).attr("text-anchor", "middle") // horizontal centering of text at x position in all browsers.
        .attr("dominant-baseline", "middle"); // vertical centering of text at y position in all browsers, except IE.

        // Regions
        $$.initRegion();

        // Grids
        $$.initGrid();

        // Define g for chart area
        main.append('g').attr("clip-path", $$.clipPath).attr('class', CLASS.chart);

        // Grid lines
        if (config.grid_lines_front) {
            $$.initGridLines();
        }

        // Cover whole with rects for events
        $$.initEventRect();

        // Define g for chart
        $$.initChartElements();

        // if zoom privileged, insert rect to forefront
        // TODO: is this needed?
        main.insert('rect', config.zoom_privileged ? null : 'g.' + CLASS.regions).attr('class', CLASS.zoomRect).attr('width', $$.width).attr('height', $$.height).style('opacity', 0).on("dblclick.zoom", null);

        // Set default extent if defined
        if (config.axis_x_extent) {
            $$.brush.extent($$.getDefaultExtent());
        }

        // Add Axis
        $$.axis.init();

        // Set targets
        $$.updateTargets($$.data.targets);

        // Draw with targets
        if (binding) {
            $$.updateDimension();
            $$.config.oninit.call($$);
            $$.redraw({
                withTransition: false,
                withTransform: true,
                withUpdateXDomain: true,
                withUpdateOrgXDomain: true,
                withTransitionForAxis: false
            });
        }

        // Bind resize event
        $$.bindResize();

        // export element of the chart
        $$.api.element = $$.selectChart.node();
    };

    c3_chart_internal_fn.smoothLines = function (el, type) {
        var $$ = this;
        if (type === 'grid') {
            el.each(function () {
                var g = $$.d3.select(this),
                    x1 = g.attr('x1'),
                    x2 = g.attr('x2'),
                    y1 = g.attr('y1'),
                    y2 = g.attr('y2');
                g.attr({
                    'x1': Math.ceil(x1),
                    'x2': Math.ceil(x2),
                    'y1': Math.ceil(y1),
                    'y2': Math.ceil(y2)
                });
            });
        }
    };

    c3_chart_internal_fn.updateSizes = function () {
        var $$ = this,
            config = $$.config;
        var legendHeight = $$.legend ? $$.getLegendHeight() : 0,
            legendWidth = $$.legend ? $$.getLegendWidth() : 0,
            legendHeightForBottom = $$.isLegendRight || $$.isLegendInset ? 0 : legendHeight,
            hasArc = $$.hasArcType(),
            xAxisHeight = config.axis_rotated || hasArc ? 0 : $$.getHorizontalAxisHeight('x'),
            subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + xAxisHeight : 0;

        $$.currentWidth = $$.getCurrentWidth();
        $$.currentHeight = $$.getCurrentHeight();

        // for main
        $$.margin = config.axis_rotated ? {
            top: $$.getHorizontalAxisHeight('y2') + $$.getCurrentPaddingTop(),
            right: hasArc ? 0 : $$.getCurrentPaddingRight(),
            bottom: $$.getHorizontalAxisHeight('y') + legendHeightForBottom + $$.getCurrentPaddingBottom(),
            left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
        } : {
            top: 4 + $$.getCurrentPaddingTop(), // for top tick text
            right: hasArc ? 0 : $$.getCurrentPaddingRight(),
            bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
            left: hasArc ? 0 : $$.getCurrentPaddingLeft()
        };

        // for subchart
        $$.margin2 = config.axis_rotated ? {
            top: $$.margin.top,
            right: NaN,
            bottom: 20 + legendHeightForBottom,
            left: $$.rotated_padding_left
        } : {
            top: $$.currentHeight - subchartHeight - legendHeightForBottom,
            right: NaN,
            bottom: xAxisHeight + legendHeightForBottom,
            left: $$.margin.left
        };

        // for legend
        $$.margin3 = {
            top: 0,
            right: NaN,
            bottom: 0,
            left: 0
        };
        if ($$.updateSizeForLegend) {
            $$.updateSizeForLegend(legendHeight, legendWidth);
        }

        $$.width = $$.currentWidth - $$.margin.left - $$.margin.right;
        $$.height = $$.currentHeight - $$.margin.top - $$.margin.bottom;
        if ($$.width < 0) {
            $$.width = 0;
        }
        if ($$.height < 0) {
            $$.height = 0;
        }

        $$.width2 = config.axis_rotated ? $$.margin.left - $$.rotated_padding_left - $$.rotated_padding_right : $$.width;
        $$.height2 = config.axis_rotated ? $$.height : $$.currentHeight - $$.margin2.top - $$.margin2.bottom;
        if ($$.width2 < 0) {
            $$.width2 = 0;
        }
        if ($$.height2 < 0) {
            $$.height2 = 0;
        }

        // for arc
        $$.arcWidth = $$.width - ($$.isLegendRight ? legendWidth + 10 : 0);
        $$.arcHeight = $$.height - ($$.isLegendRight ? 0 : 10);
        if ($$.hasType('gauge') && !config.gauge_fullCircle) {
            $$.arcHeight += $$.height - $$.getGaugeLabelHeight();
        }
        if ($$.updateRadius) {
            $$.updateRadius();
        }

        if ($$.isLegendRight && hasArc) {
            $$.margin3.left = $$.arcWidth / 2 + $$.radiusExpanded * 1.1;
        }
    };

    c3_chart_internal_fn.updateTargets = function (targets) {
        var $$ = this;

        /*-- Main --*/

        //-- Text --//
        $$.updateTargetsForText(targets);

        //-- Bar --//
        $$.updateTargetsForBar(targets);

        //-- Line --//
        $$.updateTargetsForLine(targets);

        //-- Arc --//
        if ($$.hasArcType() && $$.updateTargetsForArc) {
            $$.updateTargetsForArc(targets);
        }

        /*-- Sub --*/

        if ($$.updateTargetsForSubchart) {
            $$.updateTargetsForSubchart(targets);
        }

        // Fade-in each chart
        $$.showTargets();
    };
    c3_chart_internal_fn.showTargets = function () {
        var $$ = this;
        $$.svg.selectAll('.' + CLASS.target).filter(function (d) {
            return $$.isTargetToShow(d.id);
        }).transition().duration($$.config.transition_duration).style("opacity", 1);
    };

    c3_chart_internal_fn.redraw = function (options, transitions) {
        var $$ = this,
            main = $$.main,
            d3 = $$.d3,
            config = $$.config;
        var areaIndices = $$.getShapeIndices($$.isAreaType),
            barIndices = $$.getShapeIndices($$.isBarType),
            lineIndices = $$.getShapeIndices($$.isLineType);
        var withY, withSubchart, withTransition, withTransitionForExit, withTransitionForAxis, withTransform, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain, withLegend, withEventRect, withDimension, withUpdateXAxis;
        var hideAxis = $$.hasArcType();
        var drawArea, drawBar, drawLine, xForText, yForText;
        var duration, durationForExit, durationForAxis;
        var waitForDraw, flow;
        var targetsToShow = $$.filterTargetsToShow($$.data.targets),
            tickValues,
            i,
            intervalForCulling,
            xDomainForZoom;
        var xv = $$.xv.bind($$),
            cx,
            cy;

        options = options || {};
        withY = getOption(options, "withY", true);
        withSubchart = getOption(options, "withSubchart", true);
        withTransition = getOption(options, "withTransition", true);
        withTransform = getOption(options, "withTransform", false);
        withUpdateXDomain = getOption(options, "withUpdateXDomain", false);
        withUpdateOrgXDomain = getOption(options, "withUpdateOrgXDomain", false);
        withTrimXDomain = getOption(options, "withTrimXDomain", true);
        withUpdateXAxis = getOption(options, "withUpdateXAxis", withUpdateXDomain);
        withLegend = getOption(options, "withLegend", false);
        withEventRect = getOption(options, "withEventRect", true);
        withDimension = getOption(options, "withDimension", true);
        withTransitionForExit = getOption(options, "withTransitionForExit", withTransition);
        withTransitionForAxis = getOption(options, "withTransitionForAxis", withTransition);

        duration = withTransition ? config.transition_duration : 0;
        durationForExit = withTransitionForExit ? duration : 0;
        durationForAxis = withTransitionForAxis ? duration : 0;

        transitions = transitions || $$.axis.generateTransitions(durationForAxis);

        // update legend and transform each g
        if (withLegend && config.legend_show) {
            $$.updateLegend($$.mapToIds($$.data.targets), options, transitions);
        } else if (withDimension) {
            // need to update dimension (e.g. axis.y.tick.values) because y tick values should change
            // no need to update axis in it because they will be updated in redraw()
            $$.updateDimension(true);
        }

        // MEMO: needed for grids calculation
        if ($$.isCategorized() && targetsToShow.length === 0) {
            $$.x.domain([0, $$.axes.x.selectAll('.tick').size()]);
        }

        if (targetsToShow.length) {
            $$.updateXDomain(targetsToShow, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain);
            if (!config.axis_x_tick_values) {
                tickValues = $$.axis.updateXAxisTickValues(targetsToShow);
            }
        } else {
            $$.xAxis.tickValues([]);
            $$.subXAxis.tickValues([]);
        }

        if (config.zoom_rescale && !options.flow) {
            xDomainForZoom = $$.x.orgDomain();
        }

        $$.y.domain($$.getYDomain(targetsToShow, 'y', xDomainForZoom));
        $$.y2.domain($$.getYDomain(targetsToShow, 'y2', xDomainForZoom));

        if (!config.axis_y_tick_values && config.axis_y_tick_count) {
            $$.yAxis.tickValues($$.axis.generateTickValues($$.y.domain(), config.axis_y_tick_count));
        }
        if (!config.axis_y2_tick_values && config.axis_y2_tick_count) {
            $$.y2Axis.tickValues($$.axis.generateTickValues($$.y2.domain(), config.axis_y2_tick_count));
        }

        // axes
        $$.axis.redraw(transitions, hideAxis);

        // Update axis label
        $$.axis.updateLabels(withTransition);

        // show/hide if manual culling needed
        if ((withUpdateXDomain || withUpdateXAxis) && targetsToShow.length) {
            if (config.axis_x_tick_culling && tickValues) {
                for (i = 1; i < tickValues.length; i++) {
                    if (tickValues.length / i < config.axis_x_tick_culling_max) {
                        intervalForCulling = i;
                        break;
                    }
                }
                $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').each(function (e) {
                    var index = tickValues.indexOf(e);
                    if (index >= 0) {
                        d3.select(this).style('display', index % intervalForCulling ? 'none' : 'block');
                    }
                });
            } else {
                $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').style('display', 'block');
            }
        }

        // setup drawer - MEMO: these must be called after axis updated
        drawArea = $$.generateDrawArea ? $$.generateDrawArea(areaIndices, false) : undefined;
        drawBar = $$.generateDrawBar ? $$.generateDrawBar(barIndices) : undefined;
        drawLine = $$.generateDrawLine ? $$.generateDrawLine(lineIndices, false) : undefined;
        xForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, true);
        yForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, false);

        // Update sub domain
        if (withY) {
            $$.subY.domain($$.getYDomain(targetsToShow, 'y'));
            $$.subY2.domain($$.getYDomain(targetsToShow, 'y2'));
        }

        // xgrid focus
        $$.updateXgridFocus();

        // Data empty label positioning and text.
        main.select("text." + CLASS.text + '.' + CLASS.empty).attr("x", $$.width / 2).attr("y", $$.height / 2).text(config.data_empty_label_text).transition().style('opacity', targetsToShow.length ? 0 : 1);

        // grid
        $$.updateGrid(duration);

        // rect for regions
        $$.updateRegion(duration);

        // bars
        $$.updateBar(durationForExit);

        // lines, areas and cricles
        $$.updateLine(durationForExit);
        $$.updateArea(durationForExit);
        $$.updateCircle();

        // text
        if ($$.hasDataLabel()) {
            $$.updateText(durationForExit);
        }

        // title
        if ($$.redrawTitle) {
            $$.redrawTitle();
        }

        // arc
        if ($$.redrawArc) {
            $$.redrawArc(duration, durationForExit, withTransform);
        }

        // subchart
        if ($$.redrawSubchart) {
            $$.redrawSubchart(withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices);
        }

        // circles for select
        main.selectAll('.' + CLASS.selectedCircles).filter($$.isBarType.bind($$)).selectAll('circle').remove();

        // event rects will redrawn when flow called
        if (config.interaction_enabled && !options.flow && withEventRect) {
            $$.redrawEventRect();
            if ($$.updateZoom) {
                $$.updateZoom();
            }
        }

        // update circleY based on updated parameters
        $$.updateCircleY();

        // generate circle x/y functions depending on updated params
        cx = ($$.config.axis_rotated ? $$.circleY : $$.circleX).bind($$);
        cy = ($$.config.axis_rotated ? $$.circleX : $$.circleY).bind($$);

        if (options.flow) {
            flow = $$.generateFlow({
                targets: targetsToShow,
                flow: options.flow,
                duration: options.flow.duration,
                drawBar: drawBar,
                drawLine: drawLine,
                drawArea: drawArea,
                cx: cx,
                cy: cy,
                xv: xv,
                xForText: xForText,
                yForText: yForText
            });
        }

        if ((duration || flow) && $$.isTabVisible()) {
            // Only use transition if tab visible. See #938.
            // transition should be derived from one transition
            d3.transition().duration(duration).each(function () {
                var transitionsToWait = [];

                // redraw and gather transitions
                [$$.redrawBar(drawBar, true), $$.redrawLine(drawLine, true), $$.redrawArea(drawArea, true), $$.redrawCircle(cx, cy, true), $$.redrawText(xForText, yForText, options.flow, true), $$.redrawRegion(true), $$.redrawGrid(true)].forEach(function (transitions) {
                    transitions.forEach(function (transition) {
                        transitionsToWait.push(transition);
                    });
                });

                // Wait for end of transitions to call flow and onrendered callback
                waitForDraw = $$.generateWait();
                transitionsToWait.forEach(function (t) {
                    waitForDraw.add(t);
                });
            }).call(waitForDraw, function () {
                if (flow) {
                    flow();
                }
                if (config.onrendered) {
                    config.onrendered.call($$);
                }
            });
        } else {
            $$.redrawBar(drawBar);
            $$.redrawLine(drawLine);
            $$.redrawArea(drawArea);
            $$.redrawCircle(cx, cy);
            $$.redrawText(xForText, yForText, options.flow);
            $$.redrawRegion();
            $$.redrawGrid();
            if (config.onrendered) {
                config.onrendered.call($$);
            }
        }

        // update fadein condition
        $$.mapToIds($$.data.targets).forEach(function (id) {
            $$.withoutFadeIn[id] = true;
        });
    };

    c3_chart_internal_fn.updateAndRedraw = function (options) {
        var $$ = this,
            config = $$.config,
            transitions;
        options = options || {};
        // same with redraw
        options.withTransition = getOption(options, "withTransition", true);
        options.withTransform = getOption(options, "withTransform", false);
        options.withLegend = getOption(options, "withLegend", false);
        // NOT same with redraw
        options.withUpdateXDomain = true;
        options.withUpdateOrgXDomain = true;
        options.withTransitionForExit = false;
        options.withTransitionForTransform = getOption(options, "withTransitionForTransform", options.withTransition);
        // MEMO: this needs to be called before updateLegend and it means this ALWAYS needs to be called)
        $$.updateSizes();
        // MEMO: called in updateLegend in redraw if withLegend
        if (!(options.withLegend && config.legend_show)) {
            transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0);
            // Update scales
            $$.updateScales();
            $$.updateSvgSize();
            // Update g positions
            $$.transformAll(options.withTransitionForTransform, transitions);
        }
        // Draw with new sizes & scales
        $$.redraw(options, transitions);
    };
    c3_chart_internal_fn.redrawWithoutRescale = function () {
        this.redraw({
            withY: false,
            withSubchart: false,
            withEventRect: false,
            withTransitionForAxis: false
        });
    };

    c3_chart_internal_fn.isTimeSeries = function () {
        return this.config.axis_x_type === 'timeseries';
    };
    c3_chart_internal_fn.isCategorized = function () {
        return this.config.axis_x_type.indexOf('categor') >= 0;
    };
    c3_chart_internal_fn.isCustomX = function () {
        var $$ = this,
            config = $$.config;
        return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
    };

    c3_chart_internal_fn.isTimeSeriesY = function () {
        return this.config.axis_y_type === 'timeseries';
    };

    c3_chart_internal_fn.getTranslate = function (target) {
        var $$ = this,
            config = $$.config,
            x,
            y;
        if (target === 'main') {
            x = asHalfPixel($$.margin.left);
            y = asHalfPixel($$.margin.top);
        } else if (target === 'context') {
            x = asHalfPixel($$.margin2.left);
            y = asHalfPixel($$.margin2.top);
        } else if (target === 'legend') {
            x = $$.margin3.left;
            y = $$.margin3.top;
        } else if (target === 'x') {
            x = 0;
            y = config.axis_rotated ? 0 : $$.height;
        } else if (target === 'y') {
            x = 0;
            y = config.axis_rotated ? $$.height : 0;
        } else if (target === 'y2') {
            x = config.axis_rotated ? 0 : $$.width;
            y = config.axis_rotated ? 1 : 0;
        } else if (target === 'subx') {
            x = 0;
            y = config.axis_rotated ? 0 : $$.height2;
        } else if (target === 'arc') {
            x = $$.arcWidth / 2;
            y = $$.arcHeight / 2 - ($$.hasType('gauge') ? 6 : 0); // to prevent wrong display of min and max label
        }
        return "translate(" + x + "," + y + ")";
    };
    c3_chart_internal_fn.initialOpacity = function (d) {
        return d.value !== null && this.withoutFadeIn[d.id] ? 1 : 0;
    };
    c3_chart_internal_fn.initialOpacityForCircle = function (d) {
        return d.value !== null && this.withoutFadeIn[d.id] ? this.opacityForCircle(d) : 0;
    };
    c3_chart_internal_fn.opacityForCircle = function (d) {
        var isPointShouldBeShown = isFunction(this.config.point_show) ? this.config.point_show(d) : this.config.point_show;
        var opacity = isPointShouldBeShown ? 1 : 0;
        return isValue(d.value) ? this.isScatterType(d) ? 0.5 : opacity : 0;
    };
    c3_chart_internal_fn.opacityForText = function () {
        return this.hasDataLabel() ? 1 : 0;
    };
    c3_chart_internal_fn.xx = function (d) {
        return d ? this.x(d.x) : null;
    };
    c3_chart_internal_fn.xv = function (d) {
        var $$ = this,
            value = d.value;
        if ($$.isTimeSeries()) {
            value = $$.parseDate(d.value);
        } else if ($$.isCategorized() && typeof d.value === 'string') {
            value = $$.config.axis_x_categories.indexOf(d.value);
        }
        return Math.ceil($$.x(value));
    };
    c3_chart_internal_fn.yv = function (d) {
        var $$ = this,
            yScale = d.axis && d.axis === 'y2' ? $$.y2 : $$.y;
        return Math.ceil(yScale(d.value));
    };
    c3_chart_internal_fn.subxx = function (d) {
        return d ? this.subX(d.x) : null;
    };

    c3_chart_internal_fn.transformMain = function (withTransition, transitions) {
        var $$ = this,
            xAxis,
            yAxis,
            y2Axis;
        if (transitions && transitions.axisX) {
            xAxis = transitions.axisX;
        } else {
            xAxis = $$.main.select('.' + CLASS.axisX);
            if (withTransition) {
                xAxis = xAxis.transition();
            }
        }
        if (transitions && transitions.axisY) {
            yAxis = transitions.axisY;
        } else {
            yAxis = $$.main.select('.' + CLASS.axisY);
            if (withTransition) {
                yAxis = yAxis.transition();
            }
        }
        if (transitions && transitions.axisY2) {
            y2Axis = transitions.axisY2;
        } else {
            y2Axis = $$.main.select('.' + CLASS.axisY2);
            if (withTransition) {
                y2Axis = y2Axis.transition();
            }
        }
        (withTransition ? $$.main.transition() : $$.main).attr("transform", $$.getTranslate('main'));
        xAxis.attr("transform", $$.getTranslate('x'));
        yAxis.attr("transform", $$.getTranslate('y'));
        y2Axis.attr("transform", $$.getTranslate('y2'));
        $$.main.select('.' + CLASS.chartArcs).attr("transform", $$.getTranslate('arc'));
    };
    c3_chart_internal_fn.transformAll = function (withTransition, transitions) {
        var $$ = this;
        $$.transformMain(withTransition, transitions);
        if ($$.config.subchart_show) {
            $$.transformContext(withTransition, transitions);
        }
        if ($$.legend) {
            $$.transformLegend(withTransition);
        }
    };

    c3_chart_internal_fn.updateSvgSize = function () {
        var $$ = this,
            brush = $$.svg.select(".c3-brush .background");
        $$.svg.attr('width', $$.currentWidth).attr('height', $$.currentHeight);
        $$.svg.selectAll(['#' + $$.clipId, '#' + $$.clipIdForGrid]).select('rect').attr('width', $$.width).attr('height', $$.height);
        $$.svg.select('#' + $$.clipIdForXAxis).select('rect').attr('x', $$.getXAxisClipX.bind($$)).attr('y', $$.getXAxisClipY.bind($$)).attr('width', $$.getXAxisClipWidth.bind($$)).attr('height', $$.getXAxisClipHeight.bind($$));
        $$.svg.select('#' + $$.clipIdForYAxis).select('rect').attr('x', $$.getYAxisClipX.bind($$)).attr('y', $$.getYAxisClipY.bind($$)).attr('width', $$.getYAxisClipWidth.bind($$)).attr('height', $$.getYAxisClipHeight.bind($$));
        $$.svg.select('#' + $$.clipIdForSubchart).select('rect').attr('width', $$.width).attr('height', brush.size() ? brush.attr('height') : 0);
        $$.svg.select('.' + CLASS.zoomRect).attr('width', $$.width).attr('height', $$.height);
        // MEMO: parent div's height will be bigger than svg when <!DOCTYPE html>
        $$.selectChart.style('max-height', $$.currentHeight + "px");
    };

    c3_chart_internal_fn.updateDimension = function (withoutAxis) {
        var $$ = this;
        if (!withoutAxis) {
            if ($$.config.axis_rotated) {
                $$.axes.x.call($$.xAxis);
                $$.axes.subx.call($$.subXAxis);
            } else {
                $$.axes.y.call($$.yAxis);
                $$.axes.y2.call($$.y2Axis);
            }
        }
        $$.updateSizes();
        $$.updateScales();
        $$.updateSvgSize();
        $$.transformAll(false);
    };

    c3_chart_internal_fn.observeInserted = function (selection) {
        var $$ = this,
            observer;
        if (typeof MutationObserver === 'undefined') {
            window.console.error("MutationObserver not defined.");
            return;
        }
        observer = new MutationObserver(function (mutations) {
            mutations.forEach(function (mutation) {
                if (mutation.type === 'childList' && mutation.previousSibling) {
                    observer.disconnect();
                    // need to wait for completion of load because size calculation requires the actual sizes determined after that completion
                    $$.intervalForObserveInserted = window.setInterval(function () {
                        // parentNode will NOT be null when completed
                        if (selection.node().parentNode) {
                            window.clearInterval($$.intervalForObserveInserted);
                            $$.updateDimension();
                            if ($$.brush) {
                                $$.brush.update();
                            }
                            $$.config.oninit.call($$);
                            $$.redraw({
                                withTransform: true,
                                withUpdateXDomain: true,
                                withUpdateOrgXDomain: true,
                                withTransition: false,
                                withTransitionForTransform: false,
                                withLegend: true
                            });
                            selection.transition().style('opacity', 1);
                        }
                    }, 10);
                }
            });
        });
        observer.observe(selection.node(), { attributes: true, childList: true, characterData: true });
    };

    c3_chart_internal_fn.bindResize = function () {
        var $$ = this,
            config = $$.config;

        $$.resizeFunction = $$.generateResize(); // need to call .remove

        $$.resizeFunction.add(function () {
            config.onresize.call($$);
        });
        if (config.resize_auto) {
            $$.resizeFunction.add(function () {
                if ($$.resizeTimeout !== undefined) {
                    window.clearTimeout($$.resizeTimeout);
                }
                $$.resizeTimeout = window.setTimeout(function () {
                    delete $$.resizeTimeout;
                    $$.api.flush();
                }, 100);
            });
        }
        $$.resizeFunction.add(function () {
            config.onresized.call($$);
        });

        $$.resizeIfElementDisplayed = function () {
            // if element not displayed skip it
            if ($$.api == null || !$$.api.element.offsetParent) {
                return;
            }

            $$.resizeFunction();
        };

        if (window.attachEvent) {
            window.attachEvent('onresize', $$.resizeIfElementDisplayed);
        } else if (window.addEventListener) {
            window.addEventListener('resize', $$.resizeIfElementDisplayed, false);
        } else {
            // fallback to this, if this is a very old browser
            var wrapper = window.onresize;
            if (!wrapper) {
                // create a wrapper that will call all charts
                wrapper = $$.generateResize();
            } else if (!wrapper.add || !wrapper.remove) {
                // there is already a handler registered, make sure we call it too
                wrapper = $$.generateResize();
                wrapper.add(window.onresize);
            }
            // add this graph to the wrapper, we will be removed if the user calls destroy
            wrapper.add($$.resizeFunction);
            window.onresize = function () {
                // if element not displayed skip it
                if (!$$.api.element.offsetParent) {
                    return;
                }

                wrapper();
            };
        }
    };

    c3_chart_internal_fn.generateResize = function () {
        var resizeFunctions = [];
        function callResizeFunctions() {
            resizeFunctions.forEach(function (f) {
                f();
            });
        }
        callResizeFunctions.add = function (f) {
            resizeFunctions.push(f);
        };
        callResizeFunctions.remove = function (f) {
            for (var i = 0; i < resizeFunctions.length; i++) {
                if (resizeFunctions[i] === f) {
                    resizeFunctions.splice(i, 1);
                    break;
                }
            }
        };
        return callResizeFunctions;
    };

    c3_chart_internal_fn.endall = function (transition, callback) {
        var n = 0;
        transition.each(function () {
            ++n;
        }).each("end", function () {
            if (! --n) {
                callback.apply(this, arguments);
            }
        });
    };
    c3_chart_internal_fn.generateWait = function () {
        var transitionsToWait = [],
            f = function f(transition, callback) {
            var timer = setInterval(function () {
                var done = 0;
                transitionsToWait.forEach(function (t) {
                    if (t.empty()) {
                        done += 1;
                        return;
                    }
                    try {
                        t.transition();
                    } catch (e) {
                        done += 1;
                    }
                });
                if (done === transitionsToWait.length) {
                    clearInterval(timer);
                    if (callback) {
                        callback();
                    }
                }
            }, 10);
        };
        f.add = function (transition) {
            transitionsToWait.push(transition);
        };
        return f;
    };

    c3_chart_internal_fn.parseDate = function (date) {
        var $$ = this,
            parsedDate;
        if (date instanceof Date) {
            parsedDate = date;
        } else if (typeof date === 'string') {
            parsedDate = $$.dataTimeFormat($$.config.data_xFormat).parse(date);
        } else if ((typeof date === 'undefined' ? 'undefined' : _typeof(date)) === 'object') {
            parsedDate = new Date(+date);
        } else if (typeof date === 'number' && !isNaN(date)) {
            parsedDate = new Date(+date);
        }
        if (!parsedDate || isNaN(+parsedDate)) {
            window.console.error("Failed to parse x '" + date + "' to Date object");
        }
        return parsedDate;
    };

    c3_chart_internal_fn.isTabVisible = function () {
        var hidden;
        if (typeof document.hidden !== "undefined") {
            // Opera 12.10 and Firefox 18 and later support
            hidden = "hidden";
        } else if (typeof document.mozHidden !== "undefined") {
            hidden = "mozHidden";
        } else if (typeof document.msHidden !== "undefined") {
            hidden = "msHidden";
        } else if (typeof document.webkitHidden !== "undefined") {
            hidden = "webkitHidden";
        }

        return document[hidden] ? false : true;
    };

    c3_chart_internal_fn.isValue = isValue;
    c3_chart_internal_fn.isFunction = isFunction;
    c3_chart_internal_fn.isString = isString;
    c3_chart_internal_fn.isUndefined = isUndefined;
    c3_chart_internal_fn.isDefined = isDefined;
    c3_chart_internal_fn.ceil10 = ceil10;
    c3_chart_internal_fn.asHalfPixel = asHalfPixel;
    c3_chart_internal_fn.diffDomain = diffDomain;
    c3_chart_internal_fn.isEmpty = isEmpty;
    c3_chart_internal_fn.notEmpty = notEmpty;
    c3_chart_internal_fn.notEmpty = notEmpty;
    c3_chart_internal_fn.getOption = getOption;
    c3_chart_internal_fn.hasValue = hasValue;
    c3_chart_internal_fn.sanitise = sanitise;
    c3_chart_internal_fn.getPathBox = getPathBox;
    c3_chart_internal_fn.CLASS = CLASS;

    /* jshint ignore:start */

    // PhantomJS doesn't have support for Function.prototype.bind, which has caused confusion. Use
    // this polyfill to avoid the confusion.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill

    if (!Function.prototype.bind) {
        Function.prototype.bind = function (oThis) {
            if (typeof this !== 'function') {
                // closest thing possible to the ECMAScript 5
                // internal IsCallable function
                throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
            }

            var aArgs = Array.prototype.slice.call(arguments, 1),
                fToBind = this,
                fNOP = function fNOP() {},
                fBound = function fBound() {
                return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
            };

            fNOP.prototype = this.prototype;
            fBound.prototype = new fNOP();

            return fBound;
        };
    }

    // SVGPathSeg API polyfill
    // https://github.com/progers/pathseg
    //
    // This is a drop-in replacement for the SVGPathSeg and SVGPathSegList APIs that were removed from
    // SVG2 (https://lists.w3.org/Archives/Public/www-svg/2015Jun/0044.html), including the latest spec
    // changes which were implemented in Firefox 43 and Chrome 46.

    (function () {

        if (!("SVGPathSeg" in window)) {
            // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSeg
            window.SVGPathSeg = function (type, typeAsLetter, owningPathSegList) {
                this.pathSegType = type;
                this.pathSegTypeAsLetter = typeAsLetter;
                this._owningPathSegList = owningPathSegList;
            };

            window.SVGPathSeg.prototype.classname = "SVGPathSeg";

            window.SVGPathSeg.PATHSEG_UNKNOWN = 0;
            window.SVGPathSeg.PATHSEG_CLOSEPATH = 1;
            window.SVGPathSeg.PATHSEG_MOVETO_ABS = 2;
            window.SVGPathSeg.PATHSEG_MOVETO_REL = 3;
            window.SVGPathSeg.PATHSEG_LINETO_ABS = 4;
            window.SVGPathSeg.PATHSEG_LINETO_REL = 5;
            window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6;
            window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL = 7;
            window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8;
            window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9;
            window.SVGPathSeg.PATHSEG_ARC_ABS = 10;
            window.SVGPathSeg.PATHSEG_ARC_REL = 11;
            window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12;
            window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13;
            window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14;
            window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL = 15;
            window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;
            window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;
            window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;
            window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;

            // Notify owning PathSegList on any changes so they can be synchronized back to the path element.
            window.SVGPathSeg.prototype._segmentChanged = function () {
                if (this._owningPathSegList) this._owningPathSegList.segmentChanged(this);
            };

            window.SVGPathSegClosePath = function (owningPathSegList) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CLOSEPATH, "z", owningPathSegList);
            };
            window.SVGPathSegClosePath.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegClosePath.prototype.toString = function () {
                return "[object SVGPathSegClosePath]";
            };
            window.SVGPathSegClosePath.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter;
            };
            window.SVGPathSegClosePath.prototype.clone = function () {
                return new window.SVGPathSegClosePath(undefined);
            };

            window.SVGPathSegMovetoAbs = function (owningPathSegList, x, y) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_ABS, "M", owningPathSegList);
                this._x = x;
                this._y = y;
            };
            window.SVGPathSegMovetoAbs.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegMovetoAbs.prototype.toString = function () {
                return "[object SVGPathSegMovetoAbs]";
            };
            window.SVGPathSegMovetoAbs.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
            };
            window.SVGPathSegMovetoAbs.prototype.clone = function () {
                return new window.SVGPathSegMovetoAbs(undefined, this._x, this._y);
            };
            Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, "x", { get: function get() {
                    return this._x;
                }, set: function set(x) {
                    this._x = x;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, "y", { get: function get() {
                    return this._y;
                }, set: function set(y) {
                    this._y = y;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegMovetoRel = function (owningPathSegList, x, y) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_REL, "m", owningPathSegList);
                this._x = x;
                this._y = y;
            };
            window.SVGPathSegMovetoRel.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegMovetoRel.prototype.toString = function () {
                return "[object SVGPathSegMovetoRel]";
            };
            window.SVGPathSegMovetoRel.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
            };
            window.SVGPathSegMovetoRel.prototype.clone = function () {
                return new window.SVGPathSegMovetoRel(undefined, this._x, this._y);
            };
            Object.defineProperty(window.SVGPathSegMovetoRel.prototype, "x", { get: function get() {
                    return this._x;
                }, set: function set(x) {
                    this._x = x;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegMovetoRel.prototype, "y", { get: function get() {
                    return this._y;
                }, set: function set(y) {
                    this._y = y;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegLinetoAbs = function (owningPathSegList, x, y) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_ABS, "L", owningPathSegList);
                this._x = x;
                this._y = y;
            };
            window.SVGPathSegLinetoAbs.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegLinetoAbs.prototype.toString = function () {
                return "[object SVGPathSegLinetoAbs]";
            };
            window.SVGPathSegLinetoAbs.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
            };
            window.SVGPathSegLinetoAbs.prototype.clone = function () {
                return new window.SVGPathSegLinetoAbs(undefined, this._x, this._y);
            };
            Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, "x", { get: function get() {
                    return this._x;
                }, set: function set(x) {
                    this._x = x;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, "y", { get: function get() {
                    return this._y;
                }, set: function set(y) {
                    this._y = y;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegLinetoRel = function (owningPathSegList, x, y) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_REL, "l", owningPathSegList);
                this._x = x;
                this._y = y;
            };
            window.SVGPathSegLinetoRel.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegLinetoRel.prototype.toString = function () {
                return "[object SVGPathSegLinetoRel]";
            };
            window.SVGPathSegLinetoRel.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
            };
            window.SVGPathSegLinetoRel.prototype.clone = function () {
                return new window.SVGPathSegLinetoRel(undefined, this._x, this._y);
            };
            Object.defineProperty(window.SVGPathSegLinetoRel.prototype, "x", { get: function get() {
                    return this._x;
                }, set: function set(x) {
                    this._x = x;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegLinetoRel.prototype, "y", { get: function get() {
                    return this._y;
                }, set: function set(y) {
                    this._y = y;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegCurvetoCubicAbs = function (owningPathSegList, x, y, x1, y1, x2, y2) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS, "C", owningPathSegList);
                this._x = x;
                this._y = y;
                this._x1 = x1;
                this._y1 = y1;
                this._x2 = x2;
                this._y2 = y2;
            };
            window.SVGPathSegCurvetoCubicAbs.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegCurvetoCubicAbs.prototype.toString = function () {
                return "[object SVGPathSegCurvetoCubicAbs]";
            };
            window.SVGPathSegCurvetoCubicAbs.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;
            };
            window.SVGPathSegCurvetoCubicAbs.prototype.clone = function () {
                return new window.SVGPathSegCurvetoCubicAbs(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2);
            };
            Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "x", { get: function get() {
                    return this._x;
                }, set: function set(x) {
                    this._x = x;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "y", { get: function get() {
                    return this._y;
                }, set: function set(y) {
                    this._y = y;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "x1", { get: function get() {
                    return this._x1;
                }, set: function set(x1) {
                    this._x1 = x1;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "y1", { get: function get() {
                    return this._y1;
                }, set: function set(y1) {
                    this._y1 = y1;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "x2", { get: function get() {
                    return this._x2;
                }, set: function set(x2) {
                    this._x2 = x2;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, "y2", { get: function get() {
                    return this._y2;
                }, set: function set(y2) {
                    this._y2 = y2;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegCurvetoCubicRel = function (owningPathSegList, x, y, x1, y1, x2, y2) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL, "c", owningPathSegList);
                this._x = x;
                this._y = y;
                this._x1 = x1;
                this._y1 = y1;
                this._x2 = x2;
                this._y2 = y2;
            };
            window.SVGPathSegCurvetoCubicRel.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegCurvetoCubicRel.prototype.toString = function () {
                return "[object SVGPathSegCurvetoCubicRel]";
            };
            window.SVGPathSegCurvetoCubicRel.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;
            };
            window.SVGPathSegCurvetoCubicRel.prototype.clone = function () {
                return new window.SVGPathSegCurvetoCubicRel(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2);
            };
            Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "x", { get: function get() {
                    return this._x;
                }, set: function set(x) {
                    this._x = x;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "y", { get: function get() {
                    return this._y;
                }, set: function set(y) {
                    this._y = y;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "x1", { get: function get() {
                    return this._x1;
                }, set: function set(x1) {
                    this._x1 = x1;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "y1", { get: function get() {
                    return this._y1;
                }, set: function set(y1) {
                    this._y1 = y1;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "x2", { get: function get() {
                    return this._x2;
                }, set: function set(x2) {
                    this._x2 = x2;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, "y2", { get: function get() {
                    return this._y2;
                }, set: function set(y2) {
                    this._y2 = y2;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegCurvetoQuadraticAbs = function (owningPathSegList, x, y, x1, y1) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS, "Q", owningPathSegList);
                this._x = x;
                this._y = y;
                this._x1 = x1;
                this._y1 = y1;
            };
            window.SVGPathSegCurvetoQuadraticAbs.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegCurvetoQuadraticAbs.prototype.toString = function () {
                return "[object SVGPathSegCurvetoQuadraticAbs]";
            };
            window.SVGPathSegCurvetoQuadraticAbs.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x + " " + this._y;
            };
            window.SVGPathSegCurvetoQuadraticAbs.prototype.clone = function () {
                return new window.SVGPathSegCurvetoQuadraticAbs(undefined, this._x, this._y, this._x1, this._y1);
            };
            Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, "x", { get: function get() {
                    return this._x;
                }, set: function set(x) {
                    this._x = x;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, "y", { get: function get() {
                    return this._y;
                }, set: function set(y) {
                    this._y = y;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, "x1", { get: function get() {
                    return this._x1;
                }, set: function set(x1) {
                    this._x1 = x1;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, "y1", { get: function get() {
                    return this._y1;
                }, set: function set(y1) {
                    this._y1 = y1;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegCurvetoQuadraticRel = function (owningPathSegList, x, y, x1, y1) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL, "q", owningPathSegList);
                this._x = x;
                this._y = y;
                this._x1 = x1;
                this._y1 = y1;
            };
            window.SVGPathSegCurvetoQuadraticRel.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegCurvetoQuadraticRel.prototype.toString = function () {
                return "[object SVGPathSegCurvetoQuadraticRel]";
            };
            window.SVGPathSegCurvetoQuadraticRel.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x + " " + this._y;
            };
            window.SVGPathSegCurvetoQuadraticRel.prototype.clone = function () {
                return new window.SVGPathSegCurvetoQuadraticRel(undefined, this._x, this._y, this._x1, this._y1);
            };
            Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, "x", { get: function get() {
                    return this._x;
                }, set: function set(x) {
                    this._x = x;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, "y", { get: function get() {
                    return this._y;
                }, set: function set(y) {
                    this._y = y;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, "x1", { get: function get() {
                    return this._x1;
                }, set: function set(x1) {
                    this._x1 = x1;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, "y1", { get: function get() {
                    return this._y1;
                }, set: function set(y1) {
                    this._y1 = y1;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegArcAbs = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_ABS, "A", owningPathSegList);
                this._x = x;
                this._y = y;
                this._r1 = r1;
                this._r2 = r2;
                this._angle = angle;
                this._largeArcFlag = largeArcFlag;
                this._sweepFlag = sweepFlag;
            };
            window.SVGPathSegArcAbs.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegArcAbs.prototype.toString = function () {
                return "[object SVGPathSegArcAbs]";
            };
            window.SVGPathSegArcAbs.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._r1 + " " + this._r2 + " " + this._angle + " " + (this._largeArcFlag ? "1" : "0") + " " + (this._sweepFlag ? "1" : "0") + " " + this._x + " " + this._y;
            };
            window.SVGPathSegArcAbs.prototype.clone = function () {
                return new window.SVGPathSegArcAbs(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);
            };
            Object.defineProperty(window.SVGPathSegArcAbs.prototype, "x", { get: function get() {
                    return this._x;
                }, set: function set(x) {
                    this._x = x;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegArcAbs.prototype, "y", { get: function get() {
                    return this._y;
                }, set: function set(y) {
                    this._y = y;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegArcAbs.prototype, "r1", { get: function get() {
                    return this._r1;
                }, set: function set(r1) {
                    this._r1 = r1;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegArcAbs.prototype, "r2", { get: function get() {
                    return this._r2;
                }, set: function set(r2) {
                    this._r2 = r2;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegArcAbs.prototype, "angle", { get: function get() {
                    return this._angle;
                }, set: function set(angle) {
                    this._angle = angle;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegArcAbs.prototype, "largeArcFlag", { get: function get() {
                    return this._largeArcFlag;
                }, set: function set(largeArcFlag) {
                    this._largeArcFlag = largeArcFlag;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegArcAbs.prototype, "sweepFlag", { get: function get() {
                    return this._sweepFlag;
                }, set: function set(sweepFlag) {
                    this._sweepFlag = sweepFlag;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegArcRel = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_REL, "a", owningPathSegList);
                this._x = x;
                this._y = y;
                this._r1 = r1;
                this._r2 = r2;
                this._angle = angle;
                this._largeArcFlag = largeArcFlag;
                this._sweepFlag = sweepFlag;
            };
            window.SVGPathSegArcRel.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegArcRel.prototype.toString = function () {
                return "[object SVGPathSegArcRel]";
            };
            window.SVGPathSegArcRel.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._r1 + " " + this._r2 + " " + this._angle + " " + (this._largeArcFlag ? "1" : "0") + " " + (this._sweepFlag ? "1" : "0") + " " + this._x + " " + this._y;
            };
            window.SVGPathSegArcRel.prototype.clone = function () {
                return new window.SVGPathSegArcRel(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);
            };
            Object.defineProperty(window.SVGPathSegArcRel.prototype, "x", { get: function get() {
                    return this._x;
                }, set: function set(x) {
                    this._x = x;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegArcRel.prototype, "y", { get: function get() {
                    return this._y;
                }, set: function set(y) {
                    this._y = y;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegArcRel.prototype, "r1", { get: function get() {
                    return this._r1;
                }, set: function set(r1) {
                    this._r1 = r1;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegArcRel.prototype, "r2", { get: function get() {
                    return this._r2;
                }, set: function set(r2) {
                    this._r2 = r2;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegArcRel.prototype, "angle", { get: function get() {
                    return this._angle;
                }, set: function set(angle) {
                    this._angle = angle;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegArcRel.prototype, "largeArcFlag", { get: function get() {
                    return this._largeArcFlag;
                }, set: function set(largeArcFlag) {
                    this._largeArcFlag = largeArcFlag;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegArcRel.prototype, "sweepFlag", { get: function get() {
                    return this._sweepFlag;
                }, set: function set(sweepFlag) {
                    this._sweepFlag = sweepFlag;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegLinetoHorizontalAbs = function (owningPathSegList, x) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS, "H", owningPathSegList);
                this._x = x;
            };
            window.SVGPathSegLinetoHorizontalAbs.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegLinetoHorizontalAbs.prototype.toString = function () {
                return "[object SVGPathSegLinetoHorizontalAbs]";
            };
            window.SVGPathSegLinetoHorizontalAbs.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._x;
            };
            window.SVGPathSegLinetoHorizontalAbs.prototype.clone = function () {
                return new window.SVGPathSegLinetoHorizontalAbs(undefined, this._x);
            };
            Object.defineProperty(window.SVGPathSegLinetoHorizontalAbs.prototype, "x", { get: function get() {
                    return this._x;
                }, set: function set(x) {
                    this._x = x;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegLinetoHorizontalRel = function (owningPathSegList, x) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL, "h", owningPathSegList);
                this._x = x;
            };
            window.SVGPathSegLinetoHorizontalRel.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegLinetoHorizontalRel.prototype.toString = function () {
                return "[object SVGPathSegLinetoHorizontalRel]";
            };
            window.SVGPathSegLinetoHorizontalRel.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._x;
            };
            window.SVGPathSegLinetoHorizontalRel.prototype.clone = function () {
                return new window.SVGPathSegLinetoHorizontalRel(undefined, this._x);
            };
            Object.defineProperty(window.SVGPathSegLinetoHorizontalRel.prototype, "x", { get: function get() {
                    return this._x;
                }, set: function set(x) {
                    this._x = x;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegLinetoVerticalAbs = function (owningPathSegList, y) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS, "V", owningPathSegList);
                this._y = y;
            };
            window.SVGPathSegLinetoVerticalAbs.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegLinetoVerticalAbs.prototype.toString = function () {
                return "[object SVGPathSegLinetoVerticalAbs]";
            };
            window.SVGPathSegLinetoVerticalAbs.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._y;
            };
            window.SVGPathSegLinetoVerticalAbs.prototype.clone = function () {
                return new window.SVGPathSegLinetoVerticalAbs(undefined, this._y);
            };
            Object.defineProperty(window.SVGPathSegLinetoVerticalAbs.prototype, "y", { get: function get() {
                    return this._y;
                }, set: function set(y) {
                    this._y = y;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegLinetoVerticalRel = function (owningPathSegList, y) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL, "v", owningPathSegList);
                this._y = y;
            };
            window.SVGPathSegLinetoVerticalRel.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegLinetoVerticalRel.prototype.toString = function () {
                return "[object SVGPathSegLinetoVerticalRel]";
            };
            window.SVGPathSegLinetoVerticalRel.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._y;
            };
            window.SVGPathSegLinetoVerticalRel.prototype.clone = function () {
                return new window.SVGPathSegLinetoVerticalRel(undefined, this._y);
            };
            Object.defineProperty(window.SVGPathSegLinetoVerticalRel.prototype, "y", { get: function get() {
                    return this._y;
                }, set: function set(y) {
                    this._y = y;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegCurvetoCubicSmoothAbs = function (owningPathSegList, x, y, x2, y2) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, "S", owningPathSegList);
                this._x = x;
                this._y = y;
                this._x2 = x2;
                this._y2 = y2;
            };
            window.SVGPathSegCurvetoCubicSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegCurvetoCubicSmoothAbs.prototype.toString = function () {
                return "[object SVGPathSegCurvetoCubicSmoothAbs]";
            };
            window.SVGPathSegCurvetoCubicSmoothAbs.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;
            };
            window.SVGPathSegCurvetoCubicSmoothAbs.prototype.clone = function () {
                return new window.SVGPathSegCurvetoCubicSmoothAbs(undefined, this._x, this._y, this._x2, this._y2);
            };
            Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, "x", { get: function get() {
                    return this._x;
                }, set: function set(x) {
                    this._x = x;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, "y", { get: function get() {
                    return this._y;
                }, set: function set(y) {
                    this._y = y;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, "x2", { get: function get() {
                    return this._x2;
                }, set: function set(x2) {
                    this._x2 = x2;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, "y2", { get: function get() {
                    return this._y2;
                }, set: function set(y2) {
                    this._y2 = y2;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegCurvetoCubicSmoothRel = function (owningPathSegList, x, y, x2, y2) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL, "s", owningPathSegList);
                this._x = x;
                this._y = y;
                this._x2 = x2;
                this._y2 = y2;
            };
            window.SVGPathSegCurvetoCubicSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegCurvetoCubicSmoothRel.prototype.toString = function () {
                return "[object SVGPathSegCurvetoCubicSmoothRel]";
            };
            window.SVGPathSegCurvetoCubicSmoothRel.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;
            };
            window.SVGPathSegCurvetoCubicSmoothRel.prototype.clone = function () {
                return new window.SVGPathSegCurvetoCubicSmoothRel(undefined, this._x, this._y, this._x2, this._y2);
            };
            Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, "x", { get: function get() {
                    return this._x;
                }, set: function set(x) {
                    this._x = x;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, "y", { get: function get() {
                    return this._y;
                }, set: function set(y) {
                    this._y = y;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, "x2", { get: function get() {
                    return this._x2;
                }, set: function set(x2) {
                    this._x2 = x2;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, "y2", { get: function get() {
                    return this._y2;
                }, set: function set(y2) {
                    this._y2 = y2;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegCurvetoQuadraticSmoothAbs = function (owningPathSegList, x, y) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, "T", owningPathSegList);
                this._x = x;
                this._y = y;
            };
            window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.toString = function () {
                return "[object SVGPathSegCurvetoQuadraticSmoothAbs]";
            };
            window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
            };
            window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.clone = function () {
                return new window.SVGPathSegCurvetoQuadraticSmoothAbs(undefined, this._x, this._y);
            };
            Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, "x", { get: function get() {
                    return this._x;
                }, set: function set(x) {
                    this._x = x;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, "y", { get: function get() {
                    return this._y;
                }, set: function set(y) {
                    this._y = y;this._segmentChanged();
                }, enumerable: true });

            window.SVGPathSegCurvetoQuadraticSmoothRel = function (owningPathSegList, x, y) {
                window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, "t", owningPathSegList);
                this._x = x;
                this._y = y;
            };
            window.SVGPathSegCurvetoQuadraticSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype);
            window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.toString = function () {
                return "[object SVGPathSegCurvetoQuadraticSmoothRel]";
            };
            window.SVGPathSegCurvetoQuadraticSmoothRel.prototype._asPathString = function () {
                return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;
            };
            window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.clone = function () {
                return new window.SVGPathSegCurvetoQuadraticSmoothRel(undefined, this._x, this._y);
            };
            Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, "x", { get: function get() {
                    return this._x;
                }, set: function set(x) {
                    this._x = x;this._segmentChanged();
                }, enumerable: true });
            Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, "y", { get: function get() {
                    return this._y;
                }, set: function set(y) {
                    this._y = y;this._segmentChanged();
                }, enumerable: true });

            // Add createSVGPathSeg* functions to window.SVGPathElement.
            // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-Interfacewindow.SVGPathElement.
            window.SVGPathElement.prototype.createSVGPathSegClosePath = function () {
                return new window.SVGPathSegClosePath(undefined);
            };
            window.SVGPathElement.prototype.createSVGPathSegMovetoAbs = function (x, y) {
                return new window.SVGPathSegMovetoAbs(undefined, x, y);
            };
            window.SVGPathElement.prototype.createSVGPathSegMovetoRel = function (x, y) {
                return new window.SVGPathSegMovetoRel(undefined, x, y);
            };
            window.SVGPathElement.prototype.createSVGPathSegLinetoAbs = function (x, y) {
                return new window.SVGPathSegLinetoAbs(undefined, x, y);
            };
            window.SVGPathElement.prototype.createSVGPathSegLinetoRel = function (x, y) {
                return new window.SVGPathSegLinetoRel(undefined, x, y);
            };
            window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs = function (x, y, x1, y1, x2, y2) {
                return new window.SVGPathSegCurvetoCubicAbs(undefined, x, y, x1, y1, x2, y2);
            };
            window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel = function (x, y, x1, y1, x2, y2) {
                return new window.SVGPathSegCurvetoCubicRel(undefined, x, y, x1, y1, x2, y2);
            };
            window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs = function (x, y, x1, y1) {
                return new window.SVGPathSegCurvetoQuadraticAbs(undefined, x, y, x1, y1);
            };
            window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel = function (x, y, x1, y1) {
                return new window.SVGPathSegCurvetoQuadraticRel(undefined, x, y, x1, y1);
            };
            window.SVGPathElement.prototype.createSVGPathSegArcAbs = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
                return new window.SVGPathSegArcAbs(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag);
            };
            window.SVGPathElement.prototype.createSVGPathSegArcRel = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
                return new window.SVGPathSegArcRel(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag);
            };
            window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs = function (x) {
                return new window.SVGPathSegLinetoHorizontalAbs(undefined, x);
            };
            window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel = function (x) {
                return new window.SVGPathSegLinetoHorizontalRel(undefined, x);
            };
            window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs = function (y) {
                return new window.SVGPathSegLinetoVerticalAbs(undefined, y);
            };
            window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel = function (y) {
                return new window.SVGPathSegLinetoVerticalRel(undefined, y);
            };
            window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs = function (x, y, x2, y2) {
                return new window.SVGPathSegCurvetoCubicSmoothAbs(undefined, x, y, x2, y2);
            };
            window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel = function (x, y, x2, y2) {
                return new window.SVGPathSegCurvetoCubicSmoothRel(undefined, x, y, x2, y2);
            };
            window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs = function (x, y) {
                return new window.SVGPathSegCurvetoQuadraticSmoothAbs(undefined, x, y);
            };
            window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel = function (x, y) {
                return new window.SVGPathSegCurvetoQuadraticSmoothRel(undefined, x, y);
            };

            if (!("getPathSegAtLength" in window.SVGPathElement.prototype)) {
                // Add getPathSegAtLength to SVGPathElement.
                // Spec: https://www.w3.org/TR/SVG11/single-page.html#paths-__svg__SVGPathElement__getPathSegAtLength
                // This polyfill requires SVGPathElement.getTotalLength to implement the distance-along-a-path algorithm.
                window.SVGPathElement.prototype.getPathSegAtLength = function (distance) {
                    if (distance === undefined || !isFinite(distance)) throw "Invalid arguments.";

                    var measurementElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    measurementElement.setAttribute("d", this.getAttribute("d"));
                    var lastPathSegment = measurementElement.pathSegList.numberOfItems - 1;

                    // If the path is empty, return 0.
                    if (lastPathSegment <= 0) return 0;

                    do {
                        measurementElement.pathSegList.removeItem(lastPathSegment);
                        if (distance > measurementElement.getTotalLength()) break;
                        lastPathSegment--;
                    } while (lastPathSegment > 0);
                    return lastPathSegment;
                };
            }
        }

        if (!("SVGPathSegList" in window)) {
            // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSegList
            window.SVGPathSegList = function (pathElement) {
                this._pathElement = pathElement;
                this._list = this._parsePath(this._pathElement.getAttribute("d"));

                // Use a MutationObserver to catch changes to the path's "d" attribute.
                this._mutationObserverConfig = { "attributes": true, "attributeFilter": ["d"] };
                this._pathElementMutationObserver = new MutationObserver(this._updateListFromPathMutations.bind(this));
                this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);
            };

            window.SVGPathSegList.prototype.classname = "SVGPathSegList";

            Object.defineProperty(window.SVGPathSegList.prototype, "numberOfItems", {
                get: function get() {
                    this._checkPathSynchronizedToList();
                    return this._list.length;
                },
                enumerable: true
            });

            // Add the pathSegList accessors to window.SVGPathElement.
            // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGAnimatedPathData
            Object.defineProperty(window.SVGPathElement.prototype, "pathSegList", {
                get: function get() {
                    if (!this._pathSegList) this._pathSegList = new window.SVGPathSegList(this);
                    return this._pathSegList;
                },
                enumerable: true
            });
            // FIXME: The following are not implemented and simply return window.SVGPathElement.pathSegList.
            Object.defineProperty(window.SVGPathElement.prototype, "normalizedPathSegList", { get: function get() {
                    return this.pathSegList;
                }, enumerable: true });
            Object.defineProperty(window.SVGPathElement.prototype, "animatedPathSegList", { get: function get() {
                    return this.pathSegList;
                }, enumerable: true });
            Object.defineProperty(window.SVGPathElement.prototype, "animatedNormalizedPathSegList", { get: function get() {
                    return this.pathSegList;
                }, enumerable: true });

            // Process any pending mutations to the path element and update the list as needed.
            // This should be the first call of all public functions and is needed because
            // MutationObservers are not synchronous so we can have pending asynchronous mutations.
            window.SVGPathSegList.prototype._checkPathSynchronizedToList = function () {
                this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords());
            };

            window.SVGPathSegList.prototype._updateListFromPathMutations = function (mutationRecords) {
                if (!this._pathElement) return;
                var hasPathMutations = false;
                mutationRecords.forEach(function (record) {
                    if (record.attributeName == "d") hasPathMutations = true;
                });
                if (hasPathMutations) this._list = this._parsePath(this._pathElement.getAttribute("d"));
            };

            // Serialize the list and update the path's 'd' attribute.
            window.SVGPathSegList.prototype._writeListToPath = function () {
                this._pathElementMutationObserver.disconnect();
                this._pathElement.setAttribute("d", window.SVGPathSegList._pathSegArrayAsString(this._list));
                this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);
            };

            // When a path segment changes the list needs to be synchronized back to the path element.
            window.SVGPathSegList.prototype.segmentChanged = function (pathSeg) {
                this._writeListToPath();
            };

            window.SVGPathSegList.prototype.clear = function () {
                this._checkPathSynchronizedToList();

                this._list.forEach(function (pathSeg) {
                    pathSeg._owningPathSegList = null;
                });
                this._list = [];
                this._writeListToPath();
            };

            window.SVGPathSegList.prototype.initialize = function (newItem) {
                this._checkPathSynchronizedToList();

                this._list = [newItem];
                newItem._owningPathSegList = this;
                this._writeListToPath();
                return newItem;
            };

            window.SVGPathSegList.prototype._checkValidIndex = function (index) {
                if (isNaN(index) || index < 0 || index >= this.numberOfItems) throw "INDEX_SIZE_ERR";
            };

            window.SVGPathSegList.prototype.getItem = function (index) {
                this._checkPathSynchronizedToList();

                this._checkValidIndex(index);
                return this._list[index];
            };

            window.SVGPathSegList.prototype.insertItemBefore = function (newItem, index) {
                this._checkPathSynchronizedToList();

                // Spec: If the index is greater than or equal to numberOfItems, then the new item is appended to the end of the list.
                if (index > this.numberOfItems) index = this.numberOfItems;
                if (newItem._owningPathSegList) {
                    // SVG2 spec says to make a copy.
                    newItem = newItem.clone();
                }
                this._list.splice(index, 0, newItem);
                newItem._owningPathSegList = this;
                this._writeListToPath();
                return newItem;
            };

            window.SVGPathSegList.prototype.replaceItem = function (newItem, index) {
                this._checkPathSynchronizedToList();

                if (newItem._owningPathSegList) {
                    // SVG2 spec says to make a copy.
                    newItem = newItem.clone();
                }
                this._checkValidIndex(index);
                this._list[index] = newItem;
                newItem._owningPathSegList = this;
                this._writeListToPath();
                return newItem;
            };

            window.SVGPathSegList.prototype.removeItem = function (index) {
                this._checkPathSynchronizedToList();

                this._checkValidIndex(index);
                var item = this._list[index];
                this._list.splice(index, 1);
                this._writeListToPath();
                return item;
            };

            window.SVGPathSegList.prototype.appendItem = function (newItem) {
                this._checkPathSynchronizedToList();

                if (newItem._owningPathSegList) {
                    // SVG2 spec says to make a copy.
                    newItem = newItem.clone();
                }
                this._list.push(newItem);
                newItem._owningPathSegList = this;
                // TODO: Optimize this to just append to the existing attribute.
                this._writeListToPath();
                return newItem;
            };

            window.SVGPathSegList._pathSegArrayAsString = function (pathSegArray) {
                var string = "";
                var first = true;
                pathSegArray.forEach(function (pathSeg) {
                    if (first) {
                        first = false;
                        string += pathSeg._asPathString();
                    } else {
                        string += " " + pathSeg._asPathString();
                    }
                });
                return string;
            };

            // This closely follows SVGPathParser::parsePath from Source/core/svg/SVGPathParser.cpp.
            window.SVGPathSegList.prototype._parsePath = function (string) {
                if (!string || string.length == 0) return [];

                var owningPathSegList = this;

                var Builder = function Builder() {
                    this.pathSegList = [];
                };

                Builder.prototype.appendSegment = function (pathSeg) {
                    this.pathSegList.push(pathSeg);
                };

                var Source = function Source(string) {
                    this._string = string;
                    this._currentIndex = 0;
                    this._endIndex = this._string.length;
                    this._previousCommand = window.SVGPathSeg.PATHSEG_UNKNOWN;

                    this._skipOptionalSpaces();
                };

                Source.prototype._isCurrentSpace = function () {
                    var character = this._string[this._currentIndex];
                    return character <= " " && (character == " " || character == "\n" || character == "\t" || character == "\r" || character == "\f");
                };

                Source.prototype._skipOptionalSpaces = function () {
                    while (this._currentIndex < this._endIndex && this._isCurrentSpace()) {
                        this._currentIndex++;
                    }return this._currentIndex < this._endIndex;
                };

                Source.prototype._skipOptionalSpacesOrDelimiter = function () {
                    if (this._currentIndex < this._endIndex && !this._isCurrentSpace() && this._string.charAt(this._currentIndex) != ",") return false;
                    if (this._skipOptionalSpaces()) {
                        if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == ",") {
                            this._currentIndex++;
                            this._skipOptionalSpaces();
                        }
                    }
                    return this._currentIndex < this._endIndex;
                };

                Source.prototype.hasMoreData = function () {
                    return this._currentIndex < this._endIndex;
                };

                Source.prototype.peekSegmentType = function () {
                    var lookahead = this._string[this._currentIndex];
                    return this._pathSegTypeFromChar(lookahead);
                };

                Source.prototype._pathSegTypeFromChar = function (lookahead) {
                    switch (lookahead) {
                        case "Z":
                        case "z":
                            return window.SVGPathSeg.PATHSEG_CLOSEPATH;
                        case "M":
                            return window.SVGPathSeg.PATHSEG_MOVETO_ABS;
                        case "m":
                            return window.SVGPathSeg.PATHSEG_MOVETO_REL;
                        case "L":
                            return window.SVGPathSeg.PATHSEG_LINETO_ABS;
                        case "l":
                            return window.SVGPathSeg.PATHSEG_LINETO_REL;
                        case "C":
                            return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS;
                        case "c":
                            return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL;
                        case "Q":
                            return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS;
                        case "q":
                            return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL;
                        case "A":
                            return window.SVGPathSeg.PATHSEG_ARC_ABS;
                        case "a":
                            return window.SVGPathSeg.PATHSEG_ARC_REL;
                        case "H":
                            return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS;
                        case "h":
                            return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL;
                        case "V":
                            return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS;
                        case "v":
                            return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL;
                        case "S":
                            return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS;
                        case "s":
                            return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;
                        case "T":
                            return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS;
                        case "t":
                            return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL;
                        default:
                            return window.SVGPathSeg.PATHSEG_UNKNOWN;
                    }
                };

                Source.prototype._nextCommandHelper = function (lookahead, previousCommand) {
                    // Check for remaining coordinates in the current command.
                    if ((lookahead == "+" || lookahead == "-" || lookahead == "." || lookahead >= "0" && lookahead <= "9") && previousCommand != window.SVGPathSeg.PATHSEG_CLOSEPATH) {
                        if (previousCommand == window.SVGPathSeg.PATHSEG_MOVETO_ABS) return window.SVGPathSeg.PATHSEG_LINETO_ABS;
                        if (previousCommand == window.SVGPathSeg.PATHSEG_MOVETO_REL) return window.SVGPathSeg.PATHSEG_LINETO_REL;
                        return previousCommand;
                    }
                    return window.SVGPathSeg.PATHSEG_UNKNOWN;
                };

                Source.prototype.initialCommandIsMoveTo = function () {
                    // If the path is empty it is still valid, so return true.
                    if (!this.hasMoreData()) return true;
                    var command = this.peekSegmentType();
                    // Path must start with moveTo.
                    return command == window.SVGPathSeg.PATHSEG_MOVETO_ABS || command == window.SVGPathSeg.PATHSEG_MOVETO_REL;
                };

                // Parse a number from an SVG path. This very closely follows genericParseNumber(...) from Source/core/svg/SVGParserUtilities.cpp.
                // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF
                Source.prototype._parseNumber = function () {
                    var exponent = 0;
                    var integer = 0;
                    var frac = 1;
                    var decimal = 0;
                    var sign = 1;
                    var expsign = 1;

                    var startIndex = this._currentIndex;

                    this._skipOptionalSpaces();

                    // Read the sign.
                    if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == "+") this._currentIndex++;else if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == "-") {
                        this._currentIndex++;
                        sign = -1;
                    }

                    if (this._currentIndex == this._endIndex || (this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") && this._string.charAt(this._currentIndex) != ".")
                        // The first character of a number must be one of [0-9+-.].
                        return undefined;

                    // Read the integer part, build right-to-left.
                    var startIntPartIndex = this._currentIndex;
                    while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9") {
                        this._currentIndex++;
                    } // Advance to first non-digit.

                    if (this._currentIndex != startIntPartIndex) {
                        var scanIntPartIndex = this._currentIndex - 1;
                        var multiplier = 1;
                        while (scanIntPartIndex >= startIntPartIndex) {
                            integer += multiplier * (this._string.charAt(scanIntPartIndex--) - "0");
                            multiplier *= 10;
                        }
                    }

                    // Read the decimals.
                    if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == ".") {
                        this._currentIndex++;

                        // There must be a least one digit following the .
                        if (this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") return undefined;
                        while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9") {
                            frac *= 10;
                            decimal += (this._string.charAt(this._currentIndex) - "0") / frac;
                            this._currentIndex += 1;
                        }
                    }

                    // Read the exponent part.
                    if (this._currentIndex != startIndex && this._currentIndex + 1 < this._endIndex && (this._string.charAt(this._currentIndex) == "e" || this._string.charAt(this._currentIndex) == "E") && this._string.charAt(this._currentIndex + 1) != "x" && this._string.charAt(this._currentIndex + 1) != "m") {
                        this._currentIndex++;

                        // Read the sign of the exponent.
                        if (this._string.charAt(this._currentIndex) == "+") {
                            this._currentIndex++;
                        } else if (this._string.charAt(this._currentIndex) == "-") {
                            this._currentIndex++;
                            expsign = -1;
                        }

                        // There must be an exponent.
                        if (this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") return undefined;

                        while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9") {
                            exponent *= 10;
                            exponent += this._string.charAt(this._currentIndex) - "0";
                            this._currentIndex++;
                        }
                    }

                    var number = integer + decimal;
                    number *= sign;

                    if (exponent) number *= Math.pow(10, expsign * exponent);

                    if (startIndex == this._currentIndex) return undefined;

                    this._skipOptionalSpacesOrDelimiter();

                    return number;
                };

                Source.prototype._parseArcFlag = function () {
                    if (this._currentIndex >= this._endIndex) return undefined;
                    var flag = false;
                    var flagChar = this._string.charAt(this._currentIndex++);
                    if (flagChar == "0") flag = false;else if (flagChar == "1") flag = true;else return undefined;

                    this._skipOptionalSpacesOrDelimiter();
                    return flag;
                };

                Source.prototype.parseSegment = function () {
                    var lookahead = this._string[this._currentIndex];
                    var command = this._pathSegTypeFromChar(lookahead);
                    if (command == window.SVGPathSeg.PATHSEG_UNKNOWN) {
                        // Possibly an implicit command. Not allowed if this is the first command.
                        if (this._previousCommand == window.SVGPathSeg.PATHSEG_UNKNOWN) return null;
                        command = this._nextCommandHelper(lookahead, this._previousCommand);
                        if (command == window.SVGPathSeg.PATHSEG_UNKNOWN) return null;
                    } else {
                        this._currentIndex++;
                    }

                    this._previousCommand = command;

                    switch (command) {
                        case window.SVGPathSeg.PATHSEG_MOVETO_REL:
                            return new window.SVGPathSegMovetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                        case window.SVGPathSeg.PATHSEG_MOVETO_ABS:
                            return new window.SVGPathSegMovetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                        case window.SVGPathSeg.PATHSEG_LINETO_REL:
                            return new window.SVGPathSegLinetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                        case window.SVGPathSeg.PATHSEG_LINETO_ABS:
                            return new window.SVGPathSegLinetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                        case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:
                            return new window.SVGPathSegLinetoHorizontalRel(owningPathSegList, this._parseNumber());
                        case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:
                            return new window.SVGPathSegLinetoHorizontalAbs(owningPathSegList, this._parseNumber());
                        case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:
                            return new window.SVGPathSegLinetoVerticalRel(owningPathSegList, this._parseNumber());
                        case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:
                            return new window.SVGPathSegLinetoVerticalAbs(owningPathSegList, this._parseNumber());
                        case window.SVGPathSeg.PATHSEG_CLOSEPATH:
                            this._skipOptionalSpaces();
                            return new window.SVGPathSegClosePath(owningPathSegList);
                        case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:
                            var points = { x1: this._parseNumber(), y1: this._parseNumber(), x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                            return new window.SVGPathSegCurvetoCubicRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);
                        case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
                            var points = { x1: this._parseNumber(), y1: this._parseNumber(), x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                            return new window.SVGPathSegCurvetoCubicAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);
                        case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:
                            var points = { x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                            return new window.SVGPathSegCurvetoCubicSmoothRel(owningPathSegList, points.x, points.y, points.x2, points.y2);
                        case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:
                            var points = { x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                            return new window.SVGPathSegCurvetoCubicSmoothAbs(owningPathSegList, points.x, points.y, points.x2, points.y2);
                        case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:
                            var points = { x1: this._parseNumber(), y1: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                            return new window.SVGPathSegCurvetoQuadraticRel(owningPathSegList, points.x, points.y, points.x1, points.y1);
                        case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:
                            var points = { x1: this._parseNumber(), y1: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };
                            return new window.SVGPathSegCurvetoQuadraticAbs(owningPathSegList, points.x, points.y, points.x1, points.y1);
                        case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:
                            return new window.SVGPathSegCurvetoQuadraticSmoothRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                        case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:
                            return new window.SVGPathSegCurvetoQuadraticSmoothAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                        case window.SVGPathSeg.PATHSEG_ARC_REL:
                            var points = { x1: this._parseNumber(), y1: this._parseNumber(), arcAngle: this._parseNumber(), arcLarge: this._parseArcFlag(), arcSweep: this._parseArcFlag(), x: this._parseNumber(), y: this._parseNumber() };
                            return new window.SVGPathSegArcRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);
                        case window.SVGPathSeg.PATHSEG_ARC_ABS:
                            var points = { x1: this._parseNumber(), y1: this._parseNumber(), arcAngle: this._parseNumber(), arcLarge: this._parseArcFlag(), arcSweep: this._parseArcFlag(), x: this._parseNumber(), y: this._parseNumber() };
                            return new window.SVGPathSegArcAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);
                        default:
                            throw "Unknown path seg type.";
                    }
                };

                var builder = new Builder();
                var source = new Source(string);

                if (!source.initialCommandIsMoveTo()) return [];
                while (source.hasMoreData()) {
                    var pathSeg = source.parseSegment();
                    if (!pathSeg) return [];
                    builder.appendSegment(pathSeg);
                }

                return builder.pathSegList;
            };
        }
    })();

    // String.padEnd polyfill for IE11
    //
    // https://github.com/uxitten/polyfill/blob/master/string.polyfill.js
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd
    if (!String.prototype.padEnd) {
        String.prototype.padEnd = function padEnd(targetLength, padString) {
            targetLength = targetLength >> 0; //floor if number or convert non-number to 0;
            padString = String(typeof padString !== 'undefined' ? padString : ' ');
            if (this.length > targetLength) {
                return String(this);
            } else {
                targetLength = targetLength - this.length;
                if (targetLength > padString.length) {
                    padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
                }
                return String(this) + padString.slice(0, targetLength);
            }
        };
    }

    /* jshint ignore:end */

    c3_chart_fn.axis = function () {};
    c3_chart_fn.axis.labels = function (labels) {
        var $$ = this.internal;
        if (arguments.length) {
            Object.keys(labels).forEach(function (axisId) {
                $$.axis.setLabelText(axisId, labels[axisId]);
            });
            $$.axis.updateLabels();
        }
        // TODO: return some values?
    };
    c3_chart_fn.axis.max = function (max) {
        var $$ = this.internal,
            config = $$.config;
        if (arguments.length) {
            if ((typeof max === 'undefined' ? 'undefined' : _typeof(max)) === 'object') {
                if (isValue(max.x)) {
                    config.axis_x_max = max.x;
                }
                if (isValue(max.y)) {
                    config.axis_y_max = max.y;
                }
                if (isValue(max.y2)) {
                    config.axis_y2_max = max.y2;
                }
            } else {
                config.axis_y_max = config.axis_y2_max = max;
            }
            $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
        } else {
            return {
                x: config.axis_x_max,
                y: config.axis_y_max,
                y2: config.axis_y2_max
            };
        }
    };
    c3_chart_fn.axis.min = function (min) {
        var $$ = this.internal,
            config = $$.config;
        if (arguments.length) {
            if ((typeof min === 'undefined' ? 'undefined' : _typeof(min)) === 'object') {
                if (isValue(min.x)) {
                    config.axis_x_min = min.x;
                }
                if (isValue(min.y)) {
                    config.axis_y_min = min.y;
                }
                if (isValue(min.y2)) {
                    config.axis_y2_min = min.y2;
                }
            } else {
                config.axis_y_min = config.axis_y2_min = min;
            }
            $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
        } else {
            return {
                x: config.axis_x_min,
                y: config.axis_y_min,
                y2: config.axis_y2_min
            };
        }
    };
    c3_chart_fn.axis.range = function (range) {
        if (arguments.length) {
            if (isDefined(range.max)) {
                this.axis.max(range.max);
            }
            if (isDefined(range.min)) {
                this.axis.min(range.min);
            }
        } else {
            return {
                max: this.axis.max(),
                min: this.axis.min()
            };
        }
    };

    c3_chart_fn.category = function (i, category) {
        var $$ = this.internal,
            config = $$.config;
        if (arguments.length > 1) {
            config.axis_x_categories[i] = category;
            $$.redraw();
        }
        return config.axis_x_categories[i];
    };
    c3_chart_fn.categories = function (categories) {
        var $$ = this.internal,
            config = $$.config;
        if (!arguments.length) {
            return config.axis_x_categories;
        }
        config.axis_x_categories = categories;
        $$.redraw();
        return config.axis_x_categories;
    };

    c3_chart_fn.resize = function (size) {
        var $$ = this.internal,
            config = $$.config;
        config.size_width = size ? size.width : null;
        config.size_height = size ? size.height : null;
        this.flush();
    };

    c3_chart_fn.flush = function () {
        var $$ = this.internal;
        $$.updateAndRedraw({ withLegend: true, withTransition: false, withTransitionForTransform: false });
    };

    c3_chart_fn.destroy = function () {
        var $$ = this.internal;

        window.clearInterval($$.intervalForObserveInserted);

        if ($$.resizeTimeout !== undefined) {
            window.clearTimeout($$.resizeTimeout);
        }

        if (window.detachEvent) {
            window.detachEvent('onresize', $$.resizeIfElementDisplayed);
        } else if (window.removeEventListener) {
            window.removeEventListener('resize', $$.resizeIfElementDisplayed);
        } else {
            var wrapper = window.onresize;
            // check if no one else removed our wrapper and remove our resizeFunction from it
            if (wrapper && wrapper.add && wrapper.remove) {
                wrapper.remove($$.resizeFunction);
            }
        }

        // remove the inner resize functions
        $$.resizeFunction.remove();

        $$.selectChart.classed('c3', false).html("");

        // MEMO: this is needed because the reference of some elements will not be released, then memory leak will happen.
        Object.keys($$).forEach(function (key) {
            $$[key] = null;
        });

        return null;
    };

    // TODO: fix
    c3_chart_fn.color = function (id) {
        var $$ = this.internal;
        return $$.color(id); // more patterns
    };

    c3_chart_fn.data = function (targetIds) {
        var targets = this.internal.data.targets;
        return typeof targetIds === 'undefined' ? targets : targets.filter(function (t) {
            return [].concat(targetIds).indexOf(t.id) >= 0;
        });
    };
    c3_chart_fn.data.shown = function (targetIds) {
        return this.internal.filterTargetsToShow(this.data(targetIds));
    };
    c3_chart_fn.data.values = function (targetId) {
        var targets,
            values = null;
        if (targetId) {
            targets = this.data(targetId);
            values = targets[0] ? targets[0].values.map(function (d) {
                return d.value;
            }) : null;
        }
        return values;
    };
    c3_chart_fn.data.names = function (names) {
        this.internal.clearLegendItemTextBoxCache();
        return this.internal.updateDataAttributes('names', names);
    };
    c3_chart_fn.data.colors = function (colors) {
        return this.internal.updateDataAttributes('colors', colors);
    };
    c3_chart_fn.data.axes = function (axes) {
        return this.internal.updateDataAttributes('axes', axes);
    };

    c3_chart_fn.flow = function (args) {
        var $$ = this.internal,
            targets,
            data,
            notfoundIds = [],
            orgDataCount = $$.getMaxDataCount(),
            dataCount,
            domain,
            baseTarget,
            baseValue,
            length = 0,
            tail = 0,
            diff,
            to;

        if (args.json) {
            data = $$.convertJsonToData(args.json, args.keys);
        } else if (args.rows) {
            data = $$.convertRowsToData(args.rows);
        } else if (args.columns) {
            data = $$.convertColumnsToData(args.columns);
        } else {
            return;
        }
        targets = $$.convertDataToTargets(data, true);

        // Update/Add data
        $$.data.targets.forEach(function (t) {
            var found = false,
                i,
                j;
            for (i = 0; i < targets.length; i++) {
                if (t.id === targets[i].id) {
                    found = true;

                    if (t.values[t.values.length - 1]) {
                        tail = t.values[t.values.length - 1].index + 1;
                    }
                    length = targets[i].values.length;

                    for (j = 0; j < length; j++) {
                        targets[i].values[j].index = tail + j;
                        if (!$$.isTimeSeries()) {
                            targets[i].values[j].x = tail + j;
                        }
                    }
                    t.values = t.values.concat(targets[i].values);

                    targets.splice(i, 1);
                    break;
                }
            }
            if (!found) {
                notfoundIds.push(t.id);
            }
        });

        // Append null for not found targets
        $$.data.targets.forEach(function (t) {
            var i, j;
            for (i = 0; i < notfoundIds.length; i++) {
                if (t.id === notfoundIds[i]) {
                    tail = t.values[t.values.length - 1].index + 1;
                    for (j = 0; j < length; j++) {
                        t.values.push({
                            id: t.id,
                            index: tail + j,
                            x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + j) : tail + j,
                            value: null
                        });
                    }
                }
            }
        });

        // Generate null values for new target
        if ($$.data.targets.length) {
            targets.forEach(function (t) {
                var i,
                    missing = [];
                for (i = $$.data.targets[0].values[0].index; i < tail; i++) {
                    missing.push({
                        id: t.id,
                        index: i,
                        x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,
                        value: null
                    });
                }
                t.values.forEach(function (v) {
                    v.index += tail;
                    if (!$$.isTimeSeries()) {
                        v.x += tail;
                    }
                });
                t.values = missing.concat(t.values);
            });
        }
        $$.data.targets = $$.data.targets.concat(targets); // add remained

        // check data count because behavior needs to change when it's only one
        dataCount = $$.getMaxDataCount();
        baseTarget = $$.data.targets[0];
        baseValue = baseTarget.values[0];

        // Update length to flow if needed
        if (isDefined(args.to)) {
            length = 0;
            to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to;
            baseTarget.values.forEach(function (v) {
                if (v.x < to) {
                    length++;
                }
            });
        } else if (isDefined(args.length)) {
            length = args.length;
        }

        // If only one data, update the domain to flow from left edge of the chart
        if (!orgDataCount) {
            if ($$.isTimeSeries()) {
                if (baseTarget.values.length > 1) {
                    diff = baseTarget.values[baseTarget.values.length - 1].x - baseValue.x;
                } else {
                    diff = baseValue.x - $$.getXDomain($$.data.targets)[0];
                }
            } else {
                diff = 1;
            }
            domain = [baseValue.x - diff, baseValue.x];
            $$.updateXDomain(null, true, true, false, domain);
        } else if (orgDataCount === 1) {
            if ($$.isTimeSeries()) {
                diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2;
                domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)];
                $$.updateXDomain(null, true, true, false, domain);
            }
        }

        // Set targets
        $$.updateTargets($$.data.targets);

        // Redraw with new targets
        $$.redraw({
            flow: {
                index: baseValue.index,
                length: length,
                duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,
                done: args.done,
                orgDataCount: orgDataCount
            },
            withLegend: true,
            withTransition: orgDataCount > 1,
            withTrimXDomain: false,
            withUpdateXAxis: true
        });
    };

    c3_chart_internal_fn.generateFlow = function (args) {
        var $$ = this,
            config = $$.config,
            d3 = $$.d3;

        return function () {
            var targets = args.targets,
                flow = args.flow,
                drawBar = args.drawBar,
                drawLine = args.drawLine,
                drawArea = args.drawArea,
                cx = args.cx,
                cy = args.cy,
                xv = args.xv,
                xForText = args.xForText,
                yForText = args.yForText,
                duration = args.duration;

            var translateX,
                scaleX = 1,
                transform,
                flowIndex = flow.index,
                flowLength = flow.length,
                flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex),
                flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength),
                orgDomain = $$.x.domain(),
                domain,
                durationForFlow = flow.duration || duration,
                done = flow.done || function () {},
                wait = $$.generateWait();

            var xgrid = $$.xgrid || d3.selectAll([]),
                xgridLines = $$.xgridLines || d3.selectAll([]),
                mainRegion = $$.mainRegion || d3.selectAll([]),
                mainText = $$.mainText || d3.selectAll([]),
                mainBar = $$.mainBar || d3.selectAll([]),
                mainLine = $$.mainLine || d3.selectAll([]),
                mainArea = $$.mainArea || d3.selectAll([]),
                mainCircle = $$.mainCircle || d3.selectAll([]);

            // set flag
            $$.flowing = true;

            // remove head data after rendered
            $$.data.targets.forEach(function (d) {
                d.values.splice(0, flowLength);
            });

            // update x domain to generate axis elements for flow
            domain = $$.updateXDomain(targets, true, true);
            // update elements related to x scale
            if ($$.updateXGrid) {
                $$.updateXGrid(true);
            }

            // generate transform to flow
            if (!flow.orgDataCount) {
                // if empty
                if ($$.data.targets[0].values.length !== 1) {
                    translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
                } else {
                    if ($$.isTimeSeries()) {
                        flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0);
                        flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1);
                        translateX = $$.x(flowStart.x) - $$.x(flowEnd.x);
                    } else {
                        translateX = diffDomain(domain) / 2;
                    }
                }
            } else if (flow.orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x)) {
                translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
            } else {
                if ($$.isTimeSeries()) {
                    translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
                } else {
                    translateX = $$.x(flowStart.x) - $$.x(flowEnd.x);
                }
            }
            scaleX = diffDomain(orgDomain) / diffDomain(domain);
            transform = 'translate(' + translateX + ',0) scale(' + scaleX + ',1)';

            $$.hideXGridFocus();

            d3.transition().ease('linear').duration(durationForFlow).each(function () {
                wait.add($$.axes.x.transition().call($$.xAxis));
                wait.add(mainBar.transition().attr('transform', transform));
                wait.add(mainLine.transition().attr('transform', transform));
                wait.add(mainArea.transition().attr('transform', transform));
                wait.add(mainCircle.transition().attr('transform', transform));
                wait.add(mainText.transition().attr('transform', transform));
                wait.add(mainRegion.filter($$.isRegionOnX).transition().attr('transform', transform));
                wait.add(xgrid.transition().attr('transform', transform));
                wait.add(xgridLines.transition().attr('transform', transform));
            }).call(wait, function () {
                var i,
                    shapes = [],
                    texts = [],
                    eventRects = [];

                // remove flowed elements
                if (flowLength) {
                    for (i = 0; i < flowLength; i++) {
                        shapes.push('.' + CLASS.shape + '-' + (flowIndex + i));
                        texts.push('.' + CLASS.text + '-' + (flowIndex + i));
                        eventRects.push('.' + CLASS.eventRect + '-' + (flowIndex + i));
                    }
                    $$.svg.selectAll('.' + CLASS.shapes).selectAll(shapes).remove();
                    $$.svg.selectAll('.' + CLASS.texts).selectAll(texts).remove();
                    $$.svg.selectAll('.' + CLASS.eventRects).selectAll(eventRects).remove();
                    $$.svg.select('.' + CLASS.xgrid).remove();
                }

                // draw again for removing flowed elements and reverting attr
                xgrid.attr('transform', null).attr($$.xgridAttr);
                xgridLines.attr('transform', null);
                xgridLines.select('line').attr("x1", config.axis_rotated ? 0 : xv).attr("x2", config.axis_rotated ? $$.width : xv);
                xgridLines.select('text').attr("x", config.axis_rotated ? $$.width : 0).attr("y", xv);
                mainBar.attr('transform', null).attr("d", drawBar);
                mainLine.attr('transform', null).attr("d", drawLine);
                mainArea.attr('transform', null).attr("d", drawArea);
                mainCircle.attr('transform', null).attr("cx", cx).attr("cy", cy);
                mainText.attr('transform', null).attr('x', xForText).attr('y', yForText).style('fill-opacity', $$.opacityForText.bind($$));
                mainRegion.attr('transform', null);
                mainRegion.select('rect').filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$));

                if (config.interaction_enabled) {
                    $$.redrawEventRect();
                }

                // callback for end of flow
                done();

                $$.flowing = false;
            });
        };
    };

    c3_chart_fn.focus = function (targetIds) {
        var $$ = this.internal,
            candidates;

        targetIds = $$.mapToTargetIds(targetIds);
        candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$))), this.revert();
        this.defocus();
        candidates.classed(CLASS.focused, true).classed(CLASS.defocused, false);
        if ($$.hasArcType()) {
            $$.expandArc(targetIds);
        }
        $$.toggleFocusLegend(targetIds, true);

        $$.focusedTargetIds = targetIds;
        $$.defocusedTargetIds = $$.defocusedTargetIds.filter(function (id) {
            return targetIds.indexOf(id) < 0;
        });
    };

    c3_chart_fn.defocus = function (targetIds) {
        var $$ = this.internal,
            candidates;

        targetIds = $$.mapToTargetIds(targetIds);
        candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$))), candidates.classed(CLASS.focused, false).classed(CLASS.defocused, true);
        if ($$.hasArcType()) {
            $$.unexpandArc(targetIds);
        }
        $$.toggleFocusLegend(targetIds, false);

        $$.focusedTargetIds = $$.focusedTargetIds.filter(function (id) {
            return targetIds.indexOf(id) < 0;
        });
        $$.defocusedTargetIds = targetIds;
    };

    c3_chart_fn.revert = function (targetIds) {
        var $$ = this.internal,
            candidates;

        targetIds = $$.mapToTargetIds(targetIds);
        candidates = $$.svg.selectAll($$.selectorTargets(targetIds)); // should be for all targets

        candidates.classed(CLASS.focused, false).classed(CLASS.defocused, false);
        if ($$.hasArcType()) {
            $$.unexpandArc(targetIds);
        }
        if ($$.config.legend_show) {
            $$.showLegend(targetIds.filter($$.isLegendToShow.bind($$)));
            $$.legend.selectAll($$.selectorLegends(targetIds)).filter(function () {
                return $$.d3.select(this).classed(CLASS.legendItemFocused);
            }).classed(CLASS.legendItemFocused, false);
        }

        $$.focusedTargetIds = [];
        $$.defocusedTargetIds = [];
    };

    c3_chart_fn.xgrids = function (grids) {
        var $$ = this.internal,
            config = $$.config;
        if (!grids) {
            return config.grid_x_lines;
        }
        config.grid_x_lines = grids;
        $$.redrawWithoutRescale();
        return config.grid_x_lines;
    };
    c3_chart_fn.xgrids.add = function (grids) {
        var $$ = this.internal;
        return this.xgrids($$.config.grid_x_lines.concat(grids ? grids : []));
    };
    c3_chart_fn.xgrids.remove = function (params) {
        // TODO: multiple
        var $$ = this.internal;
        $$.removeGridLines(params, true);
    };

    c3_chart_fn.ygrids = function (grids) {
        var $$ = this.internal,
            config = $$.config;
        if (!grids) {
            return config.grid_y_lines;
        }
        config.grid_y_lines = grids;
        $$.redrawWithoutRescale();
        return config.grid_y_lines;
    };
    c3_chart_fn.ygrids.add = function (grids) {
        var $$ = this.internal;
        return this.ygrids($$.config.grid_y_lines.concat(grids ? grids : []));
    };
    c3_chart_fn.ygrids.remove = function (params) {
        // TODO: multiple
        var $$ = this.internal;
        $$.removeGridLines(params, false);
    };

    c3_chart_fn.groups = function (groups) {
        var $$ = this.internal,
            config = $$.config;
        if (isUndefined(groups)) {
            return config.data_groups;
        }
        config.data_groups = groups;
        $$.redraw();
        return config.data_groups;
    };

    c3_chart_fn.legend = function () {};
    c3_chart_fn.legend.show = function (targetIds) {
        var $$ = this.internal;
        $$.showLegend($$.mapToTargetIds(targetIds));
        $$.updateAndRedraw({ withLegend: true });
    };
    c3_chart_fn.legend.hide = function (targetIds) {
        var $$ = this.internal;
        $$.hideLegend($$.mapToTargetIds(targetIds));
        $$.updateAndRedraw({ withLegend: true });
    };

    c3_chart_fn.load = function (args) {
        var $$ = this.internal,
            config = $$.config;
        // update xs if specified
        if (args.xs) {
            $$.addXs(args.xs);
        }
        // update names if exists
        if ('names' in args) {
            c3_chart_fn.data.names.bind(this)(args.names);
        }
        // update classes if exists
        if ('classes' in args) {
            Object.keys(args.classes).forEach(function (id) {
                config.data_classes[id] = args.classes[id];
            });
        }
        // update categories if exists
        if ('categories' in args && $$.isCategorized()) {
            config.axis_x_categories = args.categories;
        }
        // update axes if exists
        if ('axes' in args) {
            Object.keys(args.axes).forEach(function (id) {
                config.data_axes[id] = args.axes[id];
            });
        }
        // update colors if exists
        if ('colors' in args) {
            Object.keys(args.colors).forEach(function (id) {
                config.data_colors[id] = args.colors[id];
            });
        }
        // use cache if exists
        if ('cacheIds' in args && $$.hasCaches(args.cacheIds)) {
            $$.load($$.getCaches(args.cacheIds), args.done);
            return;
        }
        // unload if needed
        if ('unload' in args) {
            // TODO: do not unload if target will load (included in url/rows/columns)
            $$.unload($$.mapToTargetIds(typeof args.unload === 'boolean' && args.unload ? null : args.unload), function () {
                $$.loadFromArgs(args);
            });
        } else {
            $$.loadFromArgs(args);
        }
    };

    c3_chart_fn.unload = function (args) {
        var $$ = this.internal;
        args = args || {};
        if (args instanceof Array) {
            args = { ids: args };
        } else if (typeof args === 'string') {
            args = { ids: [args] };
        }
        $$.unload($$.mapToTargetIds(args.ids), function () {
            $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true, withLegend: true });
            if (args.done) {
                args.done();
            }
        });
    };

    c3_chart_fn.regions = function (regions) {
        var $$ = this.internal,
            config = $$.config;
        if (!regions) {
            return config.regions;
        }
        config.regions = regions;
        $$.redrawWithoutRescale();
        return config.regions;
    };
    c3_chart_fn.regions.add = function (regions) {
        var $$ = this.internal,
            config = $$.config;
        if (!regions) {
            return config.regions;
        }
        config.regions = config.regions.concat(regions);
        $$.redrawWithoutRescale();
        return config.regions;
    };
    c3_chart_fn.regions.remove = function (options) {
        var $$ = this.internal,
            config = $$.config,
            duration,
            classes,
            regions;

        options = options || {};
        duration = $$.getOption(options, "duration", config.transition_duration);
        classes = $$.getOption(options, "classes", [CLASS.region]);

        regions = $$.main.select('.' + CLASS.regions).selectAll(classes.map(function (c) {
            return '.' + c;
        }));
        (duration ? regions.transition().duration(duration) : regions).style('opacity', 0).remove();

        config.regions = config.regions.filter(function (region) {
            var found = false;
            if (!region['class']) {
                return true;
            }
            region['class'].split(' ').forEach(function (c) {
                if (classes.indexOf(c) >= 0) {
                    found = true;
                }
            });
            return !found;
        });

        return config.regions;
    };

    c3_chart_fn.selected = function (targetId) {
        var $$ = this.internal,
            d3 = $$.d3;
        return d3.merge($$.main.selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(targetId)).selectAll('.' + CLASS.shape).filter(function () {
            return d3.select(this).classed(CLASS.SELECTED);
        }).map(function (d) {
            return d.map(function (d) {
                var data = d.__data__;return data.data ? data.data : data;
            });
        }));
    };
    c3_chart_fn.select = function (ids, indices, resetOther) {
        var $$ = this.internal,
            d3 = $$.d3,
            config = $$.config;
        if (!config.data_selection_enabled) {
            return;
        }
        $$.main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).each(function (d, i) {
            var shape = d3.select(this),
                id = d.data ? d.data.id : d.id,
                toggle = $$.getToggle(this, d).bind($$),
                isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
                isTargetIndex = !indices || indices.indexOf(i) >= 0,
                isSelected = shape.classed(CLASS.SELECTED);
            // line/area selection not supported yet
            if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {
                return;
            }
            if (isTargetId && isTargetIndex) {
                if (config.data_selection_isselectable(d) && !isSelected) {
                    toggle(true, shape.classed(CLASS.SELECTED, true), d, i);
                }
            } else if (isDefined(resetOther) && resetOther) {
                if (isSelected) {
                    toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
                }
            }
        });
    };
    c3_chart_fn.unselect = function (ids, indices) {
        var $$ = this.internal,
            d3 = $$.d3,
            config = $$.config;
        if (!config.data_selection_enabled) {
            return;
        }
        $$.main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).each(function (d, i) {
            var shape = d3.select(this),
                id = d.data ? d.data.id : d.id,
                toggle = $$.getToggle(this, d).bind($$),
                isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
                isTargetIndex = !indices || indices.indexOf(i) >= 0,
                isSelected = shape.classed(CLASS.SELECTED);
            // line/area selection not supported yet
            if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {
                return;
            }
            if (isTargetId && isTargetIndex) {
                if (config.data_selection_isselectable(d)) {
                    if (isSelected) {
                        toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
                    }
                }
            }
        });
    };

    c3_chart_fn.show = function (targetIds, options) {
        var $$ = this.internal,
            targets;

        targetIds = $$.mapToTargetIds(targetIds);
        options = options || {};

        $$.removeHiddenTargetIds(targetIds);
        targets = $$.svg.selectAll($$.selectorTargets(targetIds));

        targets.transition().style('opacity', 1, 'important').call($$.endall, function () {
            targets.style('opacity', null).style('opacity', 1);
        });

        if (options.withLegend) {
            $$.showLegend(targetIds);
        }

        $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true, withLegend: true });
    };

    c3_chart_fn.hide = function (targetIds, options) {
        var $$ = this.internal,
            targets;

        targetIds = $$.mapToTargetIds(targetIds);
        options = options || {};

        $$.addHiddenTargetIds(targetIds);
        targets = $$.svg.selectAll($$.selectorTargets(targetIds));

        targets.transition().style('opacity', 0, 'important').call($$.endall, function () {
            targets.style('opacity', null).style('opacity', 0);
        });

        if (options.withLegend) {
            $$.hideLegend(targetIds);
        }

        $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true, withLegend: true });
    };

    c3_chart_fn.toggle = function (targetIds, options) {
        var that = this,
            $$ = this.internal;
        $$.mapToTargetIds(targetIds).forEach(function (targetId) {
            $$.isTargetToShow(targetId) ? that.hide(targetId, options) : that.show(targetId, options);
        });
    };

    c3_chart_fn.tooltip = function () {};
    c3_chart_fn.tooltip.show = function (args) {
        var $$ = this.internal,
            index,
            mouse;

        // determine mouse position on the chart
        if (args.mouse) {
            mouse = args.mouse;
        }

        // determine focus data
        if (args.data) {
            if ($$.isMultipleX()) {
                // if multiple xs, target point will be determined by mouse
                mouse = [$$.x(args.data.x), $$.getYScale(args.data.id)(args.data.value)];
                index = null;
            } else {
                // TODO: when tooltip_grouped = false
                index = isValue(args.data.index) ? args.data.index : $$.getIndexByX(args.data.x);
            }
        } else if (typeof args.x !== 'undefined') {
            index = $$.getIndexByX(args.x);
        } else if (typeof args.index !== 'undefined') {
            index = args.index;
        }

        // emulate mouse events to show
        $$.dispatchEvent('mouseover', index, mouse);
        $$.dispatchEvent('mousemove', index, mouse);

        $$.config.tooltip_onshow.call($$, args.data);
    };
    c3_chart_fn.tooltip.hide = function () {
        // TODO: get target data by checking the state of focus
        this.internal.dispatchEvent('mouseout', 0);

        this.internal.config.tooltip_onhide.call(this);
    };

    c3_chart_fn.transform = function (type, targetIds) {
        var $$ = this.internal,
            options = ['pie', 'donut'].indexOf(type) >= 0 ? { withTransform: true } : null;
        $$.transformTo(targetIds, type, options);
    };

    c3_chart_internal_fn.transformTo = function (targetIds, type, optionsForRedraw) {
        var $$ = this,
            withTransitionForAxis = !$$.hasArcType(),
            options = optionsForRedraw || { withTransitionForAxis: withTransitionForAxis };
        options.withTransitionForTransform = false;
        $$.transiting = false;
        $$.setTargetType(targetIds, type);
        $$.updateTargets($$.data.targets); // this is needed when transforming to arc
        $$.updateAndRedraw(options);
    };

    c3_chart_fn.x = function (x) {
        var $$ = this.internal;
        if (arguments.length) {
            $$.updateTargetX($$.data.targets, x);
            $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
        }
        return $$.data.xs;
    };
    c3_chart_fn.xs = function (xs) {
        var $$ = this.internal;
        if (arguments.length) {
            $$.updateTargetXs($$.data.targets, xs);
            $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
        }
        return $$.data.xs;
    };

    c3_chart_fn.zoom = function (domain) {
        var $$ = this.internal;
        if (domain) {
            if ($$.isTimeSeries()) {
                domain = domain.map(function (x) {
                    return $$.parseDate(x);
                });
            }
            $$.brush.extent(domain);
            $$.redraw({ withUpdateXDomain: true, withY: $$.config.zoom_rescale });
            $$.config.zoom_onzoom.call(this, $$.x.orgDomain());
        }
        return $$.brush.extent();
    };
    c3_chart_fn.zoom.enable = function (enabled) {
        var $$ = this.internal;
        $$.config.zoom_enabled = enabled;
        $$.updateAndRedraw();
    };
    c3_chart_fn.unzoom = function () {
        var $$ = this.internal;
        $$.brush.clear().update();
        $$.redraw({ withUpdateXDomain: true });
    };

    c3_chart_fn.zoom.max = function (max) {
        var $$ = this.internal,
            config = $$.config,
            d3 = $$.d3;
        if (max === 0 || max) {
            config.zoom_x_max = d3.max([$$.orgXDomain[1], max]);
        } else {
            return config.zoom_x_max;
        }
    };

    c3_chart_fn.zoom.min = function (min) {
        var $$ = this.internal,
            config = $$.config,
            d3 = $$.d3;
        if (min === 0 || min) {
            config.zoom_x_min = d3.min([$$.orgXDomain[0], min]);
        } else {
            return config.zoom_x_min;
        }
    };

    c3_chart_fn.zoom.range = function (range) {
        if (arguments.length) {
            if (isDefined(range.max)) {
                this.domain.max(range.max);
            }
            if (isDefined(range.min)) {
                this.domain.min(range.min);
            }
        } else {
            return {
                max: this.domain.max(),
                min: this.domain.min()
            };
        }
    };

    c3_chart_internal_fn.initPie = function () {
        var $$ = this,
            d3 = $$.d3;
        $$.pie = d3.layout.pie().value(function (d) {
            return d.values.reduce(function (a, b) {
                return a + b.value;
            }, 0);
        });
        $$.pie.sort($$.getOrderFunction() || null);
    };

    c3_chart_internal_fn.updateRadius = function () {
        var $$ = this,
            config = $$.config,
            w = config.gauge_width || config.donut_width,
            gaugeArcWidth = $$.filterTargetsToShow($$.data.targets).length * $$.config.gauge_arcs_minWidth;
        $$.radiusExpanded = Math.min($$.arcWidth, $$.arcHeight) / 2 * ($$.hasType('gauge') ? 0.85 : 1);
        $$.radius = $$.radiusExpanded * 0.95;
        $$.innerRadiusRatio = w ? ($$.radius - w) / $$.radius : 0.6;
        $$.innerRadius = $$.hasType('donut') || $$.hasType('gauge') ? $$.radius * $$.innerRadiusRatio : 0;
        $$.gaugeArcWidth = w ? w : gaugeArcWidth <= $$.radius - $$.innerRadius ? $$.radius - $$.innerRadius : gaugeArcWidth <= $$.radius ? gaugeArcWidth : $$.radius;
    };

    c3_chart_internal_fn.updateArc = function () {
        var $$ = this;
        $$.svgArc = $$.getSvgArc();
        $$.svgArcExpanded = $$.getSvgArcExpanded();
        $$.svgArcExpandedSub = $$.getSvgArcExpanded(0.98);
    };

    c3_chart_internal_fn.updateAngle = function (d) {
        var $$ = this,
            config = $$.config,
            found = false,
            index = 0,
            gMin,
            gMax,
            gTic,
            gValue;

        if (!config) {
            return null;
        }

        $$.pie($$.filterTargetsToShow($$.data.targets)).forEach(function (t) {
            if (!found && t.data.id === d.data.id) {
                found = true;
                d = t;
                d.index = index;
            }
            index++;
        });
        if (isNaN(d.startAngle)) {
            d.startAngle = 0;
        }
        if (isNaN(d.endAngle)) {
            d.endAngle = d.startAngle;
        }
        if ($$.isGaugeType(d.data)) {
            gMin = config.gauge_min;
            gMax = config.gauge_max;
            gTic = Math.PI * (config.gauge_fullCircle ? 2 : 1) / (gMax - gMin);
            gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin;
            d.startAngle = config.gauge_startingAngle;
            d.endAngle = d.startAngle + gTic * gValue;
        }
        return found ? d : null;
    };

    c3_chart_internal_fn.getSvgArc = function () {
        var $$ = this,
            hasGaugeType = $$.hasType('gauge'),
            singleArcWidth = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
            arc = $$.d3.svg.arc().outerRadius(function (d) {
            return hasGaugeType ? $$.radius - singleArcWidth * d.index : $$.radius;
        }).innerRadius(function (d) {
            return hasGaugeType ? $$.radius - singleArcWidth * (d.index + 1) : $$.innerRadius;
        }),
            newArc = function newArc(d, withoutUpdate) {
            var updated;
            if (withoutUpdate) {
                return arc(d);
            } // for interpolate
            updated = $$.updateAngle(d);
            return updated ? arc(updated) : "M 0 0";
        };
        // TODO: extends all function
        newArc.centroid = arc.centroid;
        return newArc;
    };

    c3_chart_internal_fn.getSvgArcExpanded = function (rate) {
        rate = rate || 1;
        var $$ = this,
            hasGaugeType = $$.hasType('gauge'),
            singleArcWidth = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
            expandWidth = Math.min($$.radiusExpanded * rate - $$.radius, singleArcWidth * 0.8 - (1 - rate) * 100),
            arc = $$.d3.svg.arc().outerRadius(function (d) {
            return hasGaugeType ? $$.radius - singleArcWidth * d.index + expandWidth : $$.radiusExpanded * rate;
        }).innerRadius(function (d) {
            return hasGaugeType ? $$.radius - singleArcWidth * (d.index + 1) : $$.innerRadius;
        });
        return function (d) {
            var updated = $$.updateAngle(d);
            return updated ? arc(updated) : "M 0 0";
        };
    };

    c3_chart_internal_fn.getArc = function (d, withoutUpdate, force) {
        return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
    };

    c3_chart_internal_fn.transformForArcLabel = function (d) {
        var $$ = this,
            config = $$.config,
            updated = $$.updateAngle(d),
            c,
            x,
            y,
            h,
            ratio,
            translate = "",
            hasGauge = $$.hasType('gauge');
        if (updated && !hasGauge) {
            c = this.svgArc.centroid(updated);
            x = isNaN(c[0]) ? 0 : c[0];
            y = isNaN(c[1]) ? 0 : c[1];
            h = Math.sqrt(x * x + y * y);
            if ($$.hasType('donut') && config.donut_label_ratio) {
                ratio = isFunction(config.donut_label_ratio) ? config.donut_label_ratio(d, $$.radius, h) : config.donut_label_ratio;
            } else if ($$.hasType('pie') && config.pie_label_ratio) {
                ratio = isFunction(config.pie_label_ratio) ? config.pie_label_ratio(d, $$.radius, h) : config.pie_label_ratio;
            } else {
                ratio = $$.radius && h ? (36 / $$.radius > 0.375 ? 1.175 - 36 / $$.radius : 0.8) * $$.radius / h : 0;
            }
            translate = "translate(" + x * ratio + ',' + y * ratio + ")";
        } else if (updated && hasGauge && $$.filterTargetsToShow($$.data.targets).length > 1) {
            var y1 = Math.sin(updated.endAngle - Math.PI / 2);
            x = Math.cos(updated.endAngle - Math.PI / 2) * ($$.radiusExpanded + 25);
            y = y1 * ($$.radiusExpanded + 15 - Math.abs(y1 * 10)) + 3;
            translate = "translate(" + x + ',' + y + ")";
        }
        return translate;
    };

    c3_chart_internal_fn.getArcRatio = function (d) {
        var $$ = this,
            config = $$.config,
            whole = Math.PI * ($$.hasType('gauge') && !config.gauge_fullCircle ? 1 : 2);
        return d ? (d.endAngle - d.startAngle) / whole : null;
    };

    c3_chart_internal_fn.convertToArcData = function (d) {
        return this.addName({
            id: d.data.id,
            value: d.value,
            ratio: this.getArcRatio(d),
            index: d.index
        });
    };

    c3_chart_internal_fn.textForArcLabel = function (d) {
        var $$ = this,
            updated,
            value,
            ratio,
            id,
            format;
        if (!$$.shouldShowArcLabel()) {
            return "";
        }
        updated = $$.updateAngle(d);
        value = updated ? updated.value : null;
        ratio = $$.getArcRatio(updated);
        id = d.data.id;
        if (!$$.hasType('gauge') && !$$.meetsArcLabelThreshold(ratio)) {
            return "";
        }
        format = $$.getArcLabelFormat();
        return format ? format(value, ratio, id) : $$.defaultArcValueFormat(value, ratio);
    };

    c3_chart_internal_fn.textForGaugeMinMax = function (value, isMax) {
        var $$ = this,
            format = $$.getGaugeLabelExtents();

        return format ? format(value, isMax) : value;
    };

    c3_chart_internal_fn.expandArc = function (targetIds) {
        var $$ = this,
            interval;

        // MEMO: avoid to cancel transition
        if ($$.transiting) {
            interval = window.setInterval(function () {
                if (!$$.transiting) {
                    window.clearInterval(interval);
                    if ($$.legend.selectAll('.c3-legend-item-focused').size() > 0) {
                        $$.expandArc(targetIds);
                    }
                }
            }, 10);
            return;
        }

        targetIds = $$.mapToTargetIds(targetIds);

        $$.svg.selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc)).each(function (d) {
            if (!$$.shouldExpand(d.data.id)) {
                return;
            }
            $$.d3.select(this).selectAll('path').transition().duration($$.expandDuration(d.data.id)).attr("d", $$.svgArcExpanded).transition().duration($$.expandDuration(d.data.id) * 2).attr("d", $$.svgArcExpandedSub).each(function (d) {
                if ($$.isDonutType(d.data)) {
                    // callback here
                }
            });
        });
    };

    c3_chart_internal_fn.unexpandArc = function (targetIds) {
        var $$ = this;

        if ($$.transiting) {
            return;
        }

        targetIds = $$.mapToTargetIds(targetIds);

        $$.svg.selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc)).selectAll('path').transition().duration(function (d) {
            return $$.expandDuration(d.data.id);
        }).attr("d", $$.svgArc);
        $$.svg.selectAll('.' + CLASS.arc);
    };

    c3_chart_internal_fn.expandDuration = function (id) {
        var $$ = this,
            config = $$.config;

        if ($$.isDonutType(id)) {
            return config.donut_expand_duration;
        } else if ($$.isGaugeType(id)) {
            return config.gauge_expand_duration;
        } else if ($$.isPieType(id)) {
            return config.pie_expand_duration;
        } else {
            return 50;
        }
    };

    c3_chart_internal_fn.shouldExpand = function (id) {
        var $$ = this,
            config = $$.config;
        return $$.isDonutType(id) && config.donut_expand || $$.isGaugeType(id) && config.gauge_expand || $$.isPieType(id) && config.pie_expand;
    };

    c3_chart_internal_fn.shouldShowArcLabel = function () {
        var $$ = this,
            config = $$.config,
            shouldShow = true;
        if ($$.hasType('donut')) {
            shouldShow = config.donut_label_show;
        } else if ($$.hasType('pie')) {
            shouldShow = config.pie_label_show;
        }
        // when gauge, always true
        return shouldShow;
    };

    c3_chart_internal_fn.meetsArcLabelThreshold = function (ratio) {
        var $$ = this,
            config = $$.config,
            threshold = $$.hasType('donut') ? config.donut_label_threshold : config.pie_label_threshold;
        return ratio >= threshold;
    };

    c3_chart_internal_fn.getArcLabelFormat = function () {
        var $$ = this,
            config = $$.config,
            format = config.pie_label_format;
        if ($$.hasType('gauge')) {
            format = config.gauge_label_format;
        } else if ($$.hasType('donut')) {
            format = config.donut_label_format;
        }
        return format;
    };

    c3_chart_internal_fn.getGaugeLabelExtents = function () {
        var $$ = this,
            config = $$.config;
        return config.gauge_label_extents;
    };

    c3_chart_internal_fn.getArcTitle = function () {
        var $$ = this;
        return $$.hasType('donut') ? $$.config.donut_title : "";
    };

    c3_chart_internal_fn.updateTargetsForArc = function (targets) {
        var $$ = this,
            main = $$.main,
            mainPieUpdate,
            mainPieEnter,
            classChartArc = $$.classChartArc.bind($$),
            classArcs = $$.classArcs.bind($$),
            classFocus = $$.classFocus.bind($$);
        mainPieUpdate = main.select('.' + CLASS.chartArcs).selectAll('.' + CLASS.chartArc).data($$.pie(targets)).attr("class", function (d) {
            return classChartArc(d) + classFocus(d.data);
        });
        mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
        mainPieEnter.append('g').attr('class', classArcs);
        mainPieEnter.append("text").attr("dy", $$.hasType('gauge') ? "-.1em" : ".35em").style("opacity", 0).style("text-anchor", "middle").style("pointer-events", "none");
        // MEMO: can not keep same color..., but not bad to update color in redraw
        //mainPieUpdate.exit().remove();
    };

    c3_chart_internal_fn.initArc = function () {
        var $$ = this;
        $$.arcs = $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartArcs).attr("transform", $$.getTranslate('arc'));
        $$.arcs.append('text').attr('class', CLASS.chartArcsTitle).style("text-anchor", "middle").text($$.getArcTitle());
    };

    c3_chart_internal_fn.redrawArc = function (duration, durationForExit, withTransform) {
        var $$ = this,
            d3 = $$.d3,
            config = $$.config,
            main = $$.main,
            mainArc,
            backgroundArc,
            mainArcLabelLine,
            hasGaugeType = $$.hasType('gauge');
        mainArc = main.selectAll('.' + CLASS.arcs).selectAll('.' + CLASS.arc).data($$.arcData.bind($$));
        mainArc.enter().append('path').attr("class", $$.classArc.bind($$)).style("fill", function (d) {
            return $$.color(d.data);
        }).style("cursor", function (d) {
            return config.interaction_enabled && config.data_selection_isselectable(d) ? "pointer" : null;
        }).each(function (d) {
            if ($$.isGaugeType(d.data)) {
                d.startAngle = d.endAngle = config.gauge_startingAngle;
            }
            this._current = d;
        });
        if (hasGaugeType) {
            mainArcLabelLine = main.selectAll('.' + CLASS.arcs).selectAll('.' + CLASS.arcLabelLine).data($$.arcData.bind($$));
            mainArcLabelLine.enter().append('rect').attr("class", function (d) {
                return CLASS.arcLabelLine + ' ' + CLASS.target + ' ' + CLASS.target + '-' + d.data.id;
            });
            if ($$.filterTargetsToShow($$.data.targets).length === 1) {
                mainArcLabelLine.style("display", "none");
            } else {
                mainArcLabelLine.style("fill", function (d) {
                    return config.color_pattern.length > 0 ? $$.levelColor(d.data.values[0].value) : $$.color(d.data);
                }).style("display", config.gauge_labelLine_show ? "" : "none").each(function (d) {
                    var lineLength = 0,
                        lineThickness = 2,
                        x = 0,
                        y = 0,
                        transform = "";
                    if ($$.hiddenTargetIds.indexOf(d.data.id) < 0) {
                        var updated = $$.updateAngle(d),
                            innerLineLength = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length * (updated.index + 1),
                            lineAngle = updated.endAngle - Math.PI / 2,
                            arcInnerRadius = $$.radius - innerLineLength,
                            linePositioningAngle = lineAngle - (arcInnerRadius === 0 ? 0 : 1 / arcInnerRadius);
                        lineLength = $$.radiusExpanded - $$.radius + innerLineLength;
                        x = Math.cos(linePositioningAngle) * arcInnerRadius;
                        y = Math.sin(linePositioningAngle) * arcInnerRadius;
                        transform = "rotate(" + lineAngle * 180 / Math.PI + ", " + x + ", " + y + ")";
                    }
                    d3.select(this).attr({ x: x, y: y, width: lineLength, height: lineThickness, transform: transform }).style("stroke-dasharray", "0, " + (lineLength + lineThickness) + ", 0");
                });
            }
        }
        mainArc.attr("transform", function (d) {
            return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
        }).on('mouseover', config.interaction_enabled ? function (d) {
            var updated, arcData;
            if ($$.transiting) {
                // skip while transiting
                return;
            }
            updated = $$.updateAngle(d);
            if (updated) {
                arcData = $$.convertToArcData(updated);
                // transitions
                $$.expandArc(updated.data.id);
                $$.api.focus(updated.data.id);
                $$.toggleFocusLegend(updated.data.id, true);
                $$.config.data_onmouseover(arcData, this);
            }
        } : null).on('mousemove', config.interaction_enabled ? function (d) {
            var updated = $$.updateAngle(d),
                arcData,
                selectedData;
            if (updated) {
                arcData = $$.convertToArcData(updated), selectedData = [arcData];
                $$.showTooltip(selectedData, this);
            }
        } : null).on('mouseout', config.interaction_enabled ? function (d) {
            var updated, arcData;
            if ($$.transiting) {
                // skip while transiting
                return;
            }
            updated = $$.updateAngle(d);
            if (updated) {
                arcData = $$.convertToArcData(updated);
                // transitions
                $$.unexpandArc(updated.data.id);
                $$.api.revert();
                $$.revertLegend();
                $$.hideTooltip();
                $$.config.data_onmouseout(arcData, this);
            }
        } : null).on('click', config.interaction_enabled ? function (d, i) {
            var updated = $$.updateAngle(d),
                arcData;
            if (updated) {
                arcData = $$.convertToArcData(updated);
                if ($$.toggleShape) {
                    $$.toggleShape(this, arcData, i);
                }
                $$.config.data_onclick.call($$.api, arcData, this);
            }
        } : null).each(function () {
            $$.transiting = true;
        }).transition().duration(duration).attrTween("d", function (d) {
            var updated = $$.updateAngle(d),
                interpolate;
            if (!updated) {
                return function () {
                    return "M 0 0";
                };
            }
            //                if (this._current === d) {
            //                    this._current = {
            //                        startAngle: Math.PI*2,
            //                        endAngle: Math.PI*2,
            //                    };
            //                }
            if (isNaN(this._current.startAngle)) {
                this._current.startAngle = 0;
            }
            if (isNaN(this._current.endAngle)) {
                this._current.endAngle = this._current.startAngle;
            }
            interpolate = d3.interpolate(this._current, updated);
            this._current = interpolate(0);
            return function (t) {
                var interpolated = interpolate(t);
                interpolated.data = d.data; // data.id will be updated by interporator
                return $$.getArc(interpolated, true);
            };
        }).attr("transform", withTransform ? "scale(1)" : "").style("fill", function (d) {
            return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data.id);
        }) // Where gauge reading color would receive customization.
        .call($$.endall, function () {
            $$.transiting = false;
        });
        mainArc.exit().transition().duration(durationForExit).style('opacity', 0).remove();
        main.selectAll('.' + CLASS.chartArc).select('text').style("opacity", 0).attr('class', function (d) {
            return $$.isGaugeType(d.data) ? CLASS.gaugeValue : '';
        }).text($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style('font-size', function (d) {
            return $$.isGaugeType(d.data) && $$.filterTargetsToShow($$.data.targets).length === 1 ? Math.round($$.radius / 5) + 'px' : '';
        }).transition().duration(duration).style("opacity", function (d) {
            return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? 1 : 0;
        });
        main.select('.' + CLASS.chartArcsTitle).style("opacity", $$.hasType('donut') || hasGaugeType ? 1 : 0);

        if (hasGaugeType) {
            var index = 0;
            backgroundArc = $$.arcs.select('g.' + CLASS.chartArcsBackground).selectAll('path.' + CLASS.chartArcsBackground).data($$.data.targets);
            backgroundArc.enter().append("path");
            backgroundArc.attr("class", function (d, i) {
                return CLASS.chartArcsBackground + ' ' + CLASS.chartArcsBackground + '-' + i;
            }).attr("d", function (d1) {
                if ($$.hiddenTargetIds.indexOf(d1.id) >= 0) {
                    return "M 0 0";
                }

                var d = {
                    data: [{ value: config.gauge_max }],
                    startAngle: config.gauge_startingAngle,
                    endAngle: -1 * config.gauge_startingAngle * (config.gauge_fullCircle ? Math.PI : 1),
                    index: index++
                };
                return $$.getArc(d, true, true);
            });
            backgroundArc.exit().remove();

            $$.arcs.select('.' + CLASS.chartArcsGaugeUnit).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : '');
            $$.arcs.select('.' + CLASS.chartArcsGaugeMin).attr("dx", -1 * ($$.innerRadius + ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2)) + "px").attr("dy", "1.2em").text(config.gauge_label_show ? $$.textForGaugeMinMax(config.gauge_min, false) : '');
            $$.arcs.select('.' + CLASS.chartArcsGaugeMax).attr("dx", $$.innerRadius + ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2) + "px").attr("dy", "1.2em").text(config.gauge_label_show ? $$.textForGaugeMinMax(config.gauge_max, true) : '');
        }
    };
    c3_chart_internal_fn.initGauge = function () {
        var arcs = this.arcs;
        if (this.hasType('gauge')) {
            arcs.append('g').attr("class", CLASS.chartArcsBackground);
            arcs.append("text").attr("class", CLASS.chartArcsGaugeUnit).style("text-anchor", "middle").style("pointer-events", "none");
            arcs.append("text").attr("class", CLASS.chartArcsGaugeMin).style("text-anchor", "middle").style("pointer-events", "none");
            arcs.append("text").attr("class", CLASS.chartArcsGaugeMax).style("text-anchor", "middle").style("pointer-events", "none");
        }
    };
    c3_chart_internal_fn.getGaugeLabelHeight = function () {
        return this.config.gauge_label_show ? 20 : 0;
    };

    c3_chart_internal_fn.hasCaches = function (ids) {
        for (var i = 0; i < ids.length; i++) {
            if (!(ids[i] in this.cache)) {
                return false;
            }
        }
        return true;
    };
    c3_chart_internal_fn.addCache = function (id, target) {
        this.cache[id] = this.cloneTarget(target);
    };
    c3_chart_internal_fn.getCaches = function (ids) {
        var targets = [],
            i;
        for (i = 0; i < ids.length; i++) {
            if (ids[i] in this.cache) {
                targets.push(this.cloneTarget(this.cache[ids[i]]));
            }
        }
        return targets;
    };

    c3_chart_internal_fn.categoryName = function (i) {
        var config = this.config;
        return i < config.axis_x_categories.length ? config.axis_x_categories[i] : i;
    };

    c3_chart_internal_fn.generateClass = function (prefix, targetId) {
        return " " + prefix + " " + prefix + this.getTargetSelectorSuffix(targetId);
    };
    c3_chart_internal_fn.classText = function (d) {
        return this.generateClass(CLASS.text, d.index);
    };
    c3_chart_internal_fn.classTexts = function (d) {
        return this.generateClass(CLASS.texts, d.id);
    };
    c3_chart_internal_fn.classShape = function (d) {
        return this.generateClass(CLASS.shape, d.index);
    };
    c3_chart_internal_fn.classShapes = function (d) {
        return this.generateClass(CLASS.shapes, d.id);
    };
    c3_chart_internal_fn.classLine = function (d) {
        return this.classShape(d) + this.generateClass(CLASS.line, d.id);
    };
    c3_chart_internal_fn.classLines = function (d) {
        return this.classShapes(d) + this.generateClass(CLASS.lines, d.id);
    };
    c3_chart_internal_fn.classCircle = function (d) {
        return this.classShape(d) + this.generateClass(CLASS.circle, d.index);
    };
    c3_chart_internal_fn.classCircles = function (d) {
        return this.classShapes(d) + this.generateClass(CLASS.circles, d.id);
    };
    c3_chart_internal_fn.classBar = function (d) {
        return this.classShape(d) + this.generateClass(CLASS.bar, d.index);
    };
    c3_chart_internal_fn.classBars = function (d) {
        return this.classShapes(d) + this.generateClass(CLASS.bars, d.id);
    };
    c3_chart_internal_fn.classArc = function (d) {
        return this.classShape(d.data) + this.generateClass(CLASS.arc, d.data.id);
    };
    c3_chart_internal_fn.classArcs = function (d) {
        return this.classShapes(d.data) + this.generateClass(CLASS.arcs, d.data.id);
    };
    c3_chart_internal_fn.classArea = function (d) {
        return this.classShape(d) + this.generateClass(CLASS.area, d.id);
    };
    c3_chart_internal_fn.classAreas = function (d) {
        return this.classShapes(d) + this.generateClass(CLASS.areas, d.id);
    };
    c3_chart_internal_fn.classRegion = function (d, i) {
        return this.generateClass(CLASS.region, i) + ' ' + ('class' in d ? d['class'] : '');
    };
    c3_chart_internal_fn.classEvent = function (d) {
        return this.generateClass(CLASS.eventRect, d.index);
    };
    c3_chart_internal_fn.classTarget = function (id) {
        var $$ = this;
        var additionalClassSuffix = $$.config.data_classes[id],
            additionalClass = '';
        if (additionalClassSuffix) {
            additionalClass = ' ' + CLASS.target + '-' + additionalClassSuffix;
        }
        return $$.generateClass(CLASS.target, id) + additionalClass;
    };
    c3_chart_internal_fn.classFocus = function (d) {
        return this.classFocused(d) + this.classDefocused(d);
    };
    c3_chart_internal_fn.classFocused = function (d) {
        return ' ' + (this.focusedTargetIds.indexOf(d.id) >= 0 ? CLASS.focused : '');
    };
    c3_chart_internal_fn.classDefocused = function (d) {
        return ' ' + (this.defocusedTargetIds.indexOf(d.id) >= 0 ? CLASS.defocused : '');
    };
    c3_chart_internal_fn.classChartText = function (d) {
        return CLASS.chartText + this.classTarget(d.id);
    };
    c3_chart_internal_fn.classChartLine = function (d) {
        return CLASS.chartLine + this.classTarget(d.id);
    };
    c3_chart_internal_fn.classChartBar = function (d) {
        return CLASS.chartBar + this.classTarget(d.id);
    };
    c3_chart_internal_fn.classChartArc = function (d) {
        return CLASS.chartArc + this.classTarget(d.data.id);
    };
    c3_chart_internal_fn.getTargetSelectorSuffix = function (targetId) {
        return targetId || targetId === 0 ? ('-' + targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, '-') : '';
    };
    c3_chart_internal_fn.selectorTarget = function (id, prefix) {
        return (prefix || '') + '.' + CLASS.target + this.getTargetSelectorSuffix(id);
    };
    c3_chart_internal_fn.selectorTargets = function (ids, prefix) {
        var $$ = this;
        ids = ids || [];
        return ids.length ? ids.map(function (id) {
            return $$.selectorTarget(id, prefix);
        }) : null;
    };
    c3_chart_internal_fn.selectorLegend = function (id) {
        return '.' + CLASS.legendItem + this.getTargetSelectorSuffix(id);
    };
    c3_chart_internal_fn.selectorLegends = function (ids) {
        var $$ = this;
        return ids && ids.length ? ids.map(function (id) {
            return $$.selectorLegend(id);
        }) : null;
    };

    c3_chart_internal_fn.getClipPath = function (id) {
        var isIE9 = window.navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;
        return "url(" + (isIE9 ? "" : document.URL.split('#')[0]) + "#" + id + ")";
    };
    c3_chart_internal_fn.appendClip = function (parent, id) {
        return parent.append("clipPath").attr("id", id).append("rect");
    };
    c3_chart_internal_fn.getAxisClipX = function (forHorizontal) {
        // axis line width + padding for left
        var left = Math.max(30, this.margin.left);
        return forHorizontal ? -(1 + left) : -(left - 1);
    };
    c3_chart_internal_fn.getAxisClipY = function (forHorizontal) {
        return forHorizontal ? -20 : -this.margin.top;
    };
    c3_chart_internal_fn.getXAxisClipX = function () {
        var $$ = this;
        return $$.getAxisClipX(!$$.config.axis_rotated);
    };
    c3_chart_internal_fn.getXAxisClipY = function () {
        var $$ = this;
        return $$.getAxisClipY(!$$.config.axis_rotated);
    };
    c3_chart_internal_fn.getYAxisClipX = function () {
        var $$ = this;
        return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
    };
    c3_chart_internal_fn.getYAxisClipY = function () {
        var $$ = this;
        return $$.getAxisClipY($$.config.axis_rotated);
    };
    c3_chart_internal_fn.getAxisClipWidth = function (forHorizontal) {
        var $$ = this,
            left = Math.max(30, $$.margin.left),
            right = Math.max(30, $$.margin.right);
        // width + axis line width + padding for left/right
        return forHorizontal ? $$.width + 2 + left + right : $$.margin.left + 20;
    };
    c3_chart_internal_fn.getAxisClipHeight = function (forHorizontal) {
        // less than 20 is not enough to show the axis label 'outer' without legend
        return (forHorizontal ? this.margin.bottom : this.margin.top + this.height) + 20;
    };
    c3_chart_internal_fn.getXAxisClipWidth = function () {
        var $$ = this;
        return $$.getAxisClipWidth(!$$.config.axis_rotated);
    };
    c3_chart_internal_fn.getXAxisClipHeight = function () {
        var $$ = this;
        return $$.getAxisClipHeight(!$$.config.axis_rotated);
    };
    c3_chart_internal_fn.getYAxisClipWidth = function () {
        var $$ = this;
        return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
    };
    c3_chart_internal_fn.getYAxisClipHeight = function () {
        var $$ = this;
        return $$.getAxisClipHeight($$.config.axis_rotated);
    };

    c3_chart_internal_fn.generateColor = function () {
        var $$ = this,
            config = $$.config,
            d3 = $$.d3,
            colors = config.data_colors,
            pattern = notEmpty(config.color_pattern) ? config.color_pattern : d3.scale.category10().range(),
            callback = config.data_color,
            ids = [];

        return function (d) {
            var id = d.id || d.data && d.data.id || d,
                color;

            // if callback function is provided
            if (colors[id] instanceof Function) {
                color = colors[id](d);
            }
            // if specified, choose that color
            else if (colors[id]) {
                    color = colors[id];
                }
                // if not specified, choose from pattern
                else {
                        if (ids.indexOf(id) < 0) {
                            ids.push(id);
                        }
                        color = pattern[ids.indexOf(id) % pattern.length];
                        colors[id] = color;
                    }
            return callback instanceof Function ? callback(color, d) : color;
        };
    };
    c3_chart_internal_fn.generateLevelColor = function () {
        var $$ = this,
            config = $$.config,
            colors = config.color_pattern,
            threshold = config.color_threshold,
            asValue = threshold.unit === 'value',
            values = threshold.values && threshold.values.length ? threshold.values : [],
            max = threshold.max || 100;
        return notEmpty(config.color_threshold) ? function (value) {
            var i,
                v,
                color = colors[colors.length - 1];
            for (i = 0; i < values.length; i++) {
                v = asValue ? value : value * 100 / max;
                if (v < values[i]) {
                    color = colors[i];
                    break;
                }
            }
            return color;
        } : null;
    };

    c3_chart_internal_fn.getDefaultConfig = function () {
        var config = {
            bindto: '#chart',
            svg_classname: undefined,
            size_width: undefined,
            size_height: undefined,
            padding_left: undefined,
            padding_right: undefined,
            padding_top: undefined,
            padding_bottom: undefined,
            resize_auto: true,
            zoom_enabled: false,
            zoom_extent: undefined,
            zoom_privileged: false,
            zoom_rescale: false,
            zoom_onzoom: function zoom_onzoom() {},
            zoom_onzoomstart: function zoom_onzoomstart() {},
            zoom_onzoomend: function zoom_onzoomend() {},
            zoom_x_min: undefined,
            zoom_x_max: undefined,
            interaction_brighten: true,
            interaction_enabled: true,
            onmouseover: function onmouseover() {},
            onmouseout: function onmouseout() {},
            onresize: function onresize() {},
            onresized: function onresized() {},
            oninit: function oninit() {},
            onrendered: function onrendered() {},
            transition_duration: 350,
            data_x: undefined,
            data_xs: {},
            data_xFormat: '%Y-%m-%d',
            data_xLocaltime: true,
            data_xSort: true,
            data_idConverter: function data_idConverter(id) {
                return id;
            },
            data_names: {},
            data_classes: {},
            data_groups: [],
            data_axes: {},
            data_type: undefined,
            data_types: {},
            data_labels: {},
            data_order: 'desc',
            data_regions: {},
            data_color: undefined,
            data_colors: {},
            data_hide: false,
            data_filter: undefined,
            data_selection_enabled: false,
            data_selection_grouped: false,
            data_selection_isselectable: function data_selection_isselectable() {
                return true;
            },
            data_selection_multiple: true,
            data_selection_draggable: false,
            data_onclick: function data_onclick() {},
            data_onmouseover: function data_onmouseover() {},
            data_onmouseout: function data_onmouseout() {},
            data_onselected: function data_onselected() {},
            data_onunselected: function data_onunselected() {},
            data_url: undefined,
            data_headers: undefined,
            data_json: undefined,
            data_rows: undefined,
            data_columns: undefined,
            data_mimeType: undefined,
            data_keys: undefined,
            // configuration for no plot-able data supplied.
            data_empty_label_text: "",
            // subchart
            subchart_show: false,
            subchart_size_height: 60,
            subchart_axis_x_show: true,
            subchart_onbrush: function subchart_onbrush() {},
            // color
            color_pattern: [],
            color_threshold: {},
            // legend
            legend_show: true,
            legend_hide: false,
            legend_position: 'bottom',
            legend_inset_anchor: 'top-left',
            legend_inset_x: 10,
            legend_inset_y: 0,
            legend_inset_step: undefined,
            legend_item_onclick: undefined,
            legend_item_onmouseover: undefined,
            legend_item_onmouseout: undefined,
            legend_equally: false,
            legend_padding: 0,
            legend_item_tile_width: 10,
            legend_item_tile_height: 10,
            // axis
            axis_rotated: false,
            axis_x_show: true,
            axis_x_type: 'indexed',
            axis_x_localtime: true,
            axis_x_categories: [],
            axis_x_tick_centered: false,
            axis_x_tick_format: undefined,
            axis_x_tick_culling: {},
            axis_x_tick_culling_max: 10,
            axis_x_tick_count: undefined,
            axis_x_tick_fit: true,
            axis_x_tick_values: null,
            axis_x_tick_rotate: 0,
            axis_x_tick_outer: true,
            axis_x_tick_multiline: true,
            axis_x_tick_multilineMax: 0,
            axis_x_tick_width: null,
            axis_x_max: undefined,
            axis_x_min: undefined,
            axis_x_padding: {},
            axis_x_height: undefined,
            axis_x_extent: undefined,
            axis_x_label: {},
            axis_x_inner: undefined,
            axis_y_show: true,
            axis_y_type: undefined,
            axis_y_max: undefined,
            axis_y_min: undefined,
            axis_y_inverted: false,
            axis_y_center: undefined,
            axis_y_inner: undefined,
            axis_y_label: {},
            axis_y_tick_format: undefined,
            axis_y_tick_outer: true,
            axis_y_tick_values: null,
            axis_y_tick_rotate: 0,
            axis_y_tick_count: undefined,
            axis_y_tick_time_value: undefined,
            axis_y_tick_time_interval: undefined,
            axis_y_padding: {},
            axis_y_default: undefined,
            axis_y2_show: false,
            axis_y2_max: undefined,
            axis_y2_min: undefined,
            axis_y2_inverted: false,
            axis_y2_center: undefined,
            axis_y2_inner: undefined,
            axis_y2_label: {},
            axis_y2_tick_format: undefined,
            axis_y2_tick_outer: true,
            axis_y2_tick_values: null,
            axis_y2_tick_count: undefined,
            axis_y2_padding: {},
            axis_y2_default: undefined,
            // grid
            grid_x_show: false,
            grid_x_type: 'tick',
            grid_x_lines: [],
            grid_y_show: false,
            // not used
            // grid_y_type: 'tick',
            grid_y_lines: [],
            grid_y_ticks: 10,
            grid_focus_show: true,
            grid_lines_front: true,
            // point - point of each data
            point_show: true,
            point_r: 2.5,
            point_sensitivity: 10,
            point_focus_expand_enabled: true,
            point_focus_expand_r: undefined,
            point_select_r: undefined,
            // line
            line_connectNull: false,
            line_step_type: 'step',
            // bar
            bar_width: undefined,
            bar_width_ratio: 0.6,
            bar_width_max: undefined,
            bar_zerobased: true,
            bar_space: 0,
            // area
            area_zerobased: true,
            area_above: false,
            // pie
            pie_label_show: true,
            pie_label_format: undefined,
            pie_label_threshold: 0.05,
            pie_label_ratio: undefined,
            pie_expand: {},
            pie_expand_duration: 50,
            // gauge
            gauge_fullCircle: false,
            gauge_label_show: true,
            gauge_labelLine_show: true,
            gauge_label_format: undefined,
            gauge_min: 0,
            gauge_max: 100,
            gauge_startingAngle: -1 * Math.PI / 2,
            gauge_label_extents: undefined,
            gauge_units: undefined,
            gauge_width: undefined,
            gauge_arcs_minWidth: 5,
            gauge_expand: {},
            gauge_expand_duration: 50,
            // donut
            donut_label_show: true,
            donut_label_format: undefined,
            donut_label_threshold: 0.05,
            donut_label_ratio: undefined,
            donut_width: undefined,
            donut_title: "",
            donut_expand: {},
            donut_expand_duration: 50,
            // spline
            spline_interpolation_type: 'cardinal',
            // region - region to change style
            regions: [],
            // tooltip - show when mouseover on each data
            tooltip_show: true,
            tooltip_grouped: true,
            tooltip_order: undefined,
            tooltip_format_title: undefined,
            tooltip_format_name: undefined,
            tooltip_format_value: undefined,
            tooltip_position: undefined,
            tooltip_contents: function tooltip_contents(d, defaultTitleFormat, defaultValueFormat, color) {
                return this.getTooltipContent ? this.getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) : '';
            },
            tooltip_init_show: false,
            tooltip_init_x: 0,
            tooltip_init_position: { top: '0px', left: '50px' },
            tooltip_onshow: function tooltip_onshow() {},
            tooltip_onhide: function tooltip_onhide() {},
            // title
            title_text: undefined,
            title_padding: {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            },
            title_position: 'top-center'
        };

        Object.keys(this.additionalConfig).forEach(function (key) {
            config[key] = this.additionalConfig[key];
        }, this);

        return config;
    };
    c3_chart_internal_fn.additionalConfig = {};

    c3_chart_internal_fn.loadConfig = function (config) {
        var this_config = this.config,
            target,
            keys,
            read;
        function find() {
            var key = keys.shift();
            //        console.log("key =>", key, ", target =>", target);
            if (key && target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && key in target) {
                target = target[key];
                return find();
            } else if (!key) {
                return target;
            } else {
                return undefined;
            }
        }
        Object.keys(this_config).forEach(function (key) {
            target = config;
            keys = key.split('_');
            read = find();
            //        console.log("CONFIG : ", key, read);
            if (isDefined(read)) {
                this_config[key] = read;
            }
        });
    };

    c3_chart_internal_fn.convertUrlToData = function (url, mimeType, headers, keys, done) {
        var $$ = this,
            type = mimeType ? mimeType : 'csv';
        var req = $$.d3.xhr(url);
        if (headers) {
            Object.keys(headers).forEach(function (header) {
                req.header(header, headers[header]);
            });
        }
        req.get(function (error, data) {
            var d;
            var dataResponse = data.response || data.responseText; // Fixes IE9 XHR issue; see #1345
            if (!data) {
                throw new Error(error.responseURL + ' ' + error.status + ' (' + error.statusText + ')');
            }
            if (type === 'json') {
                d = $$.convertJsonToData(JSON.parse(dataResponse), keys);
            } else if (type === 'tsv') {
                d = $$.convertTsvToData(dataResponse);
            } else {
                d = $$.convertCsvToData(dataResponse);
            }
            done.call($$, d);
        });
    };
    c3_chart_internal_fn.convertXsvToData = function (xsv, parser) {
        var rows = parser.parseRows(xsv),
            d;
        if (rows.length === 1) {
            d = [{}];
            rows[0].forEach(function (id) {
                d[0][id] = null;
            });
        } else {
            d = parser.parse(xsv);
        }
        return d;
    };
    c3_chart_internal_fn.convertCsvToData = function (csv) {
        return this.convertXsvToData(csv, this.d3.csv);
    };
    c3_chart_internal_fn.convertTsvToData = function (tsv) {
        return this.convertXsvToData(tsv, this.d3.tsv);
    };
    c3_chart_internal_fn.convertJsonToData = function (json, keys) {
        var $$ = this,
            new_rows = [],
            targetKeys,
            data;
        if (keys) {
            // when keys specified, json would be an array that includes objects
            if (keys.x) {
                targetKeys = keys.value.concat(keys.x);
                $$.config.data_x = keys.x;
            } else {
                targetKeys = keys.value;
            }
            new_rows.push(targetKeys);
            json.forEach(function (o) {
                var new_row = [];
                targetKeys.forEach(function (key) {
                    // convert undefined to null because undefined data will be removed in convertDataToTargets()
                    var v = $$.findValueInJson(o, key);
                    if (isUndefined(v)) {
                        v = null;
                    }
                    new_row.push(v);
                });
                new_rows.push(new_row);
            });
            data = $$.convertRowsToData(new_rows);
        } else {
            Object.keys(json).forEach(function (key) {
                new_rows.push([key].concat(json[key]));
            });
            data = $$.convertColumnsToData(new_rows);
        }
        return data;
    };
    c3_chart_internal_fn.findValueInJson = function (object, path) {
        path = path.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties (replace [] with .)
        path = path.replace(/^\./, ''); // strip a leading dot
        var pathArray = path.split('.');
        for (var i = 0; i < pathArray.length; ++i) {
            var k = pathArray[i];
            if (k in object) {
                object = object[k];
            } else {
                return;
            }
        }
        return object;
    };

    /**
     * Converts the rows to normalized data.
     * @param {any[][]} rows The row data
     * @return {Object[]}
     */
    c3_chart_internal_fn.convertRowsToData = function (rows) {
        var newRows = [];
        var keys = rows[0];

        for (var i = 1; i < rows.length; i++) {
            var newRow = {};
            for (var j = 0; j < rows[i].length; j++) {
                if (isUndefined(rows[i][j])) {
                    throw new Error("Source data is missing a component at (" + i + "," + j + ")!");
                }
                newRow[keys[j]] = rows[i][j];
            }
            newRows.push(newRow);
        }
        return newRows;
    };

    /**
     * Converts the columns to normalized data.
     * @param {any[][]} columns The column data
     * @return {Object[]}
     */
    c3_chart_internal_fn.convertColumnsToData = function (columns) {
        var newRows = [];

        for (var i = 0; i < columns.length; i++) {
            var key = columns[i][0];
            for (var j = 1; j < columns[i].length; j++) {
                if (isUndefined(newRows[j - 1])) {
                    newRows[j - 1] = {};
                }
                if (isUndefined(columns[i][j])) {
                    throw new Error("Source data is missing a component at (" + i + "," + j + ")!");
                }
                newRows[j - 1][key] = columns[i][j];
            }
        }

        return newRows;
    };

    c3_chart_internal_fn.convertDataToTargets = function (data, appendXs) {
        var $$ = this,
            config = $$.config,
            ids = $$.d3.keys(data[0]).filter($$.isNotX, $$),
            xs = $$.d3.keys(data[0]).filter($$.isX, $$),
            targets;

        // save x for update data by load when custom x and c3.x API
        ids.forEach(function (id) {
            var xKey = $$.getXKey(id);

            if ($$.isCustomX() || $$.isTimeSeries()) {
                // if included in input data
                if (xs.indexOf(xKey) >= 0) {
                    $$.data.xs[id] = (appendXs && $$.data.xs[id] ? $$.data.xs[id] : []).concat(data.map(function (d) {
                        return d[xKey];
                    }).filter(isValue).map(function (rawX, i) {
                        return $$.generateTargetX(rawX, id, i);
                    }));
                }
                // if not included in input data, find from preloaded data of other id's x
                else if (config.data_x) {
                        $$.data.xs[id] = $$.getOtherTargetXs();
                    }
                    // if not included in input data, find from preloaded data
                    else if (notEmpty(config.data_xs)) {
                            $$.data.xs[id] = $$.getXValuesOfXKey(xKey, $$.data.targets);
                        }
                // MEMO: if no x included, use same x of current will be used
            } else {
                $$.data.xs[id] = data.map(function (d, i) {
                    return i;
                });
            }
        });

        // check x is defined
        ids.forEach(function (id) {
            if (!$$.data.xs[id]) {
                throw new Error('x is not defined for id = "' + id + '".');
            }
        });

        // convert to target
        targets = ids.map(function (id, index) {
            var convertedId = config.data_idConverter(id);
            return {
                id: convertedId,
                id_org: id,
                values: data.map(function (d, i) {
                    var xKey = $$.getXKey(id),
                        rawX = d[xKey],
                        value = d[id] !== null && !isNaN(d[id]) ? +d[id] : null,
                        x;
                    // use x as categories if custom x and categorized
                    if ($$.isCustomX() && $$.isCategorized() && !isUndefined(rawX)) {
                        if (index === 0 && i === 0) {
                            config.axis_x_categories = [];
                        }
                        x = config.axis_x_categories.indexOf(rawX);
                        if (x === -1) {
                            x = config.axis_x_categories.length;
                            config.axis_x_categories.push(rawX);
                        }
                    } else {
                        x = $$.generateTargetX(rawX, id, i);
                    }
                    // mark as x = undefined if value is undefined and filter to remove after mapped
                    if (isUndefined(d[id]) || $$.data.xs[id].length <= i) {
                        x = undefined;
                    }
                    return { x: x, value: value, id: convertedId };
                }).filter(function (v) {
                    return isDefined(v.x);
                })
            };
        });

        // finish targets
        targets.forEach(function (t) {
            var i;
            // sort values by its x
            if (config.data_xSort) {
                t.values = t.values.sort(function (v1, v2) {
                    var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
                        x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
                    return x1 - x2;
                });
            }
            // indexing each value
            i = 0;
            t.values.forEach(function (v) {
                v.index = i++;
            });
            // this needs to be sorted because its index and value.index is identical
            $$.data.xs[t.id].sort(function (v1, v2) {
                return v1 - v2;
            });
        });

        // cache information about values
        $$.hasNegativeValue = $$.hasNegativeValueInTargets(targets);
        $$.hasPositiveValue = $$.hasPositiveValueInTargets(targets);

        // set target types
        if (config.data_type) {
            $$.setTargetType($$.mapToIds(targets).filter(function (id) {
                return !(id in config.data_types);
            }), config.data_type);
        }

        // cache as original id keyed
        targets.forEach(function (d) {
            $$.addCache(d.id_org, d);
        });

        return targets;
    };

    c3_chart_internal_fn.isX = function (key) {
        var $$ = this,
            config = $$.config;
        return config.data_x && key === config.data_x || notEmpty(config.data_xs) && hasValue(config.data_xs, key);
    };
    c3_chart_internal_fn.isNotX = function (key) {
        return !this.isX(key);
    };
    c3_chart_internal_fn.getXKey = function (id) {
        var $$ = this,
            config = $$.config;
        return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;
    };
    c3_chart_internal_fn.getXValuesOfXKey = function (key, targets) {
        var $$ = this,
            xValues,
            ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
        ids.forEach(function (id) {
            if ($$.getXKey(id) === key) {
                xValues = $$.data.xs[id];
            }
        });
        return xValues;
    };
    c3_chart_internal_fn.getIndexByX = function (x) {
        var $$ = this,
            data = $$.filterByX($$.data.targets, x);
        return data.length ? data[0].index : null;
    };
    c3_chart_internal_fn.getXValue = function (id, i) {
        var $$ = this;
        return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
    };
    c3_chart_internal_fn.getOtherTargetXs = function () {
        var $$ = this,
            idsForX = Object.keys($$.data.xs);
        return idsForX.length ? $$.data.xs[idsForX[0]] : null;
    };
    c3_chart_internal_fn.getOtherTargetX = function (index) {
        var xs = this.getOtherTargetXs();
        return xs && index < xs.length ? xs[index] : null;
    };
    c3_chart_internal_fn.addXs = function (xs) {
        var $$ = this;
        Object.keys(xs).forEach(function (id) {
            $$.config.data_xs[id] = xs[id];
        });
    };
    c3_chart_internal_fn.hasMultipleX = function (xs) {
        return this.d3.set(Object.keys(xs).map(function (id) {
            return xs[id];
        })).size() > 1;
    };
    c3_chart_internal_fn.isMultipleX = function () {
        return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType('scatter');
    };
    c3_chart_internal_fn.addName = function (data) {
        var $$ = this,
            name;
        if (data) {
            name = $$.config.data_names[data.id];
            data.name = name !== undefined ? name : data.id;
        }
        return data;
    };
    c3_chart_internal_fn.getValueOnIndex = function (values, index) {
        var valueOnIndex = values.filter(function (v) {
            return v.index === index;
        });
        return valueOnIndex.length ? valueOnIndex[0] : null;
    };
    c3_chart_internal_fn.updateTargetX = function (targets, x) {
        var $$ = this;
        targets.forEach(function (t) {
            t.values.forEach(function (v, i) {
                v.x = $$.generateTargetX(x[i], t.id, i);
            });
            $$.data.xs[t.id] = x;
        });
    };
    c3_chart_internal_fn.updateTargetXs = function (targets, xs) {
        var $$ = this;
        targets.forEach(function (t) {
            if (xs[t.id]) {
                $$.updateTargetX([t], xs[t.id]);
            }
        });
    };
    c3_chart_internal_fn.generateTargetX = function (rawX, id, index) {
        var $$ = this,
            x;
        if ($$.isTimeSeries()) {
            x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index));
        } else if ($$.isCustomX() && !$$.isCategorized()) {
            x = isValue(rawX) ? +rawX : $$.getXValue(id, index);
        } else {
            x = index;
        }
        return x;
    };
    c3_chart_internal_fn.cloneTarget = function (target) {
        return {
            id: target.id,
            id_org: target.id_org,
            values: target.values.map(function (d) {
                return { x: d.x, value: d.value, id: d.id };
            })
        };
    };
    c3_chart_internal_fn.updateXs = function () {
        var $$ = this;
        if ($$.data.targets.length) {
            $$.xs = [];
            $$.data.targets[0].values.forEach(function (v) {
                $$.xs[v.index] = v.x;
            });
        }
    };
    c3_chart_internal_fn.getPrevX = function (i) {
        var x = this.xs[i - 1];
        return typeof x !== 'undefined' ? x : null;
    };
    c3_chart_internal_fn.getNextX = function (i) {
        var x = this.xs[i + 1];
        return typeof x !== 'undefined' ? x : null;
    };
    c3_chart_internal_fn.getMaxDataCount = function () {
        var $$ = this;
        return $$.d3.max($$.data.targets, function (t) {
            return t.values.length;
        });
    };
    c3_chart_internal_fn.getMaxDataCountTarget = function (targets) {
        var length = targets.length,
            max = 0,
            maxTarget;
        if (length > 1) {
            targets.forEach(function (t) {
                if (t.values.length > max) {
                    maxTarget = t;
                    max = t.values.length;
                }
            });
        } else {
            maxTarget = length ? targets[0] : null;
        }
        return maxTarget;
    };
    c3_chart_internal_fn.getEdgeX = function (targets) {
        var $$ = this;
        return !targets.length ? [0, 0] : [$$.d3.min(targets, function (t) {
            return t.values[0].x;
        }), $$.d3.max(targets, function (t) {
            return t.values[t.values.length - 1].x;
        })];
    };
    c3_chart_internal_fn.mapToIds = function (targets) {
        return targets.map(function (d) {
            return d.id;
        });
    };
    c3_chart_internal_fn.mapToTargetIds = function (ids) {
        var $$ = this;
        return ids ? [].concat(ids) : $$.mapToIds($$.data.targets);
    };
    c3_chart_internal_fn.hasTarget = function (targets, id) {
        var ids = this.mapToIds(targets),
            i;
        for (i = 0; i < ids.length; i++) {
            if (ids[i] === id) {
                return true;
            }
        }
        return false;
    };
    c3_chart_internal_fn.isTargetToShow = function (targetId) {
        return this.hiddenTargetIds.indexOf(targetId) < 0;
    };
    c3_chart_internal_fn.isLegendToShow = function (targetId) {
        return this.hiddenLegendIds.indexOf(targetId) < 0;
    };
    c3_chart_internal_fn.filterTargetsToShow = function (targets) {
        var $$ = this;
        return targets.filter(function (t) {
            return $$.isTargetToShow(t.id);
        });
    };
    c3_chart_internal_fn.mapTargetsToUniqueXs = function (targets) {
        var $$ = this;
        var xs = $$.d3.set($$.d3.merge(targets.map(function (t) {
            return t.values.map(function (v) {
                return +v.x;
            });
        }))).values();
        xs = $$.isTimeSeries() ? xs.map(function (x) {
            return new Date(+x);
        }) : xs.map(function (x) {
            return +x;
        });
        return xs.sort(function (a, b) {
            return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
        });
    };
    c3_chart_internal_fn.addHiddenTargetIds = function (targetIds) {
        targetIds = targetIds instanceof Array ? targetIds : new Array(targetIds);
        for (var i = 0; i < targetIds.length; i++) {
            if (this.hiddenTargetIds.indexOf(targetIds[i]) < 0) {
                this.hiddenTargetIds = this.hiddenTargetIds.concat(targetIds[i]);
            }
        }
    };
    c3_chart_internal_fn.removeHiddenTargetIds = function (targetIds) {
        this.hiddenTargetIds = this.hiddenTargetIds.filter(function (id) {
            return targetIds.indexOf(id) < 0;
        });
    };
    c3_chart_internal_fn.addHiddenLegendIds = function (targetIds) {
        targetIds = targetIds instanceof Array ? targetIds : new Array(targetIds);
        for (var i = 0; i < targetIds.length; i++) {
            if (this.hiddenLegendIds.indexOf(targetIds[i]) < 0) {
                this.hiddenLegendIds = this.hiddenLegendIds.concat(targetIds[i]);
            }
        }
    };
    c3_chart_internal_fn.removeHiddenLegendIds = function (targetIds) {
        this.hiddenLegendIds = this.hiddenLegendIds.filter(function (id) {
            return targetIds.indexOf(id) < 0;
        });
    };
    c3_chart_internal_fn.getValuesAsIdKeyed = function (targets) {
        var ys = {};
        targets.forEach(function (t) {
            ys[t.id] = [];
            t.values.forEach(function (v) {
                ys[t.id].push(v.value);
            });
        });
        return ys;
    };
    c3_chart_internal_fn.checkValueInTargets = function (targets, checker) {
        var ids = Object.keys(targets),
            i,
            j,
            values;
        for (i = 0; i < ids.length; i++) {
            values = targets[ids[i]].values;
            for (j = 0; j < values.length; j++) {
                if (checker(values[j].value)) {
                    return true;
                }
            }
        }
        return false;
    };
    c3_chart_internal_fn.hasNegativeValueInTargets = function (targets) {
        return this.checkValueInTargets(targets, function (v) {
            return v < 0;
        });
    };
    c3_chart_internal_fn.hasPositiveValueInTargets = function (targets) {
        return this.checkValueInTargets(targets, function (v) {
            return v > 0;
        });
    };
    c3_chart_internal_fn.isOrderDesc = function () {
        var config = this.config;
        return typeof config.data_order === 'string' && config.data_order.toLowerCase() === 'desc';
    };
    c3_chart_internal_fn.isOrderAsc = function () {
        var config = this.config;
        return typeof config.data_order === 'string' && config.data_order.toLowerCase() === 'asc';
    };
    c3_chart_internal_fn.getOrderFunction = function () {
        var $$ = this,
            config = $$.config,
            orderAsc = $$.isOrderAsc(),
            orderDesc = $$.isOrderDesc();
        if (orderAsc || orderDesc) {
            return function (t1, t2) {
                var reducer = function reducer(p, c) {
                    return p + Math.abs(c.value);
                };
                var t1Sum = t1.values.reduce(reducer, 0),
                    t2Sum = t2.values.reduce(reducer, 0);
                return orderDesc ? t2Sum - t1Sum : t1Sum - t2Sum;
            };
        } else if (isFunction(config.data_order)) {
            return config.data_order;
        } else if (isArray(config.data_order)) {
            var order = config.data_order;
            return function (t1, t2) {
                return order.indexOf(t1.id) - order.indexOf(t2.id);
            };
        }
    };
    c3_chart_internal_fn.orderTargets = function (targets) {
        var fct = this.getOrderFunction();
        if (fct) {
            targets.sort(fct);
            if (this.isOrderAsc() || this.isOrderDesc()) {
                targets.reverse();
            }
        }
        return targets;
    };
    c3_chart_internal_fn.filterByX = function (targets, x) {
        return this.d3.merge(targets.map(function (t) {
            return t.values;
        })).filter(function (v) {
            return v.x - x === 0;
        });
    };
    c3_chart_internal_fn.filterRemoveNull = function (data) {
        return data.filter(function (d) {
            return isValue(d.value);
        });
    };
    c3_chart_internal_fn.filterByXDomain = function (targets, xDomain) {
        return targets.map(function (t) {
            return {
                id: t.id,
                id_org: t.id_org,
                values: t.values.filter(function (v) {
                    return xDomain[0] <= v.x && v.x <= xDomain[1];
                })
            };
        });
    };
    c3_chart_internal_fn.hasDataLabel = function () {
        var config = this.config;
        if (typeof config.data_labels === 'boolean' && config.data_labels) {
            return true;
        } else if (_typeof(config.data_labels) === 'object' && notEmpty(config.data_labels)) {
            return true;
        }
        return false;
    };
    c3_chart_internal_fn.getDataLabelLength = function (min, max, key) {
        var $$ = this,
            lengths = [0, 0],
            paddingCoef = 1.3;
        $$.selectChart.select('svg').selectAll('.dummy').data([min, max]).enter().append('text').text(function (d) {
            return $$.dataLabelFormat(d.id)(d);
        }).each(function (d, i) {
            lengths[i] = this.getBoundingClientRect()[key] * paddingCoef;
        }).remove();
        return lengths;
    };
    c3_chart_internal_fn.isNoneArc = function (d) {
        return this.hasTarget(this.data.targets, d.id);
    }, c3_chart_internal_fn.isArc = function (d) {
        return 'data' in d && this.hasTarget(this.data.targets, d.data.id);
    };
    c3_chart_internal_fn.findSameXOfValues = function (values, index) {
        var i,
            targetX = values[index].x,
            sames = [];
        for (i = index - 1; i >= 0; i--) {
            if (targetX !== values[i].x) {
                break;
            }
            sames.push(values[i]);
        }
        for (i = index; i < values.length; i++) {
            if (targetX !== values[i].x) {
                break;
            }
            sames.push(values[i]);
        }
        return sames;
    };

    c3_chart_internal_fn.findClosestFromTargets = function (targets, pos) {
        var $$ = this,
            candidates;

        // map to array of closest points of each target
        candidates = targets.map(function (target) {
            return $$.findClosest(target.values, pos);
        });

        // decide closest point and return
        return $$.findClosest(candidates, pos);
    };
    c3_chart_internal_fn.findClosest = function (values, pos) {
        var $$ = this,
            minDist = $$.config.point_sensitivity,
            closest;

        // find mouseovering bar
        values.filter(function (v) {
            return v && $$.isBarType(v.id);
        }).forEach(function (v) {
            var shape = $$.main.select('.' + CLASS.bars + $$.getTargetSelectorSuffix(v.id) + ' .' + CLASS.bar + '-' + v.index).node();
            if (!closest && $$.isWithinBar(shape)) {
                closest = v;
            }
        });

        // find closest point from non-bar
        values.filter(function (v) {
            return v && !$$.isBarType(v.id);
        }).forEach(function (v) {
            var d = $$.dist(v, pos);
            if (d < minDist) {
                minDist = d;
                closest = v;
            }
        });

        return closest;
    };
    c3_chart_internal_fn.dist = function (data, pos) {
        var $$ = this,
            config = $$.config,
            xIndex = config.axis_rotated ? 1 : 0,
            yIndex = config.axis_rotated ? 0 : 1,
            y = $$.circleY(data, data.index),
            x = $$.x(data.x);
        return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
    };
    c3_chart_internal_fn.convertValuesToStep = function (values) {
        var converted = [].concat(values),
            i;

        if (!this.isCategorized()) {
            return values;
        }

        for (i = values.length + 1; 0 < i; i--) {
            converted[i] = converted[i - 1];
        }

        converted[0] = {
            x: converted[0].x - 1,
            value: converted[0].value,
            id: converted[0].id
        };
        converted[values.length + 1] = {
            x: converted[values.length].x + 1,
            value: converted[values.length].value,
            id: converted[values.length].id
        };

        return converted;
    };
    c3_chart_internal_fn.updateDataAttributes = function (name, attrs) {
        var $$ = this,
            config = $$.config,
            current = config['data_' + name];
        if (typeof attrs === 'undefined') {
            return current;
        }
        Object.keys(attrs).forEach(function (id) {
            current[id] = attrs[id];
        });
        $$.redraw({ withLegend: true });
        return current;
    };

    c3_chart_internal_fn.load = function (targets, args) {
        var $$ = this;
        if (targets) {
            // filter loading targets if needed
            if (args.filter) {
                targets = targets.filter(args.filter);
            }
            // set type if args.types || args.type specified
            if (args.type || args.types) {
                targets.forEach(function (t) {
                    var type = args.types && args.types[t.id] ? args.types[t.id] : args.type;
                    $$.setTargetType(t.id, type);
                });
            }
            // Update/Add data
            $$.data.targets.forEach(function (d) {
                for (var i = 0; i < targets.length; i++) {
                    if (d.id === targets[i].id) {
                        d.values = targets[i].values;
                        targets.splice(i, 1);
                        break;
                    }
                }
            });
            $$.data.targets = $$.data.targets.concat(targets); // add remained
        }

        // Set targets
        $$.updateTargets($$.data.targets);

        // Redraw with new targets
        $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true, withLegend: true });

        if (args.done) {
            args.done();
        }
    };
    c3_chart_internal_fn.loadFromArgs = function (args) {
        var $$ = this;
        if (args.data) {
            $$.load($$.convertDataToTargets(args.data), args);
        } else if (args.url) {
            $$.convertUrlToData(args.url, args.mimeType, args.headers, args.keys, function (data) {
                $$.load($$.convertDataToTargets(data), args);
            });
        } else if (args.json) {
            $$.load($$.convertDataToTargets($$.convertJsonToData(args.json, args.keys)), args);
        } else if (args.rows) {
            $$.load($$.convertDataToTargets($$.convertRowsToData(args.rows)), args);
        } else if (args.columns) {
            $$.load($$.convertDataToTargets($$.convertColumnsToData(args.columns)), args);
        } else {
            $$.load(null, args);
        }
    };
    c3_chart_internal_fn.unload = function (targetIds, done) {
        var $$ = this;
        if (!done) {
            done = function done() {};
        }
        // filter existing target
        targetIds = targetIds.filter(function (id) {
            return $$.hasTarget($$.data.targets, id);
        });
        // If no target, call done and return
        if (!targetIds || targetIds.length === 0) {
            done();
            return;
        }
        $$.svg.selectAll(targetIds.map(function (id) {
            return $$.selectorTarget(id);
        })).transition().style('opacity', 0).remove().call($$.endall, done);
        targetIds.forEach(function (id) {
            // Reset fadein for future load
            $$.withoutFadeIn[id] = false;
            // Remove target's elements
            if ($$.legend) {
                $$.legend.selectAll('.' + CLASS.legendItem + $$.getTargetSelectorSuffix(id)).remove();
            }
            // Remove target
            $$.data.targets = $$.data.targets.filter(function (t) {
                return t.id !== id;
            });
        });
    };

    c3_chart_internal_fn.getYDomainMin = function (targets) {
        var $$ = this,
            config = $$.config,
            ids = $$.mapToIds(targets),
            ys = $$.getValuesAsIdKeyed(targets),
            j,
            k,
            baseId,
            idsInGroup,
            id,
            hasNegativeValue;
        if (config.data_groups.length > 0) {
            hasNegativeValue = $$.hasNegativeValueInTargets(targets);
            for (j = 0; j < config.data_groups.length; j++) {
                // Determine baseId
                idsInGroup = config.data_groups[j].filter(function (id) {
                    return ids.indexOf(id) >= 0;
                });
                if (idsInGroup.length === 0) {
                    continue;
                }
                baseId = idsInGroup[0];
                // Consider negative values
                if (hasNegativeValue && ys[baseId]) {
                    ys[baseId].forEach(function (v, i) {
                        ys[baseId][i] = v < 0 ? v : 0;
                    });
                }
                // Compute min
                for (k = 1; k < idsInGroup.length; k++) {
                    id = idsInGroup[k];
                    if (!ys[id]) {
                        continue;
                    }
                    ys[id].forEach(function (v, i) {
                        if ($$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasNegativeValue && +v > 0)) {
                            ys[baseId][i] += +v;
                        }
                    });
                }
            }
        }
        return $$.d3.min(Object.keys(ys).map(function (key) {
            return $$.d3.min(ys[key]);
        }));
    };
    c3_chart_internal_fn.getYDomainMax = function (targets) {
        var $$ = this,
            config = $$.config,
            ids = $$.mapToIds(targets),
            ys = $$.getValuesAsIdKeyed(targets),
            j,
            k,
            baseId,
            idsInGroup,
            id,
            hasPositiveValue;
        if (config.data_groups.length > 0) {
            hasPositiveValue = $$.hasPositiveValueInTargets(targets);
            for (j = 0; j < config.data_groups.length; j++) {
                // Determine baseId
                idsInGroup = config.data_groups[j].filter(function (id) {
                    return ids.indexOf(id) >= 0;
                });
                if (idsInGroup.length === 0) {
                    continue;
                }
                baseId = idsInGroup[0];
                // Consider positive values
                if (hasPositiveValue && ys[baseId]) {
                    ys[baseId].forEach(function (v, i) {
                        ys[baseId][i] = v > 0 ? v : 0;
                    });
                }
                // Compute max
                for (k = 1; k < idsInGroup.length; k++) {
                    id = idsInGroup[k];
                    if (!ys[id]) {
                        continue;
                    }
                    ys[id].forEach(function (v, i) {
                        if ($$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasPositiveValue && +v < 0)) {
                            ys[baseId][i] += +v;
                        }
                    });
                }
            }
        }
        return $$.d3.max(Object.keys(ys).map(function (key) {
            return $$.d3.max(ys[key]);
        }));
    };
    c3_chart_internal_fn.getYDomain = function (targets, axisId, xDomain) {
        var $$ = this,
            config = $$.config,
            targetsByAxisId = targets.filter(function (t) {
            return $$.axis.getId(t.id) === axisId;
        }),
            yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId,
            yMin = axisId === 'y2' ? config.axis_y2_min : config.axis_y_min,
            yMax = axisId === 'y2' ? config.axis_y2_max : config.axis_y_max,
            yDomainMin = $$.getYDomainMin(yTargets),
            yDomainMax = $$.getYDomainMax(yTargets),
            domain,
            domainLength,
            padding,
            padding_top,
            padding_bottom,
            center = axisId === 'y2' ? config.axis_y2_center : config.axis_y_center,
            yDomainAbs,
            lengths,
            diff,
            ratio,
            isAllPositive,
            isAllNegative,
            isZeroBased = $$.hasType('bar', yTargets) && config.bar_zerobased || $$.hasType('area', yTargets) && config.area_zerobased,
            isInverted = axisId === 'y2' ? config.axis_y2_inverted : config.axis_y_inverted,
            showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
            showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;

        // MEMO: avoid inverting domain unexpectedly
        yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? yDomainMin < yMax ? yDomainMin : yMax - 10 : yDomainMin;
        yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? yMin < yDomainMax ? yDomainMax : yMin + 10 : yDomainMax;

        if (yTargets.length === 0) {
            // use current domain if target of axisId is none
            return axisId === 'y2' ? $$.y2.domain() : $$.y.domain();
        }
        if (isNaN(yDomainMin)) {
            // set minimum to zero when not number
            yDomainMin = 0;
        }
        if (isNaN(yDomainMax)) {
            // set maximum to have same value as yDomainMin
            yDomainMax = yDomainMin;
        }
        if (yDomainMin === yDomainMax) {
            yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0;
        }
        isAllPositive = yDomainMin >= 0 && yDomainMax >= 0;
        isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;

        // Cancel zerobased if axis_*_min / axis_*_max specified
        if (isValue(yMin) && isAllPositive || isValue(yMax) && isAllNegative) {
            isZeroBased = false;
        }

        // Bar/Area chart should be 0-based if all positive|negative
        if (isZeroBased) {
            if (isAllPositive) {
                yDomainMin = 0;
            }
            if (isAllNegative) {
                yDomainMax = 0;
            }
        }

        domainLength = Math.abs(yDomainMax - yDomainMin);
        padding = padding_top = padding_bottom = domainLength * 0.1;

        if (typeof center !== 'undefined') {
            yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
            yDomainMax = center + yDomainAbs;
            yDomainMin = center - yDomainAbs;
        }
        // add padding for data label
        if (showHorizontalDataLabel) {
            lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'width');
            diff = diffDomain($$.y.range());
            ratio = [lengths[0] / diff, lengths[1] / diff];
            padding_top += domainLength * (ratio[1] / (1 - ratio[0] - ratio[1]));
            padding_bottom += domainLength * (ratio[0] / (1 - ratio[0] - ratio[1]));
        } else if (showVerticalDataLabel) {
            lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'height');
            padding_top += $$.axis.convertPixelsToAxisPadding(lengths[1], domainLength);
            padding_bottom += $$.axis.convertPixelsToAxisPadding(lengths[0], domainLength);
        }
        if (axisId === 'y' && notEmpty(config.axis_y_padding)) {
            padding_top = $$.axis.getPadding(config.axis_y_padding, 'top', padding_top, domainLength);
            padding_bottom = $$.axis.getPadding(config.axis_y_padding, 'bottom', padding_bottom, domainLength);
        }
        if (axisId === 'y2' && notEmpty(config.axis_y2_padding)) {
            padding_top = $$.axis.getPadding(config.axis_y2_padding, 'top', padding_top, domainLength);
            padding_bottom = $$.axis.getPadding(config.axis_y2_padding, 'bottom', padding_bottom, domainLength);
        }
        // Bar/Area chart should be 0-based if all positive|negative
        if (isZeroBased) {
            if (isAllPositive) {
                padding_bottom = yDomainMin;
            }
            if (isAllNegative) {
                padding_top = -yDomainMax;
            }
        }
        domain = [yDomainMin - padding_bottom, yDomainMax + padding_top];
        return isInverted ? domain.reverse() : domain;
    };
    c3_chart_internal_fn.getXDomainMin = function (targets) {
        var $$ = this,
            config = $$.config;
        return isDefined(config.axis_x_min) ? $$.isTimeSeries() ? this.parseDate(config.axis_x_min) : config.axis_x_min : $$.d3.min(targets, function (t) {
            return $$.d3.min(t.values, function (v) {
                return v.x;
            });
        });
    };
    c3_chart_internal_fn.getXDomainMax = function (targets) {
        var $$ = this,
            config = $$.config;
        return isDefined(config.axis_x_max) ? $$.isTimeSeries() ? this.parseDate(config.axis_x_max) : config.axis_x_max : $$.d3.max(targets, function (t) {
            return $$.d3.max(t.values, function (v) {
                return v.x;
            });
        });
    };
    c3_chart_internal_fn.getXDomainPadding = function (domain) {
        var $$ = this,
            config = $$.config,
            diff = domain[1] - domain[0],
            maxDataCount,
            padding,
            paddingLeft,
            paddingRight;
        if ($$.isCategorized()) {
            padding = 0;
        } else if ($$.hasType('bar')) {
            maxDataCount = $$.getMaxDataCount();
            padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : 0.5;
        } else {
            padding = diff * 0.01;
        }
        if (_typeof(config.axis_x_padding) === 'object' && notEmpty(config.axis_x_padding)) {
            paddingLeft = isValue(config.axis_x_padding.left) ? config.axis_x_padding.left : padding;
            paddingRight = isValue(config.axis_x_padding.right) ? config.axis_x_padding.right : padding;
        } else if (typeof config.axis_x_padding === 'number') {
            paddingLeft = paddingRight = config.axis_x_padding;
        } else {
            paddingLeft = paddingRight = padding;
        }
        return { left: paddingLeft, right: paddingRight };
    };
    c3_chart_internal_fn.getXDomain = function (targets) {
        var $$ = this,
            xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
            firstX = xDomain[0],
            lastX = xDomain[1],
            padding = $$.getXDomainPadding(xDomain),
            min = 0,
            max = 0;
        // show center of x domain if min and max are the same
        if (firstX - lastX === 0 && !$$.isCategorized()) {
            if ($$.isTimeSeries()) {
                firstX = new Date(firstX.getTime() * 0.5);
                lastX = new Date(lastX.getTime() * 1.5);
            } else {
                firstX = firstX === 0 ? 1 : firstX * 0.5;
                lastX = lastX === 0 ? -1 : lastX * 1.5;
            }
        }
        if (firstX || firstX === 0) {
            min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left;
        }
        if (lastX || lastX === 0) {
            max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right;
        }
        return [min, max];
    };
    c3_chart_internal_fn.updateXDomain = function (targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
        var $$ = this,
            config = $$.config;

        if (withUpdateOrgXDomain) {
            $$.x.domain(domain ? domain : $$.d3.extent($$.getXDomain(targets)));
            $$.orgXDomain = $$.x.domain();
            if (config.zoom_enabled) {
                $$.zoom.scale($$.x).updateScaleExtent();
            }
            $$.subX.domain($$.x.domain());
            if ($$.brush) {
                $$.brush.scale($$.subX);
            }
        }
        if (withUpdateXDomain) {
            $$.x.domain(domain ? domain : !$$.brush || $$.brush.empty() ? $$.orgXDomain : $$.brush.extent());
            if (config.zoom_enabled) {
                $$.zoom.scale($$.x).updateScaleExtent();
            }
        }

        // Trim domain when too big by zoom mousemove event
        if (withTrim) {
            $$.x.domain($$.trimXDomain($$.x.orgDomain()));
        }

        return $$.x.domain();
    };
    c3_chart_internal_fn.trimXDomain = function (domain) {
        var zoomDomain = this.getZoomDomain(),
            min = zoomDomain[0],
            max = zoomDomain[1];
        if (domain[0] <= min) {
            domain[1] = +domain[1] + (min - domain[0]);
            domain[0] = min;
        }
        if (max <= domain[1]) {
            domain[0] = +domain[0] - (domain[1] - max);
            domain[1] = max;
        }
        return domain;
    };

    c3_chart_internal_fn.drag = function (mouse) {
        var $$ = this,
            config = $$.config,
            main = $$.main,
            d3 = $$.d3;
        var sx, sy, mx, my, minX, maxX, minY, maxY;

        if ($$.hasArcType()) {
            return;
        }
        if (!config.data_selection_enabled) {
            return;
        } // do nothing if not selectable
        if (config.zoom_enabled && !$$.zoom.altDomain) {
            return;
        } // skip if zoomable because of conflict drag dehavior
        if (!config.data_selection_multiple) {
            return;
        } // skip when single selection because drag is used for multiple selection

        sx = $$.dragStart[0];
        sy = $$.dragStart[1];
        mx = mouse[0];
        my = mouse[1];
        minX = Math.min(sx, mx);
        maxX = Math.max(sx, mx);
        minY = config.data_selection_grouped ? $$.margin.top : Math.min(sy, my);
        maxY = config.data_selection_grouped ? $$.height : Math.max(sy, my);

        main.select('.' + CLASS.dragarea).attr('x', minX).attr('y', minY).attr('width', maxX - minX).attr('height', maxY - minY);
        // TODO: binary search when multiple xs
        main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).filter(function (d) {
            return config.data_selection_isselectable(d);
        }).each(function (d, i) {
            var shape = d3.select(this),
                isSelected = shape.classed(CLASS.SELECTED),
                isIncluded = shape.classed(CLASS.INCLUDED),
                _x,
                _y,
                _w,
                _h,
                toggle,
                isWithin = false,
                box;
            if (shape.classed(CLASS.circle)) {
                _x = shape.attr("cx") * 1;
                _y = shape.attr("cy") * 1;
                toggle = $$.togglePoint;
                isWithin = minX < _x && _x < maxX && minY < _y && _y < maxY;
            } else if (shape.classed(CLASS.bar)) {
                box = getPathBox(this);
                _x = box.x;
                _y = box.y;
                _w = box.width;
                _h = box.height;
                toggle = $$.togglePath;
                isWithin = !(maxX < _x || _x + _w < minX) && !(maxY < _y || _y + _h < minY);
            } else {
                // line/area selection not supported yet
                return;
            }
            if (isWithin ^ isIncluded) {
                shape.classed(CLASS.INCLUDED, !isIncluded);
                // TODO: included/unincluded callback here
                shape.classed(CLASS.SELECTED, !isSelected);
                toggle.call($$, !isSelected, shape, d, i);
            }
        });
    };

    c3_chart_internal_fn.dragstart = function (mouse) {
        var $$ = this,
            config = $$.config;
        if ($$.hasArcType()) {
            return;
        }
        if (!config.data_selection_enabled) {
            return;
        } // do nothing if not selectable
        $$.dragStart = mouse;
        $$.main.select('.' + CLASS.chart).append('rect').attr('class', CLASS.dragarea).style('opacity', 0.1);
        $$.dragging = true;
    };

    c3_chart_internal_fn.dragend = function () {
        var $$ = this,
            config = $$.config;
        if ($$.hasArcType()) {
            return;
        }
        if (!config.data_selection_enabled) {
            return;
        } // do nothing if not selectable
        $$.main.select('.' + CLASS.dragarea).transition().duration(100).style('opacity', 0).remove();
        $$.main.selectAll('.' + CLASS.shape).classed(CLASS.INCLUDED, false);
        $$.dragging = false;
    };

    c3_chart_internal_fn.getYFormat = function (forArc) {
        var $$ = this,
            formatForY = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.yFormat,
            formatForY2 = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.y2Format;
        return function (v, ratio, id) {
            var format = $$.axis.getId(id) === 'y2' ? formatForY2 : formatForY;
            return format.call($$, v, ratio);
        };
    };
    c3_chart_internal_fn.yFormat = function (v) {
        var $$ = this,
            config = $$.config,
            format = config.axis_y_tick_format ? config.axis_y_tick_format : $$.defaultValueFormat;
        return format(v);
    };
    c3_chart_internal_fn.y2Format = function (v) {
        var $$ = this,
            config = $$.config,
            format = config.axis_y2_tick_format ? config.axis_y2_tick_format : $$.defaultValueFormat;
        return format(v);
    };
    c3_chart_internal_fn.defaultValueFormat = function (v) {
        return isValue(v) ? +v : "";
    };
    c3_chart_internal_fn.defaultArcValueFormat = function (v, ratio) {
        return (ratio * 100).toFixed(1) + '%';
    };
    c3_chart_internal_fn.dataLabelFormat = function (targetId) {
        var $$ = this,
            data_labels = $$.config.data_labels,
            format,
            defaultFormat = function defaultFormat(v) {
            return isValue(v) ? +v : "";
        };
        // find format according to axis id
        if (typeof data_labels.format === 'function') {
            format = data_labels.format;
        } else if (_typeof(data_labels.format) === 'object') {
            if (data_labels.format[targetId]) {
                format = data_labels.format[targetId] === true ? defaultFormat : data_labels.format[targetId];
            } else {
                format = function format() {
                    return '';
                };
            }
        } else {
            format = defaultFormat;
        }
        return format;
    };

    c3_chart_internal_fn.initGrid = function () {
        var $$ = this,
            config = $$.config,
            d3 = $$.d3;
        $$.grid = $$.main.append('g').attr("clip-path", $$.clipPathForGrid).attr('class', CLASS.grid);
        if (config.grid_x_show) {
            $$.grid.append("g").attr("class", CLASS.xgrids);
        }
        if (config.grid_y_show) {
            $$.grid.append('g').attr('class', CLASS.ygrids);
        }
        if (config.grid_focus_show) {
            $$.grid.append('g').attr("class", CLASS.xgridFocus).append('line').attr('class', CLASS.xgridFocus);
        }
        $$.xgrid = d3.selectAll([]);
        if (!config.grid_lines_front) {
            $$.initGridLines();
        }
    };
    c3_chart_internal_fn.initGridLines = function () {
        var $$ = this,
            d3 = $$.d3;
        $$.gridLines = $$.main.append('g').attr("clip-path", $$.clipPathForGrid).attr('class', CLASS.grid + ' ' + CLASS.gridLines);
        $$.gridLines.append('g').attr("class", CLASS.xgridLines);
        $$.gridLines.append('g').attr('class', CLASS.ygridLines);
        $$.xgridLines = d3.selectAll([]);
    };
    c3_chart_internal_fn.updateXGrid = function (withoutUpdate) {
        var $$ = this,
            config = $$.config,
            d3 = $$.d3,
            xgridData = $$.generateGridData(config.grid_x_type, $$.x),
            tickOffset = $$.isCategorized() ? $$.xAxis.tickOffset() : 0;

        $$.xgridAttr = config.axis_rotated ? {
            'x1': 0,
            'x2': $$.width,
            'y1': function y1(d) {
                return $$.x(d) - tickOffset;
            },
            'y2': function y2(d) {
                return $$.x(d) - tickOffset;
            }
        } : {
            'x1': function x1(d) {
                return $$.x(d) + tickOffset;
            },
            'x2': function x2(d) {
                return $$.x(d) + tickOffset;
            },
            'y1': 0,
            'y2': $$.height
        };

        $$.xgrid = $$.main.select('.' + CLASS.xgrids).selectAll('.' + CLASS.xgrid).data(xgridData);
        $$.xgrid.enter().append('line').attr("class", CLASS.xgrid);
        if (!withoutUpdate) {
            $$.xgrid.attr($$.xgridAttr).style("opacity", function () {
                return +d3.select(this).attr(config.axis_rotated ? 'y1' : 'x1') === (config.axis_rotated ? $$.height : 0) ? 0 : 1;
            });
        }
        $$.xgrid.exit().remove();
    };

    c3_chart_internal_fn.updateYGrid = function () {
        var $$ = this,
            config = $$.config,
            gridValues = $$.yAxis.tickValues() || $$.y.ticks(config.grid_y_ticks);
        $$.ygrid = $$.main.select('.' + CLASS.ygrids).selectAll('.' + CLASS.ygrid).data(gridValues);
        $$.ygrid.enter().append('line').attr('class', CLASS.ygrid);
        $$.ygrid.attr("x1", config.axis_rotated ? $$.y : 0).attr("x2", config.axis_rotated ? $$.y : $$.width).attr("y1", config.axis_rotated ? 0 : $$.y).attr("y2", config.axis_rotated ? $$.height : $$.y);
        $$.ygrid.exit().remove();
        $$.smoothLines($$.ygrid, 'grid');
    };

    c3_chart_internal_fn.gridTextAnchor = function (d) {
        return d.position ? d.position : "end";
    };
    c3_chart_internal_fn.gridTextDx = function (d) {
        return d.position === 'start' ? 4 : d.position === 'middle' ? 0 : -4;
    };
    c3_chart_internal_fn.xGridTextX = function (d) {
        return d.position === 'start' ? -this.height : d.position === 'middle' ? -this.height / 2 : 0;
    };
    c3_chart_internal_fn.yGridTextX = function (d) {
        return d.position === 'start' ? 0 : d.position === 'middle' ? this.width / 2 : this.width;
    };
    c3_chart_internal_fn.updateGrid = function (duration) {
        var $$ = this,
            main = $$.main,
            config = $$.config,
            xgridLine,
            ygridLine,
            yv;

        // hide if arc type
        $$.grid.style('visibility', $$.hasArcType() ? 'hidden' : 'visible');

        main.select('line.' + CLASS.xgridFocus).style("visibility", "hidden");
        if (config.grid_x_show) {
            $$.updateXGrid();
        }
        $$.xgridLines = main.select('.' + CLASS.xgridLines).selectAll('.' + CLASS.xgridLine).data(config.grid_x_lines);
        // enter
        xgridLine = $$.xgridLines.enter().append('g').attr("class", function (d) {
            return CLASS.xgridLine + (d['class'] ? ' ' + d['class'] : '');
        });
        xgridLine.append('line').style("opacity", 0);
        xgridLine.append('text').attr("text-anchor", $$.gridTextAnchor).attr("transform", config.axis_rotated ? "" : "rotate(-90)").attr('dx', $$.gridTextDx).attr('dy', -5).style("opacity", 0);
        // udpate
        // done in d3.transition() of the end of this function
        // exit
        $$.xgridLines.exit().transition().duration(duration).style("opacity", 0).remove();

        // Y-Grid
        if (config.grid_y_show) {
            $$.updateYGrid();
        }
        $$.ygridLines = main.select('.' + CLASS.ygridLines).selectAll('.' + CLASS.ygridLine).data(config.grid_y_lines);
        // enter
        ygridLine = $$.ygridLines.enter().append('g').attr("class", function (d) {
            return CLASS.ygridLine + (d['class'] ? ' ' + d['class'] : '');
        });
        ygridLine.append('line').style("opacity", 0);
        ygridLine.append('text').attr("text-anchor", $$.gridTextAnchor).attr("transform", config.axis_rotated ? "rotate(-90)" : "").attr('dx', $$.gridTextDx).attr('dy', -5).style("opacity", 0);
        // update
        yv = $$.yv.bind($$);
        $$.ygridLines.select('line').transition().duration(duration).attr("x1", config.axis_rotated ? yv : 0).attr("x2", config.axis_rotated ? yv : $$.width).attr("y1", config.axis_rotated ? 0 : yv).attr("y2", config.axis_rotated ? $$.height : yv).style("opacity", 1);
        $$.ygridLines.select('text').transition().duration(duration).attr("x", config.axis_rotated ? $$.xGridTextX.bind($$) : $$.yGridTextX.bind($$)).attr("y", yv).text(function (d) {
            return d.text;
        }).style("opacity", 1);
        // exit
        $$.ygridLines.exit().transition().duration(duration).style("opacity", 0).remove();
    };
    c3_chart_internal_fn.redrawGrid = function (withTransition) {
        var $$ = this,
            config = $$.config,
            xv = $$.xv.bind($$),
            lines = $$.xgridLines.select('line'),
            texts = $$.xgridLines.select('text');
        return [(withTransition ? lines.transition() : lines).attr("x1", config.axis_rotated ? 0 : xv).attr("x2", config.axis_rotated ? $$.width : xv).attr("y1", config.axis_rotated ? xv : 0).attr("y2", config.axis_rotated ? xv : $$.height).style("opacity", 1), (withTransition ? texts.transition() : texts).attr("x", config.axis_rotated ? $$.yGridTextX.bind($$) : $$.xGridTextX.bind($$)).attr("y", xv).text(function (d) {
            return d.text;
        }).style("opacity", 1)];
    };
    c3_chart_internal_fn.showXGridFocus = function (selectedData) {
        var $$ = this,
            config = $$.config,
            dataToShow = selectedData.filter(function (d) {
            return d && isValue(d.value);
        }),
            focusEl = $$.main.selectAll('line.' + CLASS.xgridFocus),
            xx = $$.xx.bind($$);
        if (!config.tooltip_show) {
            return;
        }
        // Hide when scatter plot exists
        if ($$.hasType('scatter') || $$.hasArcType()) {
            return;
        }
        focusEl.style("visibility", "visible").data([dataToShow[0]]).attr(config.axis_rotated ? 'y1' : 'x1', xx).attr(config.axis_rotated ? 'y2' : 'x2', xx);
        $$.smoothLines(focusEl, 'grid');
    };
    c3_chart_internal_fn.hideXGridFocus = function () {
        this.main.select('line.' + CLASS.xgridFocus).style("visibility", "hidden");
    };
    c3_chart_internal_fn.updateXgridFocus = function () {
        var $$ = this,
            config = $$.config;
        $$.main.select('line.' + CLASS.xgridFocus).attr("x1", config.axis_rotated ? 0 : -10).attr("x2", config.axis_rotated ? $$.width : -10).attr("y1", config.axis_rotated ? -10 : 0).attr("y2", config.axis_rotated ? -10 : $$.height);
    };
    c3_chart_internal_fn.generateGridData = function (type, scale) {
        var $$ = this,
            gridData = [],
            xDomain,
            firstYear,
            lastYear,
            i,
            tickNum = $$.main.select("." + CLASS.axisX).selectAll('.tick').size();
        if (type === 'year') {
            xDomain = $$.getXDomain();
            firstYear = xDomain[0].getFullYear();
            lastYear = xDomain[1].getFullYear();
            for (i = firstYear; i <= lastYear; i++) {
                gridData.push(new Date(i + '-01-01 00:00:00'));
            }
        } else {
            gridData = scale.ticks(10);
            if (gridData.length > tickNum) {
                // use only int
                gridData = gridData.filter(function (d) {
                    return ("" + d).indexOf('.') < 0;
                });
            }
        }
        return gridData;
    };
    c3_chart_internal_fn.getGridFilterToRemove = function (params) {
        return params ? function (line) {
            var found = false;
            [].concat(params).forEach(function (param) {
                if ('value' in param && line.value === param.value || 'class' in param && line['class'] === param['class']) {
                    found = true;
                }
            });
            return found;
        } : function () {
            return true;
        };
    };
    c3_chart_internal_fn.removeGridLines = function (params, forX) {
        var $$ = this,
            config = $$.config,
            toRemove = $$.getGridFilterToRemove(params),
            toShow = function toShow(line) {
            return !toRemove(line);
        },
            classLines = forX ? CLASS.xgridLines : CLASS.ygridLines,
            classLine = forX ? CLASS.xgridLine : CLASS.ygridLine;
        $$.main.select('.' + classLines).selectAll('.' + classLine).filter(toRemove).transition().duration(config.transition_duration).style('opacity', 0).remove();
        if (forX) {
            config.grid_x_lines = config.grid_x_lines.filter(toShow);
        } else {
            config.grid_y_lines = config.grid_y_lines.filter(toShow);
        }
    };

    c3_chart_internal_fn.initEventRect = function () {
        var $$ = this;
        $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.eventRects).style('fill-opacity', 0);
    };
    c3_chart_internal_fn.redrawEventRect = function () {
        var $$ = this,
            config = $$.config,
            eventRectUpdate,
            maxDataCountTarget,
            isMultipleX = $$.isMultipleX();

        // rects for mouseover
        var eventRects = $$.main.select('.' + CLASS.eventRects).style('cursor', config.zoom_enabled ? config.axis_rotated ? 'ns-resize' : 'ew-resize' : null).classed(CLASS.eventRectsMultiple, isMultipleX).classed(CLASS.eventRectsSingle, !isMultipleX);

        // clear old rects
        eventRects.selectAll('.' + CLASS.eventRect).remove();

        // open as public variable
        $$.eventRect = eventRects.selectAll('.' + CLASS.eventRect);

        if (isMultipleX) {
            eventRectUpdate = $$.eventRect.data([0]);
            // enter : only one rect will be added
            $$.generateEventRectsForMultipleXs(eventRectUpdate.enter());
            // update
            $$.updateEventRect(eventRectUpdate);
            // exit : not needed because always only one rect exists
        } else {
            // Set data and update $$.eventRect
            maxDataCountTarget = $$.getMaxDataCountTarget($$.data.targets);
            eventRects.datum(maxDataCountTarget ? maxDataCountTarget.values : []);
            $$.eventRect = eventRects.selectAll('.' + CLASS.eventRect);
            eventRectUpdate = $$.eventRect.data(function (d) {
                return d;
            });
            // enter
            $$.generateEventRectsForSingleX(eventRectUpdate.enter());
            // update
            $$.updateEventRect(eventRectUpdate);
            // exit
            eventRectUpdate.exit().remove();
        }
    };
    c3_chart_internal_fn.updateEventRect = function (eventRectUpdate) {
        var $$ = this,
            config = $$.config,
            x,
            y,
            w,
            h,
            rectW,
            rectX;

        // set update selection if null
        eventRectUpdate = eventRectUpdate || $$.eventRect.data(function (d) {
            return d;
        });

        if ($$.isMultipleX()) {
            // TODO: rotated not supported yet
            x = 0;
            y = 0;
            w = $$.width;
            h = $$.height;
        } else {
            if (($$.isCustomX() || $$.isTimeSeries()) && !$$.isCategorized()) {

                // update index for x that is used by prevX and nextX
                $$.updateXs();

                rectW = function rectW(d) {
                    var prevX = $$.getPrevX(d.index),
                        nextX = $$.getNextX(d.index);

                    // if there this is a single data point make the eventRect full width (or height)
                    if (prevX === null && nextX === null) {
                        return config.axis_rotated ? $$.height : $$.width;
                    }

                    if (prevX === null) {
                        prevX = $$.x.domain()[0];
                    }
                    if (nextX === null) {
                        nextX = $$.x.domain()[1];
                    }

                    return Math.max(0, ($$.x(nextX) - $$.x(prevX)) / 2);
                };
                rectX = function rectX(d) {
                    var prevX = $$.getPrevX(d.index),
                        nextX = $$.getNextX(d.index),
                        thisX = $$.data.xs[d.id][d.index];

                    // if there this is a single data point position the eventRect at 0
                    if (prevX === null && nextX === null) {
                        return 0;
                    }

                    if (prevX === null) {
                        prevX = $$.x.domain()[0];
                    }

                    return ($$.x(thisX) + $$.x(prevX)) / 2;
                };
            } else {
                rectW = $$.getEventRectWidth();
                rectX = function rectX(d) {
                    return $$.x(d.x) - rectW / 2;
                };
            }
            x = config.axis_rotated ? 0 : rectX;
            y = config.axis_rotated ? rectX : 0;
            w = config.axis_rotated ? $$.width : rectW;
            h = config.axis_rotated ? rectW : $$.height;
        }

        eventRectUpdate.attr('class', $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
    };
    c3_chart_internal_fn.generateEventRectsForSingleX = function (eventRectEnter) {
        var $$ = this,
            d3 = $$.d3,
            config = $$.config;
        eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on('mouseover', function (d) {
            var index = d.index;

            if ($$.dragging || $$.flowing) {
                return;
            } // do nothing while dragging/flowing
            if ($$.hasArcType()) {
                return;
            }

            // Expand shapes for selection
            if (config.point_focus_expand_enabled) {
                $$.expandCircles(index, null, true);
            }
            $$.expandBars(index, null, true);

            // Call event handler
            $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function (d) {
                config.data_onmouseover.call($$.api, d);
            });
        }).on('mouseout', function (d) {
            var index = d.index;
            if (!$$.config) {
                return;
            } // chart is destroyed
            if ($$.hasArcType()) {
                return;
            }
            $$.hideXGridFocus();
            $$.hideTooltip();
            // Undo expanded shapes
            $$.unexpandCircles();
            $$.unexpandBars();
            // Call event handler
            $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function (d) {
                config.data_onmouseout.call($$.api, d);
            });
        }).on('mousemove', function (d) {
            var selectedData,
                index = d.index,
                eventRect = $$.svg.select('.' + CLASS.eventRect + '-' + index);

            if ($$.dragging || $$.flowing) {
                return;
            } // do nothing while dragging/flowing
            if ($$.hasArcType()) {
                return;
            }

            if ($$.isStepType(d) && $$.config.line_step_type === 'step-after' && d3.mouse(this)[0] < $$.x($$.getXValue(d.id, index))) {
                index -= 1;
            }

            // Show tooltip
            selectedData = $$.filterTargetsToShow($$.data.targets).map(function (t) {
                return $$.addName($$.getValueOnIndex(t.values, index));
            });

            if (config.tooltip_grouped) {
                $$.showTooltip(selectedData, this);
                $$.showXGridFocus(selectedData);
            }

            if (config.tooltip_grouped && (!config.data_selection_enabled || config.data_selection_grouped)) {
                return;
            }

            $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function () {
                d3.select(this).classed(CLASS.EXPANDED, true);
                if (config.data_selection_enabled) {
                    eventRect.style('cursor', config.data_selection_grouped ? 'pointer' : null);
                }
                if (!config.tooltip_grouped) {
                    $$.hideXGridFocus();
                    $$.hideTooltip();
                    if (!config.data_selection_grouped) {
                        $$.unexpandCircles(index);
                        $$.unexpandBars(index);
                    }
                }
            }).filter(function (d) {
                return $$.isWithinShape(this, d);
            }).each(function (d) {
                if (config.data_selection_enabled && (config.data_selection_grouped || config.data_selection_isselectable(d))) {
                    eventRect.style('cursor', 'pointer');
                }
                if (!config.tooltip_grouped) {
                    $$.showTooltip([d], this);
                    $$.showXGridFocus([d]);
                    if (config.point_focus_expand_enabled) {
                        $$.expandCircles(index, d.id, true);
                    }
                    $$.expandBars(index, d.id, true);
                }
            });
        }).on('click', function (d) {
            var index = d.index;
            if ($$.hasArcType() || !$$.toggleShape) {
                return;
            }
            if ($$.cancelClick) {
                $$.cancelClick = false;
                return;
            }
            if ($$.isStepType(d) && config.line_step_type === 'step-after' && d3.mouse(this)[0] < $$.x($$.getXValue(d.id, index))) {
                index -= 1;
            }
            $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function (d) {
                if (config.data_selection_grouped || $$.isWithinShape(this, d)) {
                    $$.toggleShape(this, d, index);
                    $$.config.data_onclick.call($$.api, d, this);
                }
            });
        }).call(config.data_selection_draggable && $$.drag ? d3.behavior.drag().origin(Object).on('drag', function () {
            $$.drag(d3.mouse(this));
        }).on('dragstart', function () {
            $$.dragstart(d3.mouse(this));
        }).on('dragend', function () {
            $$.dragend();
        }) : function () {});
    };

    c3_chart_internal_fn.generateEventRectsForMultipleXs = function (eventRectEnter) {
        var $$ = this,
            d3 = $$.d3,
            config = $$.config;

        function mouseout() {
            $$.svg.select('.' + CLASS.eventRect).style('cursor', null);
            $$.hideXGridFocus();
            $$.hideTooltip();
            $$.unexpandCircles();
            $$.unexpandBars();
        }

        eventRectEnter.append('rect').attr('x', 0).attr('y', 0).attr('width', $$.width).attr('height', $$.height).attr('class', CLASS.eventRect).on('mouseout', function () {
            if (!$$.config) {
                return;
            } // chart is destroyed
            if ($$.hasArcType()) {
                return;
            }
            mouseout();
        }).on('mousemove', function () {
            var targetsToShow = $$.filterTargetsToShow($$.data.targets);
            var mouse, closest, sameXData, selectedData;

            if ($$.dragging) {
                return;
            } // do nothing when dragging
            if ($$.hasArcType(targetsToShow)) {
                return;
            }

            mouse = d3.mouse(this);
            closest = $$.findClosestFromTargets(targetsToShow, mouse);

            if ($$.mouseover && (!closest || closest.id !== $$.mouseover.id)) {
                config.data_onmouseout.call($$.api, $$.mouseover);
                $$.mouseover = undefined;
            }

            if (!closest) {
                mouseout();
                return;
            }

            if ($$.isScatterType(closest) || !config.tooltip_grouped) {
                sameXData = [closest];
            } else {
                sameXData = $$.filterByX(targetsToShow, closest.x);
            }

            // show tooltip when cursor is close to some point
            selectedData = sameXData.map(function (d) {
                return $$.addName(d);
            });
            $$.showTooltip(selectedData, this);

            // expand points
            if (config.point_focus_expand_enabled) {
                $$.expandCircles(closest.index, closest.id, true);
            }
            $$.expandBars(closest.index, closest.id, true);

            // Show xgrid focus line
            $$.showXGridFocus(selectedData);

            // Show cursor as pointer if point is close to mouse position
            if ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) {
                $$.svg.select('.' + CLASS.eventRect).style('cursor', 'pointer');
                if (!$$.mouseover) {
                    config.data_onmouseover.call($$.api, closest);
                    $$.mouseover = closest;
                }
            }
        }).on('click', function () {
            var targetsToShow = $$.filterTargetsToShow($$.data.targets);
            var mouse, closest;
            if ($$.hasArcType(targetsToShow)) {
                return;
            }

            mouse = d3.mouse(this);
            closest = $$.findClosestFromTargets(targetsToShow, mouse);
            if (!closest) {
                return;
            }
            // select if selection enabled
            if ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) {
                $$.main.selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(closest.id)).selectAll('.' + CLASS.shape + '-' + closest.index).each(function () {
                    if (config.data_selection_grouped || $$.isWithinShape(this, closest)) {
                        $$.toggleShape(this, closest, closest.index);
                        $$.config.data_onclick.call($$.api, closest, this);
                    }
                });
            }
        }).call(config.data_selection_draggable && $$.drag ? d3.behavior.drag().origin(Object).on('drag', function () {
            $$.drag(d3.mouse(this));
        }).on('dragstart', function () {
            $$.dragstart(d3.mouse(this));
        }).on('dragend', function () {
            $$.dragend();
        }) : function () {});
    };
    c3_chart_internal_fn.dispatchEvent = function (type, index, mouse) {
        var $$ = this,
            selector = '.' + CLASS.eventRect + (!$$.isMultipleX() ? '-' + index : ''),
            eventRect = $$.main.select(selector).node(),
            box = eventRect.getBoundingClientRect(),
            x = box.left + (mouse ? mouse[0] : 0),
            y = box.top + (mouse ? mouse[1] : 0),
            event = document.createEvent("MouseEvents");

        event.initMouseEvent(type, true, true, window, 0, x, y, x, y, false, false, false, false, 0, null);
        eventRect.dispatchEvent(event);
    };

    c3_chart_internal_fn.initLegend = function () {
        var $$ = this;
        $$.legendItemTextBox = {};
        $$.legendHasRendered = false;
        $$.legend = $$.svg.append("g").attr("transform", $$.getTranslate('legend'));
        if (!$$.config.legend_show) {
            $$.legend.style('visibility', 'hidden');
            $$.hiddenLegendIds = $$.mapToIds($$.data.targets);
            return;
        }
        // MEMO: call here to update legend box and tranlate for all
        // MEMO: translate will be upated by this, so transform not needed in updateLegend()
        $$.updateLegendWithDefaults();
    };
    c3_chart_internal_fn.updateLegendWithDefaults = function () {
        var $$ = this;
        $$.updateLegend($$.mapToIds($$.data.targets), { withTransform: false, withTransitionForTransform: false, withTransition: false });
    };
    c3_chart_internal_fn.updateSizeForLegend = function (legendHeight, legendWidth) {
        var $$ = this,
            config = $$.config,
            insetLegendPosition = {
            top: $$.isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : $$.currentHeight - legendHeight - $$.getCurrentPaddingBottom() - config.legend_inset_y,
            left: $$.isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + 0.5 : $$.currentWidth - legendWidth - $$.getCurrentPaddingRight() - config.legend_inset_x + 0.5
        };

        $$.margin3 = {
            top: $$.isLegendRight ? 0 : $$.isLegendInset ? insetLegendPosition.top : $$.currentHeight - legendHeight,
            right: NaN,
            bottom: 0,
            left: $$.isLegendRight ? $$.currentWidth - legendWidth : $$.isLegendInset ? insetLegendPosition.left : 0
        };
    };
    c3_chart_internal_fn.transformLegend = function (withTransition) {
        var $$ = this;
        (withTransition ? $$.legend.transition() : $$.legend).attr("transform", $$.getTranslate('legend'));
    };
    c3_chart_internal_fn.updateLegendStep = function (step) {
        this.legendStep = step;
    };
    c3_chart_internal_fn.updateLegendItemWidth = function (w) {
        this.legendItemWidth = w;
    };
    c3_chart_internal_fn.updateLegendItemHeight = function (h) {
        this.legendItemHeight = h;
    };
    c3_chart_internal_fn.getLegendWidth = function () {
        var $$ = this;
        return $$.config.legend_show ? $$.isLegendRight || $$.isLegendInset ? $$.legendItemWidth * ($$.legendStep + 1) : $$.currentWidth : 0;
    };
    c3_chart_internal_fn.getLegendHeight = function () {
        var $$ = this,
            h = 0;
        if ($$.config.legend_show) {
            if ($$.isLegendRight) {
                h = $$.currentHeight;
            } else {
                h = Math.max(20, $$.legendItemHeight) * ($$.legendStep + 1);
            }
        }
        return h;
    };
    c3_chart_internal_fn.opacityForLegend = function (legendItem) {
        return legendItem.classed(CLASS.legendItemHidden) ? null : 1;
    };
    c3_chart_internal_fn.opacityForUnfocusedLegend = function (legendItem) {
        return legendItem.classed(CLASS.legendItemHidden) ? null : 0.3;
    };
    c3_chart_internal_fn.toggleFocusLegend = function (targetIds, focus) {
        var $$ = this;
        targetIds = $$.mapToTargetIds(targetIds);
        $$.legend.selectAll('.' + CLASS.legendItem).filter(function (id) {
            return targetIds.indexOf(id) >= 0;
        }).classed(CLASS.legendItemFocused, focus).transition().duration(100).style('opacity', function () {
            var opacity = focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend;
            return opacity.call($$, $$.d3.select(this));
        });
    };
    c3_chart_internal_fn.revertLegend = function () {
        var $$ = this,
            d3 = $$.d3;
        $$.legend.selectAll('.' + CLASS.legendItem).classed(CLASS.legendItemFocused, false).transition().duration(100).style('opacity', function () {
            return $$.opacityForLegend(d3.select(this));
        });
    };
    c3_chart_internal_fn.showLegend = function (targetIds) {
        var $$ = this,
            config = $$.config;
        if (!config.legend_show) {
            config.legend_show = true;
            $$.legend.style('visibility', 'visible');
            if (!$$.legendHasRendered) {
                $$.updateLegendWithDefaults();
            }
        }
        $$.removeHiddenLegendIds(targetIds);
        $$.legend.selectAll($$.selectorLegends(targetIds)).style('visibility', 'visible').transition().style('opacity', function () {
            return $$.opacityForLegend($$.d3.select(this));
        });
    };
    c3_chart_internal_fn.hideLegend = function (targetIds) {
        var $$ = this,
            config = $$.config;
        if (config.legend_show && isEmpty(targetIds)) {
            config.legend_show = false;
            $$.legend.style('visibility', 'hidden');
        }
        $$.addHiddenLegendIds(targetIds);
        $$.legend.selectAll($$.selectorLegends(targetIds)).style('opacity', 0).style('visibility', 'hidden');
    };
    c3_chart_internal_fn.clearLegendItemTextBoxCache = function () {
        this.legendItemTextBox = {};
    };
    c3_chart_internal_fn.updateLegend = function (targetIds, options, transitions) {
        var $$ = this,
            config = $$.config;
        var xForLegend, xForLegendText, xForLegendRect, yForLegend, yForLegendText, yForLegendRect, x1ForLegendTile, x2ForLegendTile, yForLegendTile;
        var paddingTop = 4,
            paddingRight = 10,
            maxWidth = 0,
            maxHeight = 0,
            posMin = 10,
            tileWidth = config.legend_item_tile_width + 5;
        var l,
            totalLength = 0,
            offsets = {},
            widths = {},
            heights = {},
            margins = [0],
            steps = {},
            step = 0;
        var withTransition, withTransitionForTransform;
        var texts, rects, tiles, background;

        // Skip elements when their name is set to null
        targetIds = targetIds.filter(function (id) {
            return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
        });

        options = options || {};
        withTransition = getOption(options, "withTransition", true);
        withTransitionForTransform = getOption(options, "withTransitionForTransform", true);

        function getTextBox(textElement, id) {
            if (!$$.legendItemTextBox[id]) {
                $$.legendItemTextBox[id] = $$.getTextRect(textElement.textContent, CLASS.legendItem, textElement);
            }
            return $$.legendItemTextBox[id];
        }

        function updatePositions(textElement, id, index) {
            var reset = index === 0,
                isLast = index === targetIds.length - 1,
                box = getTextBox(textElement, id),
                itemWidth = box.width + tileWidth + (isLast && !($$.isLegendRight || $$.isLegendInset) ? 0 : paddingRight) + config.legend_padding,
                itemHeight = box.height + paddingTop,
                itemLength = $$.isLegendRight || $$.isLegendInset ? itemHeight : itemWidth,
                areaLength = $$.isLegendRight || $$.isLegendInset ? $$.getLegendHeight() : $$.getLegendWidth(),
                margin,
                maxLength;

            // MEMO: care about condifion of step, totalLength
            function updateValues(id, withoutStep) {
                if (!withoutStep) {
                    margin = (areaLength - totalLength - itemLength) / 2;
                    if (margin < posMin) {
                        margin = (areaLength - itemLength) / 2;
                        totalLength = 0;
                        step++;
                    }
                }
                steps[id] = step;
                margins[step] = $$.isLegendInset ? 10 : margin;
                offsets[id] = totalLength;
                totalLength += itemLength;
            }

            if (reset) {
                totalLength = 0;
                step = 0;
                maxWidth = 0;
                maxHeight = 0;
            }

            if (config.legend_show && !$$.isLegendToShow(id)) {
                widths[id] = heights[id] = steps[id] = offsets[id] = 0;
                return;
            }

            widths[id] = itemWidth;
            heights[id] = itemHeight;

            if (!maxWidth || itemWidth >= maxWidth) {
                maxWidth = itemWidth;
            }
            if (!maxHeight || itemHeight >= maxHeight) {
                maxHeight = itemHeight;
            }
            maxLength = $$.isLegendRight || $$.isLegendInset ? maxHeight : maxWidth;

            if (config.legend_equally) {
                Object.keys(widths).forEach(function (id) {
                    widths[id] = maxWidth;
                });
                Object.keys(heights).forEach(function (id) {
                    heights[id] = maxHeight;
                });
                margin = (areaLength - maxLength * targetIds.length) / 2;
                if (margin < posMin) {
                    totalLength = 0;
                    step = 0;
                    targetIds.forEach(function (id) {
                        updateValues(id);
                    });
                } else {
                    updateValues(id, true);
                }
            } else {
                updateValues(id);
            }
        }

        if ($$.isLegendInset) {
            step = config.legend_inset_step ? config.legend_inset_step : targetIds.length;
            $$.updateLegendStep(step);
        }

        if ($$.isLegendRight) {
            xForLegend = function xForLegend(id) {
                return maxWidth * steps[id];
            };
            yForLegend = function yForLegend(id) {
                return margins[steps[id]] + offsets[id];
            };
        } else if ($$.isLegendInset) {
            xForLegend = function xForLegend(id) {
                return maxWidth * steps[id] + 10;
            };
            yForLegend = function yForLegend(id) {
                return margins[steps[id]] + offsets[id];
            };
        } else {
            xForLegend = function xForLegend(id) {
                return margins[steps[id]] + offsets[id];
            };
            yForLegend = function yForLegend(id) {
                return maxHeight * steps[id];
            };
        }
        xForLegendText = function xForLegendText(id, i) {
            return xForLegend(id, i) + 4 + config.legend_item_tile_width;
        };
        yForLegendText = function yForLegendText(id, i) {
            return yForLegend(id, i) + 9;
        };
        xForLegendRect = function xForLegendRect(id, i) {
            return xForLegend(id, i);
        };
        yForLegendRect = function yForLegendRect(id, i) {
            return yForLegend(id, i) - 5;
        };
        x1ForLegendTile = function x1ForLegendTile(id, i) {
            return xForLegend(id, i) - 2;
        };
        x2ForLegendTile = function x2ForLegendTile(id, i) {
            return xForLegend(id, i) - 2 + config.legend_item_tile_width;
        };
        yForLegendTile = function yForLegendTile(id, i) {
            return yForLegend(id, i) + 4;
        };

        // Define g for legend area
        l = $$.legend.selectAll('.' + CLASS.legendItem).data(targetIds).enter().append('g').attr('class', function (id) {
            return $$.generateClass(CLASS.legendItem, id);
        }).style('visibility', function (id) {
            return $$.isLegendToShow(id) ? 'visible' : 'hidden';
        }).style('cursor', 'pointer').on('click', function (id) {
            if (config.legend_item_onclick) {
                config.legend_item_onclick.call($$, id);
            } else {
                if ($$.d3.event.altKey) {
                    $$.api.hide();
                    $$.api.show(id);
                } else {
                    $$.api.toggle(id);
                    $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert();
                }
            }
        }).on('mouseover', function (id) {
            if (config.legend_item_onmouseover) {
                config.legend_item_onmouseover.call($$, id);
            } else {
                $$.d3.select(this).classed(CLASS.legendItemFocused, true);
                if (!$$.transiting && $$.isTargetToShow(id)) {
                    $$.api.focus(id);
                }
            }
        }).on('mouseout', function (id) {
            if (config.legend_item_onmouseout) {
                config.legend_item_onmouseout.call($$, id);
            } else {
                $$.d3.select(this).classed(CLASS.legendItemFocused, false);
                $$.api.revert();
            }
        });
        l.append('text').text(function (id) {
            return isDefined(config.data_names[id]) ? config.data_names[id] : id;
        }).each(function (id, i) {
            updatePositions(this, id, i);
        }).style("pointer-events", "none").attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendText : -200).attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendText);
        l.append('rect').attr("class", CLASS.legendItemEvent).style('fill-opacity', 0).attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendRect : -200).attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendRect);
        l.append('line').attr('class', CLASS.legendItemTile).style('stroke', $$.color).style("pointer-events", "none").attr('x1', $$.isLegendRight || $$.isLegendInset ? x1ForLegendTile : -200).attr('y1', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile).attr('x2', $$.isLegendRight || $$.isLegendInset ? x2ForLegendTile : -200).attr('y2', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile).attr('stroke-width', config.legend_item_tile_height);

        // Set background for inset legend
        background = $$.legend.select('.' + CLASS.legendBackground + ' rect');
        if ($$.isLegendInset && maxWidth > 0 && background.size() === 0) {
            background = $$.legend.insert('g', '.' + CLASS.legendItem).attr("class", CLASS.legendBackground).append('rect');
        }

        texts = $$.legend.selectAll('text').data(targetIds).text(function (id) {
            return isDefined(config.data_names[id]) ? config.data_names[id] : id;
        }) // MEMO: needed for update
        .each(function (id, i) {
            updatePositions(this, id, i);
        });
        (withTransition ? texts.transition() : texts).attr('x', xForLegendText).attr('y', yForLegendText);

        rects = $$.legend.selectAll('rect.' + CLASS.legendItemEvent).data(targetIds);
        (withTransition ? rects.transition() : rects).attr('width', function (id) {
            return widths[id];
        }).attr('height', function (id) {
            return heights[id];
        }).attr('x', xForLegendRect).attr('y', yForLegendRect);

        tiles = $$.legend.selectAll('line.' + CLASS.legendItemTile).data(targetIds);
        (withTransition ? tiles.transition() : tiles).style('stroke', $$.levelColor ? function (id) {
            return $$.levelColor($$.cache[id].values[0].value);
        } : $$.color).attr('x1', x1ForLegendTile).attr('y1', yForLegendTile).attr('x2', x2ForLegendTile).attr('y2', yForLegendTile);

        if (background) {
            (withTransition ? background.transition() : background).attr('height', $$.getLegendHeight() - 12).attr('width', maxWidth * (step + 1) + 10);
        }

        // toggle legend state
        $$.legend.selectAll('.' + CLASS.legendItem).classed(CLASS.legendItemHidden, function (id) {
            return !$$.isTargetToShow(id);
        });

        // Update all to reflect change of legend
        $$.updateLegendItemWidth(maxWidth);
        $$.updateLegendItemHeight(maxHeight);
        $$.updateLegendStep(step);
        // Update size and scale
        $$.updateSizes();
        $$.updateScales();
        $$.updateSvgSize();
        // Update g positions
        $$.transformAll(withTransitionForTransform, transitions);
        $$.legendHasRendered = true;
    };

    c3_chart_internal_fn.initRegion = function () {
        var $$ = this;
        $$.region = $$.main.append('g').attr("clip-path", $$.clipPath).attr("class", CLASS.regions);
    };
    c3_chart_internal_fn.updateRegion = function (duration) {
        var $$ = this,
            config = $$.config;

        // hide if arc type
        $$.region.style('visibility', $$.hasArcType() ? 'hidden' : 'visible');

        $$.mainRegion = $$.main.select('.' + CLASS.regions).selectAll('.' + CLASS.region).data(config.regions);
        $$.mainRegion.enter().append('g').append('rect').style("fill-opacity", 0);
        $$.mainRegion.attr('class', $$.classRegion.bind($$));
        $$.mainRegion.exit().transition().duration(duration).style("opacity", 0).remove();
    };
    c3_chart_internal_fn.redrawRegion = function (withTransition) {
        var $$ = this,
            regions = $$.mainRegion.selectAll('rect').each(function () {
            // data is binded to g and it's not transferred to rect (child node) automatically,
            // then data of each rect has to be updated manually.
            // TODO: there should be more efficient way to solve this?
            var parentData = $$.d3.select(this.parentNode).datum();
            $$.d3.select(this).datum(parentData);
        }),
            x = $$.regionX.bind($$),
            y = $$.regionY.bind($$),
            w = $$.regionWidth.bind($$),
            h = $$.regionHeight.bind($$);
        return [(withTransition ? regions.transition() : regions).attr("x", x).attr("y", y).attr("width", w).attr("height", h).style("fill-opacity", function (d) {
            return isValue(d.opacity) ? d.opacity : 0.1;
        })];
    };
    c3_chart_internal_fn.regionX = function (d) {
        var $$ = this,
            config = $$.config,
            xPos,
            yScale = d.axis === 'y' ? $$.y : $$.y2;
        if (d.axis === 'y' || d.axis === 'y2') {
            xPos = config.axis_rotated ? 'start' in d ? yScale(d.start) : 0 : 0;
        } else {
            xPos = config.axis_rotated ? 0 : 'start' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0;
        }
        return xPos;
    };
    c3_chart_internal_fn.regionY = function (d) {
        var $$ = this,
            config = $$.config,
            yPos,
            yScale = d.axis === 'y' ? $$.y : $$.y2;
        if (d.axis === 'y' || d.axis === 'y2') {
            yPos = config.axis_rotated ? 0 : 'end' in d ? yScale(d.end) : 0;
        } else {
            yPos = config.axis_rotated ? 'start' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0 : 0;
        }
        return yPos;
    };
    c3_chart_internal_fn.regionWidth = function (d) {
        var $$ = this,
            config = $$.config,
            start = $$.regionX(d),
            end,
            yScale = d.axis === 'y' ? $$.y : $$.y2;
        if (d.axis === 'y' || d.axis === 'y2') {
            end = config.axis_rotated ? 'end' in d ? yScale(d.end) : $$.width : $$.width;
        } else {
            end = config.axis_rotated ? $$.width : 'end' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end) : $$.width;
        }
        return end < start ? 0 : end - start;
    };
    c3_chart_internal_fn.regionHeight = function (d) {
        var $$ = this,
            config = $$.config,
            start = this.regionY(d),
            end,
            yScale = d.axis === 'y' ? $$.y : $$.y2;
        if (d.axis === 'y' || d.axis === 'y2') {
            end = config.axis_rotated ? $$.height : 'start' in d ? yScale(d.start) : $$.height;
        } else {
            end = config.axis_rotated ? 'end' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end) : $$.height : $$.height;
        }
        return end < start ? 0 : end - start;
    };
    c3_chart_internal_fn.isRegionOnX = function (d) {
        return !d.axis || d.axis === 'x';
    };

    c3_chart_internal_fn.getScale = function (min, max, forTimeseries) {
        return (forTimeseries ? this.d3.time.scale() : this.d3.scale.linear()).range([min, max]);
    };
    c3_chart_internal_fn.getX = function (min, max, domain, offset) {
        var $$ = this,
            scale = $$.getScale(min, max, $$.isTimeSeries()),
            _scale = domain ? scale.domain(domain) : scale,
            key;
        // Define customized scale if categorized axis
        if ($$.isCategorized()) {
            offset = offset || function () {
                return 0;
            };
            scale = function scale(d, raw) {
                var v = _scale(d) + offset(d);
                return raw ? v : Math.ceil(v);
            };
        } else {
            scale = function scale(d, raw) {
                var v = _scale(d);
                return raw ? v : Math.ceil(v);
            };
        }
        // define functions
        for (key in _scale) {
            scale[key] = _scale[key];
        }
        scale.orgDomain = function () {
            return _scale.domain();
        };
        // define custom domain() for categorized axis
        if ($$.isCategorized()) {
            scale.domain = function (domain) {
                if (!arguments.length) {
                    domain = this.orgDomain();
                    return [domain[0], domain[1] + 1];
                }
                _scale.domain(domain);
                return scale;
            };
        }
        return scale;
    };
    c3_chart_internal_fn.getY = function (min, max, domain) {
        var scale = this.getScale(min, max, this.isTimeSeriesY());
        if (domain) {
            scale.domain(domain);
        }
        return scale;
    };
    c3_chart_internal_fn.getYScale = function (id) {
        return this.axis.getId(id) === 'y2' ? this.y2 : this.y;
    };
    c3_chart_internal_fn.getSubYScale = function (id) {
        return this.axis.getId(id) === 'y2' ? this.subY2 : this.subY;
    };
    c3_chart_internal_fn.updateScales = function () {
        var $$ = this,
            config = $$.config,
            forInit = !$$.x;
        // update edges
        $$.xMin = config.axis_rotated ? 1 : 0;
        $$.xMax = config.axis_rotated ? $$.height : $$.width;
        $$.yMin = config.axis_rotated ? 0 : $$.height;
        $$.yMax = config.axis_rotated ? $$.width : 1;
        $$.subXMin = $$.xMin;
        $$.subXMax = $$.xMax;
        $$.subYMin = config.axis_rotated ? 0 : $$.height2;
        $$.subYMax = config.axis_rotated ? $$.width2 : 1;
        // update scales
        $$.x = $$.getX($$.xMin, $$.xMax, forInit ? undefined : $$.x.orgDomain(), function () {
            return $$.xAxis.tickOffset();
        });
        $$.y = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y_default : $$.y.domain());
        $$.y2 = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y2_default : $$.y2.domain());
        $$.subX = $$.getX($$.xMin, $$.xMax, $$.orgXDomain, function (d) {
            return d % 1 ? 0 : $$.subXAxis.tickOffset();
        });
        $$.subY = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y_default : $$.subY.domain());
        $$.subY2 = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y2_default : $$.subY2.domain());
        // update axes
        $$.xAxisTickFormat = $$.axis.getXAxisTickFormat();
        $$.xAxisTickValues = $$.axis.getXAxisTickValues();
        $$.yAxisTickValues = $$.axis.getYAxisTickValues();
        $$.y2AxisTickValues = $$.axis.getY2AxisTickValues();

        $$.xAxis = $$.axis.getXAxis($$.x, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer);
        $$.subXAxis = $$.axis.getXAxis($$.subX, $$.subXOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer);
        $$.yAxis = $$.axis.getYAxis($$.y, $$.yOrient, config.axis_y_tick_format, $$.yAxisTickValues, config.axis_y_tick_outer);
        $$.y2Axis = $$.axis.getYAxis($$.y2, $$.y2Orient, config.axis_y2_tick_format, $$.y2AxisTickValues, config.axis_y2_tick_outer);

        // Set initialized scales to brush and zoom
        if (!forInit) {
            if ($$.brush) {
                $$.brush.scale($$.subX);
            }
            if (config.zoom_enabled) {
                $$.zoom.scale($$.x);
            }
        }
        // update for arc
        if ($$.updateArc) {
            $$.updateArc();
        }
    };

    c3_chart_internal_fn.selectPoint = function (target, d, i) {
        var $$ = this,
            config = $$.config,
            cx = (config.axis_rotated ? $$.circleY : $$.circleX).bind($$),
            cy = (config.axis_rotated ? $$.circleX : $$.circleY).bind($$),
            r = $$.pointSelectR.bind($$);
        config.data_onselected.call($$.api, d, target.node());
        // add selected-circle on low layer g
        $$.main.select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll('.' + CLASS.selectedCircle + '-' + i).data([d]).enter().append('circle').attr("class", function () {
            return $$.generateClass(CLASS.selectedCircle, i);
        }).attr("cx", cx).attr("cy", cy).attr("stroke", function () {
            return $$.color(d);
        }).attr("r", function (d) {
            return $$.pointSelectR(d) * 1.4;
        }).transition().duration(100).attr("r", r);
    };
    c3_chart_internal_fn.unselectPoint = function (target, d, i) {
        var $$ = this;
        $$.config.data_onunselected.call($$.api, d, target.node());
        // remove selected-circle from low layer g
        $$.main.select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll('.' + CLASS.selectedCircle + '-' + i).transition().duration(100).attr('r', 0).remove();
    };
    c3_chart_internal_fn.togglePoint = function (selected, target, d, i) {
        selected ? this.selectPoint(target, d, i) : this.unselectPoint(target, d, i);
    };
    c3_chart_internal_fn.selectPath = function (target, d) {
        var $$ = this;
        $$.config.data_onselected.call($$, d, target.node());
        if ($$.config.interaction_brighten) {
            target.transition().duration(100).style("fill", function () {
                return $$.d3.rgb($$.color(d)).brighter(0.75);
            });
        }
    };
    c3_chart_internal_fn.unselectPath = function (target, d) {
        var $$ = this;
        $$.config.data_onunselected.call($$, d, target.node());
        if ($$.config.interaction_brighten) {
            target.transition().duration(100).style("fill", function () {
                return $$.color(d);
            });
        }
    };
    c3_chart_internal_fn.togglePath = function (selected, target, d, i) {
        selected ? this.selectPath(target, d, i) : this.unselectPath(target, d, i);
    };
    c3_chart_internal_fn.getToggle = function (that, d) {
        var $$ = this,
            toggle;
        if (that.nodeName === 'circle') {
            if ($$.isStepType(d)) {
                // circle is hidden in step chart, so treat as within the click area
                toggle = function toggle() {}; // TODO: how to select step chart?
            } else {
                toggle = $$.togglePoint;
            }
        } else if (that.nodeName === 'path') {
            toggle = $$.togglePath;
        }
        return toggle;
    };
    c3_chart_internal_fn.toggleShape = function (that, d, i) {
        var $$ = this,
            d3 = $$.d3,
            config = $$.config,
            shape = d3.select(that),
            isSelected = shape.classed(CLASS.SELECTED),
            toggle = $$.getToggle(that, d).bind($$);

        if (config.data_selection_enabled && config.data_selection_isselectable(d)) {
            if (!config.data_selection_multiple) {
                $$.main.selectAll('.' + CLASS.shapes + (config.data_selection_grouped ? $$.getTargetSelectorSuffix(d.id) : "")).selectAll('.' + CLASS.shape).each(function (d, i) {
                    var shape = d3.select(this);
                    if (shape.classed(CLASS.SELECTED)) {
                        toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
                    }
                });
            }
            shape.classed(CLASS.SELECTED, !isSelected);
            toggle(!isSelected, shape, d, i);
        }
    };

    c3_chart_internal_fn.initBar = function () {
        var $$ = this;
        $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartBars);
    };
    c3_chart_internal_fn.updateTargetsForBar = function (targets) {
        var $$ = this,
            config = $$.config,
            mainBarUpdate,
            mainBarEnter,
            classChartBar = $$.classChartBar.bind($$),
            classBars = $$.classBars.bind($$),
            classFocus = $$.classFocus.bind($$);
        mainBarUpdate = $$.main.select('.' + CLASS.chartBars).selectAll('.' + CLASS.chartBar).data(targets).attr('class', function (d) {
            return classChartBar(d) + classFocus(d);
        });
        mainBarEnter = mainBarUpdate.enter().append('g').attr('class', classChartBar).style("pointer-events", "none");
        // Bars for each data
        mainBarEnter.append('g').attr("class", classBars).style("cursor", function (d) {
            return config.data_selection_isselectable(d) ? "pointer" : null;
        });
    };
    c3_chart_internal_fn.updateBar = function (durationForExit) {
        var $$ = this,
            barData = $$.barData.bind($$),
            classBar = $$.classBar.bind($$),
            initialOpacity = $$.initialOpacity.bind($$),
            color = function color(d) {
            return $$.color(d.id);
        };
        $$.mainBar = $$.main.selectAll('.' + CLASS.bars).selectAll('.' + CLASS.bar).data(barData);
        $$.mainBar.enter().append('path').attr("class", classBar).style("stroke", color).style("fill", color);
        $$.mainBar.style("opacity", initialOpacity);
        $$.mainBar.exit().transition().duration(durationForExit).remove();
    };
    c3_chart_internal_fn.redrawBar = function (drawBar, withTransition) {
        return [(withTransition ? this.mainBar.transition(Math.random().toString()) : this.mainBar).attr('d', drawBar).style("stroke", this.color).style("fill", this.color).style("opacity", 1)];
    };
    c3_chart_internal_fn.getBarW = function (axis, barTargetsNum) {
        var $$ = this,
            config = $$.config,
            w = typeof config.bar_width === 'number' ? config.bar_width : barTargetsNum ? axis.tickInterval() * config.bar_width_ratio / barTargetsNum : 0;
        return config.bar_width_max && w > config.bar_width_max ? config.bar_width_max : w;
    };
    c3_chart_internal_fn.getBars = function (i, id) {
        var $$ = this;
        return (id ? $$.main.selectAll('.' + CLASS.bars + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll('.' + CLASS.bar + (isValue(i) ? '-' + i : ''));
    };
    c3_chart_internal_fn.expandBars = function (i, id, reset) {
        var $$ = this;
        if (reset) {
            $$.unexpandBars();
        }
        $$.getBars(i, id).classed(CLASS.EXPANDED, true);
    };
    c3_chart_internal_fn.unexpandBars = function (i) {
        var $$ = this;
        $$.getBars(i).classed(CLASS.EXPANDED, false);
    };
    c3_chart_internal_fn.generateDrawBar = function (barIndices, isSub) {
        var $$ = this,
            config = $$.config,
            getPoints = $$.generateGetBarPoints(barIndices, isSub);
        return function (d, i) {
            // 4 points that make a bar
            var points = getPoints(d, i);

            // switch points if axis is rotated, not applicable for sub chart
            var indexX = config.axis_rotated ? 1 : 0;
            var indexY = config.axis_rotated ? 0 : 1;

            var path = 'M ' + points[0][indexX] + ',' + points[0][indexY] + ' ' + 'L' + points[1][indexX] + ',' + points[1][indexY] + ' ' + 'L' + points[2][indexX] + ',' + points[2][indexY] + ' ' + 'L' + points[3][indexX] + ',' + points[3][indexY] + ' ' + 'z';

            return path;
        };
    };
    c3_chart_internal_fn.generateGetBarPoints = function (barIndices, isSub) {
        var $$ = this,
            axis = isSub ? $$.subXAxis : $$.xAxis,
            barTargetsNum = barIndices.__max__ + 1,
            barW = $$.getBarW(axis, barTargetsNum),
            barX = $$.getShapeX(barW, barTargetsNum, barIndices, !!isSub),
            barY = $$.getShapeY(!!isSub),
            barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
            barSpaceOffset = barW * ($$.config.bar_space / 2),
            yScale = isSub ? $$.getSubYScale : $$.getYScale;
        return function (d, i) {
            var y0 = yScale.call($$, d.id)(0),
                offset = barOffset(d, i) || y0,
                // offset is for stacked bar chart
            posX = barX(d),
                posY = barY(d);
            // fix posY not to overflow opposite quadrant
            if ($$.config.axis_rotated) {
                if (0 < d.value && posY < y0 || d.value < 0 && y0 < posY) {
                    posY = y0;
                }
            }
            // 4 points that make a bar
            return [[posX + barSpaceOffset, offset], [posX + barSpaceOffset, posY - (y0 - offset)], [posX + barW - barSpaceOffset, posY - (y0 - offset)], [posX + barW - barSpaceOffset, offset]];
        };
    };
    c3_chart_internal_fn.isWithinBar = function (that) {
        var mouse = this.d3.mouse(that),
            box = that.getBoundingClientRect(),
            seg0 = that.pathSegList.getItem(0),
            seg1 = that.pathSegList.getItem(1),
            x = Math.min(seg0.x, seg1.x),
            y = Math.min(seg0.y, seg1.y),
            w = box.width,
            h = box.height,
            offset = 2,
            sx = x - offset,
            ex = x + w + offset,
            sy = y + h + offset,
            ey = y - offset;
        return sx < mouse[0] && mouse[0] < ex && ey < mouse[1] && mouse[1] < sy;
    };

    c3_chart_internal_fn.getShapeIndices = function (typeFilter) {
        var $$ = this,
            config = $$.config,
            indices = {},
            i = 0,
            j,
            k;
        $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
            for (j = 0; j < config.data_groups.length; j++) {
                if (config.data_groups[j].indexOf(d.id) < 0) {
                    continue;
                }
                for (k = 0; k < config.data_groups[j].length; k++) {
                    if (config.data_groups[j][k] in indices) {
                        indices[d.id] = indices[config.data_groups[j][k]];
                        break;
                    }
                }
            }
            if (isUndefined(indices[d.id])) {
                indices[d.id] = i++;
            }
        });
        indices.__max__ = i - 1;
        return indices;
    };
    c3_chart_internal_fn.getShapeX = function (offset, targetsNum, indices, isSub) {
        var $$ = this,
            scale = isSub ? $$.subX : $$.x;
        return function (d) {
            var index = d.id in indices ? indices[d.id] : 0;
            return d.x || d.x === 0 ? scale(d.x) - offset * (targetsNum / 2 - index) : 0;
        };
    };
    c3_chart_internal_fn.getShapeY = function (isSub) {
        var $$ = this;
        return function (d) {
            var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id);
            return scale(d.value);
        };
    };
    c3_chart_internal_fn.getShapeOffset = function (typeFilter, indices, isSub) {
        var $$ = this,
            targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
            targetIds = targets.map(function (t) {
            return t.id;
        });
        return function (d, i) {
            var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),
                y0 = scale(0),
                offset = y0;
            targets.forEach(function (t) {
                var values = $$.isStepType(d) ? $$.convertValuesToStep(t.values) : t.values;
                if (t.id === d.id || indices[t.id] !== indices[d.id]) {
                    return;
                }
                if (targetIds.indexOf(t.id) < targetIds.indexOf(d.id)) {
                    // check if the x values line up
                    if (typeof values[i] === 'undefined' || +values[i].x !== +d.x) {
                        // "+" for timeseries
                        // if not, try to find the value that does line up
                        i = -1;
                        values.forEach(function (v, j) {
                            if (v.x === d.x) {
                                i = j;
                            }
                        });
                    }
                    if (i in values && values[i].value * d.value >= 0) {
                        offset += scale(values[i].value) - y0;
                    }
                }
            });
            return offset;
        };
    };
    c3_chart_internal_fn.isWithinShape = function (that, d) {
        var $$ = this,
            shape = $$.d3.select(that),
            isWithin;
        if (!$$.isTargetToShow(d.id)) {
            isWithin = false;
        } else if (that.nodeName === 'circle') {
            isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value)) : $$.isWithinCircle(that, $$.pointSelectR(d) * 1.5);
        } else if (that.nodeName === 'path') {
            isWithin = shape.classed(CLASS.bar) ? $$.isWithinBar(that) : true;
        }
        return isWithin;
    };

    c3_chart_internal_fn.getInterpolate = function (d) {
        var $$ = this,
            interpolation = $$.isInterpolationType($$.config.spline_interpolation_type) ? $$.config.spline_interpolation_type : 'cardinal';
        return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? $$.config.line_step_type : "linear";
    };

    c3_chart_internal_fn.initLine = function () {
        var $$ = this;
        $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartLines);
    };
    c3_chart_internal_fn.updateTargetsForLine = function (targets) {
        var $$ = this,
            config = $$.config,
            mainLineUpdate,
            mainLineEnter,
            classChartLine = $$.classChartLine.bind($$),
            classLines = $$.classLines.bind($$),
            classAreas = $$.classAreas.bind($$),
            classCircles = $$.classCircles.bind($$),
            classFocus = $$.classFocus.bind($$);
        mainLineUpdate = $$.main.select('.' + CLASS.chartLines).selectAll('.' + CLASS.chartLine).data(targets).attr('class', function (d) {
            return classChartLine(d) + classFocus(d);
        });
        mainLineEnter = mainLineUpdate.enter().append('g').attr('class', classChartLine).style('opacity', 0).style("pointer-events", "none");
        // Lines for each data
        mainLineEnter.append('g').attr("class", classLines);
        // Areas
        mainLineEnter.append('g').attr('class', classAreas);
        // Circles for each data point on lines
        mainLineEnter.append('g').attr("class", function (d) {
            return $$.generateClass(CLASS.selectedCircles, d.id);
        });
        mainLineEnter.append('g').attr("class", classCircles).style("cursor", function (d) {
            return config.data_selection_isselectable(d) ? "pointer" : null;
        });
        // Update date for selected circles
        targets.forEach(function (t) {
            $$.main.selectAll('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(t.id)).selectAll('.' + CLASS.selectedCircle).each(function (d) {
                d.value = t.values[d.index].value;
            });
        });
        // MEMO: can not keep same color...
        //mainLineUpdate.exit().remove();
    };
    c3_chart_internal_fn.updateLine = function (durationForExit) {
        var $$ = this;
        $$.mainLine = $$.main.selectAll('.' + CLASS.lines).selectAll('.' + CLASS.line).data($$.lineData.bind($$));
        $$.mainLine.enter().append('path').attr('class', $$.classLine.bind($$)).style("stroke", $$.color);
        $$.mainLine.style("opacity", $$.initialOpacity.bind($$)).style('shape-rendering', function (d) {
            return $$.isStepType(d) ? 'crispEdges' : '';
        }).attr('transform', null);
        $$.mainLine.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawLine = function (drawLine, withTransition) {
        return [(withTransition ? this.mainLine.transition(Math.random().toString()) : this.mainLine).attr("d", drawLine).style("stroke", this.color).style("opacity", 1)];
    };
    c3_chart_internal_fn.generateDrawLine = function (lineIndices, isSub) {
        var $$ = this,
            config = $$.config,
            line = $$.d3.svg.line(),
            getPoints = $$.generateGetLinePoints(lineIndices, isSub),
            yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
            xValue = function xValue(d) {
            return (isSub ? $$.subxx : $$.xx).call($$, d);
        },
            yValue = function yValue(d, i) {
            return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)(d.value);
        };

        line = config.axis_rotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue);
        if (!config.line_connectNull) {
            line = line.defined(function (d) {
                return d.value != null;
            });
        }
        return function (d) {
            var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,
                x = isSub ? $$.x : $$.subX,
                y = yScaleGetter.call($$, d.id),
                x0 = 0,
                y0 = 0,
                path;
            if ($$.isLineType(d)) {
                if (config.data_regions[d.id]) {
                    path = $$.lineWithRegions(values, x, y, config.data_regions[d.id]);
                } else {
                    if ($$.isStepType(d)) {
                        values = $$.convertValuesToStep(values);
                    }
                    path = line.interpolate($$.getInterpolate(d))(values);
                }
            } else {
                if (values[0]) {
                    x0 = x(values[0].x);
                    y0 = y(values[0].value);
                }
                path = config.axis_rotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;
            }
            return path ? path : "M 0 0";
        };
    };
    c3_chart_internal_fn.generateGetLinePoints = function (lineIndices, isSub) {
        // partial duplication of generateGetBarPoints
        var $$ = this,
            config = $$.config,
            lineTargetsNum = lineIndices.__max__ + 1,
            x = $$.getShapeX(0, lineTargetsNum, lineIndices, !!isSub),
            y = $$.getShapeY(!!isSub),
            lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, !!isSub),
            yScale = isSub ? $$.getSubYScale : $$.getYScale;
        return function (d, i) {
            var y0 = yScale.call($$, d.id)(0),
                offset = lineOffset(d, i) || y0,
                // offset is for stacked area chart
            posX = x(d),
                posY = y(d);
            // fix posY not to overflow opposite quadrant
            if (config.axis_rotated) {
                if (0 < d.value && posY < y0 || d.value < 0 && y0 < posY) {
                    posY = y0;
                }
            }
            // 1 point that marks the line position
            return [[posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
            [posX, posY - (y0 - offset)], // needed for compatibility
            [posX, posY - (y0 - offset)] // needed for compatibility
            ];
        };
    };

    c3_chart_internal_fn.lineWithRegions = function (d, x, y, _regions) {
        var $$ = this,
            config = $$.config,
            prev = -1,
            i,
            j,
            s = "M",
            sWithRegion,
            xp,
            yp,
            dx,
            dy,
            dd,
            diff,
            diffx2,
            xOffset = $$.isCategorized() ? 0.5 : 0,
            xValue,
            yValue,
            regions = [];

        function isWithinRegions(x, regions) {
            var i;
            for (i = 0; i < regions.length; i++) {
                if (regions[i].start < x && x <= regions[i].end) {
                    return true;
                }
            }
            return false;
        }

        // Check start/end of regions
        if (isDefined(_regions)) {
            for (i = 0; i < _regions.length; i++) {
                regions[i] = {};
                if (isUndefined(_regions[i].start)) {
                    regions[i].start = d[0].x;
                } else {
                    regions[i].start = $$.isTimeSeries() ? $$.parseDate(_regions[i].start) : _regions[i].start;
                }
                if (isUndefined(_regions[i].end)) {
                    regions[i].end = d[d.length - 1].x;
                } else {
                    regions[i].end = $$.isTimeSeries() ? $$.parseDate(_regions[i].end) : _regions[i].end;
                }
            }
        }

        // Set scales
        xValue = config.axis_rotated ? function (d) {
            return y(d.value);
        } : function (d) {
            return x(d.x);
        };
        yValue = config.axis_rotated ? function (d) {
            return x(d.x);
        } : function (d) {
            return y(d.value);
        };

        // Define svg generator function for region
        function generateM(points) {
            return 'M' + points[0][0] + ' ' + points[0][1] + ' ' + points[1][0] + ' ' + points[1][1];
        }
        if ($$.isTimeSeries()) {
            sWithRegion = function sWithRegion(d0, d1, j, diff) {
                var x0 = d0.x.getTime(),
                    x_diff = d1.x - d0.x,
                    xv0 = new Date(x0 + x_diff * j),
                    xv1 = new Date(x0 + x_diff * (j + diff)),
                    points;
                if (config.axis_rotated) {
                    points = [[y(yp(j)), x(xv0)], [y(yp(j + diff)), x(xv1)]];
                } else {
                    points = [[x(xv0), y(yp(j))], [x(xv1), y(yp(j + diff))]];
                }
                return generateM(points);
            };
        } else {
            sWithRegion = function sWithRegion(d0, d1, j, diff) {
                var points;
                if (config.axis_rotated) {
                    points = [[y(yp(j), true), x(xp(j))], [y(yp(j + diff), true), x(xp(j + diff))]];
                } else {
                    points = [[x(xp(j), true), y(yp(j))], [x(xp(j + diff), true), y(yp(j + diff))]];
                }
                return generateM(points);
            };
        }

        // Generate
        for (i = 0; i < d.length; i++) {

            // Draw as normal
            if (isUndefined(regions) || !isWithinRegions(d[i].x, regions)) {
                s += " " + xValue(d[i]) + " " + yValue(d[i]);
            }
            // Draw with region // TODO: Fix for horizotal charts
            else {
                    xp = $$.getScale(d[i - 1].x + xOffset, d[i].x + xOffset, $$.isTimeSeries());
                    yp = $$.getScale(d[i - 1].value, d[i].value);

                    dx = x(d[i].x) - x(d[i - 1].x);
                    dy = y(d[i].value) - y(d[i - 1].value);
                    dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
                    diff = 2 / dd;
                    diffx2 = diff * 2;

                    for (j = diff; j <= 1; j += diffx2) {
                        s += sWithRegion(d[i - 1], d[i], j, diff);
                    }
                }
            prev = d[i].x;
        }

        return s;
    };

    c3_chart_internal_fn.updateArea = function (durationForExit) {
        var $$ = this,
            d3 = $$.d3;
        $$.mainArea = $$.main.selectAll('.' + CLASS.areas).selectAll('.' + CLASS.area).data($$.lineData.bind($$));
        $$.mainArea.enter().append('path').attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
            $$.orgAreaOpacity = +d3.select(this).style('opacity');return 0;
        });
        $$.mainArea.style("opacity", $$.orgAreaOpacity);
        $$.mainArea.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawArea = function (drawArea, withTransition) {
        return [(withTransition ? this.mainArea.transition(Math.random().toString()) : this.mainArea).attr("d", drawArea).style("fill", this.color).style("opacity", this.orgAreaOpacity)];
    };
    c3_chart_internal_fn.generateDrawArea = function (areaIndices, isSub) {
        var $$ = this,
            config = $$.config,
            area = $$.d3.svg.area(),
            getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
            yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
            xValue = function xValue(d) {
            return (isSub ? $$.subxx : $$.xx).call($$, d);
        },
            value0 = function value0(d, i) {
            return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.getAreaBaseValue(d.id));
        },
            value1 = function value1(d, i) {
            return config.data_groups.length > 0 ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)(d.value);
        };

        area = config.axis_rotated ? area.x0(value0).x1(value1).y(xValue) : area.x(xValue).y0(config.area_above ? 0 : value0).y1(value1);
        if (!config.line_connectNull) {
            area = area.defined(function (d) {
                return d.value !== null;
            });
        }

        return function (d) {
            var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,
                x0 = 0,
                y0 = 0,
                path;
            if ($$.isAreaType(d)) {
                if ($$.isStepType(d)) {
                    values = $$.convertValuesToStep(values);
                }
                path = area.interpolate($$.getInterpolate(d))(values);
            } else {
                if (values[0]) {
                    x0 = $$.x(values[0].x);
                    y0 = $$.getYScale(d.id)(values[0].value);
                }
                path = config.axis_rotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;
            }
            return path ? path : "M 0 0";
        };
    };
    c3_chart_internal_fn.getAreaBaseValue = function () {
        return 0;
    };
    c3_chart_internal_fn.generateGetAreaPoints = function (areaIndices, isSub) {
        // partial duplication of generateGetBarPoints
        var $$ = this,
            config = $$.config,
            areaTargetsNum = areaIndices.__max__ + 1,
            x = $$.getShapeX(0, areaTargetsNum, areaIndices, !!isSub),
            y = $$.getShapeY(!!isSub),
            areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
            yScale = isSub ? $$.getSubYScale : $$.getYScale;
        return function (d, i) {
            var y0 = yScale.call($$, d.id)(0),
                offset = areaOffset(d, i) || y0,
                // offset is for stacked area chart
            posX = x(d),
                posY = y(d);
            // fix posY not to overflow opposite quadrant
            if (config.axis_rotated) {
                if (0 < d.value && posY < y0 || d.value < 0 && y0 < posY) {
                    posY = y0;
                }
            }
            // 1 point that marks the area position
            return [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
            [posX, offset] // needed for compatibility
            ];
        };
    };

    c3_chart_internal_fn.updateCircle = function () {
        var $$ = this;
        $$.mainCircle = $$.main.selectAll('.' + CLASS.circles).selectAll('.' + CLASS.circle).data($$.lineOrScatterData.bind($$));
        $$.mainCircle.enter().append("circle").attr("class", $$.classCircle.bind($$)).attr("r", $$.pointR.bind($$)).style("fill", $$.color);
        $$.mainCircle.style("opacity", $$.initialOpacityForCircle.bind($$));
        $$.mainCircle.exit().remove();
    };
    c3_chart_internal_fn.redrawCircle = function (cx, cy, withTransition) {
        var selectedCircles = this.main.selectAll('.' + CLASS.selectedCircle);
        return [(withTransition ? this.mainCircle.transition(Math.random().toString()) : this.mainCircle).style('opacity', this.opacityForCircle.bind(this)).style("fill", this.color).attr("cx", cx).attr("cy", cy), (withTransition ? selectedCircles.transition(Math.random().toString()) : selectedCircles).attr("cx", cx).attr("cy", cy)];
    };
    c3_chart_internal_fn.circleX = function (d) {
        return d.x || d.x === 0 ? this.x(d.x) : null;
    };
    c3_chart_internal_fn.updateCircleY = function () {
        var $$ = this,
            lineIndices,
            getPoints;
        if ($$.config.data_groups.length > 0) {
            lineIndices = $$.getShapeIndices($$.isLineType), getPoints = $$.generateGetLinePoints(lineIndices);
            $$.circleY = function (d, i) {
                return getPoints(d, i)[0][1];
            };
        } else {
            $$.circleY = function (d) {
                return $$.getYScale(d.id)(d.value);
            };
        }
    };
    c3_chart_internal_fn.getCircles = function (i, id) {
        var $$ = this;
        return (id ? $$.main.selectAll('.' + CLASS.circles + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll('.' + CLASS.circle + (isValue(i) ? '-' + i : ''));
    };
    c3_chart_internal_fn.expandCircles = function (i, id, reset) {
        var $$ = this,
            r = $$.pointExpandedR.bind($$);
        if (reset) {
            $$.unexpandCircles();
        }
        $$.getCircles(i, id).classed(CLASS.EXPANDED, true).attr('r', r);
    };
    c3_chart_internal_fn.unexpandCircles = function (i) {
        var $$ = this,
            r = $$.pointR.bind($$);
        $$.getCircles(i).filter(function () {
            return $$.d3.select(this).classed(CLASS.EXPANDED);
        }).classed(CLASS.EXPANDED, false).attr('r', r);
    };
    c3_chart_internal_fn.pointR = function (d) {
        var $$ = this,
            config = $$.config;
        return $$.isStepType(d) ? 0 : isFunction(config.point_r) ? config.point_r(d) : config.point_r;
    };
    c3_chart_internal_fn.pointExpandedR = function (d) {
        var $$ = this,
            config = $$.config;
        if (config.point_focus_expand_enabled) {
            return isFunction(config.point_focus_expand_r) ? config.point_focus_expand_r(d) : config.point_focus_expand_r ? config.point_focus_expand_r : $$.pointR(d) * 1.75;
        } else {
            return $$.pointR(d);
        }
    };
    c3_chart_internal_fn.pointSelectR = function (d) {
        var $$ = this,
            config = $$.config;
        return isFunction(config.point_select_r) ? config.point_select_r(d) : config.point_select_r ? config.point_select_r : $$.pointR(d) * 4;
    };
    c3_chart_internal_fn.isWithinCircle = function (that, r) {
        var d3 = this.d3,
            mouse = d3.mouse(that),
            d3_this = d3.select(that),
            cx = +d3_this.attr("cx"),
            cy = +d3_this.attr("cy");
        return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < r;
    };
    c3_chart_internal_fn.isWithinStep = function (that, y) {
        return Math.abs(y - this.d3.mouse(that)[1]) < 30;
    };

    c3_chart_internal_fn.getCurrentWidth = function () {
        var $$ = this,
            config = $$.config;
        return config.size_width ? config.size_width : $$.getParentWidth();
    };
    c3_chart_internal_fn.getCurrentHeight = function () {
        var $$ = this,
            config = $$.config,
            h = config.size_height ? config.size_height : $$.getParentHeight();
        return h > 0 ? h : 320 / ($$.hasType('gauge') && !config.gauge_fullCircle ? 2 : 1);
    };
    c3_chart_internal_fn.getCurrentPaddingTop = function () {
        var $$ = this,
            config = $$.config,
            padding = isValue(config.padding_top) ? config.padding_top : 0;
        if ($$.title && $$.title.node()) {
            padding += $$.getTitlePadding();
        }
        return padding;
    };
    c3_chart_internal_fn.getCurrentPaddingBottom = function () {
        var config = this.config;
        return isValue(config.padding_bottom) ? config.padding_bottom : 0;
    };
    c3_chart_internal_fn.getCurrentPaddingLeft = function (withoutRecompute) {
        var $$ = this,
            config = $$.config;
        if (isValue(config.padding_left)) {
            return config.padding_left;
        } else if (config.axis_rotated) {
            return !config.axis_x_show || config.axis_x_inner ? 1 : Math.max(ceil10($$.getAxisWidthByAxisId('x', withoutRecompute)), 40);
        } else if (!config.axis_y_show || config.axis_y_inner) {
            // && !config.axis_rotated
            return $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1;
        } else {
            return ceil10($$.getAxisWidthByAxisId('y', withoutRecompute));
        }
    };
    c3_chart_internal_fn.getCurrentPaddingRight = function () {
        var $$ = this,
            config = $$.config,
            defaultPadding = 10,
            legendWidthOnRight = $$.isLegendRight ? $$.getLegendWidth() + 20 : 0;
        if (isValue(config.padding_right)) {
            return config.padding_right + 1; // 1 is needed not to hide tick line
        } else if (config.axis_rotated) {
            return defaultPadding + legendWidthOnRight;
        } else if (!config.axis_y2_show || config.axis_y2_inner) {
            // && !config.axis_rotated
            return 2 + legendWidthOnRight + ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0);
        } else {
            return ceil10($$.getAxisWidthByAxisId('y2')) + legendWidthOnRight;
        }
    };

    c3_chart_internal_fn.getParentRectValue = function (key) {
        var parent = this.selectChart.node(),
            v;
        while (parent && parent.tagName !== 'BODY') {
            try {
                v = parent.getBoundingClientRect()[key];
            } catch (e) {
                if (key === 'width') {
                    // In IE in certain cases getBoundingClientRect
                    // will cause an "unspecified error"
                    v = parent.offsetWidth;
                }
            }
            if (v) {
                break;
            }
            parent = parent.parentNode;
        }
        return v;
    };
    c3_chart_internal_fn.getParentWidth = function () {
        return this.getParentRectValue('width');
    };
    c3_chart_internal_fn.getParentHeight = function () {
        var h = this.selectChart.style('height');
        return h.indexOf('px') > 0 ? +h.replace('px', '') : 0;
    };

    c3_chart_internal_fn.getSvgLeft = function (withoutRecompute) {
        var $$ = this,
            config = $$.config,
            hasLeftAxisRect = config.axis_rotated || !config.axis_rotated && !config.axis_y_inner,
            leftAxisClass = config.axis_rotated ? CLASS.axisX : CLASS.axisY,
            leftAxis = $$.main.select('.' + leftAxisClass).node(),
            svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : { right: 0 },
            chartRect = $$.selectChart.node().getBoundingClientRect(),
            hasArc = $$.hasArcType(),
            svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
        return svgLeft > 0 ? svgLeft : 0;
    };

    c3_chart_internal_fn.getAxisWidthByAxisId = function (id, withoutRecompute) {
        var $$ = this,
            position = $$.axis.getLabelPositionById(id);
        return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
    };
    c3_chart_internal_fn.getHorizontalAxisHeight = function (axisId) {
        var $$ = this,
            config = $$.config,
            h = 30;
        if (axisId === 'x' && !config.axis_x_show) {
            return 8;
        }
        if (axisId === 'x' && config.axis_x_height) {
            return config.axis_x_height;
        }
        if (axisId === 'y' && !config.axis_y_show) {
            return config.legend_show && !$$.isLegendRight && !$$.isLegendInset ? 10 : 1;
        }
        if (axisId === 'y2' && !config.axis_y2_show) {
            return $$.rotated_padding_top;
        }
        // Calculate x axis height when tick rotated
        if (axisId === 'x' && !config.axis_rotated && config.axis_x_tick_rotate) {
            h = 30 + $$.axis.getMaxTickWidth(axisId) * Math.cos(Math.PI * (90 - config.axis_x_tick_rotate) / 180);
        }
        // Calculate y axis height when tick rotated
        if (axisId === 'y' && config.axis_rotated && config.axis_y_tick_rotate) {
            h = 30 + $$.axis.getMaxTickWidth(axisId) * Math.cos(Math.PI * (90 - config.axis_y_tick_rotate) / 180);
        }
        return h + ($$.axis.getLabelPositionById(axisId).isInner ? 0 : 10) + (axisId === 'y2' ? -10 : 0);
    };

    c3_chart_internal_fn.getEventRectWidth = function () {
        return Math.max(0, this.xAxis.tickInterval());
    };

    c3_chart_internal_fn.initBrush = function () {
        var $$ = this,
            d3 = $$.d3;
        $$.brush = d3.svg.brush().on("brush", function () {
            $$.redrawForBrush();
        });
        $$.brush.update = function () {
            if ($$.context) {
                $$.context.select('.' + CLASS.brush).call(this);
            }
            return this;
        };
        $$.brush.scale = function (scale) {
            return $$.config.axis_rotated ? this.y(scale) : this.x(scale);
        };
    };
    c3_chart_internal_fn.initSubchart = function () {
        var $$ = this,
            config = $$.config,
            context = $$.context = $$.svg.append("g").attr("transform", $$.getTranslate('context')),
            visibility = config.subchart_show ? 'visible' : 'hidden';

        context.style('visibility', visibility);

        // Define g for chart area
        context.append('g').attr("clip-path", $$.clipPathForSubchart).attr('class', CLASS.chart);

        // Define g for bar chart area
        context.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartBars);

        // Define g for line chart area
        context.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartLines);

        // Add extent rect for Brush
        context.append("g").attr("clip-path", $$.clipPath).attr("class", CLASS.brush).call($$.brush);

        // ATTENTION: This must be called AFTER chart added
        // Add Axis
        $$.axes.subx = context.append("g").attr("class", CLASS.axisX).attr("transform", $$.getTranslate('subx')).attr("clip-path", config.axis_rotated ? "" : $$.clipPathForXAxis).style("visibility", config.subchart_axis_x_show ? visibility : 'hidden');
    };
    c3_chart_internal_fn.updateTargetsForSubchart = function (targets) {
        var $$ = this,
            context = $$.context,
            config = $$.config,
            contextLineEnter,
            contextLineUpdate,
            contextBarEnter,
            contextBarUpdate,
            classChartBar = $$.classChartBar.bind($$),
            classBars = $$.classBars.bind($$),
            classChartLine = $$.classChartLine.bind($$),
            classLines = $$.classLines.bind($$),
            classAreas = $$.classAreas.bind($$);

        if (config.subchart_show) {
            //-- Bar --//
            contextBarUpdate = context.select('.' + CLASS.chartBars).selectAll('.' + CLASS.chartBar).data(targets).attr('class', classChartBar);
            contextBarEnter = contextBarUpdate.enter().append('g').style('opacity', 0).attr('class', classChartBar);
            // Bars for each data
            contextBarEnter.append('g').attr("class", classBars);

            //-- Line --//
            contextLineUpdate = context.select('.' + CLASS.chartLines).selectAll('.' + CLASS.chartLine).data(targets).attr('class', classChartLine);
            contextLineEnter = contextLineUpdate.enter().append('g').style('opacity', 0).attr('class', classChartLine);
            // Lines for each data
            contextLineEnter.append("g").attr("class", classLines);
            // Area
            contextLineEnter.append("g").attr("class", classAreas);

            //-- Brush --//
            context.selectAll('.' + CLASS.brush + ' rect').attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? $$.width2 : $$.height2);
        }
    };
    c3_chart_internal_fn.updateBarForSubchart = function (durationForExit) {
        var $$ = this;
        $$.contextBar = $$.context.selectAll('.' + CLASS.bars).selectAll('.' + CLASS.bar).data($$.barData.bind($$));
        $$.contextBar.enter().append('path').attr("class", $$.classBar.bind($$)).style("stroke", 'none').style("fill", $$.color);
        $$.contextBar.style("opacity", $$.initialOpacity.bind($$));
        $$.contextBar.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawBarForSubchart = function (drawBarOnSub, withTransition, duration) {
        (withTransition ? this.contextBar.transition(Math.random().toString()).duration(duration) : this.contextBar).attr('d', drawBarOnSub).style('opacity', 1);
    };
    c3_chart_internal_fn.updateLineForSubchart = function (durationForExit) {
        var $$ = this;
        $$.contextLine = $$.context.selectAll('.' + CLASS.lines).selectAll('.' + CLASS.line).data($$.lineData.bind($$));
        $$.contextLine.enter().append('path').attr('class', $$.classLine.bind($$)).style('stroke', $$.color);
        $$.contextLine.style("opacity", $$.initialOpacity.bind($$));
        $$.contextLine.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawLineForSubchart = function (drawLineOnSub, withTransition, duration) {
        (withTransition ? this.contextLine.transition(Math.random().toString()).duration(duration) : this.contextLine).attr("d", drawLineOnSub).style('opacity', 1);
    };
    c3_chart_internal_fn.updateAreaForSubchart = function (durationForExit) {
        var $$ = this,
            d3 = $$.d3;
        $$.contextArea = $$.context.selectAll('.' + CLASS.areas).selectAll('.' + CLASS.area).data($$.lineData.bind($$));
        $$.contextArea.enter().append('path').attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
            $$.orgAreaOpacity = +d3.select(this).style('opacity');return 0;
        });
        $$.contextArea.style("opacity", 0);
        $$.contextArea.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawAreaForSubchart = function (drawAreaOnSub, withTransition, duration) {
        (withTransition ? this.contextArea.transition(Math.random().toString()).duration(duration) : this.contextArea).attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.orgAreaOpacity);
    };
    c3_chart_internal_fn.redrawSubchart = function (withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices) {
        var $$ = this,
            d3 = $$.d3,
            config = $$.config,
            drawAreaOnSub,
            drawBarOnSub,
            drawLineOnSub;

        $$.context.style('visibility', config.subchart_show ? 'visible' : 'hidden');

        // subchart
        if (config.subchart_show) {
            // reflect main chart to extent on subchart if zoomed
            if (d3.event && d3.event.type === 'zoom') {
                $$.brush.extent($$.x.orgDomain()).update();
            }
            // update subchart elements if needed
            if (withSubchart) {

                // extent rect
                if (!$$.brush.empty()) {
                    $$.brush.extent($$.x.orgDomain()).update();
                }
                // setup drawer - MEMO: this must be called after axis updated
                drawAreaOnSub = $$.generateDrawArea(areaIndices, true);
                drawBarOnSub = $$.generateDrawBar(barIndices, true);
                drawLineOnSub = $$.generateDrawLine(lineIndices, true);

                $$.updateBarForSubchart(duration);
                $$.updateLineForSubchart(duration);
                $$.updateAreaForSubchart(duration);

                $$.redrawBarForSubchart(drawBarOnSub, duration, duration);
                $$.redrawLineForSubchart(drawLineOnSub, duration, duration);
                $$.redrawAreaForSubchart(drawAreaOnSub, duration, duration);
            }
        }
    };
    c3_chart_internal_fn.redrawForBrush = function () {
        var $$ = this,
            x = $$.x;
        $$.redraw({
            withTransition: false,
            withY: $$.config.zoom_rescale,
            withSubchart: false,
            withUpdateXDomain: true,
            withDimension: false
        });
        $$.config.subchart_onbrush.call($$.api, x.orgDomain());
    };
    c3_chart_internal_fn.transformContext = function (withTransition, transitions) {
        var $$ = this,
            subXAxis;
        if (transitions && transitions.axisSubX) {
            subXAxis = transitions.axisSubX;
        } else {
            subXAxis = $$.context.select('.' + CLASS.axisX);
            if (withTransition) {
                subXAxis = subXAxis.transition();
            }
        }
        $$.context.attr("transform", $$.getTranslate('context'));
        subXAxis.attr("transform", $$.getTranslate('subx'));
    };
    c3_chart_internal_fn.getDefaultExtent = function () {
        var $$ = this,
            config = $$.config,
            extent = isFunction(config.axis_x_extent) ? config.axis_x_extent($$.getXDomain($$.data.targets)) : config.axis_x_extent;
        if ($$.isTimeSeries()) {
            extent = [$$.parseDate(extent[0]), $$.parseDate(extent[1])];
        }
        return extent;
    };

    c3_chart_internal_fn.initText = function () {
        var $$ = this;
        $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartTexts);
        $$.mainText = $$.d3.selectAll([]);
    };
    c3_chart_internal_fn.updateTargetsForText = function (targets) {
        var $$ = this,
            mainTextUpdate,
            mainTextEnter,
            classChartText = $$.classChartText.bind($$),
            classTexts = $$.classTexts.bind($$),
            classFocus = $$.classFocus.bind($$);
        mainTextUpdate = $$.main.select('.' + CLASS.chartTexts).selectAll('.' + CLASS.chartText).data(targets).attr('class', function (d) {
            return classChartText(d) + classFocus(d);
        });
        mainTextEnter = mainTextUpdate.enter().append('g').attr('class', classChartText).style('opacity', 0).style("pointer-events", "none");
        mainTextEnter.append('g').attr('class', classTexts);
    };
    c3_chart_internal_fn.updateText = function (durationForExit) {
        var $$ = this,
            config = $$.config,
            barOrLineData = $$.barOrLineData.bind($$),
            classText = $$.classText.bind($$);
        $$.mainText = $$.main.selectAll('.' + CLASS.texts).selectAll('.' + CLASS.text).data(barOrLineData);
        $$.mainText.enter().append('text').attr("class", classText).attr('text-anchor', function (d) {
            return config.axis_rotated ? d.value < 0 ? 'end' : 'start' : 'middle';
        }).style("stroke", 'none').style("fill", function (d) {
            return $$.color(d);
        }).style("fill-opacity", 0);
        $$.mainText.text(function (d, i, j) {
            return $$.dataLabelFormat(d.id)(d.value, d.id, i, j);
        });
        $$.mainText.exit().transition().duration(durationForExit).style('fill-opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawText = function (xForText, yForText, forFlow, withTransition) {
        return [(withTransition ? this.mainText.transition() : this.mainText).attr('x', xForText).attr('y', yForText).style("fill", this.color).style("fill-opacity", forFlow ? 0 : this.opacityForText.bind(this))];
    };
    c3_chart_internal_fn.getTextRect = function (text, cls, element) {
        var dummy = this.d3.select('body').append('div').classed('c3', true),
            svg = dummy.append("svg").style('visibility', 'hidden').style('position', 'fixed').style('top', 0).style('left', 0),
            font = this.d3.select(element).style('font'),
            rect;
        svg.selectAll('.dummy').data([text]).enter().append('text').classed(cls ? cls : "", true).style('font', font).text(text).each(function () {
            rect = this.getBoundingClientRect();
        });
        dummy.remove();
        return rect;
    };
    c3_chart_internal_fn.generateXYForText = function (areaIndices, barIndices, lineIndices, forX) {
        var $$ = this,
            getAreaPoints = $$.generateGetAreaPoints(areaIndices, false),
            getBarPoints = $$.generateGetBarPoints(barIndices, false),
            getLinePoints = $$.generateGetLinePoints(lineIndices, false),
            getter = forX ? $$.getXForText : $$.getYForText;
        return function (d, i) {
            var getPoints = $$.isAreaType(d) ? getAreaPoints : $$.isBarType(d) ? getBarPoints : getLinePoints;
            return getter.call($$, getPoints(d, i), d, this);
        };
    };
    c3_chart_internal_fn.getXForText = function (points, d, textElement) {
        var $$ = this,
            box = textElement.getBoundingClientRect(),
            xPos,
            padding;
        if ($$.config.axis_rotated) {
            padding = $$.isBarType(d) ? 4 : 6;
            xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1);
        } else {
            xPos = $$.hasType('bar') ? (points[2][0] + points[0][0]) / 2 : points[0][0];
        }
        // show labels regardless of the domain if value is null
        if (d.value === null) {
            if (xPos > $$.width) {
                xPos = $$.width - box.width;
            } else if (xPos < 0) {
                xPos = 4;
            }
        }
        return xPos;
    };
    c3_chart_internal_fn.getYForText = function (points, d, textElement) {
        var $$ = this,
            box = textElement.getBoundingClientRect(),
            yPos;
        if ($$.config.axis_rotated) {
            yPos = (points[0][0] + points[2][0] + box.height * 0.6) / 2;
        } else {
            yPos = points[2][1];
            if (d.value < 0 || d.value === 0 && !$$.hasPositiveValue) {
                yPos += box.height;
                if ($$.isBarType(d) && $$.isSafari()) {
                    yPos -= 3;
                } else if (!$$.isBarType(d) && $$.isChrome()) {
                    yPos += 3;
                }
            } else {
                yPos += $$.isBarType(d) ? -3 : -6;
            }
        }
        // show labels regardless of the domain if value is null
        if (d.value === null && !$$.config.axis_rotated) {
            if (yPos < box.height) {
                yPos = box.height;
            } else if (yPos > this.height) {
                yPos = this.height - 4;
            }
        }
        return yPos;
    };

    c3_chart_internal_fn.initTitle = function () {
        var $$ = this;
        $$.title = $$.svg.append("text").text($$.config.title_text).attr("class", $$.CLASS.title);
    };
    c3_chart_internal_fn.redrawTitle = function () {
        var $$ = this;
        $$.title.attr("x", $$.xForTitle.bind($$)).attr("y", $$.yForTitle.bind($$));
    };
    c3_chart_internal_fn.xForTitle = function () {
        var $$ = this,
            config = $$.config,
            position = config.title_position || 'left',
            x;
        if (position.indexOf('right') >= 0) {
            x = $$.currentWidth - $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width - config.title_padding.right;
        } else if (position.indexOf('center') >= 0) {
            x = ($$.currentWidth - $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width) / 2;
        } else {
            // left
            x = config.title_padding.left;
        }
        return x;
    };
    c3_chart_internal_fn.yForTitle = function () {
        var $$ = this;
        return $$.config.title_padding.top + $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).height;
    };
    c3_chart_internal_fn.getTitlePadding = function () {
        var $$ = this;
        return $$.yForTitle() + $$.config.title_padding.bottom;
    };

    c3_chart_internal_fn.initTooltip = function () {
        var $$ = this,
            config = $$.config,
            i;
        $$.tooltip = $$.selectChart.style("position", "relative").append("div").attr('class', CLASS.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none");
        // Show tooltip if needed
        if (config.tooltip_init_show) {
            if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {
                config.tooltip_init_x = $$.parseDate(config.tooltip_init_x);
                for (i = 0; i < $$.data.targets[0].values.length; i++) {
                    if ($$.data.targets[0].values[i].x - config.tooltip_init_x === 0) {
                        break;
                    }
                }
                config.tooltip_init_x = i;
            }
            $$.tooltip.html(config.tooltip_contents.call($$, $$.data.targets.map(function (d) {
                return $$.addName(d.values[config.tooltip_init_x]);
            }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType()), $$.color));
            $$.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
        }
    };
    c3_chart_internal_fn.getTooltipSortFunction = function () {
        var $$ = this,
            config = $$.config;

        if (config.data_groups.length === 0 || config.tooltip_order !== undefined) {
            // if data are not grouped or if an order is specified
            // for the tooltip values we sort them by their values

            var order = config.tooltip_order;
            if (order === undefined) {
                order = config.data_order;
            }

            var valueOf = function valueOf(obj) {
                return obj ? obj.value : null;
            };

            // if data are not grouped, we sort them by their value
            if (isString(order) && order.toLowerCase() === 'asc') {
                return function (a, b) {
                    return valueOf(a) - valueOf(b);
                };
            } else if (isString(order) && order.toLowerCase() === 'desc') {
                return function (a, b) {
                    return valueOf(b) - valueOf(a);
                };
            } else if (isFunction(order)) {

                // if the function is from data_order we need
                // to wrap the returned function in order to format
                // the sorted value to the expected format

                var sortFunction = order;

                if (config.tooltip_order === undefined) {
                    sortFunction = function sortFunction(a, b) {
                        return order(a ? {
                            id: a.id,
                            values: [a]
                        } : null, b ? {
                            id: b.id,
                            values: [b]
                        } : null);
                    };
                }

                return sortFunction;
            } else if (isArray(order)) {
                return function (a, b) {
                    return order.indexOf(a.id) - order.indexOf(b.id);
                };
            }
        } else {
            // if data are grouped, we follow the order of grouped targets
            var ids = $$.orderTargets($$.data.targets).map(function (i) {
                return i.id;
            });

            // if it was either asc or desc we need to invert the order
            // returned by orderTargets
            if ($$.isOrderAsc() || $$.isOrderDesc()) {
                ids = ids.reverse();
            }

            return function (a, b) {
                return ids.indexOf(a.id) - ids.indexOf(b.id);
            };
        }
    };
    c3_chart_internal_fn.getTooltipContent = function (d, defaultTitleFormat, defaultValueFormat, color) {
        var $$ = this,
            config = $$.config,
            titleFormat = config.tooltip_format_title || defaultTitleFormat,
            nameFormat = config.tooltip_format_name || function (name) {
            return name;
        },
            valueFormat = config.tooltip_format_value || defaultValueFormat,
            text,
            i,
            title,
            value,
            name,
            bgcolor;

        var tooltipSortFunction = this.getTooltipSortFunction();
        if (tooltipSortFunction) {
            d.sort(tooltipSortFunction);
        }

        for (i = 0; i < d.length; i++) {
            if (!(d[i] && (d[i].value || d[i].value === 0))) {
                continue;
            }

            if (!text) {
                title = sanitise(titleFormat ? titleFormat(d[i].x) : d[i].x);
                text = "<table class='" + $$.CLASS.tooltip + "'>" + (title || title === 0 ? "<tr><th colspan='2'>" + title + "</th></tr>" : "");
            }

            value = sanitise(valueFormat(d[i].value, d[i].ratio, d[i].id, d[i].index, d));
            if (value !== undefined) {
                // Skip elements when their name is set to null
                if (d[i].name === null) {
                    continue;
                }
                name = sanitise(nameFormat(d[i].name, d[i].ratio, d[i].id, d[i].index));
                bgcolor = $$.levelColor ? $$.levelColor(d[i].value) : color(d[i].id);

                text += "<tr class='" + $$.CLASS.tooltipName + "-" + $$.getTargetSelectorSuffix(d[i].id) + "'>";
                text += "<td class='name'><span style='background-color:" + bgcolor + "'></span>" + name + "</td>";
                text += "<td class='value'>" + value + "</td>";
                text += "</tr>";
            }
        }
        return text + "</table>";
    };
    c3_chart_internal_fn.tooltipPosition = function (dataToShow, tWidth, tHeight, element) {
        var $$ = this,
            config = $$.config,
            d3 = $$.d3;
        var svgLeft, tooltipLeft, tooltipRight, tooltipTop, chartRight;
        var forArc = $$.hasArcType(),
            mouse = d3.mouse(element);
        // Determin tooltip position
        if (forArc) {
            tooltipLeft = ($$.width - ($$.isLegendRight ? $$.getLegendWidth() : 0)) / 2 + mouse[0];
            tooltipTop = ($$.hasType('gauge') ? $$.height : $$.height / 2) + mouse[1] + 20;
        } else {
            svgLeft = $$.getSvgLeft(true);
            if (config.axis_rotated) {
                tooltipLeft = svgLeft + mouse[0] + 100;
                tooltipRight = tooltipLeft + tWidth;
                chartRight = $$.currentWidth - $$.getCurrentPaddingRight();
                tooltipTop = $$.x(dataToShow[0].x) + 20;
            } else {
                tooltipLeft = svgLeft + $$.getCurrentPaddingLeft(true) + $$.x(dataToShow[0].x) + 20;
                tooltipRight = tooltipLeft + tWidth;
                chartRight = svgLeft + $$.currentWidth - $$.getCurrentPaddingRight();
                tooltipTop = mouse[1] + 15;
            }

            if (tooltipRight > chartRight) {
                // 20 is needed for Firefox to keep tooltip width
                tooltipLeft -= tooltipRight - chartRight + 20;
            }
            if (tooltipTop + tHeight > $$.currentHeight) {
                tooltipTop -= tHeight + 30;
            }
        }
        if (tooltipTop < 0) {
            tooltipTop = 0;
        }
        return { top: tooltipTop, left: tooltipLeft };
    };
    c3_chart_internal_fn.showTooltip = function (selectedData, element) {
        var $$ = this,
            config = $$.config;
        var tWidth, tHeight, position;
        var forArc = $$.hasArcType(),
            dataToShow = selectedData.filter(function (d) {
            return d && isValue(d.value);
        }),
            positionFunction = config.tooltip_position || c3_chart_internal_fn.tooltipPosition;
        if (dataToShow.length === 0 || !config.tooltip_show) {
            return;
        }
        $$.tooltip.html(config.tooltip_contents.call($$, selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color)).style("display", "block");

        // Get tooltip dimensions
        tWidth = $$.tooltip.property('offsetWidth');
        tHeight = $$.tooltip.property('offsetHeight');

        position = positionFunction.call(this, dataToShow, tWidth, tHeight, element);
        // Set tooltip
        $$.tooltip.style("top", position.top + "px").style("left", position.left + 'px');
    };
    c3_chart_internal_fn.hideTooltip = function () {
        this.tooltip.style("display", "none");
    };

    c3_chart_internal_fn.setTargetType = function (targetIds, type) {
        var $$ = this,
            config = $$.config;
        $$.mapToTargetIds(targetIds).forEach(function (id) {
            $$.withoutFadeIn[id] = type === config.data_types[id];
            config.data_types[id] = type;
        });
        if (!targetIds) {
            config.data_type = type;
        }
    };
    c3_chart_internal_fn.hasType = function (type, targets) {
        var $$ = this,
            types = $$.config.data_types,
            has = false;
        targets = targets || $$.data.targets;
        if (targets && targets.length) {
            targets.forEach(function (target) {
                var t = types[target.id];
                if (t && t.indexOf(type) >= 0 || !t && type === 'line') {
                    has = true;
                }
            });
        } else if (Object.keys(types).length) {
            Object.keys(types).forEach(function (id) {
                if (types[id] === type) {
                    has = true;
                }
            });
        } else {
            has = $$.config.data_type === type;
        }
        return has;
    };
    c3_chart_internal_fn.hasArcType = function (targets) {
        return this.hasType('pie', targets) || this.hasType('donut', targets) || this.hasType('gauge', targets);
    };
    c3_chart_internal_fn.isLineType = function (d) {
        var config = this.config,
            id = isString(d) ? d : d.id;
        return !config.data_types[id] || ['line', 'spline', 'area', 'area-spline', 'step', 'area-step'].indexOf(config.data_types[id]) >= 0;
    };
    c3_chart_internal_fn.isStepType = function (d) {
        var id = isString(d) ? d : d.id;
        return ['step', 'area-step'].indexOf(this.config.data_types[id]) >= 0;
    };
    c3_chart_internal_fn.isSplineType = function (d) {
        var id = isString(d) ? d : d.id;
        return ['spline', 'area-spline'].indexOf(this.config.data_types[id]) >= 0;
    };
    c3_chart_internal_fn.isAreaType = function (d) {
        var id = isString(d) ? d : d.id;
        return ['area', 'area-spline', 'area-step'].indexOf(this.config.data_types[id]) >= 0;
    };
    c3_chart_internal_fn.isBarType = function (d) {
        var id = isString(d) ? d : d.id;
        return this.config.data_types[id] === 'bar';
    };
    c3_chart_internal_fn.isScatterType = function (d) {
        var id = isString(d) ? d : d.id;
        return this.config.data_types[id] === 'scatter';
    };
    c3_chart_internal_fn.isPieType = function (d) {
        var id = isString(d) ? d : d.id;
        return this.config.data_types[id] === 'pie';
    };
    c3_chart_internal_fn.isGaugeType = function (d) {
        var id = isString(d) ? d : d.id;
        return this.config.data_types[id] === 'gauge';
    };
    c3_chart_internal_fn.isDonutType = function (d) {
        var id = isString(d) ? d : d.id;
        return this.config.data_types[id] === 'donut';
    };
    c3_chart_internal_fn.isArcType = function (d) {
        return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d);
    };
    c3_chart_internal_fn.lineData = function (d) {
        return this.isLineType(d) ? [d] : [];
    };
    c3_chart_internal_fn.arcData = function (d) {
        return this.isArcType(d.data) ? [d] : [];
    };
    /* not used
     function scatterData(d) {
     return isScatterType(d) ? d.values : [];
     }
     */
    c3_chart_internal_fn.barData = function (d) {
        return this.isBarType(d) ? d.values : [];
    };
    c3_chart_internal_fn.lineOrScatterData = function (d) {
        return this.isLineType(d) || this.isScatterType(d) ? d.values : [];
    };
    c3_chart_internal_fn.barOrLineData = function (d) {
        return this.isBarType(d) || this.isLineType(d) ? d.values : [];
    };
    c3_chart_internal_fn.isInterpolationType = function (type) {
        return ['linear', 'linear-closed', 'basis', 'basis-open', 'basis-closed', 'bundle', 'cardinal', 'cardinal-open', 'cardinal-closed', 'monotone'].indexOf(type) >= 0;
    };

    c3_chart_internal_fn.isSafari = function () {
        var ua = window.navigator.userAgent;
        return ua.indexOf('Safari') >= 0 && ua.indexOf('Chrome') < 0;
    };
    c3_chart_internal_fn.isChrome = function () {
        var ua = window.navigator.userAgent;
        return ua.indexOf('Chrome') >= 0;
    };

    c3_chart_internal_fn.initZoom = function () {
        var $$ = this,
            d3 = $$.d3,
            config = $$.config,
            startEvent;

        $$.zoom = d3.behavior.zoom().on("zoomstart", function () {
            startEvent = d3.event.sourceEvent;
            $$.zoom.altDomain = d3.event.sourceEvent.altKey ? $$.x.orgDomain() : null;
            config.zoom_onzoomstart.call($$.api, d3.event.sourceEvent);
        }).on("zoom", function () {
            $$.redrawForZoom.call($$);
        }).on('zoomend', function () {
            var event = d3.event.sourceEvent;
            // if click, do nothing. otherwise, click interaction will be canceled.
            if (event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY) {
                return;
            }
            $$.redrawEventRect();
            $$.updateZoom();
            config.zoom_onzoomend.call($$.api, $$.x.orgDomain());
        });
        $$.zoom.scale = function (scale) {
            return config.axis_rotated ? this.y(scale) : this.x(scale);
        };
        $$.zoom.orgScaleExtent = function () {
            var extent = config.zoom_extent ? config.zoom_extent : [1, 10];
            return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
        };
        $$.zoom.updateScaleExtent = function () {
            var ratio = diffDomain($$.x.orgDomain()) / diffDomain($$.getZoomDomain()),
                extent = this.orgScaleExtent();
            this.scaleExtent([extent[0] * ratio, extent[1] * ratio]);
            return this;
        };
    };
    c3_chart_internal_fn.getZoomDomain = function () {
        var $$ = this,
            config = $$.config,
            d3 = $$.d3,
            min = d3.min([$$.orgXDomain[0], config.zoom_x_min]),
            max = d3.max([$$.orgXDomain[1], config.zoom_x_max]);
        return [min, max];
    };
    c3_chart_internal_fn.updateZoom = function () {
        var $$ = this,
            z = $$.config.zoom_enabled ? $$.zoom : function () {};
        $$.main.select('.' + CLASS.zoomRect).call(z).on("dblclick.zoom", null);
        $$.main.selectAll('.' + CLASS.eventRect).call(z).on("dblclick.zoom", null);
    };
    c3_chart_internal_fn.redrawForZoom = function () {
        var $$ = this,
            d3 = $$.d3,
            config = $$.config,
            zoom = $$.zoom,
            x = $$.x;
        if (!config.zoom_enabled) {
            return;
        }
        if ($$.filterTargetsToShow($$.data.targets).length === 0) {
            return;
        }
        if (d3.event.sourceEvent.type === 'mousemove' && zoom.altDomain) {
            x.domain(zoom.altDomain);
            zoom.scale(x).updateScaleExtent();
            return;
        }
        if ($$.isCategorized() && x.orgDomain()[0] === $$.orgXDomain[0]) {
            x.domain([$$.orgXDomain[0] - 1e-10, x.orgDomain()[1]]);
        }
        $$.redraw({
            withTransition: false,
            withY: config.zoom_rescale,
            withSubchart: false,
            withEventRect: false,
            withDimension: false
        });
        if (d3.event.sourceEvent.type === 'mousemove') {
            $$.cancelClick = true;
        }
        config.zoom_onzoom.call($$.api, x.orgDomain());
    };

    return c3;

})));


/***/ }),

/***/ "../../../node_modules/d3/d3.js":
/*!****************************************************!*\
  !*** /Users/flex/Lab/tabler/node_modules/d3/d3.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {
  var d3 = {
    version: "3.5.17"
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = this.document;
  function d3_documentElement(node) {
    return node && (node.ownerDocument || node.document || node).documentElement;
  }
  function d3_window(node) {
    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
  }
  if (d3_document) {
    try {
      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
    } catch (e) {
      d3_array = function(list) {
        var i = list.length, array = new Array(i);
        while (i--) array[i] = list[i];
        return array;
      };
    }
  }
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  if (d3_document) {
    try {
      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
    } catch (error) {
      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
      d3_element_prototype.setAttribute = function(name, value) {
        d3_element_setAttribute.call(this, name, value + "");
      };
      d3_element_prototype.setAttributeNS = function(space, local, value) {
        d3_element_setAttributeNS.call(this, space, local, value + "");
      };
      d3_style_prototype.setProperty = function(name, value, priority) {
        d3_style_setProperty.call(this, name, value + "", priority);
      };
    }
  }
  d3.ascending = d3_ascending;
  function d3_ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  function d3_number(x) {
    return x === null ? NaN : +x;
  }
  function d3_numeric(x) {
    return !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
    } else {
      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.mean = function(array, f) {
    var s = 0, n = array.length, a, i = -1, j = n;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
    }
    if (j) return s / j;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    var numbers = [], n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
    }
    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
  };
  d3.variance = function(array, f) {
    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) {
        if (d3_numeric(a = d3_number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    } else {
      while (++i < n) {
        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }
    if (j > 1) return s / (j - 1);
  };
  d3.deviation = function() {
    var v = d3.variance.apply(this, arguments);
    return v ? Math.sqrt(v) : v;
  };
  function d3_bisector(compare) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  }
  var d3_bisect = d3_bisector(d3_ascending);
  d3.bisectLeft = d3_bisect.left;
  d3.bisect = d3.bisectRight = d3_bisect.right;
  d3.bisector = function(f) {
    return d3_bisector(f.length === 1 ? function(d, x) {
      return d3_ascending(f(d), x);
    } : f);
  };
  d3.shuffle = function(array, i0, i1) {
    if ((m = arguments.length) < 3) {
      i1 = array.length;
      if (m < 2) i0 = 0;
    }
    var m = i1 - i0, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.transpose = function(matrix) {
    if (!(n = matrix.length)) return [];
    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
        row[j] = matrix[j][i];
      }
    }
    return transpose;
  };
  function d3_transposeLength(d) {
    return d.length;
  }
  d3.zip = function() {
    return d3.transpose(arguments);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  }
  d3.map = function(object, f) {
    var map = new d3_Map();
    if (object instanceof d3_Map) {
      object.forEach(function(key, value) {
        map.set(key, value);
      });
    } else if (Array.isArray(object)) {
      var i = -1, n = object.length, o;
      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
    } else {
      for (var key in object) map.set(key, object[key]);
    }
    return map;
  };
  function d3_Map() {
    this._ = Object.create(null);
  }
  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function(key) {
      return this._[d3_map_escape(key)];
    },
    set: function(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function() {
      var values = [];
      for (var key in this._) values.push(this._[key]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var key in this._) entries.push({
        key: d3_map_unescape(key),
        value: this._[key]
      });
      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
    }
  });
  function d3_map_escape(key) {
    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
  }
  function d3_map_unescape(key) {
    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
  }
  function d3_map_has(key) {
    return d3_map_escape(key) in this._;
  }
  function d3_map_remove(key) {
    return (key = d3_map_escape(key)) in this._ && delete this._[key];
  }
  function d3_map_keys() {
    var keys = [];
    for (var key in this._) keys.push(d3_map_unescape(key));
    return keys;
  }
  function d3_map_size() {
    var size = 0;
    for (var key in this._) ++size;
    return size;
  }
  function d3_map_empty() {
    for (var key in this._) return false;
    return true;
  }
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {
    this._ = Object.create(null);
  }
  d3_class(d3_Set, {
    has: d3_map_has,
    add: function(key) {
      this._[d3_map_escape(key += "")] = true;
      return key;
    },
    remove: d3_map_remove,
    values: d3_map_keys,
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key));
    }
  });
  d3.behavior = {};
  function d3_identity(d) {
    return d;
  }
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.slice(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.slice(i + 1);
      type = type.slice(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatches = function(n, s) {
    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
    d3_selectMatches = function(n, s) {
      return d3_selectMatcher.call(n, s);
    };
    return d3_selectMatches(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = Sizzle;
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3.select(d3_document.documentElement);
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: d3_nsXhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return (name + "").trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) {
        var node = this.node();
        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
      }
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    function create() {
      var document = this.ownerDocument, namespace = this.namespaceURI;
      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
    }
    function createNS() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    }
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(d3_selectionRemove);
  };
  function d3_selectionRemove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
        for (i = -1; ++i < n; ) {
          if (node = group[i]) {
            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
              exitNodes[i] = node;
            } else {
              nodeByKeyValue.set(keyValue, node);
            }
            keyValues[i] = keyValue;
          }
        }
        for (i = -1; ++i < m; ) {
          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } else if (node !== true) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.set(keyValue, true);
        }
        for (i = -1; ++i < n; ) {
          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3_ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    d3_selection_each(this, function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3.select = function(node) {
    var group;
    if (typeof node === "string") {
      group = [ d3_select(node, d3_document) ];
      group.parentNode = d3_document.documentElement;
    } else {
      group = [ node ];
      group.parentNode = d3_documentElement(node);
    }
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group;
    if (typeof nodes === "string") {
      group = d3_array(d3_selectAll(nodes, d3_document));
      group.parentNode = d3_document.documentElement;
    } else {
      group = d3_array(nodes);
      group.parentNode = null;
    }
    return d3_selection([ group ]);
  };
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.slice(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  if (d3_document) {
    d3_selection_onFilters.forEach(function(k) {
      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
    });
  }
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect, d3_event_dragId = 0;
  function d3_event_dragSuppress(node) {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect == null) {
      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
    }
    if (d3_event_dragSelect) {
      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        var off = function() {
          w.on(click, null);
        };
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0) {
        var window = d3_window(container);
        if (window.scrollX || window.scrollY) {
          svg = d3.select("body").append("svg").style({
            position: "absolute",
            top: 0,
            left: 0,
            margin: 0,
            padding: 0,
            border: "none"
          }, "important");
          var ctm = svg[0][0].getScreenCTM();
          d3_mouse_bug44083 = !(ctm.f || ctm.e);
          svg.remove();
        }
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touch = function(container, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return d3_mousePoint(container, touch);
      }
    }
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function dragstart(id, position, subject, move, end) {
      return function() {
        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
        if (origin) {
          dragOffset = origin.apply(that, arguments);
          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
        } else {
          dragOffset = [ 0, 0 ];
        }
        dispatch({
          type: "dragstart"
        });
        function moved() {
          var position1 = position(parent, dragId), dx, dy;
          if (!position1) return;
          dx = position1[0] - position0[0];
          dy = position1[1] - position0[1];
          dragged |= dx | dy;
          position0 = position1;
          dispatch({
            type: "drag",
            x: position1[0] + dragOffset[0],
            y: position1[1] + dragOffset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          if (!position(parent, dragId)) return;
          dragSubject.on(move + dragName, null).on(end + dragName, null);
          dragRestore(dragged);
          dispatch({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  function d3_behavior_dragTouchId() {
    return d3.event.changedTouches[0].identifier;
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  var  = 1e-6, 2 =  * ,  = Math.PI,  = 2 * ,  =  - , half =  / 2, d3_radians =  / 180, d3_degrees = 180 / ;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_cross2d(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ?  : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? half : x < -1 ? -half : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var  = Math.SQRT2, 2 = 2, 4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < 2) {
      S = Math.log(w1 / w0) / ;
      i = function(t) {
        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp( * t * S) ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + 4 * d2) / (2 * w0 * 2 * d1), b1 = (w1 * w1 - w0 * w0 - 4 * d2) / (2 * w1 * 2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / ;
      i = function(t) {
        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (2 * d1) * (coshr0 * d3_tanh( * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh( * s + r0) ];
      };
    }
    i.duration = S * 1e3;
    return i;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    if (!d3_behavior_zoomWheel) {
      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return d3.event.wheelDelta;
      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
        return -d3.event.detail;
      }, "MozMousePixelScroll");
    }
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var dispatch = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(dispatch);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(dispatch);
            };
          }).each("interrupt.zoom", function() {
            zoomended(dispatch);
          }).each("end.zoom", function() {
            zoomended(dispatch);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(dispatch);
          zoomed(dispatch);
          zoomended(dispatch);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: null
      };
      scaleTo(+_);
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.duration = function(_) {
      if (!arguments.length) return duration;
      duration = +_;
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function zoomTo(that, p, l, k) {
      that.__chart__ = {
        x: view.x,
        y: view.y,
        k: view.k
      };
      scaleTo(Math.pow(2, k));
      translateTo(center0 = p, l);
      that = d3.select(that);
      if (duration > 0) that = that.transition().duration(duration);
      that.call(zoom.event);
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(dispatch) {
      if (!zooming++) dispatch({
        type: "zoomstart"
      });
    }
    function zoomed(dispatch) {
      rescale();
      dispatch({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(dispatch) {
      if (!--zooming) dispatch({
        type: "zoomend"
      }), center0 = null;
    }
    function mousedowned() {
      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
      d3_selection_interrupt.call(that);
      zoomstarted(dispatch);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(that), location0);
        zoomed(dispatch);
      }
      function ended() {
        subject.on(mousemove, null).on(mouseup, null);
        dragRestore(dragged);
        zoomended(dispatch);
      }
    }
    function touchstarted() {
      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
      started();
      zoomstarted(dispatch);
      subject.on(mousedown, null).on(touchstart, started);
      function relocate() {
        var touches = d3.touches(that);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var target = d3.event.target;
        d3.select(target).on(touchmove, moved).on(touchend, ended);
        targets.push(target);
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0];
            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
            d3_eventPreventDefault();
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(that), p0, l0, p1, l1;
        d3_selection_interrupt.call(that);
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(dispatch);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        d3.selectAll(targets).on(zoomName, null);
        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(dispatch);
      }
    }
    function mousewheeled() {
      var dispatch = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(dispatch);
      }, 50);
      d3_eventPreventDefault();
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(center0, translate0);
      zoomed(dispatch);
    }
    function dblclicked() {
      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
  d3.color = d3_color;
  function d3_color() {}
  d3_color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = d3_hsl;
  function d3_hsl(h, s, l) {
    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
  }
  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = d3_hcl;
  function d3_hcl(h, c, l) {
    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
  }
  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
  d3_hclPrototype.brighter = function(k) {
    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = d3_lab;
  function d3_lab(l, a, b) {
    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_lab.prototype = new d3_color();
  d3_labPrototype.brighter = function(k) {
    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = d3_rgb;
  function d3_rgb(r, g, b) {
    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
  }
  function d3_rgbNumber(value) {
    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return new d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_rgb(k * this.r, k * this.g, k * this.b);
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, color;
    m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (color = d3_rgb_names.get(format)) {
      return rgb(color.r, color.g, color.b);
    }
    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
      if (format.length === 4) {
        r = (color & 3840) >> 4;
        r = r >> 4 | r;
        g = color & 240;
        g = g >> 4 | g;
        b = color & 15;
        b = b << 4 | b;
      } else if (format.length === 7) {
        r = (color & 16711680) >> 16;
        g = (color & 65280) >> 8;
        b = color & 255;
      }
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  function d3_xhrHasResponse(request) {
    var type = request.responseType;
    return type && type !== "text" ? request.response : request.responseText;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }
        return text.slice(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv("	", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function() {
    d3_timer.apply(this, arguments);
  };
  function d3_timer(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
    return timer;
  }
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now(), timer = d3_timer_queueHead;
    while (timer) {
      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
      timer = timer.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.c) {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      } else {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value = +value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  function d3_locale_numberFormat(locale) {
    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = locale_grouping[j = (j + 1) % locale_grouping.length];
      }
      return t.reverse().join(locale_thousands);
    } : d3_identity;
    return function(specifier) {
      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
      if (precision) precision = +precision.substring(1);
      if (zfill || fill === "0" && align === "=") {
        zfill = fill = "0";
        align = "=";
      }
      switch (type) {
       case "n":
        comma = true;
        type = "g";
        break;

       case "%":
        scale = 100;
        suffix = "%";
        type = "f";
        break;

       case "p":
        scale = 100;
        suffix = "%";
        type = "r";
        break;

       case "b":
       case "o":
       case "x":
       case "X":
        if (symbol === "#") prefix = "0" + type.toLowerCase();

       case "c":
        exponent = false;

       case "d":
        integer = true;
        precision = 0;
        break;

       case "s":
        scale = -1;
        type = "r";
        break;
      }
      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
      if (type == "r" && !precision) type = "g";
      if (precision != null) {
        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
      }
      type = d3_format_types.get(type) || d3_format_typeDefault;
      var zcomma = zfill && comma;
      return function(value) {
        var fullSuffix = suffix;
        if (integer && value % 1) return "";
        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
        if (scale < 0) {
          var unit = d3.formatPrefix(value, precision);
          value = unit.scale(value);
          fullSuffix = unit.symbol + suffix;
        } else {
          value *= scale;
        }
        value = type(value, precision);
        var i = value.lastIndexOf("."), before, after;
        if (i < 0) {
          var j = exponent ? value.lastIndexOf("e") : -1;
          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
        } else {
          before = value.substring(0, i);
          after = locale_decimal + value.substring(i + 1);
        }
        if (!zfill && comma) before = formatGroup(before, Infinity);
        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
        negative += prefix;
        value = before + after;
        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
      };
    };
  }
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_time = d3.time = {}, d3_date = Date;
  function d3_date_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_date_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_date(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_date(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_date = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_date = Date;
      }
    };
  }
  d3_time.year = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3_time.years = d3_time.year.range;
  d3_time.years.utc = d3_time.year.utc.range;
  d3_time.day = d3_time_interval(function(date) {
    var day = new d3_date(2e3, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3_time.days = d3_time.day.range;
  d3_time.days.utc = d3_time.day.utc.range;
  d3_time.dayOfYear = function(date) {
    var year = d3_time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
    i = 7 - i;
    var interval = d3_time[day] = d3_time_interval(function(date) {
      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3_time[day + "s"] = interval.range;
    d3_time[day + "s"].utc = interval.utc.range;
    d3_time[day + "OfYear"] = function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3_time.week = d3_time.sunday;
  d3_time.weeks = d3_time.sunday.range;
  d3_time.weeks.utc = d3_time.sunday.utc.range;
  d3_time.weekOfYear = d3_time.sundayOfYear;
  function d3_locale_timeFormat(locale) {
    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
    function d3_time_format(template) {
      var n = template.length;
      function format(date) {
        var string = [], i = -1, j = 0, c, p, f;
        while (++i < n) {
          if (template.charCodeAt(i) === 37) {
            string.push(template.slice(j, i));
            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(template.slice(j, i));
        return string.join("");
      }
      format.parse = function(string) {
        var d = {
          y: 1900,
          m: 0,
          d: 1,
          H: 0,
          M: 0,
          S: 0,
          L: 0,
          Z: null
        }, i = d3_time_parse(d, template, string, 0);
        if (i != string.length) return null;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
          date.setFullYear(d.y, 0, 1);
          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
        } else date.setFullYear(d.y, d.m, d.d);
        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
        return localZ ? date._ : date;
      };
      format.toString = function() {
        return template;
      };
      return format;
    }
    function d3_time_parse(date, template, string, j) {
      var c, p, t, i = 0, n = template.length, m = string.length;
      while (i < n) {
        if (j >= m) return -1;
        c = template.charCodeAt(i++);
        if (c === 37) {
          t = template.charAt(i++);
          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
          if (!p || (j = p(date, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    d3_time_format.utc = function(template) {
      var local = d3_time_format(template);
      function format(date) {
        try {
          d3_date = d3_date_utc;
          var utc = new d3_date();
          utc._ = date;
          return local(utc);
        } finally {
          d3_date = Date;
        }
      }
      format.parse = function(string) {
        try {
          d3_date = d3_date_utc;
          var date = local.parse(string);
          return date && date._;
        } finally {
          d3_date = Date;
        }
      };
      format.toString = local.toString;
      return format;
    };
    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
    locale_periods.forEach(function(p, i) {
      d3_time_periodLookup.set(p.toLowerCase(), i);
    });
    var d3_time_formats = {
      a: function(d) {
        return locale_shortDays[d.getDay()];
      },
      A: function(d) {
        return locale_days[d.getDay()];
      },
      b: function(d) {
        return locale_shortMonths[d.getMonth()];
      },
      B: function(d) {
        return locale_months[d.getMonth()];
      },
      c: d3_time_format(locale_dateTime),
      d: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      e: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      H: function(d, p) {
        return d3_time_formatPad(d.getHours(), p, 2);
      },
      I: function(d, p) {
        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
      },
      j: function(d, p) {
        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
      },
      L: function(d, p) {
        return d3_time_formatPad(d.getMilliseconds(), p, 3);
      },
      m: function(d, p) {
        return d3_time_formatPad(d.getMonth() + 1, p, 2);
      },
      M: function(d, p) {
        return d3_time_formatPad(d.getMinutes(), p, 2);
      },
      p: function(d) {
        return locale_periods[+(d.getHours() >= 12)];
      },
      S: function(d, p) {
        return d3_time_formatPad(d.getSeconds(), p, 2);
      },
      U: function(d, p) {
        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
      },
      w: function(d) {
        return d.getDay();
      },
      W: function(d, p) {
        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
      },
      x: d3_time_format(locale_date),
      X: d3_time_format(locale_time),
      y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
      },
      Y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
      },
      Z: d3_time_zone,
      "%": function() {
        return "%";
      }
    };
    var d3_time_parsers = {
      a: d3_time_parseWeekdayAbbrev,
      A: d3_time_parseWeekday,
      b: d3_time_parseMonthAbbrev,
      B: d3_time_parseMonth,
      c: d3_time_parseLocaleFull,
      d: d3_time_parseDay,
      e: d3_time_parseDay,
      H: d3_time_parseHour24,
      I: d3_time_parseHour24,
      j: d3_time_parseDayOfYear,
      L: d3_time_parseMilliseconds,
      m: d3_time_parseMonthNumber,
      M: d3_time_parseMinutes,
      p: d3_time_parseAmPm,
      S: d3_time_parseSeconds,
      U: d3_time_parseWeekNumberSunday,
      w: d3_time_parseWeekdayNumber,
      W: d3_time_parseWeekNumberMonday,
      x: d3_time_parseLocaleDate,
      X: d3_time_parseLocaleTime,
      y: d3_time_parseYear,
      Y: d3_time_parseFullYear,
      Z: d3_time_parseZone,
      "%": d3_time_parseLiteralPercent
    };
    function d3_time_parseWeekdayAbbrev(date, string, i) {
      d3_time_dayAbbrevRe.lastIndex = 0;
      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseWeekday(date, string, i) {
      d3_time_dayRe.lastIndex = 0;
      var n = d3_time_dayRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonthAbbrev(date, string, i) {
      d3_time_monthAbbrevRe.lastIndex = 0;
      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonth(date, string, i) {
      d3_time_monthRe.lastIndex = 0;
      var n = d3_time_monthRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseLocaleFull(date, string, i) {
      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
    }
    function d3_time_parseLocaleDate(date, string, i) {
      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
    }
    function d3_time_parseLocaleTime(date, string, i) {
      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
    }
    function d3_time_parseAmPm(date, string, i) {
      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
      return n == null ? -1 : (date.p = n, i);
    }
    return d3_time_format;
  }
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
  function d3_time_formatPad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_parseWeekdayNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
    return n ? (date.w = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberSunday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.U = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberMonday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.W = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
    return n ? (date.y = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
  }
  function d3_time_parseZone(date, string, i) {
    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
    i + 5) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.d = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseDayOfYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.j = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.H = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.M = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.S = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.L = +n[0], i + n[0].length) : -1;
  }
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  function d3_time_parseLiteralPercent(date, string, i) {
    d3_time_percentRe.lastIndex = 0;
    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function d3_time_formatMulti(formats) {
    var n = formats.length, i = -1;
    while (++i < n) formats[i][0] = this(formats[i][0]);
    return function(date) {
      var i = 0, f = formats[i];
      while (!f[1](date)) f = formats[++i];
      return f[0](date);
    };
  }
  d3.locale = function(locale) {
    return {
      numberFormat: d3_locale_numberFormat(locale),
      timeFormat: d3_locale_timeFormat(locale)
    };
  };
  var d3_locale_enUS = d3.locale({
    decimal: ".",
    thousands: ",",
    grouping: [ 3 ],
    currency: [ "$", "" ],
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: [ "AM", "PM" ],
    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
  });
  d3.format = d3_locale_enUS.numberFormat;
  d3.geo = {};
  function d3_adder() {}
  d3_adder.prototype = {
    s: 0,
    t: 0,
    add: function(y) {
      d3_adderSum(y, this.t, d3_adderTemp);
      d3_adderSum(d3_adderTemp.s, this.s, this);
      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
    },
    reset: function() {
      this.s = this.t = 0;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var d3_adderTemp = new d3_adder();
  function d3_adderSum(a, b, o) {
    var x = o.s = a + b, bv = x - a, av = x - bv;
    o.t = a - av + (b - bv);
  }
  d3.geo.stream = function(object, listener) {
    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      object = object.coordinates;
      listener.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * ;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingSum.reset();
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * d3_geo_areaRingSum;
      d3_geo_areaSum += area < 0 ? 4 *  + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var 00, 00, 0, cos0, sin0;
    d3_geo_area.point = function(, ) {
      d3_geo_area.point = nextPoint;
      0 = (00 = ) * d3_radians, cos0 = Math.cos( = (00 = ) * d3_radians / 2 +  / 4), 
      sin0 = Math.sin();
    };
    function nextPoint(, ) {
       *= d3_radians;
       =  * d3_radians / 2 +  / 4;
      var d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, cos = Math.cos(), sin = Math.sin(), k = sin0 * sin, u = cos0 * cos + k * Math.cos(ad), v = k * sd * Math.sin(ad);
      d3_geo_areaRingSum.add(Math.atan2(v, u));
      0 = , cos0 = cos, sin0 = sin;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(00, 00);
    };
  }
  function d3_geo_cartesian(spherical) {
    var  = spherical[0],  = spherical[1], cos = Math.cos();
    return [ cos * Math.cos(), cos * Math.sin(), Math.sin() ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return abs(a[0] - b[0]) <  && abs(a[1] - b[1]) < ;
  }
  d3.geo.bounds = function() {
    var 0, 0, 1, 1, _, __, __, p0, dSum, ranges, range;
    var bound = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        bound.point = ringPoint;
        bound.lineStart = ringStart;
        bound.lineEnd = ringEnd;
        dSum = 0;
        d3_geo_area.polygonStart();
      },
      polygonEnd: function() {
        d3_geo_area.polygonEnd();
        bound.point = point;
        bound.lineStart = lineStart;
        bound.lineEnd = lineEnd;
        if (d3_geo_areaRingSum < 0) 0 = -(1 = 180), 0 = -(1 = 90); else if (dSum > ) 1 = 90; else if (dSum < -) 0 = -90;
        range[0] = 0, range[1] = 1;
      }
    };
    function point(, ) {
      ranges.push(range = [ 0 = , 1 =  ]);
      if ( < 0) 0 = ;
      if ( > 1) 1 = ;
    }
    function linePoint(, ) {
      var p = d3_geo_cartesian([  * d3_radians,  * d3_radians ]);
      if (p0) {
        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
        d3_geo_cartesianNormalize(inflection);
        inflection = d3_geo_spherical(inflection);
        var d =  - _, s = d > 0 ? 1 : -1, i = inflection[0] * d3_degrees * s, antimeridian = abs(d) > 180;
        if (antimeridian ^ (s * _ < i && i < s * )) {
          var i = inflection[1] * d3_degrees;
          if (i > 1) 1 = i;
        } else if (i = (i + 360) % 360 - 180, antimeridian ^ (s * _ < i && i < s * )) {
          var i = -inflection[1] * d3_degrees;
          if (i < 0) 0 = i;
        } else {
          if ( < 0) 0 = ;
          if ( > 1) 1 = ;
        }
        if (antimeridian) {
          if ( < _) {
            if (angle(0, ) > angle(0, 1)) 1 = ;
          } else {
            if (angle(, 1) > angle(0, 1)) 0 = ;
          }
        } else {
          if (1 >= 0) {
            if ( < 0) 0 = ;
            if ( > 1) 1 = ;
          } else {
            if ( > _) {
              if (angle(0, ) > angle(0, 1)) 1 = ;
            } else {
              if (angle(, 1) > angle(0, 1)) 0 = ;
            }
          }
        }
      } else {
        point(, );
      }
      p0 = p, _ = ;
    }
    function lineStart() {
      bound.point = linePoint;
    }
    function lineEnd() {
      range[0] = 0, range[1] = 1;
      bound.point = point;
      p0 = null;
    }
    function ringPoint(, ) {
      if (p0) {
        var d =  - _;
        dSum += abs(d) > 180 ? d + (d > 0 ? 360 : -360) : d;
      } else __ = , __ = ;
      d3_geo_area.point(, );
      linePoint(, );
    }
    function ringStart() {
      d3_geo_area.lineStart();
    }
    function ringEnd() {
      ringPoint(__, __);
      d3_geo_area.lineEnd();
      if (abs(dSum) > ) 0 = -(1 = 180);
      range[0] = 0, range[1] = 1;
      p0 = null;
    }
    function angle(0, 1) {
      return (1 -= 0) < 0 ? 1 + 360 : 1;
    }
    function compareRanges(a, b) {
      return a[0] - b[0];
    }
    function withinRange(x, range) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    return function(feature) {
      1 = 1 = -(0 = 0 = Infinity);
      ranges = [];
      d3.geo.stream(feature, bound);
      var n = ranges.length;
      if (n) {
        ranges.sort(compareRanges);
        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
          b = ranges[i];
          if (withinRange(b[0], a) || withinRange(b[1], a)) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }
        var best = -Infinity, d;
        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
          b = merged[i];
          if ((d = angle(a[1], b[0])) > best) best = d, 0 = b[0], 1 = a[1];
        }
      }
      ranges = range = null;
      return 0 === Infinity || 0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ 0, 0 ], [ 1, 1 ] ];
    };
  }();
  d3.geo.centroid = function(object) {
    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
    if (m < 2) {
      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
      if (d3_geo_centroidW1 < ) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
      m = x * x + y * y + z * z;
      if (m < 2) return [ NaN, NaN ];
    }
    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
  };
  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
  var d3_geo_centroid = {
    sphere: d3_noop,
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(, ) {
     *= d3_radians;
    var cos = Math.cos( *= d3_radians);
    d3_geo_centroidPointXYZ(cos * Math.cos(), cos * Math.sin(), Math.sin());
  }
  function d3_geo_centroidPointXYZ(x, y, z) {
    ++d3_geo_centroidW0;
    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    d3_geo_centroid.point = function(, ) {
       *= d3_radians;
      var cos = Math.cos( *= d3_radians);
      x0 = cos * Math.cos();
      y0 = cos * Math.sin();
      z0 = Math.sin();
      d3_geo_centroid.point = nextPoint;
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    function nextPoint(, ) {
       *= d3_radians;
      var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  function d3_geo_centroidRingStart() {
    var 00, 00, x0, y0, z0;
    d3_geo_centroid.point = function(, ) {
      00 = , 00 = ;
      d3_geo_centroid.point = nextPoint;
       *= d3_radians;
      var cos = Math.cos( *= d3_radians);
      x0 = cos * Math.cos();
      y0 = cos * Math.sin();
      z0 = Math.sin();
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    d3_geo_centroid.lineEnd = function() {
      nextPoint(00, 00);
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
      d3_geo_centroid.point = d3_geo_centroidPoint;
    };
    function nextPoint(, ) {
       *= d3_radians;
      var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
      d3_geo_centroidX2 += v * cx;
      d3_geo_centroidY2 += v * cy;
      d3_geo_centroidZ2 += v * cz;
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_true() {
    return true;
  }
  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
      a.o = b;
      subject.push(a);
      clip.push(b);
      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
      a.o = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
      clip[i].e = entry = !entry;
    }
    var start = subject[0], points, point;
    while (1) {
      var current = start, isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      listener.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, listener);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, listener);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }
  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
    return function(rotate, listener) {
      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
          if (segments.length) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
          } else if (clipStartInside) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(, ) {
        var point = rotate(, );
        if (pointVisible( = point[0],  = point[1])) listener.point(, );
      }
      function pointLine(, ) {
        var point = rotate(, );
        line.point(point[0], point[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
      function pointRing(, ) {
        ring.push([ ,  ]);
        var point = rotate(, );
        ringListener.point(point[0], point[1]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          var n = segment.length - 1, i = -1, point;
          if (n > 0) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            while (++i < n) listener.point((point = segment[i])[0], point[1]);
            listener.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(, ) {
        line.push([ ,  ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - half -  : half - a[1]) - ((b = b.x)[0] < 0 ? b[1] - half -  : half - b[1]);
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -, - / 2 ]);
  function d3_geo_clipAntimeridianLine(listener) {
    var 0 = NaN, 0 = NaN, s0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(1, 1) {
        var s1 = 1 > 0 ?  : -, d = abs(1 - 0);
        if (abs(d - ) < ) {
          listener.point(0, 0 = (0 + 1) / 2 > 0 ? half : -half);
          listener.point(s0, 0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(s1, 0);
          listener.point(1, 0);
          clean = 0;
        } else if (s0 !== s1 && d >= ) {
          if (abs(0 - s0) < ) 0 -= s0 * ;
          if (abs(1 - s1) < ) 1 -= s1 * ;
          0 = d3_geo_clipAntimeridianIntersect(0, 0, 1, 1);
          listener.point(s0, 0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(s1, 0);
          clean = 0;
        }
        listener.point(0 = 1, 0 = 1);
        s0 = s1;
      },
      lineEnd: function() {
        listener.lineEnd();
        0 = 0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(0, 0, 1, 1) {
    var cos0, cos1, sin0_1 = Math.sin(0 - 1);
    return abs(sin0_1) >  ? Math.atan((Math.sin(0) * (cos1 = Math.cos(1)) * Math.sin(1) - Math.sin(1) * (cos0 = Math.cos(0)) * Math.sin(0)) / (cos0 * cos1 * sin0_1)) : (0 + 1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var ;
    if (from == null) {
       = direction * half;
      listener.point(-, );
      listener.point(0, );
      listener.point(, );
      listener.point(, 0);
      listener.point(, -);
      listener.point(0, -);
      listener.point(-, -);
      listener.point(-, 0);
      listener.point(-, );
    } else if (abs(from[0] - to[0]) > ) {
      var s = from[0] < to[0] ?  : -;
       = direction * s / 2;
      listener.point(-s, );
      listener.point(0, );
      listener.point(s, );
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_pointInPolygon(point, polygon) {
    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
    d3_geo_areaRingSum.reset();
    for (var i = 0, n = polygon.length; i < n; ++i) {
      var ring = polygon[i], m = ring.length;
      if (!m) continue;
      var point0 = ring[0], 0 = point0[0], 0 = point0[1] / 2 +  / 4, sin0 = Math.sin(0), cos0 = Math.cos(0), j = 1;
      while (true) {
        if (j === m) j = 0;
        point = ring[j];
        var  = point[0],  = point[1] / 2 +  / 4, sin = Math.sin(), cos = Math.cos(), d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, antimeridian = ad > , k = sin0 * sin;
        d3_geo_areaRingSum.add(Math.atan2(k * sd * Math.sin(ad), cos0 * cos + k * Math.cos(ad)));
        polarAngle += antimeridian ? d + sd *  : d;
        if (antimeridian ^ 0 >= meridian ^  >= meridian) {
          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
          d3_geo_cartesianNormalize(arc);
          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
          d3_geo_cartesianNormalize(intersection);
          var arc = (antimeridian ^ d >= 0 ? -1 : 1) * d3_asin(intersection[2]);
          if (parallel > arc || parallel === arc && (arc[0] || arc[1])) {
            winding += antimeridian ^ d >= 0 ? 1 : -1;
          }
        }
        if (!j++) break;
        0 = , sin0 = sin, cos0 = cos, point0 = point;
      }
    }
    return (polarAngle < - || polarAngle <  && d3_geo_areaRingSum < -) ^ winding & 1;
  }
  function d3_geo_clipCircle(radius) {
    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > , interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -, radius -  ]);
    function visible(, ) {
      return Math.cos() * Math.cos() > cr;
    }
    function clipLine(listener) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(, ) {
          var point1 = [ ,  ], point2, v = visible(, ), c = smallRadius ? v ? 0 : code(, ) : v ? code( + ( < 0 ?  : -), ) : 0;
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ;
              point1[1] += ;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
              } else {
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
            listener.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b, two) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
      if (t2 < 0) return;
      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      q = d3_geo_spherical(q);
      if (!two) return q;
      var 0 = a[0], 1 = b[0], 0 = a[1], 1 = b[1], z;
      if (1 < 0) z = 0, 0 = 1, 1 = z;
      var  = 1 - 0, polar = abs( - ) < , meridian = polar ||  < ;
      if (!polar && 1 < 0) z = 0, 0 = 1, 1 = z;
      if (meridian ? polar ? 0 + 1 > 0 ^ q[1] < (abs(q[0] - 0) <  ? 0 : 1) : 0 <= q[1] && q[1] <= 1 :  >  ^ (0 <= q[0] && q[0] <= 1)) {
        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
        d3_geo_cartesianAdd(q1, A);
        return [ q, d3_geo_spherical(q1) ];
      }
    }
    function code(, ) {
      var r = smallRadius ? radius :  - radius, code = 0;
      if ( < -r) code |= 1; else if ( > r) code |= 2;
      if ( < -r) code |= 4; else if ( > r) code |= 8;
      return code;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  var d3_geo_clipExtentMAX = 1e9;
  d3.geo.clipExtent = function() {
    var x0, y0, x1, y1, stream, clip, clipExtent = {
      stream: function(output) {
        if (stream) stream.valid = false;
        stream = clip(output);
        stream.valid = true;
        return stream;
      },
      extent: function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
        if (stream) stream.valid = false, stream = null;
        return clipExtent;
      }
    };
    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
  };
  function d3_geo_clipExtent(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
          clean = true;
        },
        polygonEnd: function() {
          listener = listener_;
          segments = d3.merge(segments);
          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
          if (inside || visible) {
            listener.polygonStart();
            if (inside) {
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (visible) {
              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
            }
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function interpolate(from, to, direction, listener) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function pointVisible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (pointVisible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first, clean;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
        var v = pointVisible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var l = {
              a: {
                x: x_,
                y: y_
              },
              b: {
                x: x,
                y: y
              }
            };
            if (clipLine(l)) {
              if (!v_) {
                listener.lineStart();
                listener.point(l.a.x, l.a.y);
              }
              listener.point(l.b.x, l.b.y);
              if (!v) listener.lineEnd();
              clean = false;
            } else if (v) {
              listener.lineStart();
              listener.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return abs(p[0] - x0) <  ? direction > 0 ? 0 : 3 : abs(p[0] - x1) <  ? direction > 0 ? 2 : 1 : abs(p[1] - y0) <  ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      return comparePoints(a.x, b.x);
    }
    function comparePoints(a, b) {
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
  }
  function d3_geo_conic(projectAt) {
    var 0 = 0, 1 =  / 3, m = d3_geo_projectionMutator(projectAt), p = m(0, 1);
    p.parallels = function(_) {
      if (!arguments.length) return [ 0 /  * 180, 1 /  * 180 ];
      return m(0 = _[0] *  / 180, 1 = _[1] *  / 180);
    };
    return p;
  }
  function d3_geo_conicEqualArea(0, 1) {
    var sin0 = Math.sin(0), n = (sin0 + Math.sin(1)) / 2, C = 1 + sin0 * (2 * n - sin0), 0 = Math.sqrt(C) / n;
    function forward(, ) {
      var  = Math.sqrt(C - 2 * n * Math.sin()) / n;
      return [  * Math.sin( *= n), 0 -  * Math.cos() ];
    }
    forward.invert = function(x, y) {
      var 0_y = 0 - y;
      return [ Math.atan2(x, 0_y) / n, d3_asin((C - (x * x + 0_y * 0_y) * n * n) / (2 * n)) ];
    };
    return forward;
  }
  (d3.geo.conicEqualArea = function() {
    return d3_geo_conic(d3_geo_conicEqualArea);
  }).raw = d3_geo_conicEqualArea;
  d3.geo.albers = function() {
    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
  };
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
    var point, pointStream = {
      point: function(x, y) {
        point = [ x, y ];
      }
    }, lower48Point, alaskaPoint, hawaiiPoint;
    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      point = null;
      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
      return point;
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
      return {
        point: function(x, y) {
          lower48Stream.point(x, y);
          alaskaStream.point(x, y);
          hawaiiStream.point(x, y);
        },
        sphere: function() {
          lower48Stream.sphere();
          alaskaStream.sphere();
          hawaiiStream.sphere();
        },
        lineStart: function() {
          lower48Stream.lineStart();
          alaskaStream.lineStart();
          hawaiiStream.lineStart();
        },
        lineEnd: function() {
          lower48Stream.lineEnd();
          alaskaStream.lineEnd();
          hawaiiStream.lineEnd();
        },
        polygonStart: function() {
          lower48Stream.polygonStart();
          alaskaStream.polygonStart();
          hawaiiStream.polygonStart();
        },
        polygonEnd: function() {
          lower48Stream.polygonEnd();
          alaskaStream.polygonEnd();
          hawaiiStream.polygonEnd();
        }
      };
    };
    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_);
      alaska.precision(_);
      hawaii.precision(_);
      return albersUsa;
    };
    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_);
      alaska.scale(_ * .35);
      hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];
      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + , y + .12 * k +  ], [ x - .214 * k - , y + .234 * k -  ] ]).stream(pointStream).point;
      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + , y + .166 * k +  ], [ x - .115 * k - , y + .234 * k -  ] ]).stream(pointStream).point;
      return albersUsa;
    };
    return albersUsa.scale(1070);
  };
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
  var d3_geo_pathBounds = {
    point: d3_geo_pathBoundsPoint,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_pathBoundsPoint(x, y) {
    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathBufferCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathBufferCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    d3_geo_centroidX0 += x;
    d3_geo_centroidY0 += y;
    ++d3_geo_centroidZ0;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      z = y0 * x - x0 * y;
      d3_geo_centroidX2 += z * (x0 + x);
      d3_geo_centroidY2 += z * (y0 + y);
      d3_geo_centroidZ2 += z * 3;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x + pointRadius, y);
      context.arc(x, y, pointRadius, 0, );
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  function d3_geo_resample(project) {
    var 2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
    function resample(stream) {
      return (maxDepth ? resampleRecursive : resampleNone)(stream);
    }
    function resampleNone(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      });
    }
    function resampleRecursive(stream) {
      var 00, 00, x00, y00, a00, b00, c00, 0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(, ) {
        var c = d3_geo_cartesian([ ,  ]), p = project(, );
        resampleLineTo(x0, y0, 0, a0, b0, c0, x0 = p[0], y0 = p[1], 0 = , a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resample.point = ringPoint;
        resample.lineEnd = ringEnd;
      }
      function ringPoint(, ) {
        linePoint(00 = , 00 = ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resample.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x0, y0, 0, a0, b0, c0, x00, y00, 00, a00, b00, c00, maxDepth, stream);
        resample.lineEnd = lineEnd;
        lineEnd();
      }
      return resample;
    }
    function resampleLineTo(x0, y0, 0, a0, b0, c0, x1, y1, 1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * 2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), 2 = Math.asin(c /= m), 2 = abs(abs(c) - 1) <  || abs(0 - 1) <  ? (0 + 1) / 2 : Math.atan2(b, a), p = project(2, 2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > 2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x0, y0, 0, a0, b0, c0, x2, y2, 2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, 2, a, b, c, x1, y1, 1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(2);
      maxDepth = (2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
        d3.geo.stream(object, cacheStream);
      }
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
    };
    path.bounds = function(object) {
      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return reset();
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return reset();
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };
    function reset() {
      cacheStream = null;
      return path;
    }
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(x, y) {
      return project([ x * d3_degrees, y * d3_degrees ]);
    });
    return function(stream) {
      return d3_geo_projectionRadians(resample(stream));
    };
  }
  d3.geo.transform = function(methods) {
    return {
      stream: function(stream) {
        var transform = new d3_geo_transform(stream);
        for (var k in methods) transform[k] = methods[k];
        return transform;
      }
    };
  };
  function d3_geo_transform(stream) {
    this.stream = stream;
  }
  d3_geo_transform.prototype = {
    point: function(x, y) {
      this.stream.point(x, y);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function d3_geo_transformPoint(stream, point) {
    return {
      point: point,
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + x, y - x[1] * k ];
    }), k = 150, x = 480, y = 250,  = 0,  = 0,  = 0,  = 0,  = 0, x, y, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + x, y - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - x) / k, (y - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(output) {
      if (stream) stream.valid = false;
      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
      stream.valid = true;
      return stream;
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
      return invalidate();
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
      return invalidate();
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [  * d3_degrees,  * d3_degrees ];
       = _[0] % 360 * d3_radians;
       = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [  * d3_degrees,  * d3_degrees,  * d3_degrees ];
       = _[0] % 360 * d3_radians;
       = _[1] % 360 * d3_radians;
       = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(, , ), project);
      var center = project(, );
      x = x - center[0] * k;
      y = y + center[1] * k;
      return invalidate();
    }
    function invalidate() {
      if (stream) stream.valid = false, stream = null;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadians(stream) {
    return d3_geo_transformPoint(stream, function(x, y) {
      stream.point(x * d3_radians, y * d3_radians);
    });
  }
  function d3_geo_equirectangular(, ) {
    return [ ,  ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
    return forward;
  };
  function d3_geo_identityRotation(, ) {
    return [  >  ?  -  :  < - ?  +  : ,  ];
  }
  d3_geo_identityRotation.invert = d3_geo_equirectangular;
  function d3_geo_rotation(, , ) {
    return  ?  ||  ? d3_geo_compose(d3_geo_rotation(), d3_geo_rotation(, )) : d3_geo_rotation() :  ||  ? d3_geo_rotation(, ) : d3_geo_identityRotation;
  }
  function d3_geo_forwardRotation() {
    return function(, ) {
      return  += , [  >  ?  -  :  < - ?  +  : ,  ];
    };
  }
  function d3_geo_rotation() {
    var rotation = d3_geo_forwardRotation();
    rotation.invert = d3_geo_forwardRotation(-);
    return rotation;
  }
  function d3_geo_rotation(, ) {
    var cos = Math.cos(), sin = Math.sin(), cos = Math.cos(), sin = Math.sin();
    function rotation(, ) {
      var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos + x * sin;
      return [ Math.atan2(y * cos - k * sin, x * cos - z * sin), d3_asin(k * cos + y * sin) ];
    }
    rotation.invert = function(, ) {
      var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos - y * sin;
      return [ Math.atan2(y * cos + z * sin, x * cos + k * sin), d3_asin(k * cos - x * sin) ];
    };
    return rotation;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radius, precision) {
    var cr = Math.cos(radius), sr = Math.sin(radius);
    return function(from, to, direction, listener) {
      var step = direction * precision;
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * ;
      } else {
        from = radius + direction * ;
        to = radius - .5 * step;
      }
      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ) % (2 * Math.PI);
  }
  d3.geo.distance = function(a, b) {
    var  = (b[0] - a[0]) * d3_radians, 0 = a[1] * d3_radians, 1 = b[1] * d3_radians, sin = Math.sin(), cos = Math.cos(), sin0 = Math.sin(0), cos0 = Math.cos(0), sin1 = Math.sin(1), cos1 = Math.cos(1), t;
    return Math.atan2(Math.sqrt((t = cos1 * sin) * t + (t = cos0 * sin1 - sin0 * cos1 * cos) * t), sin0 * sin1 + cos0 * cos1 * cos);
  };
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return abs(x % DX) > ;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return abs(y % DY) > ;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 +  ], [ 180, 90 -  ] ]).minorExtent([ [ -180, -80 -  ], [ 180, 80 +  ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - , dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - , dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var 0, sin0, cos0;
    d3_geo_length.point = function(, ) {
      0 =  * d3_radians, sin0 = Math.sin( *= d3_radians), cos0 = Math.cos();
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(, ) {
      var sin = Math.sin( *= d3_radians), cos = Math.cos(), t = abs(( *= d3_radians) - 0), cos = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cos * Math.sin(t)) * t + (t = cos0 * sin - sin0 * cos * cos) * t), sin0 * sin + cos0 * cos * cos);
      0 = , sin0 = sin, cos0 = cos;
    }
  }
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(, ) {
      var cos = Math.cos(), cos = Math.cos(), k = scale(cos * cos);
      return [ k * cos * Math.sin(), k * Math.sin() ];
    }
    azimuthal.invert = function(x, y) {
      var  = Math.sqrt(x * x + y * y), c = angle(), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc,  * cosc), Math.asin( && y * sinc / ) ];
    };
    return azimuthal;
  }
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(coscos) {
    return Math.sqrt(2 / (1 + coscos));
  }, function() {
    return 2 * Math.asin( / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(coscos) {
    var c = Math.acos(coscos);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  function d3_geo_conicConformal(0, 1) {
    var cos0 = Math.cos(0), t = function() {
      return Math.tan( / 4 +  / 2);
    }, n = 0 === 1 ? Math.sin(0) : Math.log(cos0 / Math.cos(1)) / Math.log(t(1) / t(0)), F = cos0 * Math.pow(t(0), n) / n;
    if (!n) return d3_geo_mercator;
    function forward(, ) {
      if (F > 0) {
        if ( < -half + )  = -half + ;
      } else {
        if ( > half - )  = half - ;
      }
      var  = F / Math.pow(t(), n);
      return [  * Math.sin(n * ), F -  * Math.cos(n * ) ];
    }
    forward.invert = function(x, y) {
      var 0_y = F - y,  = d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y);
      return [ Math.atan2(x, 0_y) / n, 2 * Math.atan(Math.pow(F / , 1 / n)) - half ];
    };
    return forward;
  }
  (d3.geo.conicConformal = function() {
    return d3_geo_conic(d3_geo_conicConformal);
  }).raw = d3_geo_conicConformal;
  function d3_geo_conicEquidistant(0, 1) {
    var cos0 = Math.cos(0), n = 0 === 1 ? Math.sin(0) : (cos0 - Math.cos(1)) / (1 - 0), G = cos0 / n + 0;
    if (abs(n) < ) return d3_geo_equirectangular;
    function forward(, ) {
      var  = G - ;
      return [  * Math.sin(n * ), G -  * Math.cos(n * ) ];
    }
    forward.invert = function(x, y) {
      var 0_y = G - y;
      return [ Math.atan2(x, 0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y) ];
    };
    return forward;
  }
  (d3.geo.conicEquidistant = function() {
    return d3_geo_conic(d3_geo_conicEquidistant);
  }).raw = d3_geo_conicEquidistant;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(coscos) {
    return 1 / coscos;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  function d3_geo_mercator(, ) {
    return [ , Math.log(Math.tan( / 4 +  / 2)) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ x, 2 * Math.atan(Math.exp(y)) - half ];
  };
  function d3_geo_mercatorProjection(project) {
    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
    m.scale = function() {
      var v = scale.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.translate = function() {
      var v = translate.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.clipExtent = function(_) {
      var v = clipExtent.apply(m, arguments);
      if (v === m) {
        if (clipAuto = _ == null) {
          var k =  * scale(), t = translate();
          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
        }
      } else if (clipAuto) {
        v = null;
      }
      return v;
    };
    return m.clipExtent(null);
  }
  (d3.geo.mercator = function() {
    return d3_geo_mercatorProjection(d3_geo_mercator);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  var d3_geo_stereographic = d3_geo_azimuthal(function(coscos) {
    return 1 / (1 + coscos);
  }, function() {
    return 2 * Math.atan();
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_transverseMercator(, ) {
    return [ Math.log(Math.tan( / 4 +  / 2)), - ];
  }
  d3_geo_transverseMercator.invert = function(x, y) {
    return [ -y, 2 * Math.atan(Math.exp(x)) - half ];
  };
  (d3.geo.transverseMercator = function() {
    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
    projection.center = function(_) {
      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
    };
    projection.rotate = function(_) {
      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
      [ _[0], _[1], _[2] - 90 ]);
    };
    return rotate([ 0, 0, 90 ]);
  }).raw = d3_geo_transverseMercator;
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
      for (i = 0; i < n; i++) {
        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
      }
      points.sort(d3_geom_hullOrder);
      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
      return polygon;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullUpper(points) {
    var n = points.length, hull = [ 0, 1 ], hs = 2;
    for (var i = 2; i < n; i++) {
      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
      hull[hs++] = i;
    }
    return hull.slice(0, hs);
  }
  function d3_geom_hullOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) <  && abs(y - lArc.circle.cy) < ) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) <  && abs(y - rArc.circle.cy) < ) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > ) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > ) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) >  || abs(y3 - y2) > ) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) <  && y1 - y3 >  ? {
            x: x0,
            y: abs(x2 - x0) <  ? y2 : y1
          } : abs(y3 - y1) <  && x1 - x3 >  ? {
            x: abs(y2 - y1) <  ? x2 : x1,
            y: y1
          } : abs(x3 - x1) <  && y3 - y0 >  ? {
            x: x1,
            y: abs(x2 - x1) <  ? y2 : y0
          } : abs(y3 - y0) <  && x3 - x0 >  ? {
            x: abs(y2 - y0) <  ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) <  && abs(e.a.y - e.b.y) < ) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / ) * ,
          y: Math.round(fy(d, i) / ) * ,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = xm; else x2 = xm;
        if (below) y1 = ym; else y2 = ym;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      root.find = function(point) {
        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
    var minDistance2 = Infinity, closestPoint;
    (function find(node, x1, y1, x2, y2) {
      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
      if (point = node.point) {
        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
        if (distance2 < minDistance2) {
          var distance = Math.sqrt(minDistance2 = distance2);
          x0 = x - distance, y0 = y - distance;
          x3 = x + distance, y3 = y + distance;
          closestPoint = point;
        }
      }
      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
        if (node = children[i & 3]) switch (i & 3) {
         case 0:
          find(node, x1, y1, xm, ym);
          break;

         case 1:
          find(node, xm, y1, x2, ym);
          break;

         case 2:
          find(node, x1, ym, xm, y2);
          break;

         case 3:
          find(node, xm, ym, x2, y2);
          break;
        }
      }
    })(root, x0, y0, x3, y3);
    return closestPoint;
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    a = +a, b = +b;
    return function(t) {
      return a * (1 - t) + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm; else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({
          i: i,
          x: d3_interpolateNumber(am, bm)
        });
      }
      bi = d3_interpolate_numberB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
      return b(t) + "";
    }) : function() {
      return b;
    } : (b = q.length, function(t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  }
  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * half);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p /  * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) *  / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransformPop(s) {
    return s.length ? s.pop() + "," : "";
  }
  function d3_interpolateTranslate(ta, tb, s, q) {
    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
      var i = s.push("translate(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    }
  }
  function d3_interpolateRotate(ra, rb, s, q) {
    if (ra !== rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
    }
  }
  function d3_interpolateSkew(wa, wb, s, q) {
    if (wa !== wb) {
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
    }
  }
  function d3_interpolateScale(ka, kb, s, q) {
    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
      var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] !== 1 || kb[1] !== 1) {
      s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
    }
  }
  function d3_interpolateTransform(a, b) {
    var s = [], q = [];
    a = d3.transform(a), b = d3.transform(b);
    d3_interpolateTranslate(a.translate, b.translate, s, q);
    d3_interpolateRotate(a.rotate, b.rotate, s, q);
    d3_interpolateSkew(a.skew, b.skew, s, q);
    d3_interpolateScale(a.scale, b.scale, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return (x - a) / b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) / b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = ( - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: groupSums[di]
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
          if (dw * dw / theta2 < dn) {
            if (dn < chargeDistance2) {
              var k = quad.charge / dn;
              node.px -= dx * k;
              node.py -= dy * k;
            }
            return true;
          }
          if (quad.point && dn && dn < chargeDistance2) {
            var k = quad.pointCharge / dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        timer = null;
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.chargeDistance = function(x) {
      if (!arguments.length) return Math.sqrt(chargeDistance2);
      chargeDistance2 = x * x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return Math.sqrt(theta2);
      theta2 = x * x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) {
          alpha = x;
        } else {
          timer.c = null, timer.t = NaN, timer = null;
          event.end({
            type: "end",
            alpha: alpha = 0
          });
        }
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        timer = d3_timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, l = candidates.length, x;
        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function hierarchy(root) {
      var stack = [ root ], nodes = [], node;
      root.depth = 0;
      while ((node = stack.pop()) != null) {
        nodes.push(node);
        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
          var n, childs, child;
          while (--n >= 0) {
            stack.push(child = childs[n]);
            child.parent = node;
            child.depth = node.depth + 1;
          }
          if (value) node.value = 0;
          node.children = childs;
        } else {
          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
          delete node.children;
        }
      }
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var childs, parent;
        if (sort && (childs = node.children)) childs.sort(sort);
        if (value && (parent = node.parent)) parent.value += node.value;
      });
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      if (value) {
        d3_layout_hierarchyVisitBefore(root, function(node) {
          if (node.children) node.value = 0;
        });
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var parent;
          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
          if (parent = node.parent) parent.value += node.value;
        });
      }
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyVisitBefore(node, callback) {
    var nodes = [ node ];
    while ((node = nodes.pop()) != null) {
      callback(node);
      if ((children = node.children) && (n = children.length)) {
        var n, children;
        while (--n >= 0) nodes.push(children[n]);
      }
    }
  }
  function d3_layout_hierarchyVisitAfter(node, callback) {
    var nodes = [ node ], nodes2 = [];
    while ((node = nodes.pop()) != null) {
      nodes2.push(node);
      if ((children = node.children) && (n = children.length)) {
        var i = -1, n, children;
        while (++i < n) nodes.push(children[i]);
      }
    }
    while ((node = nodes2.pop()) != null) {
      callback(node);
    }
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = , padAngle = 0;
    function pie(data) {
      var n = data.length, values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      index.forEach(function(i) {
        arcs[i] = {
          data: data[i],
          value: v = values[i],
          startAngle: a,
          endAngle: a += v * k + pa,
          padAngle: p
        };
      });
      return arcs;
    }
    pie.value = function(_) {
      if (!arguments.length) return value;
      value = _;
      return pie;
    };
    pie.sort = function(_) {
      if (!arguments.length) return sort;
      sort = _;
      return pie;
    };
    pie.startAngle = function(_) {
      if (!arguments.length) return startAngle;
      startAngle = _;
      return pie;
    };
    pie.endAngle = function(_) {
      if (!arguments.length) return endAngle;
      endAngle = _;
      return pie;
    };
    pie.padAngle = function(_) {
      if (!arguments.length) return padAngle;
      padAngle = _;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      if (!(n = data.length)) return data;
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var m = series[0].length, n, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_hierarchyVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
      d3_layout_hierarchyVisitBefore(root1, secondWalk);
      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
        var left = root0, right = root0, bottom = root0;
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return nodes;
    }
    function wrapTree(root0) {
      var root1 = {
        A: null,
        children: [ root0 ]
      }, queue = [ root1 ], node1;
      while ((node1 = queue.pop()) != null) {
        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
          queue.push((children[i] = child = {
            _: children[i],
            parent: node1,
            children: (child = children[i].children) && child.slice() || [],
            A: null,
            a: null,
            z: 0,
            m: 0,
            c: 0,
            s: 0,
            t: null,
            i: i
          }).a = child);
        }
      }
      return root1.children[0];
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children.length) {
        d3_layout_treeShift(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= size[0];
      node.y = node.depth * size[1];
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null ? sizeNode : null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) == null ? null : sizeNode;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(v) {
    var children = v.children;
    return children.length ? children[0] : v.t;
  }
  function d3_layout_treeRight(v) {
    var children = v.children, n;
    return (n = children.length) ? children[n - 1] : v.t;
  }
  function d3_layout_treeMove(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function d3_layout_treeShift(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function d3_layout_treeAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = root.y = 0;
      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(, ) {
      var n = arguments.length;
      if (n < 2)  = 1;
      if (n < 1)  = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return  +  * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    return domain;
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m, format) {
    var range = d3_scale_linearTickRange(domain, m);
    if (format) {
      var match = d3_format_re.exec(format);
      match.shift();
      if (match[8] === "s") {
        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
        match[8] = "f";
        format = d3.format(match.join(""));
        return function(d) {
          return format(prefix.scale(d)) + prefix.symbol;
        };
      }
      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
      format = match.join("");
    } else {
      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
    }
    return d3.format(format);
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (!arguments.length) return d3_scale_logFormat;
      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
      var k = Math.max(1, base * n / scale.ticks().length);
      return function(d) {
        var i = d / pow(Math.round(log(d)));
        if (i * base < base - .5) i *= base;
        return i <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
      0) : (stop - start) / (domain.length - 1 + padding);
      range = steps(start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundPoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
      0) : (stop - start) / (domain.length - 1 + padding) | 0;
      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
      rangeBand = 0;
      ranger = {
        t: "rangeRoundPoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  function d3_zero() {
    return 0;
  }
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
    function arc() {
      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - half, a1 = endAngle.apply(this, arguments) - half, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
      if (da >= ) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
        if (!cw) p1 *= -1;
        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
      }
      if (r1) {
        x0 = r1 * Math.cos(a0 + p1);
        y0 = r1 * Math.sin(a0 + p1);
        x1 = r1 * Math.cos(a1 - p1);
        y1 = r1 * Math.sin(a1 - p1);
        var l1 = Math.abs(a1 - a0 - 2 * p1) <=  ? 0 : 1;
        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
          var h1 = (a0 + a1) / 2;
          x0 = r1 * Math.cos(h1);
          y0 = r1 * Math.sin(h1);
          x1 = y1 = null;
        }
      } else {
        x0 = y0 = 0;
      }
      if (r0) {
        x2 = r0 * Math.cos(a1 - p0);
        y2 = r0 * Math.sin(a1 - p0);
        x3 = r0 * Math.cos(a0 + p0);
        y3 = r0 * Math.sin(a0 + p0);
        var l0 = Math.abs(a0 - a1 + 2 * p0) <=  ? 0 : 1;
        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
          var h0 = (a0 + a1) / 2;
          x2 = r0 * Math.cos(h0);
          y2 = r0 * Math.sin(h0);
          x3 = y3 = null;
        }
      } else {
        x2 = y2 = 0;
      }
      if (da >  && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
        cr = r0 < r1 ^ cw ? 0 : 1;
        var rc1 = rc, rc0 = rc;
        if (da < ) {
          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
        }
        if (x1 != null) {
          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
          if (rc === rc1) {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
          } else {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
          }
        } else {
          path.push("M", x0, ",", y0);
        }
        if (x3 != null) {
          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
          if (rc === rc0) {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          } else {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          }
        } else {
          path.push("L", x2, ",", y2);
        }
      } else {
        path.push("M", x0, ",", y0);
        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
        path.push("L", x2, ",", y2);
        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
      }
      path.push("Z");
      return path.join("");
    }
    function circleSegment(r1, cw) {
      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.cornerRadius = function(v) {
      if (!arguments.length) return cornerRadius;
      cornerRadius = d3_functor(v);
      return arc;
    };
    arc.padRadius = function(v) {
      if (!arguments.length) return padRadius;
      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.padAngle = function(v) {
      if (!arguments.length) return padAngle;
      padAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - half;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcAuto = "auto";
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_arcPadAngle(d) {
    return d && d.padAngle;
  }
  function d3_svg_arcSweep(x0, y0, x1, y1) {
    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
  }
  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.length > 1 ? points.join("L") : points + "Z";
  }
  function d3_svg_lineLinearClosed(points) {
    return points.join("L") + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < ) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] - half;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - half, a1 = endAngle.call(self, subgroup, i) - half;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > ) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] - half;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / );
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3_selectionPrototype.transition = function(name) {
    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_selectionPrototype.interrupt = function(name) {
    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
  };
  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
  function d3_selection_interruptNS(ns) {
    return function() {
      var lock, activeId, active;
      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
        active.timer.c = null;
        active.timer.t = NaN;
        if (--lock.count) delete lock[activeId]; else delete this[ns];
        lock.active += .5;
        active.event && active.event.interrupt.call(this, this.__data__, active.index);
      }
    };
  }
  function d3_transition(groups, ns, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.namespace = ns;
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection, name) {
    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node[ns][id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.namespace, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node[ns][id].tween.remove(name);
    } : function(node) {
      node[ns][id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id, ns = groups.namespace;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node[ns][id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    var ns = this.namespace;
    return this.each("end.transition", function() {
      var p;
      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node[ns][id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].delay;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node[ns][id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].duration;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node[ns][id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      try {
        d3_transitionInheritId = id;
        d3_selection_each(this, function(node, i, j) {
          d3_transitionInherit = node[ns][id];
          type.call(node, node.__data__, i, j);
        });
      } finally {
        d3_transitionInherit = inherit;
        d3_transitionInheritId = inheritId;
      }
    } else {
      d3_selection_each(this, function(node) {
        var transition = node[ns][id];
        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = node[ns][id0];
          d3_transitionNode(node, i, ns, id1, {
            time: transition.time,
            ease: transition.ease,
            delay: transition.delay + transition.duration,
            duration: transition.duration
          });
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id1);
  };
  function d3_transitionNamespace(name) {
    return name == null ? "__transition__" : "__transition_" + name + "__";
  }
  function d3_transitionNode(node, i, ns, id, inherit) {
    var lock = node[ns] || (node[ns] = {
      active: 0,
      count: 0
    }), transition = lock[id], time, timer, duration, ease, tweens;
    function schedule(elapsed) {
      var delay = transition.delay;
      timer.t = delay + time;
      if (delay <= elapsed) return start(elapsed - delay);
      timer.c = start;
    }
    function start(elapsed) {
      var activeId = lock.active, active = lock[activeId];
      if (active) {
        active.timer.c = null;
        active.timer.t = NaN;
        --lock.count;
        delete lock[activeId];
        active.event && active.event.interrupt.call(node, node.__data__, active.index);
      }
      for (var cancelId in lock) {
        if (+cancelId < id) {
          var cancel = lock[cancelId];
          cancel.timer.c = null;
          cancel.timer.t = NaN;
          --lock.count;
          delete lock[cancelId];
        }
      }
      timer.c = tick;
      d3_timer(function() {
        if (timer.c && tick(elapsed || 1)) {
          timer.c = null;
          timer.t = NaN;
        }
        return 1;
      }, 0, time);
      lock.active = id;
      transition.event && transition.event.start.call(node, node.__data__, i);
      tweens = [];
      transition.tween.forEach(function(key, value) {
        if (value = value.call(node, node.__data__, i)) {
          tweens.push(value);
        }
      });
      ease = transition.ease;
      duration = transition.duration;
    }
    function tick(elapsed) {
      var t = elapsed / duration, e = ease(t), n = tweens.length;
      while (n > 0) {
        tweens[--n].call(node, e);
      }
      if (t >= 1) {
        transition.event && transition.event.end.call(node, node.__data__, i);
        if (--lock.count) delete lock[id]; else delete node[ns];
        return 1;
      }
    }
    if (!transition) {
      time = inherit.time;
      timer = d3_timer(schedule, 0, time);
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        timer: timer,
        delay: inherit.delay,
        duration: inherit.duration,
        ease: inherit.ease,
        index: i
      };
      inherit = null;
      ++lock.count;
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ), tickExit = d3.transition(tick.exit()).style("opacity", ).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
        if (orient === "bottom" || orient === "top") {
          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
        } else {
          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
        }
        lineEnter.attr(y2, sign * innerTickSize);
        textEnter.attr(y1, sign * tickSpacing);
        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1, scale0);
        }
        tickEnter.call(tickTransform, scale0, scale1);
        tickUpdate.call(tickTransform, scale1, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = d3_array(arguments);
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x0, x1) {
    selection.attr("transform", function(d) {
      var v0 = x0(d);
      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y0, y1) {
    selection.attr("transform", function(d) {
      var v0 = y0(d);
      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
  var d3_time_formatUtc = d3_time_format.utc;
  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3_time.second = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3_time.seconds = d3_time.second.range;
  d3_time.seconds.utc = d3_time.second.utc.range;
  d3_time.minute = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3_time.minutes = d3_time.minute.range;
  d3_time.minutes.utc = d3_time.minute.utc.range;
  d3_time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3_time.hours = d3_time.hour.range;
  d3_time.hours.utc = d3_time.hour.utc.range;
  d3_time.month = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3_time.months = d3_time.month.range;
  d3_time.months.utc = d3_time.month.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    function tickMethod(extent, count) {
      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
        return d / 31536e6;
      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
    }
    scale.nice = function(interval, skip) {
      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
      if (method) interval = method[0], skip = method[1];
      function skipped(date) {
        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
      }
      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
        floor: function(date) {
          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
          return date;
        },
        ceil: function(date) {
          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
          return date;
        }
      } : interval));
    };
    scale.ticks = function(interval, skip) {
      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
        range: interval
      }, skip ];
      if (method) interval = method[0], skip = method[1];
      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
    return d.getMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getMinutes();
  } ], [ "%I %p", function(d) {
    return d.getHours();
  } ], [ "%a %d", function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getDate() != 1;
  } ], [ "%B", function(d) {
    return d.getMonth();
  } ], [ "%Y", d3_true ] ]);
  var d3_time_scaleMilliseconds = {
    range: function(start, stop, step) {
      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
    },
    floor: d3_identity,
    ceil: d3_identity
  };
  d3_time_scaleLocalMethods.year = d3_time.year;
  d3_time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
    return d.getUTCMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getUTCSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getUTCMinutes();
  } ], [ "%I %p", function(d) {
    return d.getUTCHours();
  } ], [ "%a %d", function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getUTCDate() != 1;
  } ], [ "%B", function(d) {
    return d.getUTCMonth();
  } ], [ "%Y", d3_true ] ]);
  d3_time_scaleUtcMethods.year = d3_time.year.utc;
  d3_time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
  };
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
  if (true) this.d3 = d3, !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else {}
}();

/***/ }),

/***/ "../../../node_modules/jquery-circle-progress/dist/circle-progress.js":
/*!******************************************************************************************!*\
  !*** /Users/flex/Lab/tabler/node_modules/jquery-circle-progress/dist/circle-progress.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * jquery-circle-progress - jQuery Plugin to draw animated circular progress bars:
 * {@link http://kottenator.github.io/jquery-circle-progress/}
 *
 * @author Rostyslav Bryzgunov <kottenator@gmail.com>
 * @version 1.2.2
 * @licence MIT
 * @preserve
 */
// UMD factory - https://github.com/umdjs/umd/blob/d31bb6ee7098715e019f52bdfe27b3e4bfd2b97e/templates/jqueryPlugin.js
// Uses AMD, CommonJS or browser globals to create a jQuery plugin.
(function(factory) {
  if (true) {
    // AMD - register as an anonymous module
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var $; }
})(function($) {
  /**
   * Inner implementation of the circle progress bar.
   * The class is not exposed _yet_ but you can create an instance through jQuery method call.
   *
   * @param {object} config - You can customize any class member (property or method).
   * @class
   * @alias CircleProgress
   */
  function CircleProgress(config) {
    this.init(config);
  }

  CircleProgress.prototype = {
    //--------------------------------------- public options ---------------------------------------
    /**
     * This is the only required option. It should be from `0.0` to `1.0`.
     * @type {number}
     * @default 0.0
     */
    value: 0.0,

    /**
     * Size of the canvas in pixels.
     * It's a square so we need only one dimension.
     * @type {number}
     * @default 100.0
     */
    size: 100.0,

    /**
     * Initial angle for `0.0` value in radians.
     * @type {number}
     * @default -Math.PI
     */
    startAngle: -Math.PI,

    /**
     * Width of the arc in pixels.
     * If it's `'auto'` - the value is calculated as `[this.size]{@link CircleProgress#size} / 14`.
     * @type {number|string}
     * @default 'auto'
     */
    thickness: 'auto',

    /**
     * Fill of the arc. You may set it to:
     *
     *   - solid color:
     *     - `'#3aeabb'`
     *     - `{ color: '#3aeabb' }`
     *     - `{ color: 'rgba(255, 255, 255, .3)' }`
     *   - linear gradient _(left to right)_:
     *     - `{ gradient: ['#3aeabb', '#fdd250'], gradientAngle: Math.PI / 4 }`
     *     - `{ gradient: ['red', 'green', 'blue'], gradientDirection: [x0, y0, x1, y1] }`
     *     - `{ gradient: [["red", .2], ["green", .3], ["blue", .8]] }`
     *   - image:
     *     - `{ image: 'http://i.imgur.com/pT0i89v.png' }`
     *     - `{ image: imageObject }`
     *     - `{ color: 'lime', image: 'http://i.imgur.com/pT0i89v.png' }` -
     *       color displayed until the image is loaded
     *
     * @default {gradient: ['#3aeabb', '#fdd250']}
     */
    fill: {
      gradient: ['#3aeabb', '#fdd250']
    },

    /**
     * Color of the "empty" arc. Only a color fill supported by now.
     * @type {string}
     * @default 'rgba(0, 0, 0, .1)'
     */
    emptyFill: 'rgba(0, 0, 0, .1)',

    /**
     * jQuery Animation config.
     * You can pass `false` to disable the animation.
     * @see http://api.jquery.com/animate/
     * @type {object|boolean}
     * @default {duration: 1200, easing: 'circleProgressEasing'}
     */
    animation: {
      duration: 1200,
      easing: 'circleProgressEasing'
    },

    /**
     * Default animation starts at `0.0` and ends at specified `value`. Let's call this _direct animation_.
     * If you want to make _reversed animation_ - set `animationStartValue: 1.0`.
     * Also you may specify any other value from `0.0` to `1.0`.
     * @type {number}
     * @default 0.0
     */
    animationStartValue: 0.0,

    /**
     * Reverse animation and arc draw.
     * By default, the arc is filled from `0.0` to `value`, _clockwise_.
     * With `reverse: true` the arc is filled from `1.0` to `value`, _counter-clockwise_.
     * @type {boolean}
     * @default false
     */
    reverse: false,

    /**
     * Arc line cap: `'butt'`, `'round'` or `'square'` -
     * [read more]{@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.lineCap}.
     * @type {string}
     * @default 'butt'
     */
    lineCap: 'butt',

    /**
     * Canvas insertion mode: append or prepend it into the parent element?
     * @type {string}
     * @default 'prepend'
     */
    insertMode: 'prepend',

    //------------------------------ protected properties and methods ------------------------------
    /**
     * Link to {@link CircleProgress} constructor.
     * @protected
     */
    constructor: CircleProgress,

    /**
     * Container element. Should be passed into constructor config.
     * @protected
     * @type {jQuery}
     */
    el: null,

    /**
     * Canvas element. Automatically generated and prepended to [this.el]{@link CircleProgress#el}.
     * @protected
     * @type {HTMLCanvasElement}
     */
    canvas: null,

    /**
     * 2D-context of [this.canvas]{@link CircleProgress#canvas}.
     * @protected
     * @type {CanvasRenderingContext2D}
     */
    ctx: null,

    /**
     * Radius of the outer circle. Automatically calculated as `[this.size]{@link CircleProgress#size} / 2`.
     * @protected
     * @type {number}
     */
    radius: 0.0,

    /**
     * Fill of the main arc. Automatically calculated, depending on [this.fill]{@link CircleProgress#fill} option.
     * @protected
     * @type {string|CanvasGradient|CanvasPattern}
     */
    arcFill: null,

    /**
     * Last rendered frame value.
     * @protected
     * @type {number}
     */
    lastFrameValue: 0.0,

    /**
     * Init/re-init the widget.
     *
     * Throws a jQuery event:
     *
     * - `circle-inited(jqEvent)`
     *
     * @param {object} config - You can customize any class member (property or method).
     */
    init: function(config) {
      $.extend(this, config);
      this.radius = this.size / 2;
      this.initWidget();
      this.initFill();
      this.draw();
      this.el.trigger('circle-inited');
    },

    /**
     * Initialize `<canvas>`.
     * @protected
     */
    initWidget: function() {
      if (!this.canvas)
        this.canvas = $('<canvas>')[this.insertMode == 'prepend' ? 'prependTo' : 'appendTo'](this.el)[0];

      var canvas = this.canvas;
      canvas.width = this.size;
      canvas.height = this.size;
      this.ctx = canvas.getContext('2d');

      if (window.devicePixelRatio > 1) {
        var scaleBy = window.devicePixelRatio;
        canvas.style.width = canvas.style.height = this.size + 'px';
        canvas.width = canvas.height = this.size * scaleBy;
        this.ctx.scale(scaleBy, scaleBy);
      }
    },

    /**
     * This method sets [this.arcFill]{@link CircleProgress#arcFill}.
     * It could do this async (on image load).
     * @protected
     */
    initFill: function() {
      var self = this,
        fill = this.fill,
        ctx = this.ctx,
        size = this.size;

      if (!fill)
        throw Error("The fill is not specified!");

      if (typeof fill == 'string')
        fill = {color: fill};

      if (fill.color)
        this.arcFill = fill.color;

      if (fill.gradient) {
        var gr = fill.gradient;

        if (gr.length == 1) {
          this.arcFill = gr[0];
        } else if (gr.length > 1) {
          var ga = fill.gradientAngle || 0, // gradient direction angle; 0 by default
            gd = fill.gradientDirection || [
                size / 2 * (1 - Math.cos(ga)), // x0
                size / 2 * (1 + Math.sin(ga)), // y0
                size / 2 * (1 + Math.cos(ga)), // x1
                size / 2 * (1 - Math.sin(ga))  // y1
              ];

          var lg = ctx.createLinearGradient.apply(ctx, gd);

          for (var i = 0; i < gr.length; i++) {
            var color = gr[i],
              pos = i / (gr.length - 1);

            if ($.isArray(color)) {
              pos = color[1];
              color = color[0];
            }

            lg.addColorStop(pos, color);
          }

          this.arcFill = lg;
        }
      }

      if (fill.image) {
        var img;

        if (fill.image instanceof Image) {
          img = fill.image;
        } else {
          img = new Image();
          img.src = fill.image;
        }

        if (img.complete)
          setImageFill();
        else
          img.onload = setImageFill;
      }

      function setImageFill() {
        var bg = $('<canvas>')[0];
        bg.width = self.size;
        bg.height = self.size;
        bg.getContext('2d').drawImage(img, 0, 0, size, size);
        self.arcFill = self.ctx.createPattern(bg, 'no-repeat');
        self.drawFrame(self.lastFrameValue);
      }
    },

    /**
     * Draw the circle.
     * @protected
     */
    draw: function() {
      if (this.animation)
        this.drawAnimated(this.value);
      else
        this.drawFrame(this.value);
    },

    /**
     * Draw a single animation frame.
     * @protected
     * @param {number} v - Frame value.
     */
    drawFrame: function(v) {
      this.lastFrameValue = v;
      this.ctx.clearRect(0, 0, this.size, this.size);
      this.drawEmptyArc(v);
      this.drawArc(v);
    },

    /**
     * Draw the arc (part of the circle).
     * @protected
     * @param {number} v - Frame value.
     */
    drawArc: function(v) {
      if (v === 0)
        return;

      var ctx = this.ctx,
        r = this.radius,
        t = this.getThickness(),
        a = this.startAngle;

      ctx.save();
      ctx.beginPath();

      if (!this.reverse) {
        ctx.arc(r, r, r - t / 2, a, a + Math.PI * 2 * v);
      } else {
        ctx.arc(r, r, r - t / 2, a - Math.PI * 2 * v, a);
      }

      ctx.lineWidth = t;
      ctx.lineCap = this.lineCap;
      ctx.strokeStyle = this.arcFill;
      ctx.stroke();
      ctx.restore();
    },

    /**
     * Draw the _empty (background)_ arc (part of the circle).
     * @protected
     * @param {number} v - Frame value.
     */
    drawEmptyArc: function(v) {
      var ctx = this.ctx,
        r = this.radius,
        t = this.getThickness(),
        a = this.startAngle;

      if (v < 1) {
        ctx.save();
        ctx.beginPath();

        if (v <= 0) {
          ctx.arc(r, r, r - t / 2, 0, Math.PI * 2);
        } else {
          if (!this.reverse) {
            ctx.arc(r, r, r - t / 2, a + Math.PI * 2 * v, a);
          } else {
            ctx.arc(r, r, r - t / 2, a, a - Math.PI * 2 * v);
          }
        }

        ctx.lineWidth = t;
        ctx.strokeStyle = this.emptyFill;
        ctx.stroke();
        ctx.restore();
      }
    },

    /**
     * Animate the progress bar.
     *
     * Throws 3 jQuery events:
     *
     * - `circle-animation-start(jqEvent)`
     * - `circle-animation-progress(jqEvent, animationProgress, stepValue)` - multiple event
     *   animationProgress: from `0.0` to `1.0`; stepValue: from `0.0` to `value`
     * - `circle-animation-end(jqEvent)`
     *
     * @protected
     * @param {number} v - Final value.
     */
    drawAnimated: function(v) {
      var self = this,
        el = this.el,
        canvas = $(this.canvas);

      // stop previous animation before new "start" event is triggered
      canvas.stop(true, false);
      el.trigger('circle-animation-start');

      canvas
        .css({animationProgress: 0})
        .animate({animationProgress: 1}, $.extend({}, this.animation, {
          step: function(animationProgress) {
            var stepValue = self.animationStartValue * (1 - animationProgress) + v * animationProgress;
            self.drawFrame(stepValue);
            el.trigger('circle-animation-progress', [animationProgress, stepValue]);
          }
        }))
        .promise()
        .always(function() {
          // trigger on both successful & failure animation end
          el.trigger('circle-animation-end');
        });
    },

    /**
     * Get the circle thickness.
     * @see CircleProgress#thickness
     * @protected
     * @returns {number}
     */
    getThickness: function() {
      return $.isNumeric(this.thickness) ? this.thickness : this.size / 14;
    },

    /**
     * Get current value.
     * @protected
     * @return {number}
     */
    getValue: function() {
      return this.value;
    },

    /**
     * Set current value (with smooth animation transition).
     * @protected
     * @param {number} newValue
     */
    setValue: function(newValue) {
      if (this.animation)
        this.animationStartValue = this.lastFrameValue;
      this.value = newValue;
      this.draw();
    }
  };

  //----------------------------------- Initiating jQuery plugin -----------------------------------
  $.circleProgress = {
    // Default options (you may override them)
    defaults: CircleProgress.prototype
  };

  // ease-in-out-cubic
  $.easing.circleProgressEasing = function(x) {
    if (x < 0.5) {
      x = 2 * x;
      return 0.5 * x * x * x;
    } else {
      x = 2 - 2 * x;
      return 1 - 0.5 * x * x * x;
    }
  };

  /**
   * Creates an instance of {@link CircleProgress}.
   * Produces [init event]{@link CircleProgress#init} and [animation events]{@link CircleProgress#drawAnimated}.
   *
   * @param {object} [configOrCommand] - Config object or command name.
   *
   * Config example (you can specify any {@link CircleProgress} property):
   *
   * ```js
   * { value: 0.75, size: 50, animation: false }
   * ```
   *
   * Commands:
   *
   * ```js
   * el.circleProgress('widget'); // get the <canvas>
   * el.circleProgress('value'); // get the value
   * el.circleProgress('value', newValue); // update the value
   * el.circleProgress('redraw'); // redraw the circle
   * el.circleProgress(); // the same as 'redraw'
   * ```
   *
   * @param {string} [commandArgument] - Some commands (like `'value'`) may require an argument.
   * @see CircleProgress
   * @alias "$(...).circleProgress"
   */
  $.fn.circleProgress = function(configOrCommand, commandArgument) {
    var dataName = 'circle-progress',
      firstInstance = this.data(dataName);

    if (configOrCommand == 'widget') {
      if (!firstInstance)
        throw Error('Calling "widget" method on not initialized instance is forbidden');
      return firstInstance.canvas;
    }

    if (configOrCommand == 'value') {
      if (!firstInstance)
        throw Error('Calling "value" method on not initialized instance is forbidden');
      if (typeof commandArgument == 'undefined') {
        return firstInstance.getValue();
      } else {
        var newValue = arguments[1];
        return this.each(function() {
          $(this).data(dataName).setValue(newValue);
        });
      }
    }

    return this.each(function() {
      var el = $(this),
        instance = el.data(dataName),
        config = $.isPlainObject(configOrCommand) ? configOrCommand : {};

      if (instance) {
        instance.init(config);
      } else {
        var initialConfig = $.extend({}, el.data());
        if (typeof initialConfig.fill == 'string')
          initialConfig.fill = JSON.parse(initialConfig.fill);
        if (typeof initialConfig.animation == 'string')
          initialConfig.animation = JSON.parse(initialConfig.animation);
        config = $.extend(initialConfig, config);
        config.el = el;
        instance = new CircleProgress(config);
        el.data(dataName, instance);
      }
    });
  };
});


/***/ }),

/***/ "../../../node_modules/jquery-mask-plugin/dist/jquery.mask.js":
/*!**********************************************************************************!*\
  !*** /Users/flex/Lab/tabler/node_modules/jquery-mask-plugin/dist/jquery.mask.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * jquery.mask.js
 * @version: v1.14.15
 * @author: Igor Escobar
 *
 * Created by Igor Escobar on 2012-03-10. Please report any bug at github.com/igorescobar/jQuery-Mask-Plugin
 *
 * Copyright (c) 2012 Igor Escobar http://igorescobar.com
 *
 * The MIT License (http://www.opensource.org/licenses/mit-license.php)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/* jshint laxbreak: true */
/* jshint maxcomplexity:17 */
/* global define */

// UMD (Universal Module Definition) patterns for JavaScript modules that work everywhere.
// https://github.com/umdjs/umd/blob/master/templates/jqueryPlugin.js
(function (factory, jQuery, Zepto) {

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}

}(function ($) {
    'use strict';

    var Mask = function (el, mask, options) {

        var p = {
            invalid: [],
            getCaret: function () {
                try {
                    var sel,
                        pos = 0,
                        ctrl = el.get(0),
                        dSel = document.selection,
                        cSelStart = ctrl.selectionStart;

                    // IE Support
                    if (dSel && navigator.appVersion.indexOf('MSIE 10') === -1) {
                        sel = dSel.createRange();
                        sel.moveStart('character', -p.val().length);
                        pos = sel.text.length;
                    }
                    // Firefox support
                    else if (cSelStart || cSelStart === '0') {
                        pos = cSelStart;
                    }

                    return pos;
                } catch (e) {}
            },
            setCaret: function(pos) {
                try {
                    if (el.is(':focus')) {
                        var range, ctrl = el.get(0);

                        // Firefox, WebKit, etc..
                        if (ctrl.setSelectionRange) {
                            ctrl.setSelectionRange(pos, pos);
                        } else { // IE
                            range = ctrl.createTextRange();
                            range.collapse(true);
                            range.moveEnd('character', pos);
                            range.moveStart('character', pos);
                            range.select();
                        }
                    }
                } catch (e) {}
            },
            events: function() {
                el
                .on('keydown.mask', function(e) {
                    el.data('mask-keycode', e.keyCode || e.which);
                    el.data('mask-previus-value', el.val());
                    el.data('mask-previus-caret-pos', p.getCaret());
                    p.maskDigitPosMapOld = p.maskDigitPosMap;
                })
                .on($.jMaskGlobals.useInput ? 'input.mask' : 'keyup.mask', p.behaviour)
                .on('paste.mask drop.mask', function() {
                    setTimeout(function() {
                        el.keydown().keyup();
                    }, 100);
                })
                .on('change.mask', function(){
                    el.data('changed', true);
                })
                .on('blur.mask', function(){
                    if (oldValue !== p.val() && !el.data('changed')) {
                        el.trigger('change');
                    }
                    el.data('changed', false);
                })
                // it's very important that this callback remains in this position
                // otherwhise oldValue it's going to work buggy
                .on('blur.mask', function() {
                    oldValue = p.val();
                })
                // select all text on focus
                .on('focus.mask', function (e) {
                    if (options.selectOnFocus === true) {
                        $(e.target).select();
                    }
                })
                // clear the value if it not complete the mask
                .on('focusout.mask', function() {
                    if (options.clearIfNotMatch && !regexMask.test(p.val())) {
                       p.val('');
                   }
                });
            },
            getRegexMask: function() {
                var maskChunks = [], translation, pattern, optional, recursive, oRecursive, r;

                for (var i = 0; i < mask.length; i++) {
                    translation = jMask.translation[mask.charAt(i)];

                    if (translation) {

                        pattern = translation.pattern.toString().replace(/.{1}$|^.{1}/g, '');
                        optional = translation.optional;
                        recursive = translation.recursive;

                        if (recursive) {
                            maskChunks.push(mask.charAt(i));
                            oRecursive = {digit: mask.charAt(i), pattern: pattern};
                        } else {
                            maskChunks.push(!optional && !recursive ? pattern : (pattern + '?'));
                        }

                    } else {
                        maskChunks.push(mask.charAt(i).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
                    }
                }

                r = maskChunks.join('');

                if (oRecursive) {
                    r = r.replace(new RegExp('(' + oRecursive.digit + '(.*' + oRecursive.digit + ')?)'), '($1)?')
                         .replace(new RegExp(oRecursive.digit, 'g'), oRecursive.pattern);
                }

                return new RegExp(r);
            },
            destroyEvents: function() {
                el.off(['input', 'keydown', 'keyup', 'paste', 'drop', 'blur', 'focusout', ''].join('.mask '));
            },
            val: function(v) {
                var isInput = el.is('input'),
                    method = isInput ? 'val' : 'text',
                    r;

                if (arguments.length > 0) {
                    if (el[method]() !== v) {
                        el[method](v);
                    }
                    r = el;
                } else {
                    r = el[method]();
                }

                return r;
            },
            calculateCaretPosition: function() {
                var oldVal = el.data('mask-previus-value') || '',
                    newVal = p.getMasked(),
                    caretPosNew = p.getCaret();
                if (oldVal !== newVal) {
                    var caretPosOld = el.data('mask-previus-caret-pos') || 0,
                        newValL = newVal.length,
                        oldValL = oldVal.length,
                        maskDigitsBeforeCaret = 0,
                        maskDigitsAfterCaret = 0,
                        maskDigitsBeforeCaretAll = 0,
                        maskDigitsBeforeCaretAllOld = 0,
                        i = 0;

                    for (i = caretPosNew; i < newValL; i++) {
                        if (!p.maskDigitPosMap[i]) {
                            break;
                        }
                        maskDigitsAfterCaret++;
                    }

                    for (i = caretPosNew - 1; i >= 0; i--) {
                        if (!p.maskDigitPosMap[i]) {
                            break;
                        }
                        maskDigitsBeforeCaret++;
                    }

                    for (i = caretPosNew - 1; i >= 0; i--) {
                        if (p.maskDigitPosMap[i]) {
                            maskDigitsBeforeCaretAll++;
                        }
                    }

                    for (i = caretPosOld - 1; i >= 0; i--) {
                        if (p.maskDigitPosMapOld[i]) {
                            maskDigitsBeforeCaretAllOld++;
                        }
                    }

                    // if the cursor is at the end keep it there
                    if (caretPosNew > oldValL) {
                      caretPosNew = newValL * 10;
                    } else if (caretPosOld >= caretPosNew && caretPosOld !== oldValL) {
                        if (!p.maskDigitPosMapOld[caretPosNew])  {
                          var caretPos = caretPosNew;
                          caretPosNew -= maskDigitsBeforeCaretAllOld - maskDigitsBeforeCaretAll;
                          caretPosNew -= maskDigitsBeforeCaret;
                          if (p.maskDigitPosMap[caretPosNew])  {
                            caretPosNew = caretPos;
                          }
                        }
                    }
                    else if (caretPosNew > caretPosOld) {
                        caretPosNew += maskDigitsBeforeCaretAll - maskDigitsBeforeCaretAllOld;
                        caretPosNew += maskDigitsAfterCaret;
                    }
                }
                return caretPosNew;
            },
            behaviour: function(e) {
                e = e || window.event;
                p.invalid = [];

                var keyCode = el.data('mask-keycode');

                if ($.inArray(keyCode, jMask.byPassKeys) === -1) {
                    var newVal = p.getMasked(),
                        caretPos = p.getCaret();

                    // this is a compensation to devices/browsers that don't compensate
                    // caret positioning the right way
                    setTimeout(function() {
                      p.setCaret(p.calculateCaretPosition());
                    }, $.jMaskGlobals.keyStrokeCompensation);

                    p.val(newVal);
                    p.setCaret(caretPos);
                    return p.callbacks(e);
                }
            },
            getMasked: function(skipMaskChars, val) {
                var buf = [],
                    value = val === undefined ? p.val() : val + '',
                    m = 0, maskLen = mask.length,
                    v = 0, valLen = value.length,
                    offset = 1, addMethod = 'push',
                    resetPos = -1,
                    maskDigitCount = 0,
                    maskDigitPosArr = [],
                    lastMaskChar,
                    check;

                if (options.reverse) {
                    addMethod = 'unshift';
                    offset = -1;
                    lastMaskChar = 0;
                    m = maskLen - 1;
                    v = valLen - 1;
                    check = function () {
                        return m > -1 && v > -1;
                    };
                } else {
                    lastMaskChar = maskLen - 1;
                    check = function () {
                        return m < maskLen && v < valLen;
                    };
                }

                var lastUntranslatedMaskChar;
                while (check()) {
                    var maskDigit = mask.charAt(m),
                        valDigit = value.charAt(v),
                        translation = jMask.translation[maskDigit];

                    if (translation) {
                        if (valDigit.match(translation.pattern)) {
                            buf[addMethod](valDigit);
                             if (translation.recursive) {
                                if (resetPos === -1) {
                                    resetPos = m;
                                } else if (m === lastMaskChar && m !== resetPos) {
                                    m = resetPos - offset;
                                }

                                if (lastMaskChar === resetPos) {
                                    m -= offset;
                                }
                            }
                            m += offset;
                        } else if (valDigit === lastUntranslatedMaskChar) {
                            // matched the last untranslated (raw) mask character that we encountered
                            // likely an insert offset the mask character from the last entry; fall
                            // through and only increment v
                            maskDigitCount--;
                            lastUntranslatedMaskChar = undefined;
                        } else if (translation.optional) {
                            m += offset;
                            v -= offset;
                        } else if (translation.fallback) {
                            buf[addMethod](translation.fallback);
                            m += offset;
                            v -= offset;
                        } else {
                          p.invalid.push({p: v, v: valDigit, e: translation.pattern});
                        }
                        v += offset;
                    } else {
                        if (!skipMaskChars) {
                            buf[addMethod](maskDigit);
                        }

                        if (valDigit === maskDigit) {
                            maskDigitPosArr.push(v);
                            v += offset;
                        } else {
                            lastUntranslatedMaskChar = maskDigit;
                            maskDigitPosArr.push(v + maskDigitCount);
                            maskDigitCount++;
                        }

                        m += offset;
                    }
                }

                var lastMaskCharDigit = mask.charAt(lastMaskChar);
                if (maskLen === valLen + 1 && !jMask.translation[lastMaskCharDigit]) {
                    buf.push(lastMaskCharDigit);
                }

                var newVal = buf.join('');
                p.mapMaskdigitPositions(newVal, maskDigitPosArr, valLen);
                return newVal;
            },
            mapMaskdigitPositions: function(newVal, maskDigitPosArr, valLen) {
              var maskDiff = options.reverse ? newVal.length - valLen : 0;
              p.maskDigitPosMap = {};
              for (var i = 0; i < maskDigitPosArr.length; i++) {
                p.maskDigitPosMap[maskDigitPosArr[i] + maskDiff] = 1;
              }
            },
            callbacks: function (e) {
                var val = p.val(),
                    changed = val !== oldValue,
                    defaultArgs = [val, e, el, options],
                    callback = function(name, criteria, args) {
                        if (typeof options[name] === 'function' && criteria) {
                            options[name].apply(this, args);
                        }
                    };

                callback('onChange', changed === true, defaultArgs);
                callback('onKeyPress', changed === true, defaultArgs);
                callback('onComplete', val.length === mask.length, defaultArgs);
                callback('onInvalid', p.invalid.length > 0, [val, e, el, p.invalid, options]);
            }
        };

        el = $(el);
        var jMask = this, oldValue = p.val(), regexMask;

        mask = typeof mask === 'function' ? mask(p.val(), undefined, el,  options) : mask;

        // public methods
        jMask.mask = mask;
        jMask.options = options;
        jMask.remove = function() {
            var caret = p.getCaret();
            if (jMask.options.placeholder) {
                el.removeAttr('placeholder');
            }
            if (el.data('mask-maxlength')) {
                el.removeAttr('maxlength');
            }
            p.destroyEvents();
            p.val(jMask.getCleanVal());
            p.setCaret(caret);
            return el;
        };

        // get value without mask
        jMask.getCleanVal = function() {
           return p.getMasked(true);
        };

        // get masked value without the value being in the input or element
        jMask.getMaskedVal = function(val) {
           return p.getMasked(false, val);
        };

       jMask.init = function(onlyMask) {
            onlyMask = onlyMask || false;
            options = options || {};

            jMask.clearIfNotMatch  = $.jMaskGlobals.clearIfNotMatch;
            jMask.byPassKeys       = $.jMaskGlobals.byPassKeys;
            jMask.translation      = $.extend({}, $.jMaskGlobals.translation, options.translation);

            jMask = $.extend(true, {}, jMask, options);

            regexMask = p.getRegexMask();

            if (onlyMask) {
                p.events();
                p.val(p.getMasked());
            } else {
                if (options.placeholder) {
                    el.attr('placeholder' , options.placeholder);
                }

                // this is necessary, otherwise if the user submit the form
                // and then press the "back" button, the autocomplete will erase
                // the data. Works fine on IE9+, FF, Opera, Safari.
                if (el.data('mask')) {
                  el.attr('autocomplete', 'off');
                }

                // detect if is necessary let the user type freely.
                // for is a lot faster than forEach.
                for (var i = 0, maxlength = true; i < mask.length; i++) {
                    var translation = jMask.translation[mask.charAt(i)];
                    if (translation && translation.recursive) {
                        maxlength = false;
                        break;
                    }
                }

                if (maxlength) {
                    el.attr('maxlength', mask.length).data('mask-maxlength', true);
                }

                p.destroyEvents();
                p.events();

                var caret = p.getCaret();
                p.val(p.getMasked());
                p.setCaret(caret);
            }
        };

        jMask.init(!el.is('input'));
    };

    $.maskWatchers = {};
    var HTMLAttributes = function () {
        var input = $(this),
            options = {},
            prefix = 'data-mask-',
            mask = input.attr('data-mask');

        if (input.attr(prefix + 'reverse')) {
            options.reverse = true;
        }

        if (input.attr(prefix + 'clearifnotmatch')) {
            options.clearIfNotMatch = true;
        }

        if (input.attr(prefix + 'selectonfocus') === 'true') {
           options.selectOnFocus = true;
        }

        if (notSameMaskObject(input, mask, options)) {
            return input.data('mask', new Mask(this, mask, options));
        }
    },
    notSameMaskObject = function(field, mask, options) {
        options = options || {};
        var maskObject = $(field).data('mask'),
            stringify = JSON.stringify,
            value = $(field).val() || $(field).text();
        try {
            if (typeof mask === 'function') {
                mask = mask(value);
            }
            return typeof maskObject !== 'object' || stringify(maskObject.options) !== stringify(options) || maskObject.mask !== mask;
        } catch (e) {}
    },
    eventSupported = function(eventName) {
        var el = document.createElement('div'), isSupported;

        eventName = 'on' + eventName;
        isSupported = (eventName in el);

        if ( !isSupported ) {
            el.setAttribute(eventName, 'return;');
            isSupported = typeof el[eventName] === 'function';
        }
        el = null;

        return isSupported;
    };

    $.fn.mask = function(mask, options) {
        options = options || {};
        var selector = this.selector,
            globals = $.jMaskGlobals,
            interval = globals.watchInterval,
            watchInputs = options.watchInputs || globals.watchInputs,
            maskFunction = function() {
                if (notSameMaskObject(this, mask, options)) {
                    return $(this).data('mask', new Mask(this, mask, options));
                }
            };

        $(this).each(maskFunction);

        if (selector && selector !== '' && watchInputs) {
            clearInterval($.maskWatchers[selector]);
            $.maskWatchers[selector] = setInterval(function(){
                $(document).find(selector).each(maskFunction);
            }, interval);
        }
        return this;
    };

    $.fn.masked = function(val) {
        return this.data('mask').getMaskedVal(val);
    };

    $.fn.unmask = function() {
        clearInterval($.maskWatchers[this.selector]);
        delete $.maskWatchers[this.selector];
        return this.each(function() {
            var dataMask = $(this).data('mask');
            if (dataMask) {
                dataMask.remove().removeData('mask');
            }
        });
    };

    $.fn.cleanVal = function() {
        return this.data('mask').getCleanVal();
    };

    $.applyDataMask = function(selector) {
        selector = selector || $.jMaskGlobals.maskElements;
        var $selector = (selector instanceof $) ? selector : $(selector);
        $selector.filter($.jMaskGlobals.dataMaskAttr).each(HTMLAttributes);
    };

    var globals = {
        maskElements: 'input,td,span,div',
        dataMaskAttr: '*[data-mask]',
        dataMask: true,
        watchInterval: 300,
        watchInputs: true,
        keyStrokeCompensation: 10,
        // old versions of chrome dont work great with input event
        useInput: !/Chrome\/[2-4][0-9]|SamsungBrowser/.test(window.navigator.userAgent) && eventSupported('input'),
        watchDataMask: false,
        byPassKeys: [9, 16, 17, 18, 36, 37, 38, 39, 40, 91],
        translation: {
            '0': {pattern: /\d/},
            '9': {pattern: /\d/, optional: true},
            '#': {pattern: /\d/, recursive: true},
            'A': {pattern: /[a-zA-Z0-9]/},
            'S': {pattern: /[a-zA-Z]/}
        }
    };

    $.jMaskGlobals = $.jMaskGlobals || {};
    globals = $.jMaskGlobals = $.extend(true, {}, globals, $.jMaskGlobals);

    // looking for inputs with data-mask attribute
    if (globals.dataMask) {
        $.applyDataMask();
    }

    setInterval(function() {
        if ($.jMaskGlobals.watchDataMask) {
            $.applyDataMask();
        }
    }, globals.watchInterval);
}, __webpack_provided_window_dot_jQuery, window.Zepto));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "../../../node_modules/jvectormap/jquery-jvectormap.min.js":
/*!*******************************************************************************!*\
  !*** /Users/flex/Lab/tabler/node_modules/jvectormap/jquery-jvectormap.min.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery, $) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function($){var apiParams={set:{colors:1,values:1,backgroundColor:1,scaleColors:1,normalizeFunction:1,focus:1},get:{selectedRegions:1,selectedMarkers:1,mapObject:1,regionName:1}};$.fn.vectorMap=function(options){var map,methodName,map=this.children(".jvectormap-container").data("mapObject");if("addMap"===options)jvm.Map.maps[arguments[1]]=arguments[2];else{if(("set"===options||"get"===options)&&apiParams[options][arguments[1]])return methodName=arguments[1].charAt(0).toUpperCase()+arguments[1].substr(1),map[options+methodName].apply(map,Array.prototype.slice.call(arguments,2));options=options||{},options.container=this,map=new jvm.Map(options)}return this}}(jQuery),function(factory){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):undefined}(function($){function handler(event){var orgEvent=event||window.event,args=slice.call(arguments,1),delta=0,deltaX=0,deltaY=0,absDelta=0;if(event=$.event.fix(orgEvent),event.type="mousewheel","detail"in orgEvent&&(deltaY=-1*orgEvent.detail),"wheelDelta"in orgEvent&&(deltaY=orgEvent.wheelDelta),"wheelDeltaY"in orgEvent&&(deltaY=orgEvent.wheelDeltaY),"wheelDeltaX"in orgEvent&&(deltaX=-1*orgEvent.wheelDeltaX),"axis"in orgEvent&&orgEvent.axis===orgEvent.HORIZONTAL_AXIS&&(deltaX=-1*deltaY,deltaY=0),delta=0===deltaY?deltaX:deltaY,"deltaY"in orgEvent&&(deltaY=-1*orgEvent.deltaY,delta=deltaY),"deltaX"in orgEvent&&(deltaX=orgEvent.deltaX,0===deltaY&&(delta=-1*deltaX)),0!==deltaY||0!==deltaX){if(1===orgEvent.deltaMode){var lineHeight=$.data(this,"mousewheel-line-height");delta*=lineHeight,deltaY*=lineHeight,deltaX*=lineHeight}else if(2===orgEvent.deltaMode){var pageHeight=$.data(this,"mousewheel-page-height");delta*=pageHeight,deltaY*=pageHeight,deltaX*=pageHeight}return absDelta=Math.max(Math.abs(deltaY),Math.abs(deltaX)),(!lowestDelta||lowestDelta>absDelta)&&(lowestDelta=absDelta,shouldAdjustOldDeltas(orgEvent,absDelta)&&(lowestDelta/=40)),shouldAdjustOldDeltas(orgEvent,absDelta)&&(delta/=40,deltaX/=40,deltaY/=40),delta=Math[delta>=1?"floor":"ceil"](delta/lowestDelta),deltaX=Math[deltaX>=1?"floor":"ceil"](deltaX/lowestDelta),deltaY=Math[deltaY>=1?"floor":"ceil"](deltaY/lowestDelta),event.deltaX=deltaX,event.deltaY=deltaY,event.deltaFactor=lowestDelta,event.deltaMode=0,args.unshift(event,delta,deltaX,deltaY),nullLowestDeltaTimeout&&clearTimeout(nullLowestDeltaTimeout),nullLowestDeltaTimeout=setTimeout(nullLowestDelta,200),($.event.dispatch||$.event.handle).apply(this,args)}}function nullLowestDelta(){lowestDelta=null}function shouldAdjustOldDeltas(orgEvent,absDelta){return special.settings.adjustOldDeltas&&"mousewheel"===orgEvent.type&&absDelta%120===0}var nullLowestDeltaTimeout,lowestDelta,toFix=["wheel","mousewheel","DOMMouseScroll","MozMousePixelScroll"],toBind="onwheel"in document||document.documentMode>=9?["wheel"]:["mousewheel","DomMouseScroll","MozMousePixelScroll"],slice=Array.prototype.slice;if($.event.fixHooks)for(var i=toFix.length;i;)$.event.fixHooks[toFix[--i]]=$.event.mouseHooks;var special=$.event.special.mousewheel={version:"3.1.9",setup:function(){if(this.addEventListener)for(var i=toBind.length;i;)this.addEventListener(toBind[--i],handler,!1);else this.onmousewheel=handler;$.data(this,"mousewheel-line-height",special.getLineHeight(this)),$.data(this,"mousewheel-page-height",special.getPageHeight(this))},teardown:function(){if(this.removeEventListener)for(var i=toBind.length;i;)this.removeEventListener(toBind[--i],handler,!1);else this.onmousewheel=null},getLineHeight:function(elem){return parseInt($(elem)["offsetParent"in $.fn?"offsetParent":"parent"]().css("fontSize"),10)},getPageHeight:function(elem){return $(elem).height()},settings:{adjustOldDeltas:!0}};$.fn.extend({mousewheel:function(fn){return fn?this.bind("mousewheel",fn):this.trigger("mousewheel")},unmousewheel:function(fn){return this.unbind("mousewheel",fn)}})});var jvm={inherits:function(child,parent){function temp(){}temp.prototype=parent.prototype,child.prototype=new temp,child.prototype.constructor=child,child.parentClass=parent},mixin:function(target,source){var prop;for(prop in source.prototype)source.prototype.hasOwnProperty(prop)&&(target.prototype[prop]=source.prototype[prop])},min:function(values){var i,min=Number.MAX_VALUE;if(values instanceof Array)for(i=0;i<values.length;i++)values[i]<min&&(min=values[i]);else for(i in values)values[i]<min&&(min=values[i]);return min},max:function(values){var i,max=Number.MIN_VALUE;if(values instanceof Array)for(i=0;i<values.length;i++)values[i]>max&&(max=values[i]);else for(i in values)values[i]>max&&(max=values[i]);return max},keys:function(object){var key,keys=[];for(key in object)keys.push(key);return keys},values:function(object){var key,i,values=[];for(i=0;i<arguments.length;i++){object=arguments[i];for(key in object)values.push(object[key])}return values},whenImageLoaded:function(url){var deferred=new jvm.$.Deferred,img=jvm.$("<img/>");return img.error(function(){deferred.reject()}).load(function(){deferred.resolve(img)}),img.attr("src",url),deferred},isImageUrl:function(s){return/\.\w{3,4}$/.test(s)}};jvm.$=jQuery,Array.prototype.indexOf||(Array.prototype.indexOf=function(searchElement,fromIndex){var k;if(null==this)throw new TypeError('"this" is null or not defined');var O=Object(this),len=O.length>>>0;if(0===len)return-1;var n=+fromIndex||0;if(Math.abs(n)===1/0&&(n=0),n>=len)return-1;for(k=Math.max(n>=0?n:len-Math.abs(n),0);len>k;){if(k in O&&O[k]===searchElement)return k;k++}return-1}),jvm.AbstractElement=function(name,config){this.node=this.createElement(name),this.name=name,this.properties={},config&&this.set(config)},jvm.AbstractElement.prototype.set=function(property,value){var key;if("object"==typeof property)for(key in property)this.properties[key]=property[key],this.applyAttr(key,property[key]);else this.properties[property]=value,this.applyAttr(property,value)},jvm.AbstractElement.prototype.get=function(property){return this.properties[property]},jvm.AbstractElement.prototype.applyAttr=function(property,value){this.node.setAttribute(property,value)},jvm.AbstractElement.prototype.remove=function(){jvm.$(this.node).remove()},jvm.AbstractCanvasElement=function(container,width,height){this.container=container,this.setSize(width,height),this.rootElement=new jvm[this.classPrefix+"GroupElement"],this.node.appendChild(this.rootElement.node),this.container.appendChild(this.node)},jvm.AbstractCanvasElement.prototype.add=function(element,group){group=group||this.rootElement,group.add(element),element.canvas=this},jvm.AbstractCanvasElement.prototype.addPath=function(config,style,group){var el=new jvm[this.classPrefix+"PathElement"](config,style);return this.add(el,group),el},jvm.AbstractCanvasElement.prototype.addCircle=function(config,style,group){var el=new jvm[this.classPrefix+"CircleElement"](config,style);return this.add(el,group),el},jvm.AbstractCanvasElement.prototype.addImage=function(config,style,group){var el=new jvm[this.classPrefix+"ImageElement"](config,style);return this.add(el,group),el},jvm.AbstractCanvasElement.prototype.addText=function(config,style,group){var el=new jvm[this.classPrefix+"TextElement"](config,style);return this.add(el,group),el},jvm.AbstractCanvasElement.prototype.addGroup=function(parentGroup){var el=new jvm[this.classPrefix+"GroupElement"];return parentGroup?parentGroup.node.appendChild(el.node):this.node.appendChild(el.node),el.canvas=this,el},jvm.AbstractShapeElement=function(name,config,style){this.style=style||{},this.style.current=this.style.current||{},this.isHovered=!1,this.isSelected=!1,this.updateStyle()},jvm.AbstractShapeElement.prototype.setStyle=function(property,value){var styles={};"object"==typeof property?styles=property:styles[property]=value,jvm.$.extend(this.style.current,styles),this.updateStyle()},jvm.AbstractShapeElement.prototype.updateStyle=function(){var attrs={};jvm.AbstractShapeElement.mergeStyles(attrs,this.style.initial),jvm.AbstractShapeElement.mergeStyles(attrs,this.style.current),this.isHovered&&jvm.AbstractShapeElement.mergeStyles(attrs,this.style.hover),this.isSelected&&(jvm.AbstractShapeElement.mergeStyles(attrs,this.style.selected),this.isHovered&&jvm.AbstractShapeElement.mergeStyles(attrs,this.style.selectedHover)),this.set(attrs)},jvm.AbstractShapeElement.mergeStyles=function(styles,newStyles){var key;newStyles=newStyles||{};for(key in newStyles)null===newStyles[key]?delete styles[key]:styles[key]=newStyles[key]},jvm.SVGElement=function(){jvm.SVGElement.parentClass.apply(this,arguments)},jvm.inherits(jvm.SVGElement,jvm.AbstractElement),jvm.SVGElement.svgns="http://www.w3.org/2000/svg",jvm.SVGElement.prototype.createElement=function(tagName){return document.createElementNS(jvm.SVGElement.svgns,tagName)},jvm.SVGElement.prototype.addClass=function(className){this.node.setAttribute("class",className)},jvm.SVGElement.prototype.getElementCtr=function(ctr){return jvm["SVG"+ctr]},jvm.SVGElement.prototype.getBBox=function(){return this.node.getBBox()},jvm.SVGGroupElement=function(){jvm.SVGGroupElement.parentClass.call(this,"g")},jvm.inherits(jvm.SVGGroupElement,jvm.SVGElement),jvm.SVGGroupElement.prototype.add=function(element){this.node.appendChild(element.node)},jvm.SVGCanvasElement=function(){this.classPrefix="SVG",jvm.SVGCanvasElement.parentClass.call(this,"svg"),this.defsElement=new jvm.SVGElement("defs"),this.node.appendChild(this.defsElement.node),jvm.AbstractCanvasElement.apply(this,arguments)},jvm.inherits(jvm.SVGCanvasElement,jvm.SVGElement),jvm.mixin(jvm.SVGCanvasElement,jvm.AbstractCanvasElement),jvm.SVGCanvasElement.prototype.setSize=function(width,height){this.width=width,this.height=height,this.node.setAttribute("width",width),this.node.setAttribute("height",height)},jvm.SVGCanvasElement.prototype.applyTransformParams=function(scale,transX,transY){this.scale=scale,this.transX=transX,this.transY=transY,this.rootElement.node.setAttribute("transform","scale("+scale+") translate("+transX+", "+transY+")")},jvm.SVGShapeElement=function(name,config){jvm.SVGShapeElement.parentClass.call(this,name,config),jvm.AbstractShapeElement.apply(this,arguments)},jvm.inherits(jvm.SVGShapeElement,jvm.SVGElement),jvm.mixin(jvm.SVGShapeElement,jvm.AbstractShapeElement),jvm.SVGShapeElement.prototype.applyAttr=function(attr,value){var patternEl,imageEl,that=this;"fill"===attr&&jvm.isImageUrl(value)?jvm.SVGShapeElement.images[value]?this.applyAttr("fill","url(#image"+jvm.SVGShapeElement.images[value]+")"):jvm.whenImageLoaded(value).then(function(img){imageEl=new jvm.SVGElement("image"),imageEl.node.setAttributeNS("http://www.w3.org/1999/xlink","href",value),imageEl.applyAttr("x","0"),imageEl.applyAttr("y","0"),imageEl.applyAttr("width",img[0].width),imageEl.applyAttr("height",img[0].height),patternEl=new jvm.SVGElement("pattern"),patternEl.applyAttr("id","image"+jvm.SVGShapeElement.imageCounter),patternEl.applyAttr("x",0),patternEl.applyAttr("y",0),patternEl.applyAttr("width",img[0].width/2),patternEl.applyAttr("height",img[0].height/2),patternEl.applyAttr("viewBox","0 0 "+img[0].width+" "+img[0].height),patternEl.applyAttr("patternUnits","userSpaceOnUse"),patternEl.node.appendChild(imageEl.node),that.canvas.defsElement.node.appendChild(patternEl.node),jvm.SVGShapeElement.images[value]=jvm.SVGShapeElement.imageCounter++,that.applyAttr("fill","url(#image"+jvm.SVGShapeElement.images[value]+")")}):jvm.SVGShapeElement.parentClass.prototype.applyAttr.apply(this,arguments)},jvm.SVGShapeElement.imageCounter=1,jvm.SVGShapeElement.images={},jvm.SVGPathElement=function(config,style){jvm.SVGPathElement.parentClass.call(this,"path",config,style),this.node.setAttribute("fill-rule","evenodd")},jvm.inherits(jvm.SVGPathElement,jvm.SVGShapeElement),jvm.SVGCircleElement=function(config,style){jvm.SVGCircleElement.parentClass.call(this,"circle",config,style)},jvm.inherits(jvm.SVGCircleElement,jvm.SVGShapeElement),jvm.SVGImageElement=function(config,style){jvm.SVGImageElement.parentClass.call(this,"image",config,style)},jvm.inherits(jvm.SVGImageElement,jvm.SVGShapeElement),jvm.SVGImageElement.prototype.applyAttr=function(attr,value){var that=this;"image"==attr?jvm.whenImageLoaded(value).then(function(img){that.node.setAttributeNS("http://www.w3.org/1999/xlink","href",value),that.width=img[0].width,that.height=img[0].height,that.applyAttr("width",that.width),that.applyAttr("height",that.height),that.applyAttr("x",that.cx-that.width/2),that.applyAttr("y",that.cy-that.height/2),jvm.$(that.node).trigger("imageloaded",[img])}):"cx"==attr?(this.cx=value,this.width&&this.applyAttr("x",value-this.width/2)):"cy"==attr?(this.cy=value,this.height&&this.applyAttr("y",value-this.height/2)):jvm.SVGImageElement.parentClass.prototype.applyAttr.apply(this,arguments)},jvm.SVGTextElement=function(config,style){jvm.SVGTextElement.parentClass.call(this,"text",config,style)},jvm.inherits(jvm.SVGTextElement,jvm.SVGShapeElement),jvm.SVGTextElement.prototype.applyAttr=function(attr,value){"text"===attr?this.node.textContent=value:jvm.SVGTextElement.parentClass.prototype.applyAttr.apply(this,arguments)},jvm.VMLElement=function(){jvm.VMLElement.VMLInitialized||jvm.VMLElement.initializeVML(),jvm.VMLElement.parentClass.apply(this,arguments)},jvm.inherits(jvm.VMLElement,jvm.AbstractElement),jvm.VMLElement.VMLInitialized=!1,jvm.VMLElement.initializeVML=function(){try{document.namespaces.rvml||document.namespaces.add("rvml","urn:schemas-microsoft-com:vml"),jvm.VMLElement.prototype.createElement=function(tagName){return document.createElement("<rvml:"+tagName+' class="rvml">')}}catch(e){jvm.VMLElement.prototype.createElement=function(tagName){return document.createElement("<"+tagName+' xmlns="urn:schemas-microsoft.com:vml" class="rvml">')}}document.createStyleSheet().addRule(".rvml","behavior:url(#default#VML)"),jvm.VMLElement.VMLInitialized=!0},jvm.VMLElement.prototype.getElementCtr=function(ctr){return jvm["VML"+ctr]},jvm.VMLElement.prototype.addClass=function(className){jvm.$(this.node).addClass(className)},jvm.VMLElement.prototype.applyAttr=function(attr,value){this.node[attr]=value},jvm.VMLElement.prototype.getBBox=function(){var node=jvm.$(this.node);return{x:node.position().left/this.canvas.scale,y:node.position().top/this.canvas.scale,width:node.width()/this.canvas.scale,height:node.height()/this.canvas.scale}},jvm.VMLGroupElement=function(){jvm.VMLGroupElement.parentClass.call(this,"group"),this.node.style.left="0px",this.node.style.top="0px",this.node.coordorigin="0 0"},jvm.inherits(jvm.VMLGroupElement,jvm.VMLElement),jvm.VMLGroupElement.prototype.add=function(element){this.node.appendChild(element.node)},jvm.VMLCanvasElement=function(){this.classPrefix="VML",jvm.VMLCanvasElement.parentClass.call(this,"group"),jvm.AbstractCanvasElement.apply(this,arguments),this.node.style.position="absolute"},jvm.inherits(jvm.VMLCanvasElement,jvm.VMLElement),jvm.mixin(jvm.VMLCanvasElement,jvm.AbstractCanvasElement),jvm.VMLCanvasElement.prototype.setSize=function(width,height){var paths,groups,i,l;if(this.width=width,this.height=height,this.node.style.width=width+"px",this.node.style.height=height+"px",this.node.coordsize=width+" "+height,this.node.coordorigin="0 0",this.rootElement){for(paths=this.rootElement.node.getElementsByTagName("shape"),i=0,l=paths.length;l>i;i++)paths[i].coordsize=width+" "+height,paths[i].style.width=width+"px",paths[i].style.height=height+"px";for(groups=this.node.getElementsByTagName("group"),i=0,l=groups.length;l>i;i++)groups[i].coordsize=width+" "+height,groups[i].style.width=width+"px",groups[i].style.height=height+"px"}},jvm.VMLCanvasElement.prototype.applyTransformParams=function(scale,transX,transY){this.scale=scale,this.transX=transX,this.transY=transY,this.rootElement.node.coordorigin=this.width-transX-this.width/100+","+(this.height-transY-this.height/100),this.rootElement.node.coordsize=this.width/scale+","+this.height/scale},jvm.VMLShapeElement=function(name,config){jvm.VMLShapeElement.parentClass.call(this,name,config),this.fillElement=new jvm.VMLElement("fill"),this.strokeElement=new jvm.VMLElement("stroke"),this.node.appendChild(this.fillElement.node),this.node.appendChild(this.strokeElement.node),this.node.stroked=!1,jvm.AbstractShapeElement.apply(this,arguments)},jvm.inherits(jvm.VMLShapeElement,jvm.VMLElement),jvm.mixin(jvm.VMLShapeElement,jvm.AbstractShapeElement),jvm.VMLShapeElement.prototype.applyAttr=function(attr,value){switch(attr){case"fill":this.node.fillcolor=value;break;case"fill-opacity":this.fillElement.node.opacity=Math.round(100*value)+"%";break;case"stroke":this.node.stroked="none"===value?!1:!0,this.node.strokecolor=value;break;case"stroke-opacity":this.strokeElement.node.opacity=Math.round(100*value)+"%";break;case"stroke-width":this.node.stroked=0===parseInt(value,10)?!1:!0,this.node.strokeweight=value;break;case"d":this.node.path=jvm.VMLPathElement.pathSvgToVml(value);break;default:jvm.VMLShapeElement.parentClass.prototype.applyAttr.apply(this,arguments)}},jvm.VMLPathElement=function(config,style){var scale=new jvm.VMLElement("skew");jvm.VMLPathElement.parentClass.call(this,"shape",config,style),this.node.coordorigin="0 0",scale.node.on=!0,scale.node.matrix="0.01,0,0,0.01,0,0",scale.node.offset="0,0",this.node.appendChild(scale.node)},jvm.inherits(jvm.VMLPathElement,jvm.VMLShapeElement),jvm.VMLPathElement.prototype.applyAttr=function(attr,value){"d"===attr?this.node.path=jvm.VMLPathElement.pathSvgToVml(value):jvm.VMLShapeElement.prototype.applyAttr.call(this,attr,value)},jvm.VMLPathElement.pathSvgToVml=function(path){var ctrlx,ctrly,cx=0,cy=0;return path=path.replace(/(-?\d+)e(-?\d+)/g,"0"),path.replace(/([MmLlHhVvCcSs])\s*((?:-?\d*(?:\.\d+)?\s*,?\s*)+)/g,function(segment,letter,coords){coords=coords.replace(/(\d)-/g,"$1,-").replace(/^\s+/g,"").replace(/\s+$/g,"").replace(/\s+/g,",").split(","),coords[0]||coords.shift();for(var i=0,l=coords.length;l>i;i++)coords[i]=Math.round(100*coords[i]);switch(letter){case"m":return cx+=coords[0],cy+=coords[1],"t"+coords.join(",");case"M":return cx=coords[0],cy=coords[1],"m"+coords.join(",");case"l":return cx+=coords[0],cy+=coords[1],"r"+coords.join(",");case"L":return cx=coords[0],cy=coords[1],"l"+coords.join(",");case"h":return cx+=coords[0],"r"+coords[0]+",0";case"H":return cx=coords[0],"l"+cx+","+cy;case"v":return cy+=coords[0],"r0,"+coords[0];case"V":return cy=coords[0],"l"+cx+","+cy;case"c":return ctrlx=cx+coords[coords.length-4],ctrly=cy+coords[coords.length-3],cx+=coords[coords.length-2],cy+=coords[coords.length-1],"v"+coords.join(",");case"C":return ctrlx=coords[coords.length-4],ctrly=coords[coords.length-3],cx=coords[coords.length-2],cy=coords[coords.length-1],"c"+coords.join(",");case"s":return coords.unshift(cy-ctrly),coords.unshift(cx-ctrlx),ctrlx=cx+coords[coords.length-4],ctrly=cy+coords[coords.length-3],cx+=coords[coords.length-2],cy+=coords[coords.length-1],"v"+coords.join(",");case"S":return coords.unshift(cy+cy-ctrly),coords.unshift(cx+cx-ctrlx),ctrlx=coords[coords.length-4],ctrly=coords[coords.length-3],cx=coords[coords.length-2],cy=coords[coords.length-1],"c"+coords.join(",")}return""}).replace(/z/g,"e")},jvm.VMLCircleElement=function(config,style){jvm.VMLCircleElement.parentClass.call(this,"oval",config,style)},jvm.inherits(jvm.VMLCircleElement,jvm.VMLShapeElement),jvm.VMLCircleElement.prototype.applyAttr=function(attr,value){switch(attr){case"r":this.node.style.width=2*value+"px",this.node.style.height=2*value+"px",this.applyAttr("cx",this.get("cx")||0),this.applyAttr("cy",this.get("cy")||0);break;case"cx":if(!value)return;this.node.style.left=value-(this.get("r")||0)+"px";break;case"cy":if(!value)return;this.node.style.top=value-(this.get("r")||0)+"px";break;default:jvm.VMLCircleElement.parentClass.prototype.applyAttr.call(this,attr,value)}},jvm.VectorCanvas=function(container,width,height){return this.mode=window.SVGAngle?"svg":"vml",this.impl="svg"==this.mode?new jvm.SVGCanvasElement(container,width,height):new jvm.VMLCanvasElement(container,width,height),this.impl.mode=this.mode,this.impl},jvm.SimpleScale=function(scale){this.scale=scale},jvm.SimpleScale.prototype.getValue=function(value){return value},jvm.OrdinalScale=function(scale){this.scale=scale},jvm.OrdinalScale.prototype.getValue=function(value){return this.scale[value]},jvm.OrdinalScale.prototype.getTicks=function(){var key,ticks=[];for(key in this.scale)ticks.push({label:key,value:this.scale[key]});return ticks},jvm.NumericScale=function(scale,normalizeFunction,minValue,maxValue){this.scale=[],normalizeFunction=normalizeFunction||"linear",scale&&this.setScale(scale),normalizeFunction&&this.setNormalizeFunction(normalizeFunction),"undefined"!=typeof minValue&&this.setMin(minValue),"undefined"!=typeof maxValue&&this.setMax(maxValue)},jvm.NumericScale.prototype={setMin:function(min){this.clearMinValue=min,this.minValue="function"==typeof this.normalize?this.normalize(min):min},setMax:function(max){this.clearMaxValue=max,this.maxValue="function"==typeof this.normalize?this.normalize(max):max},setScale:function(scale){var i;for(this.scale=[],i=0;i<scale.length;i++)this.scale[i]=[scale[i]]},setNormalizeFunction:function(f){"polynomial"===f?this.normalize=function(value){return Math.pow(value,.2)}:"linear"===f?delete this.normalize:this.normalize=f,this.setMin(this.clearMinValue),this.setMax(this.clearMaxValue)},getValue:function(value){var l,c,lengthes=[],fullLength=0,i=0;for("function"==typeof this.normalize&&(value=this.normalize(value)),i=0;i<this.scale.length-1;i++)l=this.vectorLength(this.vectorSubtract(this.scale[i+1],this.scale[i])),lengthes.push(l),fullLength+=l;for(c=(this.maxValue-this.minValue)/fullLength,i=0;i<lengthes.length;i++)lengthes[i]*=c;for(i=0,value-=this.minValue;value-lengthes[i]>=0;)value-=lengthes[i],i++;return value=this.vectorToNum(i==this.scale.length-1?this.scale[i]:this.vectorAdd(this.scale[i],this.vectorMult(this.vectorSubtract(this.scale[i+1],this.scale[i]),value/lengthes[i])))},vectorToNum:function(vector){var i,num=0;for(i=0;i<vector.length;i++)num+=Math.round(vector[i])*Math.pow(256,vector.length-i-1);return num},vectorSubtract:function(vector1,vector2){var i,vector=[];for(i=0;i<vector1.length;i++)vector[i]=vector1[i]-vector2[i];return vector},vectorAdd:function(vector1,vector2){var i,vector=[];for(i=0;i<vector1.length;i++)vector[i]=vector1[i]+vector2[i];return vector},vectorMult:function(vector,num){var i,result=[];for(i=0;i<vector.length;i++)result[i]=vector[i]*num;return result},vectorLength:function(vector){var i,result=0;for(i=0;i<vector.length;i++)result+=vector[i]*vector[i];return Math.sqrt(result)},getTicks:function(){var tick,v,m=5,extent=[this.clearMinValue,this.clearMaxValue],span=extent[1]-extent[0],step=Math.pow(10,Math.floor(Math.log(span/m)/Math.LN10)),err=m/span*step,ticks=[];for(.15>=err?step*=10:.35>=err?step*=5:.75>=err&&(step*=2),extent[0]=Math.floor(extent[0]/step)*step,extent[1]=Math.ceil(extent[1]/step)*step,tick=extent[0];tick<=extent[1];)v=tick==extent[0]?this.clearMinValue:tick==extent[1]?this.clearMaxValue:tick,ticks.push({label:tick,value:this.getValue(v)}),tick+=step;return ticks}},jvm.ColorScale=function(){jvm.ColorScale.parentClass.apply(this,arguments)},jvm.inherits(jvm.ColorScale,jvm.NumericScale),jvm.ColorScale.prototype.setScale=function(scale){var i;for(i=0;i<scale.length;i++)this.scale[i]=jvm.ColorScale.rgbToArray(scale[i])},jvm.ColorScale.prototype.getValue=function(value){return jvm.ColorScale.numToRgb(jvm.ColorScale.parentClass.prototype.getValue.call(this,value))},jvm.ColorScale.arrayToRgb=function(ar){var d,i,rgb="#";for(i=0;i<ar.length;i++)d=ar[i].toString(16),rgb+=1==d.length?"0"+d:d;return rgb},jvm.ColorScale.numToRgb=function(num){for(num=num.toString(16);num.length<6;)num="0"+num;return"#"+num},jvm.ColorScale.rgbToArray=function(rgb){return rgb=rgb.substr(1),[parseInt(rgb.substr(0,2),16),parseInt(rgb.substr(2,2),16),parseInt(rgb.substr(4,2),16)]},jvm.Legend=function(params){this.params=params||{},this.map=this.params.map,this.series=this.params.series,this.body=jvm.$("<div/>"),this.body.addClass("jvectormap-legend"),this.params.cssClass&&this.body.addClass(this.params.cssClass),params.vertical?this.map.legendCntVertical.append(this.body):this.map.legendCntHorizontal.append(this.body),this.render()},jvm.Legend.prototype.render=function(){var i,tick,sample,label,ticks=this.series.scale.getTicks(),inner=jvm.$("<div/>").addClass("jvectormap-legend-inner");for(this.body.html(""),this.params.title&&this.body.append(jvm.$("<div/>").addClass("jvectormap-legend-title").html(this.params.title)),this.body.append(inner),i=0;i<ticks.length;i++){switch(tick=jvm.$("<div/>").addClass("jvectormap-legend-tick"),sample=jvm.$("<div/>").addClass("jvectormap-legend-tick-sample"),this.series.params.attribute){case"fill":jvm.isImageUrl(ticks[i].value)?sample.css("background","url("+ticks[i].value+")"):sample.css("background",ticks[i].value);break;case"stroke":sample.css("background",ticks[i].value);break;case"image":sample.css("background","url("+ticks[i].value+") no-repeat center center");break;case"r":jvm.$("<div/>").css({"border-radius":ticks[i].value,border:this.map.params.markerStyle.initial["stroke-width"]+"px "+this.map.params.markerStyle.initial.stroke+" solid",width:2*ticks[i].value+"px",height:2*ticks[i].value+"px",background:this.map.params.markerStyle.initial.fill}).appendTo(sample)}tick.append(sample),label=ticks[i].label,this.params.labelRender&&(label=this.params.labelRender(label)),tick.append(jvm.$("<div>"+label+" </div>").addClass("jvectormap-legend-tick-text")),inner.append(tick)}inner.append(jvm.$("<div/>").css("clear","both"))},jvm.DataSeries=function(params,elements,map){var scaleConstructor;params=params||{},params.attribute=params.attribute||"fill",this.elements=elements,this.params=params,this.map=map,params.attributes&&this.setAttributes(params.attributes),jvm.$.isArray(params.scale)?(scaleConstructor="fill"===params.attribute||"stroke"===params.attribute?jvm.ColorScale:jvm.NumericScale,this.scale=new scaleConstructor(params.scale,params.normalizeFunction,params.min,params.max)):this.scale=params.scale?new jvm.OrdinalScale(params.scale):new jvm.SimpleScale(params.scale),this.values=params.values||{},this.setValues(this.values),this.params.legend&&(this.legend=new jvm.Legend($.extend({map:this.map,series:this},this.params.legend)))},jvm.DataSeries.prototype={setAttributes:function(key,attr){var code,attrs=key;if("string"==typeof key)this.elements[key]&&this.elements[key].setStyle(this.params.attribute,attr);else for(code in attrs)this.elements[code]&&this.elements[code].element.setStyle(this.params.attribute,attrs[code])},setValues:function(values){var val,cc,max=-Number.MAX_VALUE,min=Number.MAX_VALUE,attrs={};if(this.scale instanceof jvm.OrdinalScale||this.scale instanceof jvm.SimpleScale)for(cc in values)attrs[cc]=values[cc]?this.scale.getValue(values[cc]):this.elements[cc].element.style.initial[this.params.attribute];else{if("undefined"==typeof this.params.min||"undefined"==typeof this.params.max)for(cc in values)val=parseFloat(values[cc]),val>max&&(max=val),min>val&&(min=val);"undefined"==typeof this.params.min?(this.scale.setMin(min),this.params.min=min):this.scale.setMin(this.params.min),"undefined"==typeof this.params.max?(this.scale.setMax(max),this.params.max=max):this.scale.setMax(this.params.max);for(cc in values)"indexOf"!=cc&&(val=parseFloat(values[cc]),attrs[cc]=isNaN(val)?this.elements[cc].element.style.initial[this.params.attribute]:this.scale.getValue(val))}this.setAttributes(attrs),jvm.$.extend(this.values,values)},clear:function(){var key,attrs={};for(key in this.values)this.elements[key]&&(attrs[key]=this.elements[key].element.shape.style.initial[this.params.attribute]);this.setAttributes(attrs),this.values={}},setScale:function(scale){this.scale.setScale(scale),this.values&&this.setValues(this.values)},setNormalizeFunction:function(f){this.scale.setNormalizeFunction(f),this.values&&this.setValues(this.values)}},jvm.Proj={degRad:180/Math.PI,radDeg:Math.PI/180,radius:6381372,sgn:function(n){return n>0?1:0>n?-1:n},mill:function(lat,lng,c){return{x:this.radius*(lng-c)*this.radDeg,y:-this.radius*Math.log(Math.tan((45+.4*lat)*this.radDeg))/.8}},mill_inv:function(x,y,c){return{lat:(2.5*Math.atan(Math.exp(.8*y/this.radius))-5*Math.PI/8)*this.degRad,lng:(c*this.radDeg+x/this.radius)*this.degRad}},merc:function(lat,lng,c){return{x:this.radius*(lng-c)*this.radDeg,y:-this.radius*Math.log(Math.tan(Math.PI/4+lat*Math.PI/360))}},merc_inv:function(x,y,c){return{lat:(2*Math.atan(Math.exp(y/this.radius))-Math.PI/2)*this.degRad,lng:(c*this.radDeg+x/this.radius)*this.degRad}},aea:function(lat,lng,c){var fi0=0,lambda0=c*this.radDeg,fi1=29.5*this.radDeg,fi2=45.5*this.radDeg,fi=lat*this.radDeg,lambda=lng*this.radDeg,n=(Math.sin(fi1)+Math.sin(fi2))/2,C=Math.cos(fi1)*Math.cos(fi1)+2*n*Math.sin(fi1),theta=n*(lambda-lambda0),ro=Math.sqrt(C-2*n*Math.sin(fi))/n,ro0=Math.sqrt(C-2*n*Math.sin(fi0))/n;return{x:ro*Math.sin(theta)*this.radius,y:-(ro0-ro*Math.cos(theta))*this.radius}},aea_inv:function(xCoord,yCoord,c){var x=xCoord/this.radius,y=yCoord/this.radius,fi0=0,lambda0=c*this.radDeg,fi1=29.5*this.radDeg,fi2=45.5*this.radDeg,n=(Math.sin(fi1)+Math.sin(fi2))/2,C=Math.cos(fi1)*Math.cos(fi1)+2*n*Math.sin(fi1),ro0=Math.sqrt(C-2*n*Math.sin(fi0))/n,ro=Math.sqrt(x*x+(ro0-y)*(ro0-y)),theta=Math.atan(x/(ro0-y));return{lat:Math.asin((C-ro*ro*n*n)/(2*n))*this.degRad,lng:(lambda0+theta/n)*this.degRad}},lcc:function(lat,lng,c){var fi0=0,lambda0=c*this.radDeg,lambda=lng*this.radDeg,fi1=33*this.radDeg,fi2=45*this.radDeg,fi=lat*this.radDeg,n=Math.log(Math.cos(fi1)*(1/Math.cos(fi2)))/Math.log(Math.tan(Math.PI/4+fi2/2)*(1/Math.tan(Math.PI/4+fi1/2))),F=Math.cos(fi1)*Math.pow(Math.tan(Math.PI/4+fi1/2),n)/n,ro=F*Math.pow(1/Math.tan(Math.PI/4+fi/2),n),ro0=F*Math.pow(1/Math.tan(Math.PI/4+fi0/2),n);return{x:ro*Math.sin(n*(lambda-lambda0))*this.radius,y:-(ro0-ro*Math.cos(n*(lambda-lambda0)))*this.radius}},lcc_inv:function(xCoord,yCoord,c){var x=xCoord/this.radius,y=yCoord/this.radius,fi0=0,lambda0=c*this.radDeg,fi1=33*this.radDeg,fi2=45*this.radDeg,n=Math.log(Math.cos(fi1)*(1/Math.cos(fi2)))/Math.log(Math.tan(Math.PI/4+fi2/2)*(1/Math.tan(Math.PI/4+fi1/2))),F=Math.cos(fi1)*Math.pow(Math.tan(Math.PI/4+fi1/2),n)/n,ro0=F*Math.pow(1/Math.tan(Math.PI/4+fi0/2),n),ro=this.sgn(n)*Math.sqrt(x*x+(ro0-y)*(ro0-y)),theta=Math.atan(x/(ro0-y));return{lat:(2*Math.atan(Math.pow(F/ro,1/n))-Math.PI/2)*this.degRad,lng:(lambda0+theta/n)*this.degRad}}},jvm.MapObject=function(){},jvm.MapObject.prototype.getLabelText=function(key){var text;return text=this.config.label?"function"==typeof this.config.label.render?this.config.label.render(key):key:null},jvm.MapObject.prototype.getLabelOffsets=function(key){var offsets;return this.config.label&&("function"==typeof this.config.label.offsets?offsets=this.config.label.offsets(key):"object"==typeof this.config.label.offsets&&(offsets=this.config.label.offsets[key])),offsets||[0,0]},jvm.MapObject.prototype.setHovered=function(isHovered){this.isHovered!==isHovered&&(this.isHovered=isHovered,this.shape.isHovered=isHovered,this.shape.updateStyle(),this.label&&(this.label.isHovered=isHovered,this.label.updateStyle()))},jvm.MapObject.prototype.setSelected=function(isSelected){this.isSelected!==isSelected&&(this.isSelected=isSelected,this.shape.isSelected=isSelected,this.shape.updateStyle(),this.label&&(this.label.isSelected=isSelected,this.label.updateStyle()),jvm.$(this.shape).trigger("selected",[isSelected]))},jvm.MapObject.prototype.setStyle=function(){this.shape.setStyle.apply(this.shape,arguments)},jvm.MapObject.prototype.remove=function(){this.shape.remove(),this.label&&this.label.remove()},jvm.Region=function(config){var bbox,text,offsets;this.config=config,this.map=this.config.map,this.shape=config.canvas.addPath({d:config.path,"data-code":config.code},config.style,config.canvas.rootElement),this.shape.addClass("jvectormap-region jvectormap-element"),bbox=this.shape.getBBox(),text=this.getLabelText(config.code),
this.config.label&&text&&(offsets=this.getLabelOffsets(config.code),this.labelX=bbox.x+bbox.width/2+offsets[0],this.labelY=bbox.y+bbox.height/2+offsets[1],this.label=config.canvas.addText({text:text,"text-anchor":"middle","alignment-baseline":"central",x:this.labelX,y:this.labelY,"data-code":config.code},config.labelStyle,config.labelsGroup),this.label.addClass("jvectormap-region jvectormap-element"))},jvm.inherits(jvm.Region,jvm.MapObject),jvm.Region.prototype.updateLabelPosition=function(){this.label&&this.label.set({x:this.labelX*this.map.scale+this.map.transX*this.map.scale,y:this.labelY*this.map.scale+this.map.transY*this.map.scale})},jvm.Marker=function(config){var text;this.config=config,this.map=this.config.map,this.isImage=!!this.config.style.initial.image,this.createShape(),text=this.getLabelText(config.index),this.config.label&&text&&(this.offsets=this.getLabelOffsets(config.index),this.labelX=config.cx/this.map.scale-this.map.transX,this.labelY=config.cy/this.map.scale-this.map.transY,this.label=config.canvas.addText({text:text,"data-index":config.index,dy:"0.6ex",x:this.labelX,y:this.labelY},config.labelStyle,config.labelsGroup),this.label.addClass("jvectormap-marker jvectormap-element"))},jvm.inherits(jvm.Marker,jvm.MapObject),jvm.Marker.prototype.createShape=function(){var that=this;this.shape&&this.shape.remove(),this.shape=this.config.canvas[this.isImage?"addImage":"addCircle"]({"data-index":this.config.index,cx:this.config.cx,cy:this.config.cy},this.config.style,this.config.group),this.shape.addClass("jvectormap-marker jvectormap-element"),this.isImage&&jvm.$(this.shape.node).on("imageloaded",function(){that.updateLabelPosition()})},jvm.Marker.prototype.updateLabelPosition=function(){this.label&&this.label.set({x:this.labelX*this.map.scale+this.offsets[0]+this.map.transX*this.map.scale+5+(this.isImage?(this.shape.width||0)/2:this.shape.properties.r),y:this.labelY*this.map.scale+this.map.transY*this.map.scale+this.offsets[1]})},jvm.Marker.prototype.setStyle=function(property){var isImage;jvm.Marker.parentClass.prototype.setStyle.apply(this,arguments),"r"===property&&this.updateLabelPosition(),isImage=!!this.shape.get("image"),isImage!=this.isImage&&(this.isImage=isImage,this.config.style=jvm.$.extend(!0,{},this.shape.style),this.createShape())},jvm.Map=function(params){var e,map=this;if(this.params=jvm.$.extend(!0,{},jvm.Map.defaultParams,params),!jvm.Map.maps[this.params.map])throw new Error("Attempt to use map which was not loaded: "+this.params.map);this.mapData=jvm.Map.maps[this.params.map],this.markers={},this.regions={},this.regionsColors={},this.regionsData={},this.container=jvm.$("<div>").addClass("jvectormap-container"),this.params.container&&this.params.container.append(this.container),this.container.data("mapObject",this),this.defaultWidth=this.mapData.width,this.defaultHeight=this.mapData.height,this.setBackgroundColor(this.params.backgroundColor),this.onResize=function(){map.updateSize()},jvm.$(window).resize(this.onResize);for(e in jvm.Map.apiEvents)this.params[e]&&this.container.bind(jvm.Map.apiEvents[e]+".jvectormap",this.params[e]);this.canvas=new jvm.VectorCanvas(this.container[0],this.width,this.height),this.params.bindTouchEvents&&("ontouchstart"in window||window.DocumentTouch&&document instanceof DocumentTouch?this.bindContainerTouchEvents():window.MSGesture&&this.bindContainerPointerEvents()),this.bindContainerEvents(),this.bindElementEvents(),this.createTip(),this.params.zoomButtons&&this.bindZoomButtons(),this.createRegions(),this.createMarkers(this.params.markers||{}),this.updateSize(),this.params.focusOn&&("string"==typeof this.params.focusOn?this.params.focusOn={region:this.params.focusOn}:jvm.$.isArray(this.params.focusOn)&&(this.params.focusOn={regions:this.params.focusOn}),this.setFocus(this.params.focusOn)),this.params.selectedRegions&&this.setSelectedRegions(this.params.selectedRegions),this.params.selectedMarkers&&this.setSelectedMarkers(this.params.selectedMarkers),this.legendCntHorizontal=jvm.$("<div/>").addClass("jvectormap-legend-cnt jvectormap-legend-cnt-h"),this.legendCntVertical=jvm.$("<div/>").addClass("jvectormap-legend-cnt jvectormap-legend-cnt-v"),this.container.append(this.legendCntHorizontal),this.container.append(this.legendCntVertical),this.params.series&&this.createSeries()},jvm.Map.prototype={transX:0,transY:0,scale:1,baseTransX:0,baseTransY:0,baseScale:1,width:0,height:0,setBackgroundColor:function(backgroundColor){this.container.css("background-color",backgroundColor)},resize:function(){var curBaseScale=this.baseScale;this.width/this.height>this.defaultWidth/this.defaultHeight?(this.baseScale=this.height/this.defaultHeight,this.baseTransX=Math.abs(this.width-this.defaultWidth*this.baseScale)/(2*this.baseScale)):(this.baseScale=this.width/this.defaultWidth,this.baseTransY=Math.abs(this.height-this.defaultHeight*this.baseScale)/(2*this.baseScale)),this.scale*=this.baseScale/curBaseScale,this.transX*=this.baseScale/curBaseScale,this.transY*=this.baseScale/curBaseScale},updateSize:function(){this.width=this.container.width(),this.height=this.container.height(),this.resize(),this.canvas.setSize(this.width,this.height),this.applyTransform()},reset:function(){var key,i;for(key in this.series)for(i=0;i<this.series[key].length;i++)this.series[key][i].clear();this.scale=this.baseScale,this.transX=this.baseTransX,this.transY=this.baseTransY,this.applyTransform()},applyTransform:function(){var maxTransX,maxTransY,minTransX,minTransY;this.defaultWidth*this.scale<=this.width?(maxTransX=(this.width-this.defaultWidth*this.scale)/(2*this.scale),minTransX=(this.width-this.defaultWidth*this.scale)/(2*this.scale)):(maxTransX=0,minTransX=(this.width-this.defaultWidth*this.scale)/this.scale),this.defaultHeight*this.scale<=this.height?(maxTransY=(this.height-this.defaultHeight*this.scale)/(2*this.scale),minTransY=(this.height-this.defaultHeight*this.scale)/(2*this.scale)):(maxTransY=0,minTransY=(this.height-this.defaultHeight*this.scale)/this.scale),this.transY>maxTransY?this.transY=maxTransY:this.transY<minTransY&&(this.transY=minTransY),this.transX>maxTransX?this.transX=maxTransX:this.transX<minTransX&&(this.transX=minTransX),this.canvas.applyTransformParams(this.scale,this.transX,this.transY),this.markers&&this.repositionMarkers(),this.repositionLabels(),this.container.trigger("viewportChange",[this.scale/this.baseScale,this.transX,this.transY])},bindContainerEvents:function(){var oldPageX,oldPageY,mouseDown=!1,map=this;this.params.panOnDrag&&(this.container.mousemove(function(e){return mouseDown&&(map.transX-=(oldPageX-e.pageX)/map.scale,map.transY-=(oldPageY-e.pageY)/map.scale,map.applyTransform(),oldPageX=e.pageX,oldPageY=e.pageY),!1}).mousedown(function(e){return mouseDown=!0,oldPageX=e.pageX,oldPageY=e.pageY,!1}),this.onContainerMouseUp=function(){mouseDown=!1},jvm.$("body").mouseup(this.onContainerMouseUp)),this.params.zoomOnScroll&&this.container.mousewheel(function(event){var offset=jvm.$(map.container).offset(),centerX=event.pageX-offset.left,centerY=event.pageY-offset.top,zoomStep=Math.pow(1+map.params.zoomOnScrollSpeed/1e3,event.deltaFactor*event.deltaY);map.tip.hide(),map.setScale(map.scale*zoomStep,centerX,centerY),event.preventDefault()})},bindContainerTouchEvents:function(){var touchStartScale,touchStartDistance,touchX,touchY,centerTouchX,centerTouchY,lastTouchesLength,map=this,handleTouchEvent=function(e){var offset,scale,transXOld,transYOld,touches=e.originalEvent.touches;"touchstart"==e.type&&(lastTouchesLength=0),1==touches.length?(1==lastTouchesLength&&(transXOld=map.transX,transYOld=map.transY,map.transX-=(touchX-touches[0].pageX)/map.scale,map.transY-=(touchY-touches[0].pageY)/map.scale,map.applyTransform(),map.tip.hide(),(transXOld!=map.transX||transYOld!=map.transY)&&e.preventDefault()),touchX=touches[0].pageX,touchY=touches[0].pageY):2==touches.length&&(2==lastTouchesLength?(scale=Math.sqrt(Math.pow(touches[0].pageX-touches[1].pageX,2)+Math.pow(touches[0].pageY-touches[1].pageY,2))/touchStartDistance,map.setScale(touchStartScale*scale,centerTouchX,centerTouchY),map.tip.hide(),e.preventDefault()):(offset=jvm.$(map.container).offset(),centerTouchX=touches[0].pageX>touches[1].pageX?touches[1].pageX+(touches[0].pageX-touches[1].pageX)/2:touches[0].pageX+(touches[1].pageX-touches[0].pageX)/2,centerTouchY=touches[0].pageY>touches[1].pageY?touches[1].pageY+(touches[0].pageY-touches[1].pageY)/2:touches[0].pageY+(touches[1].pageY-touches[0].pageY)/2,centerTouchX-=offset.left,centerTouchY-=offset.top,touchStartScale=map.scale,touchStartDistance=Math.sqrt(Math.pow(touches[0].pageX-touches[1].pageX,2)+Math.pow(touches[0].pageY-touches[1].pageY,2)))),lastTouchesLength=touches.length};jvm.$(this.container).bind("touchstart",handleTouchEvent),jvm.$(this.container).bind("touchmove",handleTouchEvent)},bindContainerPointerEvents:function(){var map=this,gesture=new MSGesture,element=this.container[0],handlePointerDownEvent=function(e){gesture.addPointer(e.pointerId)},handleGestureEvent=function(e){var transXOld,transYOld;(0!=e.translationX||0!=e.translationY)&&(transXOld=map.transX,transYOld=map.transY,map.transX+=e.translationX/map.scale,map.transY+=e.translationY/map.scale,map.applyTransform(),map.tip.hide(),(transXOld!=map.transX||transYOld!=map.transY)&&e.preventDefault()),1!=e.scale&&(map.setScale(map.scale*e.scale,e.offsetX,e.offsetY),map.tip.hide(),e.preventDefault())};gesture.target=element,element.addEventListener("MSGestureChange",handleGestureEvent,!1),element.addEventListener("pointerdown",handlePointerDownEvent,!1)},bindElementEvents:function(){var pageX,pageY,mouseMoved,map=this;this.container.mousemove(function(e){Math.abs(pageX-e.pageX)+Math.abs(pageY-e.pageY)>2&&(mouseMoved=!0)}),this.container.delegate("[class~='jvectormap-element']","mouseover mouseout",function(e){var baseVal=jvm.$(this).attr("class").baseVal||jvm.$(this).attr("class"),type=-1===baseVal.indexOf("jvectormap-region")?"marker":"region",code=jvm.$(this).attr("region"==type?"data-code":"data-index"),element="region"==type?map.regions[code].element:map.markers[code].element,tipText="region"==type?map.mapData.paths[code].name:map.markers[code].config.name||"",tipShowEvent=jvm.$.Event(type+"TipShow.jvectormap"),overEvent=jvm.$.Event(type+"Over.jvectormap");"mouseover"==e.type?(map.container.trigger(overEvent,[code]),overEvent.isDefaultPrevented()||element.setHovered(!0),map.tip.text(tipText),map.container.trigger(tipShowEvent,[map.tip,code]),tipShowEvent.isDefaultPrevented()||(map.tip.show(),map.tipWidth=map.tip.width(),map.tipHeight=map.tip.height())):(element.setHovered(!1),map.tip.hide(),map.container.trigger(type+"Out.jvectormap",[code]))}),this.container.delegate("[class~='jvectormap-element']","mousedown",function(e){pageX=e.pageX,pageY=e.pageY,mouseMoved=!1}),this.container.delegate("[class~='jvectormap-element']","mouseup",function(){var baseVal=jvm.$(this).attr("class").baseVal?jvm.$(this).attr("class").baseVal:jvm.$(this).attr("class"),type=-1===baseVal.indexOf("jvectormap-region")?"marker":"region",code=jvm.$(this).attr("region"==type?"data-code":"data-index"),clickEvent=jvm.$.Event(type+"Click.jvectormap"),element="region"==type?map.regions[code].element:map.markers[code].element;mouseMoved||(map.container.trigger(clickEvent,[code]),("region"===type&&map.params.regionsSelectable||"marker"===type&&map.params.markersSelectable)&&(clickEvent.isDefaultPrevented()||(map.params[type+"sSelectableOne"]&&map.clearSelected(type+"s"),element.setSelected(!element.isSelected))))})},bindZoomButtons:function(){var map=this;jvm.$("<div/>").addClass("jvectormap-zoomin").text("+").appendTo(this.container),jvm.$("<div/>").addClass("jvectormap-zoomout").html("&#x2212;").appendTo(this.container),this.container.find(".jvectormap-zoomin").click(function(){map.setScale(map.scale*map.params.zoomStep,map.width/2,map.height/2,!1,map.params.zoomAnimate)}),this.container.find(".jvectormap-zoomout").click(function(){map.setScale(map.scale/map.params.zoomStep,map.width/2,map.height/2,!1,map.params.zoomAnimate)})},createTip:function(){var map=this;this.tip=jvm.$("<div/>").addClass("jvectormap-tip").appendTo(jvm.$("body")),this.container.mousemove(function(e){var left=e.pageX-15-map.tipWidth,top=e.pageY-15-map.tipHeight;5>left&&(left=e.pageX+15),5>top&&(top=e.pageY+15),map.tip.css({left:left,top:top})})},setScale:function(scale,anchorX,anchorY,isCentered,animate){var interval,scaleStart,scaleDiff,transXStart,transXDiff,transYStart,transYDiff,transX,transY,viewportChangeEvent=jvm.$.Event("zoom.jvectormap"),that=this,i=0,count=Math.abs(Math.round(60*(scale-this.scale)/Math.max(scale,this.scale))),deferred=new jvm.$.Deferred;return scale>this.params.zoomMax*this.baseScale?scale=this.params.zoomMax*this.baseScale:scale<this.params.zoomMin*this.baseScale&&(scale=this.params.zoomMin*this.baseScale),"undefined"!=typeof anchorX&&"undefined"!=typeof anchorY&&(zoomStep=scale/this.scale,isCentered?(transX=anchorX+this.defaultWidth*(this.width/(this.defaultWidth*scale))/2,transY=anchorY+this.defaultHeight*(this.height/(this.defaultHeight*scale))/2):(transX=this.transX-(zoomStep-1)/scale*anchorX,transY=this.transY-(zoomStep-1)/scale*anchorY)),animate&&count>0?(scaleStart=this.scale,scaleDiff=(scale-scaleStart)/count,transXStart=this.transX*this.scale,transYStart=this.transY*this.scale,transXDiff=(transX*scale-transXStart)/count,transYDiff=(transY*scale-transYStart)/count,interval=setInterval(function(){i+=1,that.scale=scaleStart+scaleDiff*i,that.transX=(transXStart+transXDiff*i)/that.scale,that.transY=(transYStart+transYDiff*i)/that.scale,that.applyTransform(),i==count&&(clearInterval(interval),that.container.trigger(viewportChangeEvent,[scale/that.baseScale]),deferred.resolve())},10)):(this.transX=transX,this.transY=transY,this.scale=scale,this.applyTransform(),this.container.trigger(viewportChangeEvent,[scale/this.baseScale]),deferred.resolve()),deferred},setFocus:function(config){var bbox,itemBbox,newBbox,codes,i,point;if(config=config||{},config.region?codes=[config.region]:config.regions&&(codes=config.regions),codes){for(i=0;i<codes.length;i++)this.regions[codes[i]]&&(itemBbox=this.regions[codes[i]].element.shape.getBBox(),itemBbox&&("undefined"==typeof bbox?bbox=itemBbox:(newBbox={x:Math.min(bbox.x,itemBbox.x),y:Math.min(bbox.y,itemBbox.y),width:Math.max(bbox.x+bbox.width,itemBbox.x+itemBbox.width)-Math.min(bbox.x,itemBbox.x),height:Math.max(bbox.y+bbox.height,itemBbox.y+itemBbox.height)-Math.min(bbox.y,itemBbox.y)},bbox=newBbox)));return this.setScale(Math.min(this.width/bbox.width,this.height/bbox.height),-(bbox.x+bbox.width/2),-(bbox.y+bbox.height/2),!0,config.animate)}return config.lat&&config.lng?(point=this.latLngToPoint(config.lat,config.lng),config.x=this.transX-point.x/this.scale,config.y=this.transY-point.y/this.scale):config.x&&config.y&&(config.x*=-this.defaultWidth,config.y*=-this.defaultHeight),this.setScale(config.scale*this.baseScale,config.x,config.y,!0,config.animate)},getSelected:function(type){var key,selected=[];for(key in this[type])this[type][key].element.isSelected&&selected.push(key);return selected},getSelectedRegions:function(){return this.getSelected("regions")},getSelectedMarkers:function(){return this.getSelected("markers")},setSelected:function(type,keys){var i;if("object"!=typeof keys&&(keys=[keys]),jvm.$.isArray(keys))for(i=0;i<keys.length;i++)this[type][keys[i]].element.setSelected(!0);else for(i in keys)this[type][i].element.setSelected(!!keys[i])},setSelectedRegions:function(keys){this.setSelected("regions",keys)},setSelectedMarkers:function(keys){this.setSelected("markers",keys)},clearSelected:function(type){var i,select={},selected=this.getSelected(type);for(i=0;i<selected.length;i++)select[selected[i]]=!1;this.setSelected(type,select)},clearSelectedRegions:function(){this.clearSelected("regions")},clearSelectedMarkers:function(){this.clearSelected("markers")},getMapObject:function(){return this},getRegionName:function(code){return this.mapData.paths[code].name},createRegions:function(){var key,region,map=this;this.regionLabelsGroup=this.regionLabelsGroup||this.canvas.addGroup();for(key in this.mapData.paths)region=new jvm.Region({map:this,path:this.mapData.paths[key].path,code:key,style:jvm.$.extend(!0,{},this.params.regionStyle),labelStyle:jvm.$.extend(!0,{},this.params.regionLabelStyle),canvas:this.canvas,labelsGroup:this.regionLabelsGroup,label:"vml"!=this.canvas.mode?this.params.labels&&this.params.labels.regions:null}),jvm.$(region.shape).bind("selected",function(e,isSelected){map.container.trigger("regionSelected.jvectormap",[jvm.$(this.node).attr("data-code"),isSelected,map.getSelectedRegions()])}),this.regions[key]={element:region,config:this.mapData.paths[key]}},createMarkers:function(markers){var i,marker,point,markerConfig,markersArray,map=this;if(this.markersGroup=this.markersGroup||this.canvas.addGroup(),this.markerLabelsGroup=this.markerLabelsGroup||this.canvas.addGroup(),jvm.$.isArray(markers))for(markersArray=markers.slice(),markers={},i=0;i<markersArray.length;i++)markers[i]=markersArray[i];for(i in markers)markerConfig=markers[i]instanceof Array?{latLng:markers[i]}:markers[i],point=this.getMarkerPosition(markerConfig),point!==!1&&(marker=new jvm.Marker({map:this,style:jvm.$.extend(!0,{},this.params.markerStyle,{initial:markerConfig.style||{}}),labelStyle:jvm.$.extend(!0,{},this.params.markerLabelStyle),index:i,cx:point.x,cy:point.y,group:this.markersGroup,canvas:this.canvas,labelsGroup:this.markerLabelsGroup,label:"vml"!=this.canvas.mode?this.params.labels&&this.params.labels.markers:null}),jvm.$(marker.shape).bind("selected",function(e,isSelected){map.container.trigger("markerSelected.jvectormap",[jvm.$(this.node).attr("data-index"),isSelected,map.getSelectedMarkers()])}),this.markers[i]&&this.removeMarkers([i]),this.markers[i]={element:marker,config:markerConfig})},repositionMarkers:function(){var i,point;for(i in this.markers)point=this.getMarkerPosition(this.markers[i].config),point!==!1&&this.markers[i].element.setStyle({cx:point.x,cy:point.y})},repositionLabels:function(){var key;for(key in this.regions)this.regions[key].element.updateLabelPosition();for(key in this.markers)this.markers[key].element.updateLabelPosition()},getMarkerPosition:function(markerConfig){return jvm.Map.maps[this.params.map].projection?this.latLngToPoint.apply(this,markerConfig.latLng||[0,0]):{x:markerConfig.coords[0]*this.scale+this.transX*this.scale,y:markerConfig.coords[1]*this.scale+this.transY*this.scale}},addMarker:function(key,marker,seriesData){var values,i,markers={},data=[],seriesData=seriesData||[];for(markers[key]=marker,i=0;i<seriesData.length;i++)values={},"undefined"!=typeof seriesData[i]&&(values[key]=seriesData[i]),data.push(values);this.addMarkers(markers,data)},addMarkers:function(markers,seriesData){var i;for(seriesData=seriesData||[],this.createMarkers(markers),i=0;i<seriesData.length;i++)this.series.markers[i].setValues(seriesData[i]||{})},removeMarkers:function(markers){var i;for(i=0;i<markers.length;i++)this.markers[markers[i]].element.remove(),delete this.markers[markers[i]]},removeAllMarkers:function(){var i,markers=[];for(i in this.markers)markers.push(i);this.removeMarkers(markers)},latLngToPoint:function(lat,lng){var point,inset,bbox,proj=jvm.Map.maps[this.params.map].projection,centralMeridian=proj.centralMeridian;return-180+centralMeridian>lng&&(lng+=360),point=jvm.Proj[proj.type](lat,lng,centralMeridian),inset=this.getInsetForPoint(point.x,point.y),inset?(bbox=inset.bbox,point.x=(point.x-bbox[0].x)/(bbox[1].x-bbox[0].x)*inset.width*this.scale,point.y=(point.y-bbox[0].y)/(bbox[1].y-bbox[0].y)*inset.height*this.scale,{x:point.x+this.transX*this.scale+inset.left*this.scale,y:point.y+this.transY*this.scale+inset.top*this.scale}):!1},pointToLatLng:function(x,y){var i,inset,bbox,nx,ny,proj=jvm.Map.maps[this.params.map].projection,centralMeridian=proj.centralMeridian,insets=jvm.Map.maps[this.params.map].insets;for(i=0;i<insets.length;i++)if(inset=insets[i],bbox=inset.bbox,nx=x-(this.transX*this.scale+inset.left*this.scale),ny=y-(this.transY*this.scale+inset.top*this.scale),nx=nx/(inset.width*this.scale)*(bbox[1].x-bbox[0].x)+bbox[0].x,ny=ny/(inset.height*this.scale)*(bbox[1].y-bbox[0].y)+bbox[0].y,nx>bbox[0].x&&nx<bbox[1].x&&ny>bbox[0].y&&ny<bbox[1].y)return jvm.Proj[proj.type+"_inv"](nx,-ny,centralMeridian);return!1},getInsetForPoint:function(x,y){var i,bbox,insets=jvm.Map.maps[this.params.map].insets;for(i=0;i<insets.length;i++)if(bbox=insets[i].bbox,x>bbox[0].x&&x<bbox[1].x&&y>bbox[0].y&&y<bbox[1].y)return insets[i]},createSeries:function(){var i,key;this.series={markers:[],regions:[]};for(key in this.params.series)for(i=0;i<this.params.series[key].length;i++)this.series[key][i]=new jvm.DataSeries(this.params.series[key][i],this[key],this)},remove:function(){this.tip.remove(),this.container.remove(),jvm.$(window).unbind("resize",this.onResize),jvm.$("body").unbind("mouseup",this.onContainerMouseUp)}},jvm.Map.maps={},jvm.Map.defaultParams={map:"world_mill_en",backgroundColor:"#505050",zoomButtons:!0,zoomOnScroll:!0,zoomOnScrollSpeed:3,panOnDrag:!0,zoomMax:8,zoomMin:1,zoomStep:1.6,zoomAnimate:!0,regionsSelectable:!1,markersSelectable:!1,bindTouchEvents:!0,regionStyle:{initial:{fill:"white","fill-opacity":1,stroke:"none","stroke-width":0,"stroke-opacity":1},hover:{"fill-opacity":.8,cursor:"pointer"},selected:{fill:"yellow"},selectedHover:{}},regionLabelStyle:{initial:{"font-family":"Verdana","font-size":"12","font-weight":"bold",cursor:"default",fill:"black"},hover:{cursor:"pointer"}},markerStyle:{initial:{fill:"grey",stroke:"#505050","fill-opacity":1,"stroke-width":1,"stroke-opacity":1,r:5},hover:{stroke:"black","stroke-width":2,cursor:"pointer"},selected:{fill:"blue"},selectedHover:{}},markerLabelStyle:{initial:{"font-family":"Verdana","font-size":"12","font-weight":"bold",cursor:"default",fill:"black"},hover:{cursor:"pointer"}}},jvm.Map.apiEvents={onRegionTipShow:"regionTipShow",onRegionOver:"regionOver",onRegionOut:"regionOut",onRegionClick:"regionClick",onRegionSelected:"regionSelected",onMarkerTipShow:"markerTipShow",onMarkerOver:"markerOver",onMarkerOut:"markerOut",onMarkerClick:"markerClick",onMarkerSelected:"markerSelected",onViewportChange:"viewportChange"},jvm.MultiMap=function(params){var that=this;this.maps={},this.params=jvm.$.extend(!0,{},jvm.MultiMap.defaultParams,params),this.params.maxLevel=this.params.maxLevel||Number.MAX_VALUE,this.params.main=this.params.main||{},this.params.main.multiMapLevel=0,this.history=[this.addMap(this.params.main.map,this.params.main)],this.defaultProjection=this.history[0].mapData.projection.type,this.mapsLoaded={},this.params.container.css({position:"relative"}),this.backButton=jvm.$("<div/>").addClass("jvectormap-goback").text("Back").appendTo(this.params.container),this.backButton.hide(),this.backButton.click(function(){that.goBack()}),this.spinner=jvm.$("<div/>").addClass("jvectormap-spinner").appendTo(this.params.container),this.spinner.hide()},jvm.MultiMap.prototype={addMap:function(name,config){var cnt=jvm.$("<div/>").css({width:"100%",height:"100%"});return this.params.container.append(cnt),this.maps[name]=new jvm.Map(jvm.$.extend(config,{container:cnt})),this.params.maxLevel>config.multiMapLevel&&this.maps[name].container.on("regionClick.jvectormap",{scope:this},function(e,code){var multimap=e.data.scope,mapName=multimap.params.mapNameByCode(code,multimap);multimap.drillDownPromise&&"pending"===multimap.drillDownPromise.state()||multimap.drillDown(mapName,code)}),this.maps[name]},downloadMap:function(code){var that=this,deferred=jvm.$.Deferred();return this.mapsLoaded[code]?deferred.resolve():jvm.$.get(this.params.mapUrlByCode(code,this)).then(function(){that.mapsLoaded[code]=!0,deferred.resolve()},function(){deferred.reject()}),deferred},drillDown:function(name,code){var currentMap=this.history[this.history.length-1],that=this,focusPromise=currentMap.setFocus({region:code,animate:!0}),downloadPromise=this.downloadMap(code);focusPromise.then(function(){"pending"===downloadPromise.state()&&that.spinner.show()}),downloadPromise.always(function(){that.spinner.hide()}),this.drillDownPromise=jvm.$.when(downloadPromise,focusPromise),this.drillDownPromise.then(function(){currentMap.params.container.hide(),that.maps[name]?that.maps[name].params.container.show():that.addMap(name,{map:name,multiMapLevel:currentMap.params.multiMapLevel+1}),that.history.push(that.maps[name]),that.backButton.show()})},goBack:function(){var currentMap=this.history.pop(),prevMap=this.history[this.history.length-1],that=this;currentMap.setFocus({scale:1,x:.5,y:.5,animate:!0}).then(function(){currentMap.params.container.hide(),prevMap.params.container.show(),prevMap.updateSize(),1===that.history.length&&that.backButton.hide(),prevMap.setFocus({scale:1,x:.5,y:.5,animate:!0})})}},jvm.MultiMap.defaultParams={mapNameByCode:function(code,multiMap){return code.toLowerCase()+"_"+multiMap.defaultProjection+"_en"},mapUrlByCode:function(code,multiMap){return"jquery-jvectormap-data-"+code.toLowerCase()+"-"+multiMap.defaultProjection+"-en.js"}};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "../../../node_modules/microplugin/src/microplugin.js":
/*!**************************************************************************!*\
  !*** /Users/flex/Lab/tabler/node_modules/microplugin/src/microplugin.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * microplugin.js
 * Copyright (c) 2013 Brian Reavis & contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 * @author Brian Reavis <brian@thirdroute.com>
 */

(function(root, factory) {
	if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}(this, function() {
	var MicroPlugin = {};

	MicroPlugin.mixin = function(Interface) {
		Interface.plugins = {};

		/**
		 * Initializes the listed plugins (with options).
		 * Acceptable formats:
		 *
		 * List (without options):
		 *   ['a', 'b', 'c']
		 *
		 * List (with options):
		 *   [{'name': 'a', options: {}}, {'name': 'b', options: {}}]
		 *
		 * Hash (with options):
		 *   {'a': { ... }, 'b': { ... }, 'c': { ... }}
		 *
		 * @param {mixed} plugins
		 */
		Interface.prototype.initializePlugins = function(plugins) {
			var i, n, key;
			var self  = this;
			var queue = [];

			self.plugins = {
				names     : [],
				settings  : {},
				requested : {},
				loaded    : {}
			};

			if (utils.isArray(plugins)) {
				for (i = 0, n = plugins.length; i < n; i++) {
					if (typeof plugins[i] === 'string') {
						queue.push(plugins[i]);
					} else {
						self.plugins.settings[plugins[i].name] = plugins[i].options;
						queue.push(plugins[i].name);
					}
				}
			} else if (plugins) {
				for (key in plugins) {
					if (plugins.hasOwnProperty(key)) {
						self.plugins.settings[key] = plugins[key];
						queue.push(key);
					}
				}
			}

			while (queue.length) {
				self.require(queue.shift());
			}
		};

		Interface.prototype.loadPlugin = function(name) {
			var self    = this;
			var plugins = self.plugins;
			var plugin  = Interface.plugins[name];

			if (!Interface.plugins.hasOwnProperty(name)) {
				throw new Error('Unable to find "' +  name + '" plugin');
			}

			plugins.requested[name] = true;
			plugins.loaded[name] = plugin.fn.apply(self, [self.plugins.settings[name] || {}]);
			plugins.names.push(name);
		};

		/**
		 * Initializes a plugin.
		 *
		 * @param {string} name
		 */
		Interface.prototype.require = function(name) {
			var self = this;
			var plugins = self.plugins;

			if (!self.plugins.loaded.hasOwnProperty(name)) {
				if (plugins.requested[name]) {
					throw new Error('Plugin has circular dependency ("' + name + '")');
				}
				self.loadPlugin(name);
			}

			return plugins.loaded[name];
		};

		/**
		 * Registers a plugin.
		 *
		 * @param {string} name
		 * @param {function} fn
		 */
		Interface.define = function(name, fn) {
			Interface.plugins[name] = {
				'name' : name,
				'fn'   : fn
			};
		};
	};

	var utils = {
		isArray: Array.isArray || function(vArg) {
			return Object.prototype.toString.call(vArg) === '[object Array]';
		}
	};

	return MicroPlugin;
}));

/***/ }),

/***/ "../../../node_modules/popper.js/dist/esm/popper.js":
/*!************************************************************************!*\
  !*** /Users/flex/Lab/tabler/node_modules/popper.js/dist/esm/popper.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.14.3
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var css = getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
}

function getWindowSizes() {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && parent.nodeName === 'HTML') {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  return isFixed(getParentNode(element));
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  boundaries.left += padding;
  boundaries.top += padding;
  boundaries.right -= padding;
  boundaries.bottom -= padding;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var styles = getComputedStyle(element);
  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroy the popper
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger onUpdate callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  // Avoid blurry text by using full pixel integers.
  // For pixel-perfect positioning, top/bottom prefers rounded
  // values, while left/right prefers floored values.
  var offsets = {
    left: Math.floor(popper.left),
    top: Math.round(popper.top),
    bottom: Math.round(popper.bottom),
    right: Math.floor(popper.right)
  };

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    top = -offsetParentRect.height + offsets.bottom;
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    left = -offsetParentRect.width + offsets.right;
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjuction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-right` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unitless, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the height.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * An scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries"  or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper this makes sure the popper has always a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier, can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near eachothers
   * without leaving any gap between the two. Expecially useful when the arrow is
   * enabled and you want to assure it to point to its reference element.
   * It cares only about the first axis, you can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjuction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations).
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position,
     * the popper will never be placed outside of the defined boundaries
     * (except if keepTogether is enabled)
     */
    boundariesElement: 'viewport'
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define you own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the informations used by Popper.js
 * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overriden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass as 3rd argument an object with the same
 * structure of this object, example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated, this callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Create a new Popper.js instance
   * @class Popper
   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper.
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedule an update, it will run on the next UI update available
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

/* harmony default export */ __webpack_exports__["default"] = (Popper);
//# sourceMappingURL=popper.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "../../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../../node_modules/selectize/dist/js/selectize.js":
/*!**************************************************************************!*\
  !*** /Users/flex/Lab/tabler/node_modules/selectize/dist/js/selectize.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * selectize.js (v0.12.4)
 * Copyright (c) 20132015 Brian Reavis & contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 * @author Brian Reavis <brian@thirdroute.com>
 */

/*jshint curly:false */
/*jshint browser:true */

(function(root, factory) {
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js"),__webpack_require__(/*! sifter */ "../../../node_modules/sifter/sifter.js"),__webpack_require__(/*! microplugin */ "../../../node_modules/microplugin/src/microplugin.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}(this, function($, Sifter, MicroPlugin) {
	'use strict';

	var highlight = function($element, pattern) {
		if (typeof pattern === 'string' && !pattern.length) return;
		var regex = (typeof pattern === 'string') ? new RegExp(pattern, 'i') : pattern;
	
		var highlight = function(node) {
			var skip = 0;
			if (node.nodeType === 3) {
				var pos = node.data.search(regex);
				if (pos >= 0 && node.data.length > 0) {
					var match = node.data.match(regex);
					var spannode = document.createElement('span');
					spannode.className = 'highlight';
					var middlebit = node.splitText(pos);
					var endbit = middlebit.splitText(match[0].length);
					var middleclone = middlebit.cloneNode(true);
					spannode.appendChild(middleclone);
					middlebit.parentNode.replaceChild(spannode, middlebit);
					skip = 1;
				}
			} else if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName)) {
				for (var i = 0; i < node.childNodes.length; ++i) {
					i += highlight(node.childNodes[i]);
				}
			}
			return skip;
		};
	
		return $element.each(function() {
			highlight(this);
		});
	};
	
	/**
	 * removeHighlight fn copied from highlight v5 and
	 * edited to remove with() and pass js strict mode
	 */
	$.fn.removeHighlight = function() {
		return this.find("span.highlight").each(function() {
			this.parentNode.firstChild.nodeName;
			var parent = this.parentNode;
			parent.replaceChild(this.firstChild, this);
			parent.normalize();
		}).end();
	};
	
	
	var MicroEvent = function() {};
	MicroEvent.prototype = {
		on: function(event, fct){
			this._events = this._events || {};
			this._events[event] = this._events[event] || [];
			this._events[event].push(fct);
		},
		off: function(event, fct){
			var n = arguments.length;
			if (n === 0) return delete this._events;
			if (n === 1) return delete this._events[event];
	
			this._events = this._events || {};
			if (event in this._events === false) return;
			this._events[event].splice(this._events[event].indexOf(fct), 1);
		},
		trigger: function(event /* , args... */){
			this._events = this._events || {};
			if (event in this._events === false) return;
			for (var i = 0; i < this._events[event].length; i++){
				this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
			}
		}
	};
	
	/**
	 * Mixin will delegate all MicroEvent.js function in the destination object.
	 *
	 * - MicroEvent.mixin(Foobar) will make Foobar able to use MicroEvent
	 *
	 * @param {object} the object which will support MicroEvent
	 */
	MicroEvent.mixin = function(destObject){
		var props = ['on', 'off', 'trigger'];
		for (var i = 0; i < props.length; i++){
			destObject.prototype[props[i]] = MicroEvent.prototype[props[i]];
		}
	};
	
	var IS_MAC        = /Mac/.test(navigator.userAgent);
	
	var KEY_A         = 65;
	var KEY_COMMA     = 188;
	var KEY_RETURN    = 13;
	var KEY_ESC       = 27;
	var KEY_LEFT      = 37;
	var KEY_UP        = 38;
	var KEY_P         = 80;
	var KEY_RIGHT     = 39;
	var KEY_DOWN      = 40;
	var KEY_N         = 78;
	var KEY_BACKSPACE = 8;
	var KEY_DELETE    = 46;
	var KEY_SHIFT     = 16;
	var KEY_CMD       = IS_MAC ? 91 : 17;
	var KEY_CTRL      = IS_MAC ? 18 : 17;
	var KEY_TAB       = 9;
	
	var TAG_SELECT    = 1;
	var TAG_INPUT     = 2;
	
	// for now, android support in general is too spotty to support validity
	var SUPPORTS_VALIDITY_API = !/android/i.test(window.navigator.userAgent) && !!document.createElement('input').validity;
	
	
	var isset = function(object) {
		return typeof object !== 'undefined';
	};
	
	/**
	 * Converts a scalar to its best string representation
	 * for hash keys and HTML attribute values.
	 *
	 * Transformations:
	 *   'str'     -> 'str'
	 *   null      -> ''
	 *   undefined -> ''
	 *   true      -> '1'
	 *   false     -> '0'
	 *   0         -> '0'
	 *   1         -> '1'
	 *
	 * @param {string} value
	 * @returns {string|null}
	 */
	var hash_key = function(value) {
		if (typeof value === 'undefined' || value === null) return null;
		if (typeof value === 'boolean') return value ? '1' : '0';
		return value + '';
	};
	
	/**
	 * Escapes a string for use within HTML.
	 *
	 * @param {string} str
	 * @returns {string}
	 */
	var escape_html = function(str) {
		return (str + '')
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/"/g, '&quot;');
	};
	
	/**
	 * Escapes "$" characters in replacement strings.
	 *
	 * @param {string} str
	 * @returns {string}
	 */
	var escape_replace = function(str) {
		return (str + '').replace(/\$/g, '$$$$');
	};
	
	var hook = {};
	
	/**
	 * Wraps `method` on `self` so that `fn`
	 * is invoked before the original method.
	 *
	 * @param {object} self
	 * @param {string} method
	 * @param {function} fn
	 */
	hook.before = function(self, method, fn) {
		var original = self[method];
		self[method] = function() {
			fn.apply(self, arguments);
			return original.apply(self, arguments);
		};
	};
	
	/**
	 * Wraps `method` on `self` so that `fn`
	 * is invoked after the original method.
	 *
	 * @param {object} self
	 * @param {string} method
	 * @param {function} fn
	 */
	hook.after = function(self, method, fn) {
		var original = self[method];
		self[method] = function() {
			var result = original.apply(self, arguments);
			fn.apply(self, arguments);
			return result;
		};
	};
	
	/**
	 * Wraps `fn` so that it can only be invoked once.
	 *
	 * @param {function} fn
	 * @returns {function}
	 */
	var once = function(fn) {
		var called = false;
		return function() {
			if (called) return;
			called = true;
			fn.apply(this, arguments);
		};
	};
	
	/**
	 * Wraps `fn` so that it can only be called once
	 * every `delay` milliseconds (invoked on the falling edge).
	 *
	 * @param {function} fn
	 * @param {int} delay
	 * @returns {function}
	 */
	var debounce = function(fn, delay) {
		var timeout;
		return function() {
			var self = this;
			var args = arguments;
			window.clearTimeout(timeout);
			timeout = window.setTimeout(function() {
				fn.apply(self, args);
			}, delay);
		};
	};
	
	/**
	 * Debounce all fired events types listed in `types`
	 * while executing the provided `fn`.
	 *
	 * @param {object} self
	 * @param {array} types
	 * @param {function} fn
	 */
	var debounce_events = function(self, types, fn) {
		var type;
		var trigger = self.trigger;
		var event_args = {};
	
		// override trigger method
		self.trigger = function() {
			var type = arguments[0];
			if (types.indexOf(type) !== -1) {
				event_args[type] = arguments;
			} else {
				return trigger.apply(self, arguments);
			}
		};
	
		// invoke provided function
		fn.apply(self, []);
		self.trigger = trigger;
	
		// trigger queued events
		for (type in event_args) {
			if (event_args.hasOwnProperty(type)) {
				trigger.apply(self, event_args[type]);
			}
		}
	};
	
	/**
	 * A workaround for http://bugs.jquery.com/ticket/6696
	 *
	 * @param {object} $parent - Parent element to listen on.
	 * @param {string} event - Event name.
	 * @param {string} selector - Descendant selector to filter by.
	 * @param {function} fn - Event handler.
	 */
	var watchChildEvent = function($parent, event, selector, fn) {
		$parent.on(event, selector, function(e) {
			var child = e.target;
			while (child && child.parentNode !== $parent[0]) {
				child = child.parentNode;
			}
			e.currentTarget = child;
			return fn.apply(this, [e]);
		});
	};
	
	/**
	 * Determines the current selection within a text input control.
	 * Returns an object containing:
	 *   - start
	 *   - length
	 *
	 * @param {object} input
	 * @returns {object}
	 */
	var getSelection = function(input) {
		var result = {};
		if ('selectionStart' in input) {
			result.start = input.selectionStart;
			result.length = input.selectionEnd - result.start;
		} else if (document.selection) {
			input.focus();
			var sel = document.selection.createRange();
			var selLen = document.selection.createRange().text.length;
			sel.moveStart('character', -input.value.length);
			result.start = sel.text.length - selLen;
			result.length = selLen;
		}
		return result;
	};
	
	/**
	 * Copies CSS properties from one element to another.
	 *
	 * @param {object} $from
	 * @param {object} $to
	 * @param {array} properties
	 */
	var transferStyles = function($from, $to, properties) {
		var i, n, styles = {};
		if (properties) {
			for (i = 0, n = properties.length; i < n; i++) {
				styles[properties[i]] = $from.css(properties[i]);
			}
		} else {
			styles = $from.css();
		}
		$to.css(styles);
	};
	
	/**
	 * Measures the width of a string within a
	 * parent element (in pixels).
	 *
	 * @param {string} str
	 * @param {object} $parent
	 * @returns {int}
	 */
	var measureString = function(str, $parent) {
		if (!str) {
			return 0;
		}
	
		var $test = $('<test>').css({
			position: 'absolute',
			top: -99999,
			left: -99999,
			width: 'auto',
			padding: 0,
			whiteSpace: 'pre'
		}).text(str).appendTo('body');
	
		transferStyles($parent, $test, [
			'letterSpacing',
			'fontSize',
			'fontFamily',
			'fontWeight',
			'textTransform'
		]);
	
		var width = $test.width();
		$test.remove();
	
		return width;
	};
	
	/**
	 * Sets up an input to grow horizontally as the user
	 * types. If the value is changed manually, you can
	 * trigger the "update" handler to resize:
	 *
	 * $input.trigger('update');
	 *
	 * @param {object} $input
	 */
	var autoGrow = function($input) {
		var currentWidth = null;
	
		var update = function(e, options) {
			var value, keyCode, printable, placeholder, width;
			var shift, character, selection;
			e = e || window.event || {};
			options = options || {};
	
			if (e.metaKey || e.altKey) return;
			if (!options.force && $input.data('grow') === false) return;
	
			value = $input.val();
			if (e.type && e.type.toLowerCase() === 'keydown') {
				keyCode = e.keyCode;
				printable = (
					(keyCode >= 97 && keyCode <= 122) || // a-z
					(keyCode >= 65 && keyCode <= 90)  || // A-Z
					(keyCode >= 48 && keyCode <= 57)  || // 0-9
					keyCode === 32 // space
				);
	
				if (keyCode === KEY_DELETE || keyCode === KEY_BACKSPACE) {
					selection = getSelection($input[0]);
					if (selection.length) {
						value = value.substring(0, selection.start) + value.substring(selection.start + selection.length);
					} else if (keyCode === KEY_BACKSPACE && selection.start) {
						value = value.substring(0, selection.start - 1) + value.substring(selection.start + 1);
					} else if (keyCode === KEY_DELETE && typeof selection.start !== 'undefined') {
						value = value.substring(0, selection.start) + value.substring(selection.start + 1);
					}
				} else if (printable) {
					shift = e.shiftKey;
					character = String.fromCharCode(e.keyCode);
					if (shift) character = character.toUpperCase();
					else character = character.toLowerCase();
					value += character;
				}
			}
	
			placeholder = $input.attr('placeholder');
			if (!value && placeholder) {
				value = placeholder;
			}
	
			width = measureString(value, $input) + 4;
			if (width !== currentWidth) {
				currentWidth = width;
				$input.width(width);
				$input.triggerHandler('resize');
			}
		};
	
		$input.on('keydown keyup update blur', update);
		update();
	};
	
	var domToString = function(d) {
		var tmp = document.createElement('div');
	
		tmp.appendChild(d.cloneNode(true));
	
		return tmp.innerHTML;
	};
	
	var logError = function(message, options){
		if(!options) options = {};
		var component = "Selectize";
	
		console.error(component + ": " + message)
	
		if(options.explanation){
			// console.group is undefined in <IE11
			if(console.group) console.group();
			console.error(options.explanation);
			if(console.group) console.groupEnd();
		}
	}
	
	
	var Selectize = function($input, settings) {
		var key, i, n, dir, input, self = this;
		input = $input[0];
		input.selectize = self;
	
		// detect rtl environment
		var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);
		dir = computedStyle ? computedStyle.getPropertyValue('direction') : input.currentStyle && input.currentStyle.direction;
		dir = dir || $input.parents('[dir]:first').attr('dir') || '';
	
		// setup default state
		$.extend(self, {
			order            : 0,
			settings         : settings,
			$input           : $input,
			tabIndex         : $input.attr('tabindex') || '',
			tagType          : input.tagName.toLowerCase() === 'select' ? TAG_SELECT : TAG_INPUT,
			rtl              : /rtl/i.test(dir),
	
			eventNS          : '.selectize' + (++Selectize.count),
			highlightedValue : null,
			isOpen           : false,
			isDisabled       : false,
			isRequired       : $input.is('[required]'),
			isInvalid        : false,
			isLocked         : false,
			isFocused        : false,
			isInputHidden    : false,
			isSetup          : false,
			isShiftDown      : false,
			isCmdDown        : false,
			isCtrlDown       : false,
			ignoreFocus      : false,
			ignoreBlur       : false,
			ignoreHover      : false,
			hasOptions       : false,
			currentResults   : null,
			lastValue        : '',
			caretPos         : 0,
			loading          : 0,
			loadedSearches   : {},
	
			$activeOption    : null,
			$activeItems     : [],
	
			optgroups        : {},
			options          : {},
			userOptions      : {},
			items            : [],
			renderCache      : {},
			onSearchChange   : settings.loadThrottle === null ? self.onSearchChange : debounce(self.onSearchChange, settings.loadThrottle)
		});
	
		// search system
		self.sifter = new Sifter(this.options, {diacritics: settings.diacritics});
	
		// build options table
		if (self.settings.options) {
			for (i = 0, n = self.settings.options.length; i < n; i++) {
				self.registerOption(self.settings.options[i]);
			}
			delete self.settings.options;
		}
	
		// build optgroup table
		if (self.settings.optgroups) {
			for (i = 0, n = self.settings.optgroups.length; i < n; i++) {
				self.registerOptionGroup(self.settings.optgroups[i]);
			}
			delete self.settings.optgroups;
		}
	
		// option-dependent defaults
		self.settings.mode = self.settings.mode || (self.settings.maxItems === 1 ? 'single' : 'multi');
		if (typeof self.settings.hideSelected !== 'boolean') {
			self.settings.hideSelected = self.settings.mode === 'multi';
		}
	
		self.initializePlugins(self.settings.plugins);
		self.setupCallbacks();
		self.setupTemplates();
		self.setup();
	};
	
	// mixins
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	MicroEvent.mixin(Selectize);
	
	if(typeof MicroPlugin !== "undefined"){
		MicroPlugin.mixin(Selectize);
	}else{
		logError("Dependency MicroPlugin is missing",
			{explanation:
				"Make sure you either: (1) are using the \"standalone\" "+
				"version of Selectize, or (2) require MicroPlugin before you "+
				"load Selectize."}
		);
	}
	
	
	// methods
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	$.extend(Selectize.prototype, {
	
		/**
		 * Creates all elements and sets up event bindings.
		 */
		setup: function() {
			var self      = this;
			var settings  = self.settings;
			var eventNS   = self.eventNS;
			var $window   = $(window);
			var $document = $(document);
			var $input    = self.$input;
	
			var $wrapper;
			var $control;
			var $control_input;
			var $dropdown;
			var $dropdown_content;
			var $dropdown_parent;
			var inputMode;
			var timeout_blur;
			var timeout_focus;
			var classes;
			var classes_plugins;
			var inputId;
	
			inputMode         = self.settings.mode;
			classes           = $input.attr('class') || '';
	
			$wrapper          = $('<div>').addClass(settings.wrapperClass).addClass(classes).addClass(inputMode);
			$control          = $('<div>').addClass(settings.inputClass).addClass('items').appendTo($wrapper);
			$control_input    = $('<input type="text" autocomplete="off" />').appendTo($control).attr('tabindex', $input.is(':disabled') ? '-1' : self.tabIndex);
			$dropdown_parent  = $(settings.dropdownParent || $wrapper);
			$dropdown         = $('<div>').addClass(settings.dropdownClass).addClass(inputMode).hide().appendTo($dropdown_parent);
			$dropdown_content = $('<div>').addClass(settings.dropdownContentClass).appendTo($dropdown);
	
			if(inputId = $input.attr('id')) {
				$control_input.attr('id', inputId + '-selectized');
				$("label[for='"+inputId+"']").attr('for', inputId + '-selectized');
			}
	
			if(self.settings.copyClassesToDropdown) {
				$dropdown.addClass(classes);
			}
	
			$wrapper.css({
				width: $input[0].style.width
			});
	
			if (self.plugins.names.length) {
				classes_plugins = 'plugin-' + self.plugins.names.join(' plugin-');
				$wrapper.addClass(classes_plugins);
				$dropdown.addClass(classes_plugins);
			}
	
			if ((settings.maxItems === null || settings.maxItems > 1) && self.tagType === TAG_SELECT) {
				$input.attr('multiple', 'multiple');
			}
	
			if (self.settings.placeholder) {
				$control_input.attr('placeholder', settings.placeholder);
			}
	
			// if splitOn was not passed in, construct it from the delimiter to allow pasting universally
			if (!self.settings.splitOn && self.settings.delimiter) {
				var delimiterEscaped = self.settings.delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
				self.settings.splitOn = new RegExp('\\s*' + delimiterEscaped + '+\\s*');
			}
	
			if ($input.attr('autocorrect')) {
				$control_input.attr('autocorrect', $input.attr('autocorrect'));
			}
	
			if ($input.attr('autocapitalize')) {
				$control_input.attr('autocapitalize', $input.attr('autocapitalize'));
			}
	
			self.$wrapper          = $wrapper;
			self.$control          = $control;
			self.$control_input    = $control_input;
			self.$dropdown         = $dropdown;
			self.$dropdown_content = $dropdown_content;
	
			$dropdown.on('mouseenter', '[data-selectable]', function() { return self.onOptionHover.apply(self, arguments); });
			$dropdown.on('mousedown click', '[data-selectable]', function() { return self.onOptionSelect.apply(self, arguments); });
			watchChildEvent($control, 'mousedown', '*:not(input)', function() { return self.onItemSelect.apply(self, arguments); });
			autoGrow($control_input);
	
			$control.on({
				mousedown : function() { return self.onMouseDown.apply(self, arguments); },
				click     : function() { return self.onClick.apply(self, arguments); }
			});
	
			$control_input.on({
				mousedown : function(e) { e.stopPropagation(); },
				keydown   : function() { return self.onKeyDown.apply(self, arguments); },
				keyup     : function() { return self.onKeyUp.apply(self, arguments); },
				keypress  : function() { return self.onKeyPress.apply(self, arguments); },
				resize    : function() { self.positionDropdown.apply(self, []); },
				blur      : function() { return self.onBlur.apply(self, arguments); },
				focus     : function() { self.ignoreBlur = false; return self.onFocus.apply(self, arguments); },
				paste     : function() { return self.onPaste.apply(self, arguments); }
			});
	
			$document.on('keydown' + eventNS, function(e) {
				self.isCmdDown = e[IS_MAC ? 'metaKey' : 'ctrlKey'];
				self.isCtrlDown = e[IS_MAC ? 'altKey' : 'ctrlKey'];
				self.isShiftDown = e.shiftKey;
			});
	
			$document.on('keyup' + eventNS, function(e) {
				if (e.keyCode === KEY_CTRL) self.isCtrlDown = false;
				if (e.keyCode === KEY_SHIFT) self.isShiftDown = false;
				if (e.keyCode === KEY_CMD) self.isCmdDown = false;
			});
	
			$document.on('mousedown' + eventNS, function(e) {
				if (self.isFocused) {
					// prevent events on the dropdown scrollbar from causing the control to blur
					if (e.target === self.$dropdown[0] || e.target.parentNode === self.$dropdown[0]) {
						return false;
					}
					// blur on click outside
					if (!self.$control.has(e.target).length && e.target !== self.$control[0]) {
						self.blur(e.target);
					}
				}
			});
	
			$window.on(['scroll' + eventNS, 'resize' + eventNS].join(' '), function() {
				if (self.isOpen) {
					self.positionDropdown.apply(self, arguments);
				}
			});
			$window.on('mousemove' + eventNS, function() {
				self.ignoreHover = false;
			});
	
			// store original children and tab index so that they can be
			// restored when the destroy() method is called.
			this.revertSettings = {
				$children : $input.children().detach(),
				tabindex  : $input.attr('tabindex')
			};
	
			$input.attr('tabindex', -1).hide().after(self.$wrapper);
	
			if ($.isArray(settings.items)) {
				self.setValue(settings.items);
				delete settings.items;
			}
	
			// feature detect for the validation API
			if (SUPPORTS_VALIDITY_API) {
				$input.on('invalid' + eventNS, function(e) {
					e.preventDefault();
					self.isInvalid = true;
					self.refreshState();
				});
			}
	
			self.updateOriginalInput();
			self.refreshItems();
			self.refreshState();
			self.updatePlaceholder();
			self.isSetup = true;
	
			if ($input.is(':disabled')) {
				self.disable();
			}
	
			self.on('change', this.onChange);
	
			$input.data('selectize', self);
			$input.addClass('selectized');
			self.trigger('initialize');
	
			// preload options
			if (settings.preload === true) {
				self.onSearchChange('');
			}
	
		},
	
		/**
		 * Sets up default rendering functions.
		 */
		setupTemplates: function() {
			var self = this;
			var field_label = self.settings.labelField;
			var field_optgroup = self.settings.optgroupLabelField;
	
			var templates = {
				'optgroup': function(data) {
					return '<div class="optgroup">' + data.html + '</div>';
				},
				'optgroup_header': function(data, escape) {
					return '<div class="optgroup-header">' + escape(data[field_optgroup]) + '</div>';
				},
				'option': function(data, escape) {
					return '<div class="option">' + escape(data[field_label]) + '</div>';
				},
				'item': function(data, escape) {
					return '<div class="item">' + escape(data[field_label]) + '</div>';
				},
				'option_create': function(data, escape) {
					return '<div class="create">Add <strong>' + escape(data.input) + '</strong>&hellip;</div>';
				}
			};
	
			self.settings.render = $.extend({}, templates, self.settings.render);
		},
	
		/**
		 * Maps fired events to callbacks provided
		 * in the settings used when creating the control.
		 */
		setupCallbacks: function() {
			var key, fn, callbacks = {
				'initialize'      : 'onInitialize',
				'change'          : 'onChange',
				'item_add'        : 'onItemAdd',
				'item_remove'     : 'onItemRemove',
				'clear'           : 'onClear',
				'option_add'      : 'onOptionAdd',
				'option_remove'   : 'onOptionRemove',
				'option_clear'    : 'onOptionClear',
				'optgroup_add'    : 'onOptionGroupAdd',
				'optgroup_remove' : 'onOptionGroupRemove',
				'optgroup_clear'  : 'onOptionGroupClear',
				'dropdown_open'   : 'onDropdownOpen',
				'dropdown_close'  : 'onDropdownClose',
				'type'            : 'onType',
				'load'            : 'onLoad',
				'focus'           : 'onFocus',
				'blur'            : 'onBlur'
			};
	
			for (key in callbacks) {
				if (callbacks.hasOwnProperty(key)) {
					fn = this.settings[callbacks[key]];
					if (fn) this.on(key, fn);
				}
			}
		},
	
		/**
		 * Triggered when the main control element
		 * has a click event.
		 *
		 * @param {object} e
		 * @return {boolean}
		 */
		onClick: function(e) {
			var self = this;
	
			// necessary for mobile webkit devices (manual focus triggering
			// is ignored unless invoked within a click event)
			if (!self.isFocused) {
				self.focus();
				e.preventDefault();
			}
		},
	
		/**
		 * Triggered when the main control element
		 * has a mouse down event.
		 *
		 * @param {object} e
		 * @return {boolean}
		 */
		onMouseDown: function(e) {
			var self = this;
			var defaultPrevented = e.isDefaultPrevented();
			var $target = $(e.target);
	
			if (self.isFocused) {
				// retain focus by preventing native handling. if the
				// event target is the input it should not be modified.
				// otherwise, text selection within the input won't work.
				if (e.target !== self.$control_input[0]) {
					if (self.settings.mode === 'single') {
						// toggle dropdown
						self.isOpen ? self.close() : self.open();
					} else if (!defaultPrevented) {
						self.setActiveItem(null);
					}
					return false;
				}
			} else {
				// give control focus
				if (!defaultPrevented) {
					window.setTimeout(function() {
						self.focus();
					}, 0);
				}
			}
		},
	
		/**
		 * Triggered when the value of the control has been changed.
		 * This should propagate the event to the original DOM
		 * input / select element.
		 */
		onChange: function() {
			this.$input.trigger('change');
		},
	
		/**
		 * Triggered on <input> paste.
		 *
		 * @param {object} e
		 * @returns {boolean}
		 */
		onPaste: function(e) {
			var self = this;
	
			if (self.isFull() || self.isInputHidden || self.isLocked) {
				e.preventDefault();
				return;
			}
	
			// If a regex or string is included, this will split the pasted
			// input and create Items for each separate value
			if (self.settings.splitOn) {
	
				// Wait for pasted text to be recognized in value
				setTimeout(function() {
					var pastedText = self.$control_input.val();
					if(!pastedText.match(self.settings.splitOn)){ return }
	
					var splitInput = $.trim(pastedText).split(self.settings.splitOn);
					for (var i = 0, n = splitInput.length; i < n; i++) {
						self.createItem(splitInput[i]);
					}
				}, 0);
			}
		},
	
		/**
		 * Triggered on <input> keypress.
		 *
		 * @param {object} e
		 * @returns {boolean}
		 */
		onKeyPress: function(e) {
			if (this.isLocked) return e && e.preventDefault();
			var character = String.fromCharCode(e.keyCode || e.which);
			if (this.settings.create && this.settings.mode === 'multi' && character === this.settings.delimiter) {
				this.createItem();
				e.preventDefault();
				return false;
			}
		},
	
		/**
		 * Triggered on <input> keydown.
		 *
		 * @param {object} e
		 * @returns {boolean}
		 */
		onKeyDown: function(e) {
			var isInput = e.target === this.$control_input[0];
			var self = this;
	
			if (self.isLocked) {
				if (e.keyCode !== KEY_TAB) {
					e.preventDefault();
				}
				return;
			}
	
			switch (e.keyCode) {
				case KEY_A:
					if (self.isCmdDown) {
						self.selectAll();
						return;
					}
					break;
				case KEY_ESC:
					if (self.isOpen) {
						e.preventDefault();
						e.stopPropagation();
						self.close();
					}
					return;
				case KEY_N:
					if (!e.ctrlKey || e.altKey) break;
				case KEY_DOWN:
					if (!self.isOpen && self.hasOptions) {
						self.open();
					} else if (self.$activeOption) {
						self.ignoreHover = true;
						var $next = self.getAdjacentOption(self.$activeOption, 1);
						if ($next.length) self.setActiveOption($next, true, true);
					}
					e.preventDefault();
					return;
				case KEY_P:
					if (!e.ctrlKey || e.altKey) break;
				case KEY_UP:
					if (self.$activeOption) {
						self.ignoreHover = true;
						var $prev = self.getAdjacentOption(self.$activeOption, -1);
						if ($prev.length) self.setActiveOption($prev, true, true);
					}
					e.preventDefault();
					return;
				case KEY_RETURN:
					if (self.isOpen && self.$activeOption) {
						self.onOptionSelect({currentTarget: self.$activeOption});
						e.preventDefault();
					}
					return;
				case KEY_LEFT:
					self.advanceSelection(-1, e);
					return;
				case KEY_RIGHT:
					self.advanceSelection(1, e);
					return;
				case KEY_TAB:
					if (self.settings.selectOnTab && self.isOpen && self.$activeOption) {
						self.onOptionSelect({currentTarget: self.$activeOption});
	
						// Default behaviour is to jump to the next field, we only want this
						// if the current field doesn't accept any more entries
						if (!self.isFull()) {
							e.preventDefault();
						}
					}
					if (self.settings.create && self.createItem()) {
						e.preventDefault();
					}
					return;
				case KEY_BACKSPACE:
				case KEY_DELETE:
					self.deleteSelection(e);
					return;
			}
	
			if ((self.isFull() || self.isInputHidden) && !(IS_MAC ? e.metaKey : e.ctrlKey)) {
				e.preventDefault();
				return;
			}
		},
	
		/**
		 * Triggered on <input> keyup.
		 *
		 * @param {object} e
		 * @returns {boolean}
		 */
		onKeyUp: function(e) {
			var self = this;
	
			if (self.isLocked) return e && e.preventDefault();
			var value = self.$control_input.val() || '';
			if (self.lastValue !== value) {
				self.lastValue = value;
				self.onSearchChange(value);
				self.refreshOptions();
				self.trigger('type', value);
			}
		},
	
		/**
		 * Invokes the user-provide option provider / loader.
		 *
		 * Note: this function is debounced in the Selectize
		 * constructor (by `settings.loadThrottle` milliseconds)
		 *
		 * @param {string} value
		 */
		onSearchChange: function(value) {
			var self = this;
			var fn = self.settings.load;
			if (!fn) return;
			if (self.loadedSearches.hasOwnProperty(value)) return;
			self.loadedSearches[value] = true;
			self.load(function(callback) {
				fn.apply(self, [value, callback]);
			});
		},
	
		/**
		 * Triggered on <input> focus.
		 *
		 * @param {object} e (optional)
		 * @returns {boolean}
		 */
		onFocus: function(e) {
			var self = this;
			var wasFocused = self.isFocused;
	
			if (self.isDisabled) {
				self.blur();
				e && e.preventDefault();
				return false;
			}
	
			if (self.ignoreFocus) return;
			self.isFocused = true;
			if (self.settings.preload === 'focus') self.onSearchChange('');
	
			if (!wasFocused) self.trigger('focus');
	
			if (!self.$activeItems.length) {
				self.showInput();
				self.setActiveItem(null);
				self.refreshOptions(!!self.settings.openOnFocus);
			}
	
			self.refreshState();
		},
	
		/**
		 * Triggered on <input> blur.
		 *
		 * @param {object} e
		 * @param {Element} dest
		 */
		onBlur: function(e, dest) {
			var self = this;
			if (!self.isFocused) return;
			self.isFocused = false;
	
			if (self.ignoreFocus) {
				return;
			} else if (!self.ignoreBlur && document.activeElement === self.$dropdown_content[0]) {
				// necessary to prevent IE closing the dropdown when the scrollbar is clicked
				self.ignoreBlur = true;
				self.onFocus(e);
				return;
			}
	
			var deactivate = function() {
				self.close();
				self.setTextboxValue('');
				self.setActiveItem(null);
				self.setActiveOption(null);
				self.setCaret(self.items.length);
				self.refreshState();
	
				// IE11 bug: element still marked as active
				dest && dest.focus && dest.focus();
	
				self.ignoreFocus = false;
				self.trigger('blur');
			};
	
			self.ignoreFocus = true;
			if (self.settings.create && self.settings.createOnBlur) {
				self.createItem(null, false, deactivate);
			} else {
				deactivate();
			}
		},
	
		/**
		 * Triggered when the user rolls over
		 * an option in the autocomplete dropdown menu.
		 *
		 * @param {object} e
		 * @returns {boolean}
		 */
		onOptionHover: function(e) {
			if (this.ignoreHover) return;
			this.setActiveOption(e.currentTarget, false);
		},
	
		/**
		 * Triggered when the user clicks on an option
		 * in the autocomplete dropdown menu.
		 *
		 * @param {object} e
		 * @returns {boolean}
		 */
		onOptionSelect: function(e) {
			var value, $target, $option, self = this;
	
			if (e.preventDefault) {
				e.preventDefault();
				e.stopPropagation();
			}
	
			$target = $(e.currentTarget);
			if ($target.hasClass('create')) {
				self.createItem(null, function() {
					if (self.settings.closeAfterSelect) {
						self.close();
					}
				});
			} else {
				value = $target.attr('data-value');
				if (typeof value !== 'undefined') {
					self.lastQuery = null;
					self.setTextboxValue('');
					self.addItem(value);
					if (self.settings.closeAfterSelect) {
						self.close();
					} else if (!self.settings.hideSelected && e.type && /mouse/.test(e.type)) {
						self.setActiveOption(self.getOption(value));
					}
				}
			}
		},
	
		/**
		 * Triggered when the user clicks on an item
		 * that has been selected.
		 *
		 * @param {object} e
		 * @returns {boolean}
		 */
		onItemSelect: function(e) {
			var self = this;
	
			if (self.isLocked) return;
			if (self.settings.mode === 'multi') {
				e.preventDefault();
				self.setActiveItem(e.currentTarget, e);
			}
		},
	
		/**
		 * Invokes the provided method that provides
		 * results to a callback---which are then added
		 * as options to the control.
		 *
		 * @param {function} fn
		 */
		load: function(fn) {
			var self = this;
			var $wrapper = self.$wrapper.addClass(self.settings.loadingClass);
	
			self.loading++;
			fn.apply(self, [function(results) {
				self.loading = Math.max(self.loading - 1, 0);
				if (results && results.length) {
					self.addOption(results);
					self.refreshOptions(self.isFocused && !self.isInputHidden);
				}
				if (!self.loading) {
					$wrapper.removeClass(self.settings.loadingClass);
				}
				self.trigger('load', results);
			}]);
		},
	
		/**
		 * Sets the input field of the control to the specified value.
		 *
		 * @param {string} value
		 */
		setTextboxValue: function(value) {
			var $input = this.$control_input;
			var changed = $input.val() !== value;
			if (changed) {
				$input.val(value).triggerHandler('update');
				this.lastValue = value;
			}
		},
	
		/**
		 * Returns the value of the control. If multiple items
		 * can be selected (e.g. <select multiple>), this returns
		 * an array. If only one item can be selected, this
		 * returns a string.
		 *
		 * @returns {mixed}
		 */
		getValue: function() {
			if (this.tagType === TAG_SELECT && this.$input.attr('multiple')) {
				return this.items;
			} else {
				return this.items.join(this.settings.delimiter);
			}
		},
	
		/**
		 * Resets the selected items to the given value.
		 *
		 * @param {mixed} value
		 */
		setValue: function(value, silent) {
			var events = silent ? [] : ['change'];
	
			debounce_events(this, events, function() {
				this.clear(silent);
				this.addItems(value, silent);
			});
		},
	
		/**
		 * Sets the selected item.
		 *
		 * @param {object} $item
		 * @param {object} e (optional)
		 */
		setActiveItem: function($item, e) {
			var self = this;
			var eventName;
			var i, idx, begin, end, item, swap;
			var $last;
	
			if (self.settings.mode === 'single') return;
			$item = $($item);
	
			// clear the active selection
			if (!$item.length) {
				$(self.$activeItems).removeClass('active');
				self.$activeItems = [];
				if (self.isFocused) {
					self.showInput();
				}
				return;
			}
	
			// modify selection
			eventName = e && e.type.toLowerCase();
	
			if (eventName === 'mousedown' && self.isShiftDown && self.$activeItems.length) {
				$last = self.$control.children('.active:last');
				begin = Array.prototype.indexOf.apply(self.$control[0].childNodes, [$last[0]]);
				end   = Array.prototype.indexOf.apply(self.$control[0].childNodes, [$item[0]]);
				if (begin > end) {
					swap  = begin;
					begin = end;
					end   = swap;
				}
				for (i = begin; i <= end; i++) {
					item = self.$control[0].childNodes[i];
					if (self.$activeItems.indexOf(item) === -1) {
						$(item).addClass('active');
						self.$activeItems.push(item);
					}
				}
				e.preventDefault();
			} else if ((eventName === 'mousedown' && self.isCtrlDown) || (eventName === 'keydown' && this.isShiftDown)) {
				if ($item.hasClass('active')) {
					idx = self.$activeItems.indexOf($item[0]);
					self.$activeItems.splice(idx, 1);
					$item.removeClass('active');
				} else {
					self.$activeItems.push($item.addClass('active')[0]);
				}
			} else {
				$(self.$activeItems).removeClass('active');
				self.$activeItems = [$item.addClass('active')[0]];
			}
	
			// ensure control has focus
			self.hideInput();
			if (!this.isFocused) {
				self.focus();
			}
		},
	
		/**
		 * Sets the selected item in the dropdown menu
		 * of available options.
		 *
		 * @param {object} $object
		 * @param {boolean} scroll
		 * @param {boolean} animate
		 */
		setActiveOption: function($option, scroll, animate) {
			var height_menu, height_item, y;
			var scroll_top, scroll_bottom;
			var self = this;
	
			if (self.$activeOption) self.$activeOption.removeClass('active');
			self.$activeOption = null;
	
			$option = $($option);
			if (!$option.length) return;
	
			self.$activeOption = $option.addClass('active');
	
			if (scroll || !isset(scroll)) {
	
				height_menu   = self.$dropdown_content.height();
				height_item   = self.$activeOption.outerHeight(true);
				scroll        = self.$dropdown_content.scrollTop() || 0;
				y             = self.$activeOption.offset().top - self.$dropdown_content.offset().top + scroll;
				scroll_top    = y;
				scroll_bottom = y - height_menu + height_item;
	
				if (y + height_item > height_menu + scroll) {
					self.$dropdown_content.stop().animate({scrollTop: scroll_bottom}, animate ? self.settings.scrollDuration : 0);
				} else if (y < scroll) {
					self.$dropdown_content.stop().animate({scrollTop: scroll_top}, animate ? self.settings.scrollDuration : 0);
				}
	
			}
		},
	
		/**
		 * Selects all items (CTRL + A).
		 */
		selectAll: function() {
			var self = this;
			if (self.settings.mode === 'single') return;
	
			self.$activeItems = Array.prototype.slice.apply(self.$control.children(':not(input)').addClass('active'));
			if (self.$activeItems.length) {
				self.hideInput();
				self.close();
			}
			self.focus();
		},
	
		/**
		 * Hides the input element out of view, while
		 * retaining its focus.
		 */
		hideInput: function() {
			var self = this;
	
			self.setTextboxValue('');
			self.$control_input.css({opacity: 0, position: 'absolute', left: self.rtl ? 10000 : -10000});
			self.isInputHidden = true;
		},
	
		/**
		 * Restores input visibility.
		 */
		showInput: function() {
			this.$control_input.css({opacity: 1, position: 'relative', left: 0});
			this.isInputHidden = false;
		},
	
		/**
		 * Gives the control focus.
		 */
		focus: function() {
			var self = this;
			if (self.isDisabled) return;
	
			self.ignoreFocus = true;
			self.$control_input[0].focus();
			window.setTimeout(function() {
				self.ignoreFocus = false;
				self.onFocus();
			}, 0);
		},
	
		/**
		 * Forces the control out of focus.
		 *
		 * @param {Element} dest
		 */
		blur: function(dest) {
			this.$control_input[0].blur();
			this.onBlur(null, dest);
		},
	
		/**
		 * Returns a function that scores an object
		 * to show how good of a match it is to the
		 * provided query.
		 *
		 * @param {string} query
		 * @param {object} options
		 * @return {function}
		 */
		getScoreFunction: function(query) {
			return this.sifter.getScoreFunction(query, this.getSearchOptions());
		},
	
		/**
		 * Returns search options for sifter (the system
		 * for scoring and sorting results).
		 *
		 * @see https://github.com/brianreavis/sifter.js
		 * @return {object}
		 */
		getSearchOptions: function() {
			var settings = this.settings;
			var sort = settings.sortField;
			if (typeof sort === 'string') {
				sort = [{field: sort}];
			}
	
			return {
				fields      : settings.searchField,
				conjunction : settings.searchConjunction,
				sort        : sort
			};
		},
	
		/**
		 * Searches through available options and returns
		 * a sorted array of matches.
		 *
		 * Returns an object containing:
		 *
		 *   - query {string}
		 *   - tokens {array}
		 *   - total {int}
		 *   - items {array}
		 *
		 * @param {string} query
		 * @returns {object}
		 */
		search: function(query) {
			var i, value, score, result, calculateScore;
			var self     = this;
			var settings = self.settings;
			var options  = this.getSearchOptions();
	
			// validate user-provided result scoring function
			if (settings.score) {
				calculateScore = self.settings.score.apply(this, [query]);
				if (typeof calculateScore !== 'function') {
					throw new Error('Selectize "score" setting must be a function that returns a function');
				}
			}
	
			// perform search
			if (query !== self.lastQuery) {
				self.lastQuery = query;
				result = self.sifter.search(query, $.extend(options, {score: calculateScore}));
				self.currentResults = result;
			} else {
				result = $.extend(true, {}, self.currentResults);
			}
	
			// filter out selected items
			if (settings.hideSelected) {
				for (i = result.items.length - 1; i >= 0; i--) {
					if (self.items.indexOf(hash_key(result.items[i].id)) !== -1) {
						result.items.splice(i, 1);
					}
				}
			}
	
			return result;
		},
	
		/**
		 * Refreshes the list of available options shown
		 * in the autocomplete dropdown menu.
		 *
		 * @param {boolean} triggerDropdown
		 */
		refreshOptions: function(triggerDropdown) {
			var i, j, k, n, groups, groups_order, option, option_html, optgroup, optgroups, html, html_children, has_create_option;
			var $active, $active_before, $create;
	
			if (typeof triggerDropdown === 'undefined') {
				triggerDropdown = true;
			}
	
			var self              = this;
			var query             = $.trim(self.$control_input.val());
			var results           = self.search(query);
			var $dropdown_content = self.$dropdown_content;
			var active_before     = self.$activeOption && hash_key(self.$activeOption.attr('data-value'));
	
			// build markup
			n = results.items.length;
			if (typeof self.settings.maxOptions === 'number') {
				n = Math.min(n, self.settings.maxOptions);
			}
	
			// render and group available options individually
			groups = {};
			groups_order = [];
	
			for (i = 0; i < n; i++) {
				option      = self.options[results.items[i].id];
				option_html = self.render('option', option);
				optgroup    = option[self.settings.optgroupField] || '';
				optgroups   = $.isArray(optgroup) ? optgroup : [optgroup];
	
				for (j = 0, k = optgroups && optgroups.length; j < k; j++) {
					optgroup = optgroups[j];
					if (!self.optgroups.hasOwnProperty(optgroup)) {
						optgroup = '';
					}
					if (!groups.hasOwnProperty(optgroup)) {
						groups[optgroup] = document.createDocumentFragment();
						groups_order.push(optgroup);
					}
					groups[optgroup].appendChild(option_html);
				}
			}
	
			// sort optgroups
			if (this.settings.lockOptgroupOrder) {
				groups_order.sort(function(a, b) {
					var a_order = self.optgroups[a].$order || 0;
					var b_order = self.optgroups[b].$order || 0;
					return a_order - b_order;
				});
			}
	
			// render optgroup headers & join groups
			html = document.createDocumentFragment();
			for (i = 0, n = groups_order.length; i < n; i++) {
				optgroup = groups_order[i];
				if (self.optgroups.hasOwnProperty(optgroup) && groups[optgroup].childNodes.length) {
					// render the optgroup header and options within it,
					// then pass it to the wrapper template
					html_children = document.createDocumentFragment();
					html_children.appendChild(self.render('optgroup_header', self.optgroups[optgroup]));
					html_children.appendChild(groups[optgroup]);
	
					html.appendChild(self.render('optgroup', $.extend({}, self.optgroups[optgroup], {
						html: domToString(html_children),
						dom:  html_children
					})));
				} else {
					html.appendChild(groups[optgroup]);
				}
			}
	
			$dropdown_content.html(html);
	
			// highlight matching terms inline
			if (self.settings.highlight && results.query.length && results.tokens.length) {
				$dropdown_content.removeHighlight();
				for (i = 0, n = results.tokens.length; i < n; i++) {
					highlight($dropdown_content, results.tokens[i].regex);
				}
			}
	
			// add "selected" class to selected options
			if (!self.settings.hideSelected) {
				for (i = 0, n = self.items.length; i < n; i++) {
					self.getOption(self.items[i]).addClass('selected');
				}
			}
	
			// add create option
			has_create_option = self.canCreate(query);
			if (has_create_option) {
				$dropdown_content.prepend(self.render('option_create', {input: query}));
				$create = $($dropdown_content[0].childNodes[0]);
			}
	
			// activate
			self.hasOptions = results.items.length > 0 || has_create_option;
			if (self.hasOptions) {
				if (results.items.length > 0) {
					$active_before = active_before && self.getOption(active_before);
					if ($active_before && $active_before.length) {
						$active = $active_before;
					} else if (self.settings.mode === 'single' && self.items.length) {
						$active = self.getOption(self.items[0]);
					}
					if (!$active || !$active.length) {
						if ($create && !self.settings.addPrecedence) {
							$active = self.getAdjacentOption($create, 1);
						} else {
							$active = $dropdown_content.find('[data-selectable]:first');
						}
					}
				} else {
					$active = $create;
				}
				self.setActiveOption($active);
				if (triggerDropdown && !self.isOpen) { self.open(); }
			} else {
				self.setActiveOption(null);
				if (triggerDropdown && self.isOpen) { self.close(); }
			}
		},
	
		/**
		 * Adds an available option. If it already exists,
		 * nothing will happen. Note: this does not refresh
		 * the options list dropdown (use `refreshOptions`
		 * for that).
		 *
		 * Usage:
		 *
		 *   this.addOption(data)
		 *
		 * @param {object|array} data
		 */
		addOption: function(data) {
			var i, n, value, self = this;
	
			if ($.isArray(data)) {
				for (i = 0, n = data.length; i < n; i++) {
					self.addOption(data[i]);
				}
				return;
			}
	
			if (value = self.registerOption(data)) {
				self.userOptions[value] = true;
				self.lastQuery = null;
				self.trigger('option_add', value, data);
			}
		},
	
		/**
		 * Registers an option to the pool of options.
		 *
		 * @param {object} data
		 * @return {boolean|string}
		 */
		registerOption: function(data) {
			var key = hash_key(data[this.settings.valueField]);
			if (typeof key === 'undefined' || key === null || this.options.hasOwnProperty(key)) return false;
			data.$order = data.$order || ++this.order;
			this.options[key] = data;
			return key;
		},
	
		/**
		 * Registers an option group to the pool of option groups.
		 *
		 * @param {object} data
		 * @return {boolean|string}
		 */
		registerOptionGroup: function(data) {
			var key = hash_key(data[this.settings.optgroupValueField]);
			if (!key) return false;
	
			data.$order = data.$order || ++this.order;
			this.optgroups[key] = data;
			return key;
		},
	
		/**
		 * Registers a new optgroup for options
		 * to be bucketed into.
		 *
		 * @param {string} id
		 * @param {object} data
		 */
		addOptionGroup: function(id, data) {
			data[this.settings.optgroupValueField] = id;
			if (id = this.registerOptionGroup(data)) {
				this.trigger('optgroup_add', id, data);
			}
		},
	
		/**
		 * Removes an existing option group.
		 *
		 * @param {string} id
		 */
		removeOptionGroup: function(id) {
			if (this.optgroups.hasOwnProperty(id)) {
				delete this.optgroups[id];
				this.renderCache = {};
				this.trigger('optgroup_remove', id);
			}
		},
	
		/**
		 * Clears all existing option groups.
		 */
		clearOptionGroups: function() {
			this.optgroups = {};
			this.renderCache = {};
			this.trigger('optgroup_clear');
		},
	
		/**
		 * Updates an option available for selection. If
		 * it is visible in the selected items or options
		 * dropdown, it will be re-rendered automatically.
		 *
		 * @param {string} value
		 * @param {object} data
		 */
		updateOption: function(value, data) {
			var self = this;
			var $item, $item_new;
			var value_new, index_item, cache_items, cache_options, order_old;
	
			value     = hash_key(value);
			value_new = hash_key(data[self.settings.valueField]);
	
			// sanity checks
			if (value === null) return;
			if (!self.options.hasOwnProperty(value)) return;
			if (typeof value_new !== 'string') throw new Error('Value must be set in option data');
	
			order_old = self.options[value].$order;
	
			// update references
			if (value_new !== value) {
				delete self.options[value];
				index_item = self.items.indexOf(value);
				if (index_item !== -1) {
					self.items.splice(index_item, 1, value_new);
				}
			}
			data.$order = data.$order || order_old;
			self.options[value_new] = data;
	
			// invalidate render cache
			cache_items = self.renderCache['item'];
			cache_options = self.renderCache['option'];
	
			if (cache_items) {
				delete cache_items[value];
				delete cache_items[value_new];
			}
			if (cache_options) {
				delete cache_options[value];
				delete cache_options[value_new];
			}
	
			// update the item if it's selected
			if (self.items.indexOf(value_new) !== -1) {
				$item = self.getItem(value);
				$item_new = $(self.render('item', data));
				if ($item.hasClass('active')) $item_new.addClass('active');
				$item.replaceWith($item_new);
			}
	
			// invalidate last query because we might have updated the sortField
			self.lastQuery = null;
	
			// update dropdown contents
			if (self.isOpen) {
				self.refreshOptions(false);
			}
		},
	
		/**
		 * Removes a single option.
		 *
		 * @param {string} value
		 * @param {boolean} silent
		 */
		removeOption: function(value, silent) {
			var self = this;
			value = hash_key(value);
	
			var cache_items = self.renderCache['item'];
			var cache_options = self.renderCache['option'];
			if (cache_items) delete cache_items[value];
			if (cache_options) delete cache_options[value];
	
			delete self.userOptions[value];
			delete self.options[value];
			self.lastQuery = null;
			self.trigger('option_remove', value);
			self.removeItem(value, silent);
		},
	
		/**
		 * Clears all options.
		 */
		clearOptions: function() {
			var self = this;
	
			self.loadedSearches = {};
			self.userOptions = {};
			self.renderCache = {};
			self.options = self.sifter.items = {};
			self.lastQuery = null;
			self.trigger('option_clear');
			self.clear();
		},
	
		/**
		 * Returns the jQuery element of the option
		 * matching the given value.
		 *
		 * @param {string} value
		 * @returns {object}
		 */
		getOption: function(value) {
			return this.getElementWithValue(value, this.$dropdown_content.find('[data-selectable]'));
		},
	
		/**
		 * Returns the jQuery element of the next or
		 * previous selectable option.
		 *
		 * @param {object} $option
		 * @param {int} direction  can be 1 for next or -1 for previous
		 * @return {object}
		 */
		getAdjacentOption: function($option, direction) {
			var $options = this.$dropdown.find('[data-selectable]');
			var index    = $options.index($option) + direction;
	
			return index >= 0 && index < $options.length ? $options.eq(index) : $();
		},
	
		/**
		 * Finds the first element with a "data-value" attribute
		 * that matches the given value.
		 *
		 * @param {mixed} value
		 * @param {object} $els
		 * @return {object}
		 */
		getElementWithValue: function(value, $els) {
			value = hash_key(value);
	
			if (typeof value !== 'undefined' && value !== null) {
				for (var i = 0, n = $els.length; i < n; i++) {
					if ($els[i].getAttribute('data-value') === value) {
						return $($els[i]);
					}
				}
			}
	
			return $();
		},
	
		/**
		 * Returns the jQuery element of the item
		 * matching the given value.
		 *
		 * @param {string} value
		 * @returns {object}
		 */
		getItem: function(value) {
			return this.getElementWithValue(value, this.$control.children());
		},
	
		/**
		 * "Selects" multiple items at once. Adds them to the list
		 * at the current caret position.
		 *
		 * @param {string} value
		 * @param {boolean} silent
		 */
		addItems: function(values, silent) {
			var items = $.isArray(values) ? values : [values];
			for (var i = 0, n = items.length; i < n; i++) {
				this.isPending = (i < n - 1);
				this.addItem(items[i], silent);
			}
		},
	
		/**
		 * "Selects" an item. Adds it to the list
		 * at the current caret position.
		 *
		 * @param {string} value
		 * @param {boolean} silent
		 */
		addItem: function(value, silent) {
			var events = silent ? [] : ['change'];
	
			debounce_events(this, events, function() {
				var $item, $option, $options;
				var self = this;
				var inputMode = self.settings.mode;
				var i, active, value_next, wasFull;
				value = hash_key(value);
	
				if (self.items.indexOf(value) !== -1) {
					if (inputMode === 'single') self.close();
					return;
				}
	
				if (!self.options.hasOwnProperty(value)) return;
				if (inputMode === 'single') self.clear(silent);
				if (inputMode === 'multi' && self.isFull()) return;
	
				$item = $(self.render('item', self.options[value]));
				wasFull = self.isFull();
				self.items.splice(self.caretPos, 0, value);
				self.insertAtCaret($item);
				if (!self.isPending || (!wasFull && self.isFull())) {
					self.refreshState();
				}
	
				if (self.isSetup) {
					$options = self.$dropdown_content.find('[data-selectable]');
	
					// update menu / remove the option (if this is not one item being added as part of series)
					if (!self.isPending) {
						$option = self.getOption(value);
						value_next = self.getAdjacentOption($option, 1).attr('data-value');
						self.refreshOptions(self.isFocused && inputMode !== 'single');
						if (value_next) {
							self.setActiveOption(self.getOption(value_next));
						}
					}
	
					// hide the menu if the maximum number of items have been selected or no options are left
					if (!$options.length || self.isFull()) {
						self.close();
					} else {
						self.positionDropdown();
					}
	
					self.updatePlaceholder();
					self.trigger('item_add', value, $item);
					self.updateOriginalInput({silent: silent});
				}
			});
		},
	
		/**
		 * Removes the selected item matching
		 * the provided value.
		 *
		 * @param {string} value
		 */
		removeItem: function(value, silent) {
			var self = this;
			var $item, i, idx;
	
			$item = (value instanceof $) ? value : self.getItem(value);
			value = hash_key($item.attr('data-value'));
			i = self.items.indexOf(value);
	
			if (i !== -1) {
				$item.remove();
				if ($item.hasClass('active')) {
					idx = self.$activeItems.indexOf($item[0]);
					self.$activeItems.splice(idx, 1);
				}
	
				self.items.splice(i, 1);
				self.lastQuery = null;
				if (!self.settings.persist && self.userOptions.hasOwnProperty(value)) {
					self.removeOption(value, silent);
				}
	
				if (i < self.caretPos) {
					self.setCaret(self.caretPos - 1);
				}
	
				self.refreshState();
				self.updatePlaceholder();
				self.updateOriginalInput({silent: silent});
				self.positionDropdown();
				self.trigger('item_remove', value, $item);
			}
		},
	
		/**
		 * Invokes the `create` method provided in the
		 * selectize options that should provide the data
		 * for the new item, given the user input.
		 *
		 * Once this completes, it will be added
		 * to the item list.
		 *
		 * @param {string} value
		 * @param {boolean} [triggerDropdown]
		 * @param {function} [callback]
		 * @return {boolean}
		 */
		createItem: function(input, triggerDropdown) {
			var self  = this;
			var caret = self.caretPos;
			input = input || $.trim(self.$control_input.val() || '');
	
			var callback = arguments[arguments.length - 1];
			if (typeof callback !== 'function') callback = function() {};
	
			if (typeof triggerDropdown !== 'boolean') {
				triggerDropdown = true;
			}
	
			if (!self.canCreate(input)) {
				callback();
				return false;
			}
	
			self.lock();
	
			var setup = (typeof self.settings.create === 'function') ? this.settings.create : function(input) {
				var data = {};
				data[self.settings.labelField] = input;
				data[self.settings.valueField] = input;
				return data;
			};
	
			var create = once(function(data) {
				self.unlock();
	
				if (!data || typeof data !== 'object') return callback();
				var value = hash_key(data[self.settings.valueField]);
				if (typeof value !== 'string') return callback();
	
				self.setTextboxValue('');
				self.addOption(data);
				self.setCaret(caret);
				self.addItem(value);
				self.refreshOptions(triggerDropdown && self.settings.mode !== 'single');
				callback(data);
			});
	
			var output = setup.apply(this, [input, create]);
			if (typeof output !== 'undefined') {
				create(output);
			}
	
			return true;
		},
	
		/**
		 * Re-renders the selected item lists.
		 */
		refreshItems: function() {
			this.lastQuery = null;
	
			if (this.isSetup) {
				this.addItem(this.items);
			}
	
			this.refreshState();
			this.updateOriginalInput();
		},
	
		/**
		 * Updates all state-dependent attributes
		 * and CSS classes.
		 */
		refreshState: function() {
			this.refreshValidityState();
			this.refreshClasses();
		},
	
		/**
		 * Update the `required` attribute of both input and control input.
		 *
		 * The `required` property needs to be activated on the control input
		 * for the error to be displayed at the right place. `required` also
		 * needs to be temporarily deactivated on the input since the input is
		 * hidden and can't show errors.
		 */
		refreshValidityState: function() {
			if (!this.isRequired) return false;
	
			var invalid = !this.items.length;
	
			this.isInvalid = invalid;
			this.$control_input.prop('required', invalid);
			this.$input.prop('required', !invalid);
		},
	
		/**
		 * Updates all state-dependent CSS classes.
		 */
		refreshClasses: function() {
			var self     = this;
			var isFull   = self.isFull();
			var isLocked = self.isLocked;
	
			self.$wrapper
				.toggleClass('rtl', self.rtl);
	
			self.$control
				.toggleClass('focus', self.isFocused)
				.toggleClass('disabled', self.isDisabled)
				.toggleClass('required', self.isRequired)
				.toggleClass('invalid', self.isInvalid)
				.toggleClass('locked', isLocked)
				.toggleClass('full', isFull).toggleClass('not-full', !isFull)
				.toggleClass('input-active', self.isFocused && !self.isInputHidden)
				.toggleClass('dropdown-active', self.isOpen)
				.toggleClass('has-options', !$.isEmptyObject(self.options))
				.toggleClass('has-items', self.items.length > 0);
	
			self.$control_input.data('grow', !isFull && !isLocked);
		},
	
		/**
		 * Determines whether or not more items can be added
		 * to the control without exceeding the user-defined maximum.
		 *
		 * @returns {boolean}
		 */
		isFull: function() {
			return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;
		},
	
		/**
		 * Refreshes the original <select> or <input>
		 * element to reflect the current state.
		 */
		updateOriginalInput: function(opts) {
			var i, n, options, label, self = this;
			opts = opts || {};
	
			if (self.tagType === TAG_SELECT) {
				options = [];
				for (i = 0, n = self.items.length; i < n; i++) {
					label = self.options[self.items[i]][self.settings.labelField] || '';
					options.push('<option value="' + escape_html(self.items[i]) + '" selected="selected">' + escape_html(label) + '</option>');
				}
				if (!options.length && !this.$input.attr('multiple')) {
					options.push('<option value="" selected="selected"></option>');
				}
				self.$input.html(options.join(''));
			} else {
				self.$input.val(self.getValue());
				self.$input.attr('value',self.$input.val());
			}
	
			if (self.isSetup) {
				if (!opts.silent) {
					self.trigger('change', self.$input.val());
				}
			}
		},
	
		/**
		 * Shows/hide the input placeholder depending
		 * on if there items in the list already.
		 */
		updatePlaceholder: function() {
			if (!this.settings.placeholder) return;
			var $input = this.$control_input;
	
			if (this.items.length) {
				$input.removeAttr('placeholder');
			} else {
				$input.attr('placeholder', this.settings.placeholder);
			}
			$input.triggerHandler('update', {force: true});
		},
	
		/**
		 * Shows the autocomplete dropdown containing
		 * the available options.
		 */
		open: function() {
			var self = this;
	
			if (self.isLocked || self.isOpen || (self.settings.mode === 'multi' && self.isFull())) return;
			self.focus();
			self.isOpen = true;
			self.refreshState();
			self.$dropdown.css({visibility: 'hidden', display: 'block'});
			self.positionDropdown();
			self.$dropdown.css({visibility: 'visible'});
			self.trigger('dropdown_open', self.$dropdown);
		},
	
		/**
		 * Closes the autocomplete dropdown menu.
		 */
		close: function() {
			var self = this;
			var trigger = self.isOpen;
	
			if (self.settings.mode === 'single' && self.items.length) {
				self.hideInput();
				self.$control_input.blur(); // close keyboard on iOS
			}
	
			self.isOpen = false;
			self.$dropdown.hide();
			self.setActiveOption(null);
			self.refreshState();
	
			if (trigger) self.trigger('dropdown_close', self.$dropdown);
		},
	
		/**
		 * Calculates and applies the appropriate
		 * position of the dropdown.
		 */
		positionDropdown: function() {
			var $control = this.$control;
			var offset = this.settings.dropdownParent === 'body' ? $control.offset() : $control.position();
			offset.top += $control.outerHeight(true);
	
			this.$dropdown.css({
				width : $control.outerWidth(),
				top   : offset.top,
				left  : offset.left
			});
		},
	
		/**
		 * Resets / clears all selected items
		 * from the control.
		 *
		 * @param {boolean} silent
		 */
		clear: function(silent) {
			var self = this;
	
			if (!self.items.length) return;
			self.$control.children(':not(input)').remove();
			self.items = [];
			self.lastQuery = null;
			self.setCaret(0);
			self.setActiveItem(null);
			self.updatePlaceholder();
			self.updateOriginalInput({silent: silent});
			self.refreshState();
			self.showInput();
			self.trigger('clear');
		},
	
		/**
		 * A helper method for inserting an element
		 * at the current caret position.
		 *
		 * @param {object} $el
		 */
		insertAtCaret: function($el) {
			var caret = Math.min(this.caretPos, this.items.length);
			if (caret === 0) {
				this.$control.prepend($el);
			} else {
				$(this.$control[0].childNodes[caret]).before($el);
			}
			this.setCaret(caret + 1);
		},
	
		/**
		 * Removes the current selected item(s).
		 *
		 * @param {object} e (optional)
		 * @returns {boolean}
		 */
		deleteSelection: function(e) {
			var i, n, direction, selection, values, caret, option_select, $option_select, $tail;
			var self = this;
	
			direction = (e && e.keyCode === KEY_BACKSPACE) ? -1 : 1;
			selection = getSelection(self.$control_input[0]);
	
			if (self.$activeOption && !self.settings.hideSelected) {
				option_select = self.getAdjacentOption(self.$activeOption, -1).attr('data-value');
			}
	
			// determine items that will be removed
			values = [];
	
			if (self.$activeItems.length) {
				$tail = self.$control.children('.active:' + (direction > 0 ? 'last' : 'first'));
				caret = self.$control.children(':not(input)').index($tail);
				if (direction > 0) { caret++; }
	
				for (i = 0, n = self.$activeItems.length; i < n; i++) {
					values.push($(self.$activeItems[i]).attr('data-value'));
				}
				if (e) {
					e.preventDefault();
					e.stopPropagation();
				}
			} else if ((self.isFocused || self.settings.mode === 'single') && self.items.length) {
				if (direction < 0 && selection.start === 0 && selection.length === 0) {
					values.push(self.items[self.caretPos - 1]);
				} else if (direction > 0 && selection.start === self.$control_input.val().length) {
					values.push(self.items[self.caretPos]);
				}
			}
	
			// allow the callback to abort
			if (!values.length || (typeof self.settings.onDelete === 'function' && self.settings.onDelete.apply(self, [values]) === false)) {
				return false;
			}
	
			// perform removal
			if (typeof caret !== 'undefined') {
				self.setCaret(caret);
			}
			while (values.length) {
				self.removeItem(values.pop());
			}
	
			self.showInput();
			self.positionDropdown();
			self.refreshOptions(true);
	
			// select previous option
			if (option_select) {
				$option_select = self.getOption(option_select);
				if ($option_select.length) {
					self.setActiveOption($option_select);
				}
			}
	
			return true;
		},
	
		/**
		 * Selects the previous / next item (depending
		 * on the `direction` argument).
		 *
		 * > 0 - right
		 * < 0 - left
		 *
		 * @param {int} direction
		 * @param {object} e (optional)
		 */
		advanceSelection: function(direction, e) {
			var tail, selection, idx, valueLength, cursorAtEdge, $tail;
			var self = this;
	
			if (direction === 0) return;
			if (self.rtl) direction *= -1;
	
			tail = direction > 0 ? 'last' : 'first';
			selection = getSelection(self.$control_input[0]);
	
			if (self.isFocused && !self.isInputHidden) {
				valueLength = self.$control_input.val().length;
				cursorAtEdge = direction < 0
					? selection.start === 0 && selection.length === 0
					: selection.start === valueLength;
	
				if (cursorAtEdge && !valueLength) {
					self.advanceCaret(direction, e);
				}
			} else {
				$tail = self.$control.children('.active:' + tail);
				if ($tail.length) {
					idx = self.$control.children(':not(input)').index($tail);
					self.setActiveItem(null);
					self.setCaret(direction > 0 ? idx + 1 : idx);
				}
			}
		},
	
		/**
		 * Moves the caret left / right.
		 *
		 * @param {int} direction
		 * @param {object} e (optional)
		 */
		advanceCaret: function(direction, e) {
			var self = this, fn, $adj;
	
			if (direction === 0) return;
	
			fn = direction > 0 ? 'next' : 'prev';
			if (self.isShiftDown) {
				$adj = self.$control_input[fn]();
				if ($adj.length) {
					self.hideInput();
					self.setActiveItem($adj);
					e && e.preventDefault();
				}
			} else {
				self.setCaret(self.caretPos + direction);
			}
		},
	
		/**
		 * Moves the caret to the specified index.
		 *
		 * @param {int} i
		 */
		setCaret: function(i) {
			var self = this;
	
			if (self.settings.mode === 'single') {
				i = self.items.length;
			} else {
				i = Math.max(0, Math.min(self.items.length, i));
			}
	
			if(!self.isPending) {
				// the input must be moved by leaving it in place and moving the
				// siblings, due to the fact that focus cannot be restored once lost
				// on mobile webkit devices
				var j, n, fn, $children, $child;
				$children = self.$control.children(':not(input)');
				for (j = 0, n = $children.length; j < n; j++) {
					$child = $($children[j]).detach();
					if (j <  i) {
						self.$control_input.before($child);
					} else {
						self.$control.append($child);
					}
				}
			}
	
			self.caretPos = i;
		},
	
		/**
		 * Disables user input on the control. Used while
		 * items are being asynchronously created.
		 */
		lock: function() {
			this.close();
			this.isLocked = true;
			this.refreshState();
		},
	
		/**
		 * Re-enables user input on the control.
		 */
		unlock: function() {
			this.isLocked = false;
			this.refreshState();
		},
	
		/**
		 * Disables user input on the control completely.
		 * While disabled, it cannot receive focus.
		 */
		disable: function() {
			var self = this;
			self.$input.prop('disabled', true);
			self.$control_input.prop('disabled', true).prop('tabindex', -1);
			self.isDisabled = true;
			self.lock();
		},
	
		/**
		 * Enables the control so that it can respond
		 * to focus and user input.
		 */
		enable: function() {
			var self = this;
			self.$input.prop('disabled', false);
			self.$control_input.prop('disabled', false).prop('tabindex', self.tabIndex);
			self.isDisabled = false;
			self.unlock();
		},
	
		/**
		 * Completely destroys the control and
		 * unbinds all event listeners so that it can
		 * be garbage collected.
		 */
		destroy: function() {
			var self = this;
			var eventNS = self.eventNS;
			var revertSettings = self.revertSettings;
	
			self.trigger('destroy');
			self.off();
			self.$wrapper.remove();
			self.$dropdown.remove();
	
			self.$input
				.html('')
				.append(revertSettings.$children)
				.removeAttr('tabindex')
				.removeClass('selectized')
				.attr({tabindex: revertSettings.tabindex})
				.show();
	
			self.$control_input.removeData('grow');
			self.$input.removeData('selectize');
	
			$(window).off(eventNS);
			$(document).off(eventNS);
			$(document.body).off(eventNS);
	
			delete self.$input[0].selectize;
		},
	
		/**
		 * A helper method for rendering "item" and
		 * "option" templates, given the data.
		 *
		 * @param {string} templateName
		 * @param {object} data
		 * @returns {string}
		 */
		render: function(templateName, data) {
			var value, id, label;
			var html = '';
			var cache = false;
			var self = this;
			var regex_tag = /^[\t \r\n]*<([a-z][a-z0-9\-_]*(?:\:[a-z][a-z0-9\-_]*)?)/i;
	
			if (templateName === 'option' || templateName === 'item') {
				value = hash_key(data[self.settings.valueField]);
				cache = !!value;
			}
	
			// pull markup from cache if it exists
			if (cache) {
				if (!isset(self.renderCache[templateName])) {
					self.renderCache[templateName] = {};
				}
				if (self.renderCache[templateName].hasOwnProperty(value)) {
					return self.renderCache[templateName][value];
				}
			}
	
			// render markup
			html = $(self.settings.render[templateName].apply(this, [data, escape_html]));
	
			// add mandatory attributes
			if (templateName === 'option' || templateName === 'option_create') {
				html.attr('data-selectable', '');
			}
			else if (templateName === 'optgroup') {
				id = data[self.settings.optgroupValueField] || '';
				html.attr('data-group', id);
			}
			if (templateName === 'option' || templateName === 'item') {
				html.attr('data-value', value || '');
			}
	
			// update cache
			if (cache) {
				self.renderCache[templateName][value] = html[0];
			}
	
			return html[0];
		},
	
		/**
		 * Clears the render cache for a template. If
		 * no template is given, clears all render
		 * caches.
		 *
		 * @param {string} templateName
		 */
		clearCache: function(templateName) {
			var self = this;
			if (typeof templateName === 'undefined') {
				self.renderCache = {};
			} else {
				delete self.renderCache[templateName];
			}
		},
	
		/**
		 * Determines whether or not to display the
		 * create item prompt, given a user input.
		 *
		 * @param {string} input
		 * @return {boolean}
		 */
		canCreate: function(input) {
			var self = this;
			if (!self.settings.create) return false;
			var filter = self.settings.createFilter;
			return input.length
				&& (typeof filter !== 'function' || filter.apply(self, [input]))
				&& (typeof filter !== 'string' || new RegExp(filter).test(input))
				&& (!(filter instanceof RegExp) || filter.test(input));
		}
	
	});
	
	
	Selectize.count = 0;
	Selectize.defaults = {
		options: [],
		optgroups: [],
	
		plugins: [],
		delimiter: ',',
		splitOn: null, // regexp or string for splitting up values from a paste command
		persist: true,
		diacritics: true,
		create: false,
		createOnBlur: false,
		createFilter: null,
		highlight: true,
		openOnFocus: true,
		maxOptions: 1000,
		maxItems: null,
		hideSelected: null,
		addPrecedence: false,
		selectOnTab: false,
		preload: false,
		allowEmptyOption: false,
		closeAfterSelect: false,
	
		scrollDuration: 60,
		loadThrottle: 300,
		loadingClass: 'loading',
	
		dataAttr: 'data-data',
		optgroupField: 'optgroup',
		valueField: 'value',
		labelField: 'text',
		optgroupLabelField: 'label',
		optgroupValueField: 'value',
		lockOptgroupOrder: false,
	
		sortField: '$order',
		searchField: ['text'],
		searchConjunction: 'and',
	
		mode: null,
		wrapperClass: 'selectize-control',
		inputClass: 'selectize-input',
		dropdownClass: 'selectize-dropdown',
		dropdownContentClass: 'selectize-dropdown-content',
	
		dropdownParent: null,
	
		copyClassesToDropdown: true,
	
		/*
		load                 : null, // function(query, callback) { ... }
		score                : null, // function(search) { ... }
		onInitialize         : null, // function() { ... }
		onChange             : null, // function(value) { ... }
		onItemAdd            : null, // function(value, $item) { ... }
		onItemRemove         : null, // function(value) { ... }
		onClear              : null, // function() { ... }
		onOptionAdd          : null, // function(value, data) { ... }
		onOptionRemove       : null, // function(value) { ... }
		onOptionClear        : null, // function() { ... }
		onOptionGroupAdd     : null, // function(id, data) { ... }
		onOptionGroupRemove  : null, // function(id) { ... }
		onOptionGroupClear   : null, // function() { ... }
		onDropdownOpen       : null, // function($dropdown) { ... }
		onDropdownClose      : null, // function($dropdown) { ... }
		onType               : null, // function(str) { ... }
		onDelete             : null, // function(values) { ... }
		*/
	
		render: {
			/*
			item: null,
			optgroup: null,
			optgroup_header: null,
			option: null,
			option_create: null
			*/
		}
	};
	
	
	$.fn.selectize = function(settings_user) {
		var defaults             = $.fn.selectize.defaults;
		var settings             = $.extend({}, defaults, settings_user);
		var attr_data            = settings.dataAttr;
		var field_label          = settings.labelField;
		var field_value          = settings.valueField;
		var field_optgroup       = settings.optgroupField;
		var field_optgroup_label = settings.optgroupLabelField;
		var field_optgroup_value = settings.optgroupValueField;
	
		/**
		 * Initializes selectize from a <input type="text"> element.
		 *
		 * @param {object} $input
		 * @param {object} settings_element
		 */
		var init_textbox = function($input, settings_element) {
			var i, n, values, option;
	
			var data_raw = $input.attr(attr_data);
	
			if (!data_raw) {
				var value = $.trim($input.val() || '');
				if (!settings.allowEmptyOption && !value.length) return;
				values = value.split(settings.delimiter);
				for (i = 0, n = values.length; i < n; i++) {
					option = {};
					option[field_label] = values[i];
					option[field_value] = values[i];
					settings_element.options.push(option);
				}
				settings_element.items = values;
			} else {
				settings_element.options = JSON.parse(data_raw);
				for (i = 0, n = settings_element.options.length; i < n; i++) {
					settings_element.items.push(settings_element.options[i][field_value]);
				}
			}
		};
	
		/**
		 * Initializes selectize from a <select> element.
		 *
		 * @param {object} $input
		 * @param {object} settings_element
		 */
		var init_select = function($input, settings_element) {
			var i, n, tagName, $children, order = 0;
			var options = settings_element.options;
			var optionsMap = {};
	
			var readData = function($el) {
				var data = attr_data && $el.attr(attr_data);
				if (typeof data === 'string' && data.length) {
					return JSON.parse(data);
				}
				return null;
			};
	
			var addOption = function($option, group) {
				$option = $($option);
	
				var value = hash_key($option.val());
				if (!value && !settings.allowEmptyOption) return;
	
				// if the option already exists, it's probably been
				// duplicated in another optgroup. in this case, push
				// the current group to the "optgroup" property on the
				// existing option so that it's rendered in both places.
				if (optionsMap.hasOwnProperty(value)) {
					if (group) {
						var arr = optionsMap[value][field_optgroup];
						if (!arr) {
							optionsMap[value][field_optgroup] = group;
						} else if (!$.isArray(arr)) {
							optionsMap[value][field_optgroup] = [arr, group];
						} else {
							arr.push(group);
						}
					}
					return;
				}
	
				var option             = readData($option) || {};
				option[field_label]    = option[field_label] || $option.text();
				option[field_value]    = option[field_value] || value;
				option[field_optgroup] = option[field_optgroup] || group;
	
				optionsMap[value] = option;
				options.push(option);
	
				if ($option.is(':selected')) {
					settings_element.items.push(value);
				}
			};
	
			var addGroup = function($optgroup) {
				var i, n, id, optgroup, $options;
	
				$optgroup = $($optgroup);
				id = $optgroup.attr('label');
	
				if (id) {
					optgroup = readData($optgroup) || {};
					optgroup[field_optgroup_label] = id;
					optgroup[field_optgroup_value] = id;
					settings_element.optgroups.push(optgroup);
				}
	
				$options = $('option', $optgroup);
				for (i = 0, n = $options.length; i < n; i++) {
					addOption($options[i], id);
				}
			};
	
			settings_element.maxItems = $input.attr('multiple') ? null : 1;
	
			$children = $input.children();
			for (i = 0, n = $children.length; i < n; i++) {
				tagName = $children[i].tagName.toLowerCase();
				if (tagName === 'optgroup') {
					addGroup($children[i]);
				} else if (tagName === 'option') {
					addOption($children[i]);
				}
			}
		};
	
		return this.each(function() {
			if (this.selectize) return;
	
			var instance;
			var $input = $(this);
			var tag_name = this.tagName.toLowerCase();
			var placeholder = $input.attr('placeholder') || $input.attr('data-placeholder');
			if (!placeholder && !settings.allowEmptyOption) {
				placeholder = $input.children('option[value=""]').text();
			}
	
			var settings_element = {
				'placeholder' : placeholder,
				'options'     : [],
				'optgroups'   : [],
				'items'       : []
			};
	
			if (tag_name === 'select') {
				init_select($input, settings_element);
			} else {
				init_textbox($input, settings_element);
			}
	
			instance = new Selectize($input, $.extend(true, {}, defaults, settings_element, settings_user));
		});
	};
	
	$.fn.selectize.defaults = Selectize.defaults;
	$.fn.selectize.support = {
		validity: SUPPORTS_VALIDITY_API
	};
	
	
	Selectize.define('drag_drop', function(options) {
		if (!$.fn.sortable) throw new Error('The "drag_drop" plugin requires jQuery UI "sortable".');
		if (this.settings.mode !== 'multi') return;
		var self = this;
	
		self.lock = (function() {
			var original = self.lock;
			return function() {
				var sortable = self.$control.data('sortable');
				if (sortable) sortable.disable();
				return original.apply(self, arguments);
			};
		})();
	
		self.unlock = (function() {
			var original = self.unlock;
			return function() {
				var sortable = self.$control.data('sortable');
				if (sortable) sortable.enable();
				return original.apply(self, arguments);
			};
		})();
	
		self.setup = (function() {
			var original = self.setup;
			return function() {
				original.apply(this, arguments);
	
				var $control = self.$control.sortable({
					items: '[data-value]',
					forcePlaceholderSize: true,
					disabled: self.isLocked,
					start: function(e, ui) {
						ui.placeholder.css('width', ui.helper.css('width'));
						$control.css({overflow: 'visible'});
					},
					stop: function() {
						$control.css({overflow: 'hidden'});
						var active = self.$activeItems ? self.$activeItems.slice() : null;
						var values = [];
						$control.children('[data-value]').each(function() {
							values.push($(this).attr('data-value'));
						});
						self.setValue(values);
						self.setActiveItem(active);
					}
				});
			};
		})();
	
	});
	
	Selectize.define('dropdown_header', function(options) {
		var self = this;
	
		options = $.extend({
			title         : 'Untitled',
			headerClass   : 'selectize-dropdown-header',
			titleRowClass : 'selectize-dropdown-header-title',
			labelClass    : 'selectize-dropdown-header-label',
			closeClass    : 'selectize-dropdown-header-close',
	
			html: function(data) {
				return (
					'<div class="' + data.headerClass + '">' +
						'<div class="' + data.titleRowClass + '">' +
							'<span class="' + data.labelClass + '">' + data.title + '</span>' +
							'<a href="javascript:void(0)" class="' + data.closeClass + '">&times;</a>' +
						'</div>' +
					'</div>'
				);
			}
		}, options);
	
		self.setup = (function() {
			var original = self.setup;
			return function() {
				original.apply(self, arguments);
				self.$dropdown_header = $(options.html(options));
				self.$dropdown.prepend(self.$dropdown_header);
			};
		})();
	
	});
	
	Selectize.define('optgroup_columns', function(options) {
		var self = this;
	
		options = $.extend({
			equalizeWidth  : true,
			equalizeHeight : true
		}, options);
	
		this.getAdjacentOption = function($option, direction) {
			var $options = $option.closest('[data-group]').find('[data-selectable]');
			var index    = $options.index($option) + direction;
	
			return index >= 0 && index < $options.length ? $options.eq(index) : $();
		};
	
		this.onKeyDown = (function() {
			var original = self.onKeyDown;
			return function(e) {
				var index, $option, $options, $optgroup;
	
				if (this.isOpen && (e.keyCode === KEY_LEFT || e.keyCode === KEY_RIGHT)) {
					self.ignoreHover = true;
					$optgroup = this.$activeOption.closest('[data-group]');
					index = $optgroup.find('[data-selectable]').index(this.$activeOption);
	
					if(e.keyCode === KEY_LEFT) {
						$optgroup = $optgroup.prev('[data-group]');
					} else {
						$optgroup = $optgroup.next('[data-group]');
					}
	
					$options = $optgroup.find('[data-selectable]');
					$option  = $options.eq(Math.min($options.length - 1, index));
					if ($option.length) {
						this.setActiveOption($option);
					}
					return;
				}
	
				return original.apply(this, arguments);
			};
		})();
	
		var getScrollbarWidth = function() {
			var div;
			var width = getScrollbarWidth.width;
			var doc = document;
	
			if (typeof width === 'undefined') {
				div = doc.createElement('div');
				div.innerHTML = '<div style="width:50px;height:50px;position:absolute;left:-50px;top:-50px;overflow:auto;"><div style="width:1px;height:100px;"></div></div>';
				div = div.firstChild;
				doc.body.appendChild(div);
				width = getScrollbarWidth.width = div.offsetWidth - div.clientWidth;
				doc.body.removeChild(div);
			}
			return width;
		};
	
		var equalizeSizes = function() {
			var i, n, height_max, width, width_last, width_parent, $optgroups;
	
			$optgroups = $('[data-group]', self.$dropdown_content);
			n = $optgroups.length;
			if (!n || !self.$dropdown_content.width()) return;
	
			if (options.equalizeHeight) {
				height_max = 0;
				for (i = 0; i < n; i++) {
					height_max = Math.max(height_max, $optgroups.eq(i).height());
				}
				$optgroups.css({height: height_max});
			}
	
			if (options.equalizeWidth) {
				width_parent = self.$dropdown_content.innerWidth() - getScrollbarWidth();
				width = Math.round(width_parent / n);
				$optgroups.css({width: width});
				if (n > 1) {
					width_last = width_parent - width * (n - 1);
					$optgroups.eq(n - 1).css({width: width_last});
				}
			}
		};
	
		if (options.equalizeHeight || options.equalizeWidth) {
			hook.after(this, 'positionDropdown', equalizeSizes);
			hook.after(this, 'refreshOptions', equalizeSizes);
		}
	
	
	});
	
	Selectize.define('remove_button', function(options) {
		options = $.extend({
				label     : '&times;',
				title     : 'Remove',
				className : 'remove',
				append    : true
			}, options);
	
			var singleClose = function(thisRef, options) {
	
				options.className = 'remove-single';
	
				var self = thisRef;
				var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + '</a>';
	
				/**
				 * Appends an element as a child (with raw HTML).
				 *
				 * @param {string} html_container
				 * @param {string} html_element
				 * @return {string}
				 */
				var append = function(html_container, html_element) {
					return html_container + html_element;
				};
	
				thisRef.setup = (function() {
					var original = self.setup;
					return function() {
						// override the item rendering method to add the button to each
						if (options.append) {
							var id = $(self.$input.context).attr('id');
							var selectizer = $('#'+id);
	
							var render_item = self.settings.render.item;
							self.settings.render.item = function(data) {
								return append(render_item.apply(thisRef, arguments), html);
							};
						}
	
						original.apply(thisRef, arguments);
	
						// add event listener
						thisRef.$control.on('click', '.' + options.className, function(e) {
							e.preventDefault();
							if (self.isLocked) return;
	
							self.clear();
						});
	
					};
				})();
			};
	
			var multiClose = function(thisRef, options) {
	
				var self = thisRef;
				var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + '</a>';
	
				/**
				 * Appends an element as a child (with raw HTML).
				 *
				 * @param {string} html_container
				 * @param {string} html_element
				 * @return {string}
				 */
				var append = function(html_container, html_element) {
					var pos = html_container.search(/(<\/[^>]+>\s*)$/);
					return html_container.substring(0, pos) + html_element + html_container.substring(pos);
				};
	
				thisRef.setup = (function() {
					var original = self.setup;
					return function() {
						// override the item rendering method to add the button to each
						if (options.append) {
							var render_item = self.settings.render.item;
							self.settings.render.item = function(data) {
								return append(render_item.apply(thisRef, arguments), html);
							};
						}
	
						original.apply(thisRef, arguments);
	
						// add event listener
						thisRef.$control.on('click', '.' + options.className, function(e) {
							e.preventDefault();
							if (self.isLocked) return;
	
							var $item = $(e.currentTarget).parent();
							self.setActiveItem($item);
							if (self.deleteSelection()) {
								self.setCaret(self.items.length);
							}
						});
	
					};
				})();
			};
	
			if (this.settings.mode === 'single') {
				singleClose(this, options);
				return;
			} else {
				multiClose(this, options);
			}
	});
	
	
	Selectize.define('restore_on_backspace', function(options) {
		var self = this;
	
		options.text = options.text || function(option) {
			return option[this.settings.labelField];
		};
	
		this.onKeyDown = (function() {
			var original = self.onKeyDown;
			return function(e) {
				var index, option;
				if (e.keyCode === KEY_BACKSPACE && this.$control_input.val() === '' && !this.$activeItems.length) {
					index = this.caretPos - 1;
					if (index >= 0 && index < this.items.length) {
						option = this.options[this.items[index]];
						if (this.deleteSelection(e)) {
							this.setTextboxValue(options.text.apply(this, [option]));
							this.refreshOptions(true);
						}
						e.preventDefault();
						return;
					}
				}
				return original.apply(this, arguments);
			};
		})();
	});
	

	return Selectize;
}));

/***/ }),

/***/ "../../../node_modules/sifter/sifter.js":
/*!************************************************************!*\
  !*** /Users/flex/Lab/tabler/node_modules/sifter/sifter.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * sifter.js
 * Copyright (c) 2013 Brian Reavis & contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the License at:
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *
 * @author Brian Reavis <brian@thirdroute.com>
 */

(function(root, factory) {
	if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}(this, function() {

	/**
	 * Textually searches arrays and hashes of objects
	 * by property (or multiple properties). Designed
	 * specifically for autocomplete.
	 *
	 * @constructor
	 * @param {array|object} items
	 * @param {object} items
	 */
	var Sifter = function(items, settings) {
		this.items = items;
		this.settings = settings || {diacritics: true};
	};

	/**
	 * Splits a search string into an array of individual
	 * regexps to be used to match results.
	 *
	 * @param {string} query
	 * @returns {array}
	 */
	Sifter.prototype.tokenize = function(query) {
		query = trim(String(query || '').toLowerCase());
		if (!query || !query.length) return [];

		var i, n, regex, letter;
		var tokens = [];
		var words = query.split(/ +/);

		for (i = 0, n = words.length; i < n; i++) {
			regex = escape_regex(words[i]);
			if (this.settings.diacritics) {
				for (letter in DIACRITICS) {
					if (DIACRITICS.hasOwnProperty(letter)) {
						regex = regex.replace(new RegExp(letter, 'g'), DIACRITICS[letter]);
					}
				}
			}
			tokens.push({
				string : words[i],
				regex  : new RegExp(regex, 'i')
			});
		}

		return tokens;
	};

	/**
	 * Iterates over arrays and hashes.
	 *
	 * ```
	 * this.iterator(this.items, function(item, id) {
	 *    // invoked for each item
	 * });
	 * ```
	 *
	 * @param {array|object} object
	 */
	Sifter.prototype.iterator = function(object, callback) {
		var iterator;
		if (is_array(object)) {
			iterator = Array.prototype.forEach || function(callback) {
				for (var i = 0, n = this.length; i < n; i++) {
					callback(this[i], i, this);
				}
			};
		} else {
			iterator = function(callback) {
				for (var key in this) {
					if (this.hasOwnProperty(key)) {
						callback(this[key], key, this);
					}
				}
			};
		}

		iterator.apply(object, [callback]);
	};

	/**
	 * Returns a function to be used to score individual results.
	 *
	 * Good matches will have a higher score than poor matches.
	 * If an item is not a match, 0 will be returned by the function.
	 *
	 * @param {object|string} search
	 * @param {object} options (optional)
	 * @returns {function}
	 */
	Sifter.prototype.getScoreFunction = function(search, options) {
		var self, fields, tokens, token_count, nesting;

		self        = this;
		search      = self.prepareSearch(search, options);
		tokens      = search.tokens;
		fields      = search.options.fields;
		token_count = tokens.length;
		nesting     = search.options.nesting;

		/**
		 * Calculates how close of a match the
		 * given value is against a search token.
		 *
		 * @param {mixed} value
		 * @param {object} token
		 * @return {number}
		 */
		var scoreValue = function(value, token) {
			var score, pos;

			if (!value) return 0;
			value = String(value || '');
			pos = value.search(token.regex);
			if (pos === -1) return 0;
			score = token.string.length / value.length;
			if (pos === 0) score += 0.5;
			return score;
		};

		/**
		 * Calculates the score of an object
		 * against the search query.
		 *
		 * @param {object} token
		 * @param {object} data
		 * @return {number}
		 */
		var scoreObject = (function() {
			var field_count = fields.length;
			if (!field_count) {
				return function() { return 0; };
			}
			if (field_count === 1) {
				return function(token, data) {
					return scoreValue(getattr(data, fields[0], nesting), token);
				};
			}
			return function(token, data) {
				for (var i = 0, sum = 0; i < field_count; i++) {
					sum += scoreValue(getattr(data, fields[i], nesting), token);
				}
				return sum / field_count;
			};
		})();

		if (!token_count) {
			return function() { return 0; };
		}
		if (token_count === 1) {
			return function(data) {
				return scoreObject(tokens[0], data);
			};
		}

		if (search.options.conjunction === 'and') {
			return function(data) {
				var score;
				for (var i = 0, sum = 0; i < token_count; i++) {
					score = scoreObject(tokens[i], data);
					if (score <= 0) return 0;
					sum += score;
				}
				return sum / token_count;
			};
		} else {
			return function(data) {
				for (var i = 0, sum = 0; i < token_count; i++) {
					sum += scoreObject(tokens[i], data);
				}
				return sum / token_count;
			};
		}
	};

	/**
	 * Returns a function that can be used to compare two
	 * results, for sorting purposes. If no sorting should
	 * be performed, `null` will be returned.
	 *
	 * @param {string|object} search
	 * @param {object} options
	 * @return function(a,b)
	 */
	Sifter.prototype.getSortFunction = function(search, options) {
		var i, n, self, field, fields, fields_count, multiplier, multipliers, get_field, implicit_score, sort;

		self   = this;
		search = self.prepareSearch(search, options);
		sort   = (!search.query && options.sort_empty) || options.sort;

		/**
		 * Fetches the specified sort field value
		 * from a search result item.
		 *
		 * @param  {string} name
		 * @param  {object} result
		 * @return {mixed}
		 */
		get_field = function(name, result) {
			if (name === '$score') return result.score;
			return getattr(self.items[result.id], name, options.nesting);
		};

		// parse options
		fields = [];
		if (sort) {
			for (i = 0, n = sort.length; i < n; i++) {
				if (search.query || sort[i].field !== '$score') {
					fields.push(sort[i]);
				}
			}
		}

		// the "$score" field is implied to be the primary
		// sort field, unless it's manually specified
		if (search.query) {
			implicit_score = true;
			for (i = 0, n = fields.length; i < n; i++) {
				if (fields[i].field === '$score') {
					implicit_score = false;
					break;
				}
			}
			if (implicit_score) {
				fields.unshift({field: '$score', direction: 'desc'});
			}
		} else {
			for (i = 0, n = fields.length; i < n; i++) {
				if (fields[i].field === '$score') {
					fields.splice(i, 1);
					break;
				}
			}
		}

		multipliers = [];
		for (i = 0, n = fields.length; i < n; i++) {
			multipliers.push(fields[i].direction === 'desc' ? -1 : 1);
		}

		// build function
		fields_count = fields.length;
		if (!fields_count) {
			return null;
		} else if (fields_count === 1) {
			field = fields[0].field;
			multiplier = multipliers[0];
			return function(a, b) {
				return multiplier * cmp(
					get_field(field, a),
					get_field(field, b)
				);
			};
		} else {
			return function(a, b) {
				var i, result, a_value, b_value, field;
				for (i = 0; i < fields_count; i++) {
					field = fields[i].field;
					result = multipliers[i] * cmp(
						get_field(field, a),
						get_field(field, b)
					);
					if (result) return result;
				}
				return 0;
			};
		}
	};

	/**
	 * Parses a search query and returns an object
	 * with tokens and fields ready to be populated
	 * with results.
	 *
	 * @param {string} query
	 * @param {object} options
	 * @returns {object}
	 */
	Sifter.prototype.prepareSearch = function(query, options) {
		if (typeof query === 'object') return query;

		options = extend({}, options);

		var option_fields     = options.fields;
		var option_sort       = options.sort;
		var option_sort_empty = options.sort_empty;

		if (option_fields && !is_array(option_fields)) options.fields = [option_fields];
		if (option_sort && !is_array(option_sort)) options.sort = [option_sort];
		if (option_sort_empty && !is_array(option_sort_empty)) options.sort_empty = [option_sort_empty];

		return {
			options : options,
			query   : String(query || '').toLowerCase(),
			tokens  : this.tokenize(query),
			total   : 0,
			items   : []
		};
	};

	/**
	 * Searches through all items and returns a sorted array of matches.
	 *
	 * The `options` parameter can contain:
	 *
	 *   - fields {string|array}
	 *   - sort {array}
	 *   - score {function}
	 *   - filter {bool}
	 *   - limit {integer}
	 *
	 * Returns an object containing:
	 *
	 *   - options {object}
	 *   - query {string}
	 *   - tokens {array}
	 *   - total {int}
	 *   - items {array}
	 *
	 * @param {string} query
	 * @param {object} options
	 * @returns {object}
	 */
	Sifter.prototype.search = function(query, options) {
		var self = this, value, score, search, calculateScore;
		var fn_sort;
		var fn_score;

		search  = this.prepareSearch(query, options);
		options = search.options;
		query   = search.query;

		// generate result scoring function
		fn_score = options.score || self.getScoreFunction(search);

		// perform search and sort
		if (query.length) {
			self.iterator(self.items, function(item, id) {
				score = fn_score(item);
				if (options.filter === false || score > 0) {
					search.items.push({'score': score, 'id': id});
				}
			});
		} else {
			self.iterator(self.items, function(item, id) {
				search.items.push({'score': 1, 'id': id});
			});
		}

		fn_sort = self.getSortFunction(search, options);
		if (fn_sort) search.items.sort(fn_sort);

		// apply limits
		search.total = search.items.length;
		if (typeof options.limit === 'number') {
			search.items = search.items.slice(0, options.limit);
		}

		return search;
	};

	// utilities
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	var cmp = function(a, b) {
		if (typeof a === 'number' && typeof b === 'number') {
			return a > b ? 1 : (a < b ? -1 : 0);
		}
		a = asciifold(String(a || ''));
		b = asciifold(String(b || ''));
		if (a > b) return 1;
		if (b > a) return -1;
		return 0;
	};

	var extend = function(a, b) {
		var i, n, k, object;
		for (i = 1, n = arguments.length; i < n; i++) {
			object = arguments[i];
			if (!object) continue;
			for (k in object) {
				if (object.hasOwnProperty(k)) {
					a[k] = object[k];
				}
			}
		}
		return a;
	};

	/**
	 * A property getter resolving dot-notation
	 * @param  {Object}  obj     The root object to fetch property on
	 * @param  {String}  name    The optionally dotted property name to fetch
	 * @param  {Boolean} nesting Handle nesting or not
	 * @return {Object}          The resolved property value
	 */
	var getattr = function(obj, name, nesting) {
	    if (!obj || !name) return;
	    if (!nesting) return obj[name];
	    var names = name.split(".");
	    while(names.length && (obj = obj[names.shift()]));
	    return obj;
	};

	var trim = function(str) {
		return (str + '').replace(/^\s+|\s+$|/g, '');
	};

	var escape_regex = function(str) {
		return (str + '').replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
	};

	var is_array = Array.isArray || (typeof $ !== 'undefined' && $.isArray) || function(object) {
		return Object.prototype.toString.call(object) === '[object Array]';
	};

	var DIACRITICS = {
		'a': '[a]',
		'b': '[bB]',
		'c': '[cCc]',
		'd': '[dDd]',
		'e': '[e]',
		'f': '[f]',
		'g': '[g]',
		'h': '[h]',
		'i': '[iiI]',
		'j': '[j]',
		'k': '[k]',
		'l': '[l]',
		'n': '[nNn]',
		'o': '[o]',
		'p': '[p]',
		'q': '[qq]',
		'r': '[r]',
		's': '[sSs]',
		't': '[t]',
		'u': '[u]',
		'v': '[v]',
		'w': '[w]',
		'x': '[x]',
		'y': '[y]',
		'z': '[z]'
	};

	var asciifold = (function() {
		var i, n, k, chunk;
		var foreignletters = '';
		var lookup = {};
		for (k in DIACRITICS) {
			if (DIACRITICS.hasOwnProperty(k)) {
				chunk = DIACRITICS[k].substring(2, DIACRITICS[k].length - 1);
				foreignletters += chunk;
				for (i = 0, n = chunk.length; i < n; i++) {
					lookup[chunk.charAt(i)] = k;
				}
			}
		}
		var regexp = new RegExp('[' +  foreignletters + ']', 'g');
		return function(str) {
			return str.replace(regexp, function(foreignletter) {
				return lookup[foreignletter];
			}).toLowerCase();
		};
	})();


	// export
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	return Sifter;
}));


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "../../../node_modules/sparkline/lib/sparkline.js":
/*!**********************************************************************!*\
  !*** /Users/flex/Lab/tabler/node_modules/sparkline/lib/sparkline.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * sparkline
 * https://github.com/shiwano/sparkline
 *
 * Copyright (c) 2013 Shogo Iwano
 * Licensed under the MIT license.
 */

(function(window) {
  'use strict';

  var sparkline,
      ticks = ['', '', '', '', '', '', '', ''];

  function lshift(n, bits) {
    return Math.floor(n) * Math.pow(2, bits);
  }

  sparkline = function(numbers, options) {
    options = options || {};
    var max = typeof options.max === 'number' ? options.max : Math.max.apply(null, numbers),
        min = typeof options.min === 'number' ? options.min : Math.min.apply(null, numbers),
        html = typeof options.html === 'boolean' ? options.html : false,
        results = [],
        f, i;

    f = Math.floor(lshift(max - min, 8) / (ticks.length - 1));
    if (f < 1) { f = 1; }

    for (i = 0; i < numbers.length; i++) {
      var value = ticks[Math.floor(lshift(numbers[i] - min, 8) / f)];

      if (html) {
        value = '<span title="' + numbers[i] + '">' + value + '</span>';
      }

      results.push(value);
    }

    return results.join('');
  };

  if (typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = sparkline;
  } else {
    window.sparkline = sparkline;

    if (true) {
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () { return sparkline; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
})(this);


/***/ }),

/***/ "../../../node_modules/tablesorter/dist/js/jquery.tablesorter.combined.js":
/*!**********************************************************************************************!*\
  !*** /Users/flex/Lab/tabler/node_modules/tablesorter/dist/js/jquery.tablesorter.combined.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! tablesorter (FORK) - updated 2018-05-16 (v2.30.4)*/
/* Includes widgets ( storage,uitheme,columns,filter,stickyHeaders,resizable,saveSort ) */
(function(factory) {
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}(function(jQuery) {

/*! TableSorter (FORK) v2.30.4 *//*
* Client-side table sorting with ease!
* @requires jQuery v1.2.6+
*
* Copyright (c) 2007 Christian Bach
* fork maintained by Rob Garrison
*
* Examples and original docs at: http://tablesorter.com
* Dual licensed under the MIT and GPL licenses:
* http://www.opensource.org/licenses/mit-license.php
* http://www.gnu.org/licenses/gpl.html
*
* @type jQuery
* @name tablesorter (FORK)
* @cat Plugins/Tablesorter
* @author Christian Bach - christian.bach@polyester.se
* @contributor Rob Garrison - https://github.com/Mottie/tablesorter
* @docs (fork) - https://mottie.github.io/tablesorter/docs/
*/
/*jshint browser:true, jquery:true, unused:false, expr: true */
;( function( $ ) {
	'use strict';
	var ts = $.tablesorter = {

		version : '2.30.4',

		parsers : [],
		widgets : [],
		defaults : {

			// *** appearance
			theme            : 'default',  // adds tablesorter-{theme} to the table for styling
			widthFixed       : false,      // adds colgroup to fix widths of columns
			showProcessing   : false,      // show an indeterminate timer icon in the header when the table is sorted or filtered.

			headerTemplate   : '{content}',// header layout template (HTML ok); {content} = innerHTML, {icon} = <i/> // class from cssIcon
			onRenderTemplate : null,       // function( index, template ) { return template; }, // template is a string
			onRenderHeader   : null,       // function( index ) {}, // nothing to return

			// *** functionality
			cancelSelection  : true,       // prevent text selection in the header
			tabIndex         : true,       // add tabindex to header for keyboard accessibility
			dateFormat       : 'mmddyyyy', // other options: 'ddmmyyy' or 'yyyymmdd'
			sortMultiSortKey : 'shiftKey', // key used to select additional columns
			sortResetKey     : 'ctrlKey',  // key used to remove sorting on a column
			usNumberFormat   : true,       // false for German '1.234.567,89' or French '1 234 567,89'
			delayInit        : false,      // if false, the parsed table contents will not update until the first sort
			serverSideSorting: false,      // if true, server-side sorting should be performed because client-side sorting will be disabled, but the ui and events will still be used.
			resort           : true,       // default setting to trigger a resort after an 'update', 'addRows', 'updateCell', etc has completed

			// *** sort options
			headers          : {},         // set sorter, string, empty, locked order, sortInitialOrder, filter, etc.
			ignoreCase       : true,       // ignore case while sorting
			sortForce        : null,       // column(s) first sorted; always applied
			sortList         : [],         // Initial sort order; applied initially; updated when manually sorted
			sortAppend       : null,       // column(s) sorted last; always applied
			sortStable       : false,      // when sorting two rows with exactly the same content, the original sort order is maintained

			sortInitialOrder : 'asc',      // sort direction on first click
			sortLocaleCompare: false,      // replace equivalent character (accented characters)
			sortReset        : false,      // third click on the header will reset column to default - unsorted
			sortRestart      : false,      // restart sort to 'sortInitialOrder' when clicking on previously unsorted columns

			emptyTo          : 'bottom',   // sort empty cell to bottom, top, none, zero, emptyMax, emptyMin
			stringTo         : 'max',      // sort strings in numerical column as max, min, top, bottom, zero
			duplicateSpan    : true,       // colspan cells in the tbody will have duplicated content in the cache for each spanned column
			textExtraction   : 'basic',    // text extraction method/function - function( node, table, cellIndex ) {}
			textAttribute    : 'data-text',// data-attribute that contains alternate cell text (used in default textExtraction function)
			textSorter       : null,       // choose overall or specific column sorter function( a, b, direction, table, columnIndex ) [alt: ts.sortText]
			numberSorter     : null,       // choose overall numeric sorter function( a, b, direction, maxColumnValue )

			// *** widget options
			initWidgets      : true,       // apply widgets on tablesorter initialization
			widgetClass      : 'widget-{name}', // table class name template to match to include a widget
			widgets          : [],         // method to add widgets, e.g. widgets: ['zebra']
			widgetOptions    : {
				zebra : [ 'even', 'odd' ]  // zebra widget alternating row class names
			},

			// *** callbacks
			initialized      : null,       // function( table ) {},

			// *** extra css class names
			tableClass       : '',
			cssAsc           : '',
			cssDesc          : '',
			cssNone          : '',
			cssHeader        : '',
			cssHeaderRow     : '',
			cssProcessing    : '', // processing icon applied to header during sort/filter

			cssChildRow      : 'tablesorter-childRow', // class name indiciating that a row is to be attached to its parent
			cssInfoBlock     : 'tablesorter-infoOnly', // don't sort tbody with this class name (only one class name allowed here!)
			cssNoSort        : 'tablesorter-noSort',   // class name added to element inside header; clicking on it won't cause a sort
			cssIgnoreRow     : 'tablesorter-ignoreRow',// header row to ignore; cells within this row will not be added to c.$headers

			cssIcon          : 'tablesorter-icon', // if this class does not exist, the {icon} will not be added from the headerTemplate
			cssIconNone      : '', // class name added to the icon when there is no column sort
			cssIconAsc       : '', // class name added to the icon when the column has an ascending sort
			cssIconDesc      : '', // class name added to the icon when the column has a descending sort
			cssIconDisabled  : '', // class name added to the icon when the column has a disabled sort

			// *** events
			pointerClick     : 'click',
			pointerDown      : 'mousedown',
			pointerUp        : 'mouseup',

			// *** selectors
			selectorHeaders  : '> thead th, > thead td',
			selectorSort     : 'th, td', // jQuery selector of content within selectorHeaders that is clickable to trigger a sort
			selectorRemove   : '.remove-me',

			// *** advanced
			debug            : false,

			// *** Internal variables
			headerList: [],
			empties: {},
			strings: {},
			parsers: [],

			// *** parser options for validator; values must be falsy!
			globalize: 0,
			imgAttr: 0

			// removed: widgetZebra: { css: ['even', 'odd'] }

		},

		// internal css classes - these will ALWAYS be added to
		// the table and MUST only contain one class name - fixes #381
		css : {
			table      : 'tablesorter',
			cssHasChild: 'tablesorter-hasChildRow',
			childRow   : 'tablesorter-childRow',
			colgroup   : 'tablesorter-colgroup',
			header     : 'tablesorter-header',
			headerRow  : 'tablesorter-headerRow',
			headerIn   : 'tablesorter-header-inner',
			icon       : 'tablesorter-icon',
			processing : 'tablesorter-processing',
			sortAsc    : 'tablesorter-headerAsc',
			sortDesc   : 'tablesorter-headerDesc',
			sortNone   : 'tablesorter-headerUnSorted'
		},

		// labels applied to sortable headers for accessibility (aria) support
		language : {
			sortAsc      : 'Ascending sort applied, ',
			sortDesc     : 'Descending sort applied, ',
			sortNone     : 'No sort applied, ',
			sortDisabled : 'sorting is disabled',
			nextAsc      : 'activate to apply an ascending sort',
			nextDesc     : 'activate to apply a descending sort',
			nextNone     : 'activate to remove the sort'
		},

		regex : {
			templateContent : /\{content\}/g,
			templateIcon    : /\{icon\}/g,
			templateName    : /\{name\}/i,
			spaces          : /\s+/g,
			nonWord         : /\W/g,
			formElements    : /(input|select|button|textarea)/i,

			// *** sort functions ***
			// regex used in natural sort
			// chunk/tokenize numbers & letters
			chunk  : /(^([+\-]?(?:\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,
			// replace chunks @ ends
			chunks : /(^\\0|\\0$)/,
			hex    : /^0x[0-9a-f]+$/i,

			// *** formatFloat ***
			comma                : /,/g,
			digitNonUS           : /[\s|\.]/g,
			digitNegativeTest    : /^\s*\([.\d]+\)/,
			digitNegativeReplace : /^\s*\(([.\d]+)\)/,

			// *** isDigit ***
			digitTest    : /^[\-+(]?\d+[)]?$/,
			digitReplace : /[,.'"\s]/g

		},

		// digit sort, text location
		string : {
			max      : 1,
			min      : -1,
			emptymin : 1,
			emptymax : -1,
			zero     : 0,
			none     : 0,
			'null'   : 0,
			top      : true,
			bottom   : false
		},

		keyCodes : {
			enter : 13
		},

		// placeholder date parser data (globalize)
		dates : {},

		// These methods can be applied on table.config instance
		instanceMethods : {},

		/*
		      
		               
		               
		        
		*/

		setup : function( table, c ) {
			// if no thead or tbody, or tablesorter is already present, quit
			if ( !table || !table.tHead || table.tBodies.length === 0 || table.hasInitialized === true ) {
				if ( ts.debug(c, 'core') ) {
					if ( table.hasInitialized ) {
						console.warn( 'Stopping initialization. Tablesorter has already been initialized' );
					} else {
						console.error( 'Stopping initialization! No table, thead or tbody', table );
					}
				}
				return;
			}

			var tmp = '',
				$table = $( table ),
				meta = $.metadata;
			// initialization flag
			table.hasInitialized = false;
			// table is being processed flag
			table.isProcessing = true;
			// make sure to store the config object
			table.config = c;
			// save the settings where they read
			$.data( table, 'tablesorter', c );
			if ( ts.debug(c, 'core') ) {
				console[ console.group ? 'group' : 'log' ]( 'Initializing tablesorter v' + ts.version );
				$.data( table, 'startoveralltimer', new Date() );
			}

			// removing this in version 3 (only supports jQuery 1.7+)
			c.supportsDataObject = ( function( version ) {
				version[ 0 ] = parseInt( version[ 0 ], 10 );
				return ( version[ 0 ] > 1 ) || ( version[ 0 ] === 1 && parseInt( version[ 1 ], 10 ) >= 4 );
			})( $.fn.jquery.split( '.' ) );
			// ensure case insensitivity
			c.emptyTo = c.emptyTo.toLowerCase();
			c.stringTo = c.stringTo.toLowerCase();
			c.last = { sortList : [], clickedIndex : -1 };
			// add table theme class only if there isn't already one there
			if ( !/tablesorter\-/.test( $table.attr( 'class' ) ) ) {
				tmp = ( c.theme !== '' ? ' tablesorter-' + c.theme : '' );
			}

			// give the table a unique id, which will be used in namespace binding
			if ( !c.namespace ) {
				c.namespace = '.tablesorter' + Math.random().toString( 16 ).slice( 2 );
			} else {
				// make sure namespace starts with a period & doesn't have weird characters
				c.namespace = '.' + c.namespace.replace( ts.regex.nonWord, '' );
			}

			c.table = table;
			c.$table = $table
				// add namespace to table to allow bindings on extra elements to target
				// the parent table (e.g. parser-input-select)
				.addClass( ts.css.table + ' ' + c.tableClass + tmp + ' ' + c.namespace.slice(1) )
				.attr( 'role', 'grid' );
			c.$headers = $table.find( c.selectorHeaders );

			c.$table.children().children( 'tr' ).attr( 'role', 'row' );
			c.$tbodies = $table.children( 'tbody:not(.' + c.cssInfoBlock + ')' ).attr({
				'aria-live' : 'polite',
				'aria-relevant' : 'all'
			});
			if ( c.$table.children( 'caption' ).length ) {
				tmp = c.$table.children( 'caption' )[ 0 ];
				if ( !tmp.id ) { tmp.id = c.namespace.slice( 1 ) + 'caption'; }
				c.$table.attr( 'aria-labelledby', tmp.id );
			}
			c.widgetInit = {}; // keep a list of initialized widgets
			// change textExtraction via data-attribute
			c.textExtraction = c.$table.attr( 'data-text-extraction' ) || c.textExtraction || 'basic';
			// build headers
			ts.buildHeaders( c );
			// fixate columns if the users supplies the fixedWidth option
			// do this after theme has been applied
			ts.fixColumnWidth( table );
			// add widgets from class name
			ts.addWidgetFromClass( table );
			// add widget options before parsing (e.g. grouping widget has parser settings)
			ts.applyWidgetOptions( table );
			// try to auto detect column type, and store in tables config
			ts.setupParsers( c );
			// start total row count at zero
			c.totalRows = 0;
			// only validate options while debugging. See #1528
			if (c.debug) {
				ts.validateOptions( c );
			}
			// build the cache for the tbody cells
			// delayInit will delay building the cache until the user starts a sort
			if ( !c.delayInit ) { ts.buildCache( c ); }
			// bind all header events and methods
			ts.bindEvents( table, c.$headers, true );
			ts.bindMethods( c );
			// get sort list from jQuery data or metadata
			// in jQuery < 1.4, an error occurs when calling $table.data()
			if ( c.supportsDataObject && typeof $table.data().sortlist !== 'undefined' ) {
				c.sortList = $table.data().sortlist;
			} else if ( meta && ( $table.metadata() && $table.metadata().sortlist ) ) {
				c.sortList = $table.metadata().sortlist;
			}
			// apply widget init code
			ts.applyWidget( table, true );
			// if user has supplied a sort list to constructor
			if ( c.sortList.length > 0 ) {
				ts.sortOn( c, c.sortList, {}, !c.initWidgets );
			} else {
				ts.setHeadersCss( c );
				if ( c.initWidgets ) {
					// apply widget format
					ts.applyWidget( table, false );
				}
			}

			// show processesing icon
			if ( c.showProcessing ) {
				$table
				.unbind( 'sortBegin' + c.namespace + ' sortEnd' + c.namespace )
				.bind( 'sortBegin' + c.namespace + ' sortEnd' + c.namespace, function( e ) {
					clearTimeout( c.timerProcessing );
					ts.isProcessing( table );
					if ( e.type === 'sortBegin' ) {
						c.timerProcessing = setTimeout( function() {
							ts.isProcessing( table, true );
						}, 500 );
					}
				});
			}

			// initialized
			table.hasInitialized = true;
			table.isProcessing = false;
			if ( ts.debug(c, 'core') ) {
				console.log( 'Overall initialization time:' + ts.benchmark( $.data( table, 'startoveralltimer' ) ) );
				if ( ts.debug(c, 'core') && console.groupEnd ) { console.groupEnd(); }
			}
			$table.triggerHandler( 'tablesorter-initialized', table );
			if ( typeof c.initialized === 'function' ) {
				c.initialized( table );
			}
		},

		bindMethods : function( c ) {
			var $table = c.$table,
				namespace = c.namespace,
				events = ( 'sortReset update updateRows updateAll updateHeaders addRows updateCell updateComplete ' +
					'sorton appendCache updateCache applyWidgetId applyWidgets refreshWidgets destroy mouseup ' +
					'mouseleave ' ).split( ' ' )
					.join( namespace + ' ' );
			// apply easy methods that trigger bound events
			$table
			.unbind( events.replace( ts.regex.spaces, ' ' ) )
			.bind( 'sortReset' + namespace, function( e, callback ) {
				e.stopPropagation();
				// using this.config to ensure functions are getting a non-cached version of the config
				ts.sortReset( this.config, function( table ) {
					if (table.isApplyingWidgets) {
						// multiple triggers in a row... filterReset, then sortReset - see #1361
						// wait to update widgets
						setTimeout( function() {
							ts.applyWidget( table, '', callback );
						}, 100 );
					} else {
						ts.applyWidget( table, '', callback );
					}
				});
			})
			.bind( 'updateAll' + namespace, function( e, resort, callback ) {
				e.stopPropagation();
				ts.updateAll( this.config, resort, callback );
			})
			.bind( 'update' + namespace + ' updateRows' + namespace, function( e, resort, callback ) {
				e.stopPropagation();
				ts.update( this.config, resort, callback );
			})
			.bind( 'updateHeaders' + namespace, function( e, callback ) {
				e.stopPropagation();
				ts.updateHeaders( this.config, callback );
			})
			.bind( 'updateCell' + namespace, function( e, cell, resort, callback ) {
				e.stopPropagation();
				ts.updateCell( this.config, cell, resort, callback );
			})
			.bind( 'addRows' + namespace, function( e, $row, resort, callback ) {
				e.stopPropagation();
				ts.addRows( this.config, $row, resort, callback );
			})
			.bind( 'updateComplete' + namespace, function() {
				this.isUpdating = false;
			})
			.bind( 'sorton' + namespace, function( e, list, callback, init ) {
				e.stopPropagation();
				ts.sortOn( this.config, list, callback, init );
			})
			.bind( 'appendCache' + namespace, function( e, callback, init ) {
				e.stopPropagation();
				ts.appendCache( this.config, init );
				if ( $.isFunction( callback ) ) {
					callback( this );
				}
			})
			// $tbodies variable is used by the tbody sorting widget
			.bind( 'updateCache' + namespace, function( e, callback, $tbodies ) {
				e.stopPropagation();
				ts.updateCache( this.config, callback, $tbodies );
			})
			.bind( 'applyWidgetId' + namespace, function( e, id ) {
				e.stopPropagation();
				ts.applyWidgetId( this, id );
			})
			.bind( 'applyWidgets' + namespace, function( e, callback ) {
				e.stopPropagation();
				// apply widgets (false = not initializing)
				ts.applyWidget( this, false, callback );
			})
			.bind( 'refreshWidgets' + namespace, function( e, all, dontapply ) {
				e.stopPropagation();
				ts.refreshWidgets( this, all, dontapply );
			})
			.bind( 'removeWidget' + namespace, function( e, name, refreshing ) {
				e.stopPropagation();
				ts.removeWidget( this, name, refreshing );
			})
			.bind( 'destroy' + namespace, function( e, removeClasses, callback ) {
				e.stopPropagation();
				ts.destroy( this, removeClasses, callback );
			})
			.bind( 'resetToLoadState' + namespace, function( e ) {
				e.stopPropagation();
				// remove all widgets
				ts.removeWidget( this, true, false );
				var tmp = $.extend( true, {}, c.originalSettings );
				// restore original settings; this clears out current settings, but does not clear
				// values saved to storage.
				c = $.extend( true, {}, ts.defaults, tmp );
				c.originalSettings = tmp;
				this.hasInitialized = false;
				// setup the entire table again
				ts.setup( this, c );
			});
		},

		bindEvents : function( table, $headers, core ) {
			table = $( table )[ 0 ];
			var tmp,
				c = table.config,
				namespace = c.namespace,
				downTarget = null;
			if ( core !== true ) {
				$headers.addClass( namespace.slice( 1 ) + '_extra_headers' );
				tmp = ts.getClosest( $headers, 'table' );
				if ( tmp.length && tmp[ 0 ].nodeName === 'TABLE' && tmp[ 0 ] !== table ) {
					$( tmp[ 0 ] ).addClass( namespace.slice( 1 ) + '_extra_table' );
				}
			}
			tmp = ( c.pointerDown + ' ' + c.pointerUp + ' ' + c.pointerClick + ' sort keyup ' )
				.replace( ts.regex.spaces, ' ' )
				.split( ' ' )
				.join( namespace + ' ' );
			// apply event handling to headers and/or additional headers (stickyheaders, scroller, etc)
			$headers
			// http://stackoverflow.com/questions/5312849/jquery-find-self;
			.find( c.selectorSort )
			.add( $headers.filter( c.selectorSort ) )
			.unbind( tmp )
			.bind( tmp, function( e, external ) {
				var $cell, cell, temp,
					$target = $( e.target ),
					// wrap event type in spaces, so the match doesn't trigger on inner words
					type = ' ' + e.type + ' ';
				// only recognize left clicks
				if ( ( ( e.which || e.button ) !== 1 && !type.match( ' ' + c.pointerClick + ' | sort | keyup ' ) ) ||
					// allow pressing enter
					( type === ' keyup ' && e.which !== ts.keyCodes.enter ) ||
					// allow triggering a click event (e.which is undefined) & ignore physical clicks
					( type.match( ' ' + c.pointerClick + ' ' ) && typeof e.which !== 'undefined' ) ) {
					return;
				}
				// ignore mouseup if mousedown wasn't on the same target
				if ( type.match( ' ' + c.pointerUp + ' ' ) && downTarget !== e.target && external !== true ) {
					return;
				}
				// set target on mousedown
				if ( type.match( ' ' + c.pointerDown + ' ' ) ) {
					downTarget = e.target;
					// preventDefault needed or jQuery v1.3.2 and older throws an
					// "Uncaught TypeError: handler.apply is not a function" error
					temp = $target.jquery.split( '.' );
					if ( temp[ 0 ] === '1' && temp[ 1 ] < 4 ) { e.preventDefault(); }
					return;
				}
				downTarget = null;
				// prevent sort being triggered on form elements
				if ( ts.regex.formElements.test( e.target.nodeName ) ||
					// nosort class name, or elements within a nosort container
					$target.hasClass( c.cssNoSort ) || $target.parents( '.' + c.cssNoSort ).length > 0 ||
					// elements within a button
					$target.parents( 'button' ).length > 0 ) {
					return !c.cancelSelection;
				}
				if ( c.delayInit && ts.isEmptyObject( c.cache ) ) {
					ts.buildCache( c );
				}
				$cell = ts.getClosest( $( this ), '.' + ts.css.header );
				// use column index from data-attribute or index of current row; fixes #1116
				c.last.clickedIndex = $cell.attr( 'data-column' ) || $cell.index();
				cell = c.$headerIndexed[ c.last.clickedIndex ][0];
				if ( cell && !cell.sortDisabled ) {
					ts.initSort( c, cell, e );
				}
			});
			if ( c.cancelSelection ) {
				// cancel selection
				$headers
					.attr( 'unselectable', 'on' )
					.bind( 'selectstart', false )
					.css({
						'user-select' : 'none',
						'MozUserSelect' : 'none' // not needed for jQuery 1.8+
					});
			}
		},

		buildHeaders : function( c ) {
			var $temp, icon, timer, indx;
			c.headerList = [];
			c.headerContent = [];
			c.sortVars = [];
			if ( ts.debug(c, 'core') ) {
				timer = new Date();
			}
			// children tr in tfoot - see issue #196 & #547
			// don't pass table.config to computeColumnIndex here - widgets (math) pass it to "quickly" index tbody cells
			c.columns = ts.computeColumnIndex( c.$table.children( 'thead, tfoot' ).children( 'tr' ) );
			// add icon if cssIcon option exists
			icon = c.cssIcon ?
				'<i class="' + ( c.cssIcon === ts.css.icon ? ts.css.icon : c.cssIcon + ' ' + ts.css.icon ) + '"></i>' :
				'';
			// redefine c.$headers here in case of an updateAll that replaces or adds an entire header cell - see #683
			c.$headers = $( $.map( c.$table.find( c.selectorHeaders ), function( elem, index ) {
				var configHeaders, header, column, template, tmp,
					$elem = $( elem );
				// ignore cell (don't add it to c.$headers) if row has ignoreRow class
				if ( ts.getClosest( $elem, 'tr' ).hasClass( c.cssIgnoreRow ) ) { return; }
				// transfer data-column to element if not th/td - #1459
				if ( !/(th|td)/i.test( elem.nodeName ) ) {
					tmp = ts.getClosest( $elem, 'th, td' );
					$elem.attr( 'data-column', tmp.attr( 'data-column' ) );
				}
				// make sure to get header cell & not column indexed cell
				configHeaders = ts.getColumnData( c.table, c.headers, index, true );
				// save original header content
				c.headerContent[ index ] = $elem.html();
				// if headerTemplate is empty, don't reformat the header cell
				if ( c.headerTemplate !== '' && !$elem.find( '.' + ts.css.headerIn ).length ) {
					// set up header template
					template = c.headerTemplate
						.replace( ts.regex.templateContent, $elem.html() )
						.replace( ts.regex.templateIcon, $elem.find( '.' + ts.css.icon ).length ? '' : icon );
					if ( c.onRenderTemplate ) {
						header = c.onRenderTemplate.apply( $elem, [ index, template ] );
						// only change t if something is returned
						if ( header && typeof header === 'string' ) {
							template = header;
						}
					}
					$elem.html( '<div class="' + ts.css.headerIn + '">' + template + '</div>' ); // faster than wrapInner
				}
				if ( c.onRenderHeader ) {
					c.onRenderHeader.apply( $elem, [ index, c, c.$table ] );
				}
				column = parseInt( $elem.attr( 'data-column' ), 10 );
				elem.column = column;
				tmp = ts.getOrder( ts.getData( $elem, configHeaders, 'sortInitialOrder' ) || c.sortInitialOrder );
				// this may get updated numerous times if there are multiple rows
				c.sortVars[ column ] = {
					count : -1, // set to -1 because clicking on the header automatically adds one
					order:  tmp ?
						( c.sortReset ? [ 1, 0, 2 ] : [ 1, 0 ] ) : // desc, asc, unsorted
						( c.sortReset ? [ 0, 1, 2 ] : [ 0, 1 ] ),  // asc, desc, unsorted
					lockedOrder : false
				};
				tmp = ts.getData( $elem, configHeaders, 'lockedOrder' ) || false;
				if ( typeof tmp !== 'undefined' && tmp !== false ) {
					c.sortVars[ column ].lockedOrder = true;
					c.sortVars[ column ].order = ts.getOrder( tmp ) ? [ 1, 1 ] : [ 0, 0 ];
				}
				// add cell to headerList
				c.headerList[ index ] = elem;
				$elem.addClass( ts.css.header + ' ' + c.cssHeader );
				// add to parent in case there are multiple rows
				ts.getClosest( $elem, 'tr' )
					.addClass( ts.css.headerRow + ' ' + c.cssHeaderRow )
					.attr( 'role', 'row' );
				// allow keyboard cursor to focus on element
				if ( c.tabIndex ) {
					$elem.attr( 'tabindex', 0 );
				}
				return elem;
			}) );
			// cache headers per column
			c.$headerIndexed = [];
			for ( indx = 0; indx < c.columns; indx++ ) {
				// colspan in header making a column undefined
				if ( ts.isEmptyObject( c.sortVars[ indx ] ) ) {
					c.sortVars[ indx ] = {};
				}
				// Use c.$headers.parent() in case selectorHeaders doesn't point to the th/td
				$temp = c.$headers.filter( '[data-column="' + indx + '"]' );
				// target sortable column cells, unless there are none, then use non-sortable cells
				// .last() added in jQuery 1.4; use .filter(':last') to maintain compatibility with jQuery v1.2.6
				c.$headerIndexed[ indx ] = $temp.length ?
					$temp.not( '.sorter-false' ).length ?
						$temp.not( '.sorter-false' ).filter( ':last' ) :
						$temp.filter( ':last' ) :
					$();
			}
			c.$table.find( c.selectorHeaders ).attr({
				scope: 'col',
				role : 'columnheader'
			});
			// enable/disable sorting
			ts.updateHeader( c );
			if ( ts.debug(c, 'core') ) {
				console.log( 'Built headers:' + ts.benchmark( timer ) );
				console.log( c.$headers );
			}
		},

		// Use it to add a set of methods to table.config which will be available for all tables.
		// This should be done before table initialization
		addInstanceMethods : function( methods ) {
			$.extend( ts.instanceMethods, methods );
		},

		/*
		      
		           
		                 
		                
		*/
		setupParsers : function( c, $tbodies ) {
			var rows, list, span, max, colIndex, indx, header, configHeaders,
				noParser, parser, extractor, time, tbody, len,
				table = c.table,
				tbodyIndex = 0,
				debug = ts.debug(c, 'core'),
				debugOutput = {};
			// update table bodies in case we start with an empty table
			c.$tbodies = c.$table.children( 'tbody:not(.' + c.cssInfoBlock + ')' );
			tbody = typeof $tbodies === 'undefined' ? c.$tbodies : $tbodies;
			len = tbody.length;
			if ( len === 0 ) {
				return debug ? console.warn( 'Warning: *Empty table!* Not building a parser cache' ) : '';
			} else if ( debug ) {
				time = new Date();
				console[ console.group ? 'group' : 'log' ]( 'Detecting parsers for each column' );
			}
			list = {
				extractors: [],
				parsers: []
			};
			while ( tbodyIndex < len ) {
				rows = tbody[ tbodyIndex ].rows;
				if ( rows.length ) {
					colIndex = 0;
					max = c.columns;
					for ( indx = 0; indx < max; indx++ ) {
						header = c.$headerIndexed[ colIndex ];
						if ( header && header.length ) {
							// get column indexed table cell; adding true parameter fixes #1362 but
							// it would break backwards compatibility...
							configHeaders = ts.getColumnData( table, c.headers, colIndex ); // , true );
							// get column parser/extractor
							extractor = ts.getParserById( ts.getData( header, configHeaders, 'extractor' ) );
							parser = ts.getParserById( ts.getData( header, configHeaders, 'sorter' ) );
							noParser = ts.getData( header, configHeaders, 'parser' ) === 'false';
							// empty cells behaviour - keeping emptyToBottom for backwards compatibility
							c.empties[colIndex] = (
								ts.getData( header, configHeaders, 'empty' ) ||
								c.emptyTo || ( c.emptyToBottom ? 'bottom' : 'top' ) ).toLowerCase();
							// text strings behaviour in numerical sorts
							c.strings[colIndex] = (
								ts.getData( header, configHeaders, 'string' ) ||
								c.stringTo ||
								'max' ).toLowerCase();
							if ( noParser ) {
								parser = ts.getParserById( 'no-parser' );
							}
							if ( !extractor ) {
								// For now, maybe detect someday
								extractor = false;
							}
							if ( !parser ) {
								parser = ts.detectParserForColumn( c, rows, -1, colIndex );
							}
							if ( debug ) {
								debugOutput[ '(' + colIndex + ') ' + header.text() ] = {
									parser : parser.id,
									extractor : extractor ? extractor.id : 'none',
									string : c.strings[ colIndex ],
									empty  : c.empties[ colIndex ]
								};
							}
							list.parsers[ colIndex ] = parser;
							list.extractors[ colIndex ] = extractor;
							span = header[ 0 ].colSpan - 1;
							if ( span > 0 ) {
								colIndex += span;
								max += span;
								while ( span + 1 > 0 ) {
									// set colspan columns to use the same parsers & extractors
									list.parsers[ colIndex - span ] = parser;
									list.extractors[ colIndex - span ] = extractor;
									span--;
								}
							}
						}
						colIndex++;
					}
				}
				tbodyIndex += ( list.parsers.length ) ? len : 1;
			}
			if ( debug ) {
				if ( !ts.isEmptyObject( debugOutput ) ) {
					console[ console.table ? 'table' : 'log' ]( debugOutput );
				} else {
					console.warn( '  No parsers detected!' );
				}
				console.log( 'Completed detecting parsers' + ts.benchmark( time ) );
				if ( console.groupEnd ) { console.groupEnd(); }
			}
			c.parsers = list.parsers;
			c.extractors = list.extractors;
		},

		addParser : function( parser ) {
			var indx,
				len = ts.parsers.length,
				add = true;
			for ( indx = 0; indx < len; indx++ ) {
				if ( ts.parsers[ indx ].id.toLowerCase() === parser.id.toLowerCase() ) {
					add = false;
				}
			}
			if ( add ) {
				ts.parsers[ ts.parsers.length ] = parser;
			}
		},

		getParserById : function( name ) {
			/*jshint eqeqeq:false */ // eslint-disable-next-line eqeqeq
			if ( name == 'false' ) { return false; }
			var indx,
				len = ts.parsers.length;
			for ( indx = 0; indx < len; indx++ ) {
				if ( ts.parsers[ indx ].id.toLowerCase() === ( name.toString() ).toLowerCase() ) {
					return ts.parsers[ indx ];
				}
			}
			return false;
		},

		detectParserForColumn : function( c, rows, rowIndex, cellIndex ) {
			var cur, $node, row,
				indx = ts.parsers.length,
				node = false,
				nodeValue = '',
				debug = ts.debug(c, 'core'),
				keepLooking = true;
			while ( nodeValue === '' && keepLooking ) {
				rowIndex++;
				row = rows[ rowIndex ];
				// stop looking after 50 empty rows
				if ( row && rowIndex < 50 ) {
					if ( row.className.indexOf( ts.cssIgnoreRow ) < 0 ) {
						node = rows[ rowIndex ].cells[ cellIndex ];
						nodeValue = ts.getElementText( c, node, cellIndex );
						$node = $( node );
						if ( debug ) {
							console.log( 'Checking if value was empty on row ' + rowIndex + ', column: ' +
								cellIndex + ': "' + nodeValue + '"' );
						}
					}
				} else {
					keepLooking = false;
				}
			}
			while ( --indx >= 0 ) {
				cur = ts.parsers[ indx ];
				// ignore the default text parser because it will always be true
				if ( cur && cur.id !== 'text' && cur.is && cur.is( nodeValue, c.table, node, $node ) ) {
					return cur;
				}
			}
			// nothing found, return the generic parser (text)
			return ts.getParserById( 'text' );
		},

		getElementText : function( c, node, cellIndex ) {
			if ( !node ) { return ''; }
			var tmp,
				extract = c.textExtraction || '',
				// node could be a jquery object
				// http://jsperf.com/jquery-vs-instanceof-jquery/2
				$node = node.jquery ? node : $( node );
			if ( typeof extract === 'string' ) {
				// check data-attribute first when set to 'basic'; don't use node.innerText - it's really slow!
				// http://www.kellegous.com/j/2013/02/27/innertext-vs-textcontent/
				if ( extract === 'basic' && typeof ( tmp = $node.attr( c.textAttribute ) ) !== 'undefined' ) {
					return $.trim( tmp );
				}
				return $.trim( node.textContent || $node.text() );
			} else {
				if ( typeof extract === 'function' ) {
					return $.trim( extract( $node[ 0 ], c.table, cellIndex ) );
				} else if ( typeof ( tmp = ts.getColumnData( c.table, extract, cellIndex ) ) === 'function' ) {
					return $.trim( tmp( $node[ 0 ], c.table, cellIndex ) );
				}
			}
			// fallback
			return $.trim( $node[ 0 ].textContent || $node.text() );
		},

		// centralized function to extract/parse cell contents
		getParsedText : function( c, cell, colIndex, txt ) {
			if ( typeof txt === 'undefined' ) {
				txt = ts.getElementText( c, cell, colIndex );
			}
			// if no parser, make sure to return the txt
			var val = '' + txt,
				parser = c.parsers[ colIndex ],
				extractor = c.extractors[ colIndex ];
			if ( parser ) {
				// do extract before parsing, if there is one
				if ( extractor && typeof extractor.format === 'function' ) {
					txt = extractor.format( txt, c.table, cell, colIndex );
				}
				// allow parsing if the string is empty, previously parsing would change it to zero,
				// in case the parser needs to extract data from the table cell attributes
				val = parser.id === 'no-parser' ? '' :
					// make sure txt is a string (extractor may have converted it)
					parser.format( '' + txt, c.table, cell, colIndex );
				if ( c.ignoreCase && typeof val === 'string' ) {
					val = val.toLowerCase();
				}
			}
			return val;
		},

		/*
		      
		        
		        
		        
		*/
		buildCache : function( c, callback, $tbodies ) {
			var cache, val, txt, rowIndex, colIndex, tbodyIndex, $tbody, $row,
				cols, $cells, cell, cacheTime, totalRows, rowData, prevRowData,
				colMax, span, cacheIndex, hasParser, max, len, index,
				table = c.table,
				parsers = c.parsers,
				debug = ts.debug(c, 'core');
			// update tbody variable
			c.$tbodies = c.$table.children( 'tbody:not(.' + c.cssInfoBlock + ')' );
			$tbody = typeof $tbodies === 'undefined' ? c.$tbodies : $tbodies,
			c.cache = {};
			c.totalRows = 0;
			// if no parsers found, return - it's an empty table.
			if ( !parsers ) {
				return debug ? console.warn( 'Warning: *Empty table!* Not building a cache' ) : '';
			}
			if ( debug ) {
				cacheTime = new Date();
			}
			// processing icon
			if ( c.showProcessing ) {
				ts.isProcessing( table, true );
			}
			for ( tbodyIndex = 0; tbodyIndex < $tbody.length; tbodyIndex++ ) {
				colMax = []; // column max value per tbody
				cache = c.cache[ tbodyIndex ] = {
					normalized: [] // array of normalized row data; last entry contains 'rowData' above
					// colMax: #   // added at the end
				};

				totalRows = ( $tbody[ tbodyIndex ] && $tbody[ tbodyIndex ].rows.length ) || 0;
				for ( rowIndex = 0; rowIndex < totalRows; ++rowIndex ) {
					rowData = {
						// order: original row order #
						// $row : jQuery Object[]
						child: [], // child row text (filter widget)
						raw: []    // original row text
					};
					/** Add the table data to main data array */
					$row = $( $tbody[ tbodyIndex ].rows[ rowIndex ] );
					cols = [];
					// ignore "remove-me" rows
					if ( $row.hasClass( c.selectorRemove.slice(1) ) ) {
						continue;
					}
					// if this is a child row, add it to the last row's children and continue to the next row
					// ignore child row class, if it is the first row
					if ( $row.hasClass( c.cssChildRow ) && rowIndex !== 0 ) {
						len = cache.normalized.length - 1;
						prevRowData = cache.normalized[ len ][ c.columns ];
						prevRowData.$row = prevRowData.$row.add( $row );
						// add 'hasChild' class name to parent row
						if ( !$row.prev().hasClass( c.cssChildRow ) ) {
							$row.prev().addClass( ts.css.cssHasChild );
						}
						// save child row content (un-parsed!)
						$cells = $row.children( 'th, td' );
						len = prevRowData.child.length;
						prevRowData.child[ len ] = [];
						// child row content does not account for colspans/rowspans; so indexing may be off
						cacheIndex = 0;
						max = c.columns;
						for ( colIndex = 0; colIndex < max; colIndex++ ) {
							cell = $cells[ colIndex ];
							if ( cell ) {
								prevRowData.child[ len ][ colIndex ] = ts.getParsedText( c, cell, colIndex );
								span = $cells[ colIndex ].colSpan - 1;
								if ( span > 0 ) {
									cacheIndex += span;
									max += span;
								}
							}
							cacheIndex++;
						}
						// go to the next for loop
						continue;
					}
					rowData.$row = $row;
					rowData.order = rowIndex; // add original row position to rowCache
					cacheIndex = 0;
					max = c.columns;
					for ( colIndex = 0; colIndex < max; ++colIndex ) {
						cell = $row[ 0 ].cells[ colIndex ];
						if ( cell && cacheIndex < c.columns ) {
							hasParser = typeof parsers[ cacheIndex ] !== 'undefined';
							if ( !hasParser && debug ) {
								console.warn( 'No parser found for row: ' + rowIndex + ', column: ' + colIndex +
									'; cell containing: "' + $(cell).text() + '"; does it have a header?' );
							}
							val = ts.getElementText( c, cell, cacheIndex );
							rowData.raw[ cacheIndex ] = val; // save original row text
							// save raw column text even if there is no parser set
							txt = ts.getParsedText( c, cell, cacheIndex, val );
							cols[ cacheIndex ] = txt;
							if ( hasParser && ( parsers[ cacheIndex ].type || '' ).toLowerCase() === 'numeric' ) {
								// determine column max value (ignore sign)
								colMax[ cacheIndex ] = Math.max( Math.abs( txt ) || 0, colMax[ cacheIndex ] || 0 );
							}
							// allow colSpan in tbody
							span = cell.colSpan - 1;
							if ( span > 0 ) {
								index = 0;
								while ( index <= span ) {
									// duplicate text (or not) to spanned columns
									// instead of setting duplicate span to empty string, use textExtraction to try to get a value
									// see http://stackoverflow.com/q/36449711/145346
									txt = c.duplicateSpan || index === 0 ?
										val :
										typeof c.textExtraction !== 'string' ?
											ts.getElementText( c, cell, cacheIndex + index ) || '' :
											'';
									rowData.raw[ cacheIndex + index ] = txt;
									cols[ cacheIndex + index ] = txt;
									index++;
								}
								cacheIndex += span;
								max += span;
							}
						}
						cacheIndex++;
					}
					// ensure rowData is always in the same location (after the last column)
					cols[ c.columns ] = rowData;
					cache.normalized[ cache.normalized.length ] = cols;
				}
				cache.colMax = colMax;
				// total up rows, not including child rows
				c.totalRows += cache.normalized.length;

			}
			if ( c.showProcessing ) {
				ts.isProcessing( table ); // remove processing icon
			}
			if ( debug ) {
				len = Math.min( 5, c.cache[ 0 ].normalized.length );
				console[ console.group ? 'group' : 'log' ]( 'Building cache for ' + c.totalRows +
					' rows (showing ' + len + ' rows in log) and ' + c.columns + ' columns' +
					ts.benchmark( cacheTime ) );
				val = {};
				for ( colIndex = 0; colIndex < c.columns; colIndex++ ) {
					for ( cacheIndex = 0; cacheIndex < len; cacheIndex++ ) {
						if ( !val[ 'row: ' + cacheIndex ] ) {
							val[ 'row: ' + cacheIndex ] = {};
						}
						val[ 'row: ' + cacheIndex ][ c.$headerIndexed[ colIndex ].text() ] =
							c.cache[ 0 ].normalized[ cacheIndex ][ colIndex ];
					}
				}
				console[ console.table ? 'table' : 'log' ]( val );
				if ( console.groupEnd ) { console.groupEnd(); }
			}
			if ( $.isFunction( callback ) ) {
				callback( table );
			}
		},

		getColumnText : function( table, column, callback, rowFilter ) {
			table = $( table )[0];
			var tbodyIndex, rowIndex, cache, row, tbodyLen, rowLen, raw, parsed, $cell, result,
				hasCallback = typeof callback === 'function',
				allColumns = column === 'all',
				data = { raw : [], parsed: [], $cell: [] },
				c = table.config;
			if ( ts.isEmptyObject( c ) ) {
				if ( ts.debug(c, 'core') ) {
					console.warn( 'No cache found - aborting getColumnText function!' );
				}
			} else {
				tbodyLen = c.$tbodies.length;
				for ( tbodyIndex = 0; tbodyIndex < tbodyLen; tbodyIndex++ ) {
					cache = c.cache[ tbodyIndex ].normalized;
					rowLen = cache.length;
					for ( rowIndex = 0; rowIndex < rowLen; rowIndex++ ) {
						row = cache[ rowIndex ];
						if ( rowFilter && !row[ c.columns ].$row.is( rowFilter ) ) {
							continue;
						}
						result = true;
						parsed = ( allColumns ) ? row.slice( 0, c.columns ) : row[ column ];
						row = row[ c.columns ];
						raw = ( allColumns ) ? row.raw : row.raw[ column ];
						$cell = ( allColumns ) ? row.$row.children() : row.$row.children().eq( column );
						if ( hasCallback ) {
							result = callback({
								tbodyIndex : tbodyIndex,
								rowIndex : rowIndex,
								parsed : parsed,
								raw : raw,
								$row : row.$row,
								$cell : $cell
							});
						}
						if ( result !== false ) {
							data.parsed[ data.parsed.length ] = parsed;
							data.raw[ data.raw.length ] = raw;
							data.$cell[ data.$cell.length ] = $cell;
						}
					}
				}
				// return everything
				return data;
			}
		},

		/*
		       
		             
		              
		               
		*/
		setHeadersCss : function( c ) {
			var indx, column,
				list = c.sortList,
				len = list.length,
				none = ts.css.sortNone + ' ' + c.cssNone,
				css = [ ts.css.sortAsc + ' ' + c.cssAsc, ts.css.sortDesc + ' ' + c.cssDesc ],
				cssIcon = [ c.cssIconAsc, c.cssIconDesc, c.cssIconNone ],
				aria = [ 'ascending', 'descending' ],
				updateColumnSort = function($el, index) {
					$el
						.removeClass( none )
						.addClass( css[ index ] )
						.attr( 'aria-sort', aria[ index ] )
						.find( '.' + ts.css.icon )
						.removeClass( cssIcon[ 2 ] )
						.addClass( cssIcon[ index ] );
				},
				// find the footer
				$extras = c.$table
					.find( 'tfoot tr' )
					.children( 'td, th' )
					.add( $( c.namespace + '_extra_headers' ) )
					.removeClass( css.join( ' ' ) ),
				// remove all header information
				$sorted = c.$headers
					.add( $( 'thead ' + c.namespace + '_extra_headers' ) )
					.removeClass( css.join( ' ' ) )
					.addClass( none )
					.attr( 'aria-sort', 'none' )
					.find( '.' + ts.css.icon )
					.removeClass( cssIcon.join( ' ' ) )
					.end();
			// add css none to all sortable headers
			$sorted
				.not( '.sorter-false' )
				.find( '.' + ts.css.icon )
				.addClass( cssIcon[ 2 ] );
			// add disabled css icon class
			if ( c.cssIconDisabled ) {
				$sorted
					.filter( '.sorter-false' )
					.find( '.' + ts.css.icon )
					.addClass( c.cssIconDisabled );
			}
			for ( indx = 0; indx < len; indx++ ) {
				// direction = 2 means reset!
				if ( list[ indx ][ 1 ] !== 2 ) {
					// multicolumn sorting updating - see #1005
					// .not(function() {}) needs jQuery 1.4
					// filter(function(i, el) {}) <- el is undefined in jQuery v1.2.6
					$sorted = c.$headers.filter( function( i ) {
						// only include headers that are in the sortList (this includes colspans)
						var include = true,
							$el = c.$headers.eq( i ),
							col = parseInt( $el.attr( 'data-column' ), 10 ),
							end = col + ts.getClosest( $el, 'th, td' )[0].colSpan;
						for ( ; col < end; col++ ) {
							include = include ? include || ts.isValueInArray( col, c.sortList ) > -1 : false;
						}
						return include;
					});

					// choose the :last in case there are nested columns
					$sorted = $sorted
						.not( '.sorter-false' )
						.filter( '[data-column="' + list[ indx ][ 0 ] + '"]' + ( len === 1 ? ':last' : '' ) );
					if ( $sorted.length ) {
						for ( column = 0; column < $sorted.length; column++ ) {
							if ( !$sorted[ column ].sortDisabled ) {
								updateColumnSort( $sorted.eq( column ), list[ indx ][ 1 ] );
							}
						}
					}
					// add sorted class to footer & extra headers, if they exist
					if ( $extras.length ) {
						updateColumnSort( $extras.filter( '[data-column="' + list[ indx ][ 0 ] + '"]' ), list[ indx ][ 1 ] );
					}
				}
			}
			// add verbose aria labels
			len = c.$headers.length;
			for ( indx = 0; indx < len; indx++ ) {
				ts.setColumnAriaLabel( c, c.$headers.eq( indx ) );
			}
		},

		getClosest : function( $el, selector ) {
			// jQuery v1.2.6 doesn't have closest()
			if ( $.fn.closest ) {
				return $el.closest( selector );
			}
			return $el.is( selector ) ?
				$el :
				$el.parents( selector ).filter( ':first' );
		},

		// nextSort (optional), lets you disable next sort text
		setColumnAriaLabel : function( c, $header, nextSort ) {
			if ( $header.length ) {
				var column = parseInt( $header.attr( 'data-column' ), 10 ),
					vars = c.sortVars[ column ],
					tmp = $header.hasClass( ts.css.sortAsc ) ?
						'sortAsc' :
						$header.hasClass( ts.css.sortDesc ) ? 'sortDesc' : 'sortNone',
					txt = $.trim( $header.text() ) + ': ' + ts.language[ tmp ];
				if ( $header.hasClass( 'sorter-false' ) || nextSort === false ) {
					txt += ts.language.sortDisabled;
				} else {
					tmp = ( vars.count + 1 ) % vars.order.length;
					nextSort = vars.order[ tmp ];
					// if nextSort
					txt += ts.language[ nextSort === 0 ? 'nextAsc' : nextSort === 1 ? 'nextDesc' : 'nextNone' ];
				}
				$header.attr( 'aria-label', txt );
			}
		},

		updateHeader : function( c ) {
			var index, isDisabled, $header, col,
				table = c.table,
				len = c.$headers.length;
			for ( index = 0; index < len; index++ ) {
				$header = c.$headers.eq( index );
				col = ts.getColumnData( table, c.headers, index, true );
				// add 'sorter-false' class if 'parser-false' is set
				isDisabled = ts.getData( $header, col, 'sorter' ) === 'false' || ts.getData( $header, col, 'parser' ) === 'false';
				ts.setColumnSort( c, $header, isDisabled );
			}
		},

		setColumnSort : function( c, $header, isDisabled ) {
			var id = c.table.id;
			$header[ 0 ].sortDisabled = isDisabled;
			$header[ isDisabled ? 'addClass' : 'removeClass' ]( 'sorter-false' )
				.attr( 'aria-disabled', '' + isDisabled );
			// disable tab index on disabled cells
			if ( c.tabIndex ) {
				if ( isDisabled ) {
					$header.removeAttr( 'tabindex' );
				} else {
					$header.attr( 'tabindex', '0' );
				}
			}
			// aria-controls - requires table ID
			if ( id ) {
				if ( isDisabled ) {
					$header.removeAttr( 'aria-controls' );
				} else {
					$header.attr( 'aria-controls', id );
				}
			}
		},

		updateHeaderSortCount : function( c, list ) {
			var col, dir, group, indx, primary, temp, val, order,
				sortList = list || c.sortList,
				len = sortList.length;
			c.sortList = [];
			for ( indx = 0; indx < len; indx++ ) {
				val = sortList[ indx ];
				// ensure all sortList values are numeric - fixes #127
				col = parseInt( val[ 0 ], 10 );
				// prevents error if sorton array is wrong
				if ( col < c.columns ) {

					// set order if not already defined - due to colspan header without associated header cell
					// adding this check prevents a javascript error
					if ( !c.sortVars[ col ].order ) {
						if ( ts.getOrder( c.sortInitialOrder ) ) {
							order = c.sortReset ? [ 1, 0, 2 ] : [ 1, 0 ];
						} else {
							order = c.sortReset ? [ 0, 1, 2 ] : [ 0, 1 ];
						}
						c.sortVars[ col ].order = order;
						c.sortVars[ col ].count = 0;
					}

					order = c.sortVars[ col ].order;
					dir = ( '' + val[ 1 ] ).match( /^(1|d|s|o|n)/ );
					dir = dir ? dir[ 0 ] : '';
					// 0/(a)sc (default), 1/(d)esc, (s)ame, (o)pposite, (n)ext
					switch ( dir ) {
						case '1' : case 'd' : // descending
							dir = 1;
							break;
						case 's' : // same direction (as primary column)
							// if primary sort is set to 's', make it ascending
							dir = primary || 0;
							break;
						case 'o' :
							temp = order[ ( primary || 0 ) % order.length ];
							// opposite of primary column; but resets if primary resets
							dir = temp === 0 ? 1 : temp === 1 ? 0 : 2;
							break;
						case 'n' :
							dir = order[ ( ++c.sortVars[ col ].count ) % order.length ];
							break;
						default : // ascending
							dir = 0;
							break;
					}
					primary = indx === 0 ? dir : primary;
					group = [ col, parseInt( dir, 10 ) || 0 ];
					c.sortList[ c.sortList.length ] = group;
					dir = $.inArray( group[ 1 ], order ); // fixes issue #167
					c.sortVars[ col ].count = dir >= 0 ? dir : group[ 1 ] % order.length;
				}
			}
		},

		updateAll : function( c, resort, callback ) {
			var table = c.table;
			table.isUpdating = true;
			ts.refreshWidgets( table, true, true );
			ts.buildHeaders( c );
			ts.bindEvents( table, c.$headers, true );
			ts.bindMethods( c );
			ts.commonUpdate( c, resort, callback );
		},

		update : function( c, resort, callback ) {
			var table = c.table;
			table.isUpdating = true;
			// update sorting (if enabled/disabled)
			ts.updateHeader( c );
			ts.commonUpdate( c, resort, callback );
		},

		// simple header update - see #989
		updateHeaders : function( c, callback ) {
			c.table.isUpdating = true;
			ts.buildHeaders( c );
			ts.bindEvents( c.table, c.$headers, true );
			ts.resortComplete( c, callback );
		},

		updateCell : function( c, cell, resort, callback ) {
			// updateCell for child rows is a mess - we'll ignore them for now
			// eventually I'll break out the "update" row cache code to make everything consistent
			if ( $( cell ).closest( 'tr' ).hasClass( c.cssChildRow ) ) {
				console.warn('Tablesorter Warning! "updateCell" for child row content has been disabled, use "update" instead');
				return;
			}
			if ( ts.isEmptyObject( c.cache ) ) {
				// empty table, do an update instead - fixes #1099
				ts.updateHeader( c );
				ts.commonUpdate( c, resort, callback );
				return;
			}
			c.table.isUpdating = true;
			c.$table.find( c.selectorRemove ).remove();
			// get position from the dom
			var tmp, indx, row, icell, cache, len,
				$tbodies = c.$tbodies,
				$cell = $( cell ),
				// update cache - format: function( s, table, cell, cellIndex )
				// no closest in jQuery v1.2.6
				tbodyIndex = $tbodies.index( ts.getClosest( $cell, 'tbody' ) ),
				tbcache = c.cache[ tbodyIndex ],
				$row = ts.getClosest( $cell, 'tr' );
			cell = $cell[ 0 ]; // in case cell is a jQuery object
			// tbody may not exist if update is initialized while tbody is removed for processing
			if ( $tbodies.length && tbodyIndex >= 0 ) {
				row = $tbodies.eq( tbodyIndex ).find( 'tr' ).not( '.' + c.cssChildRow ).index( $row );
				cache = tbcache.normalized[ row ];
				len = $row[ 0 ].cells.length;
				if ( len !== c.columns ) {
					// colspan in here somewhere!
					icell = 0;
					tmp = false;
					for ( indx = 0; indx < len; indx++ ) {
						if ( !tmp && $row[ 0 ].cells[ indx ] !== cell ) {
							icell += $row[ 0 ].cells[ indx ].colSpan;
						} else {
							tmp = true;
						}
					}
				} else {
					icell = $cell.index();
				}
				tmp = ts.getElementText( c, cell, icell ); // raw
				cache[ c.columns ].raw[ icell ] = tmp;
				tmp = ts.getParsedText( c, cell, icell, tmp );
				cache[ icell ] = tmp; // parsed
				if ( ( c.parsers[ icell ].type || '' ).toLowerCase() === 'numeric' ) {
					// update column max value (ignore sign)
					tbcache.colMax[ icell ] = Math.max( Math.abs( tmp ) || 0, tbcache.colMax[ icell ] || 0 );
				}
				tmp = resort !== 'undefined' ? resort : c.resort;
				if ( tmp !== false ) {
					// widgets will be reapplied
					ts.checkResort( c, tmp, callback );
				} else {
					// don't reapply widgets is resort is false, just in case it causes
					// problems with element focus
					ts.resortComplete( c, callback );
				}
			} else {
				if ( ts.debug(c, 'core') ) {
					console.error( 'updateCell aborted, tbody missing or not within the indicated table' );
				}
				c.table.isUpdating = false;
			}
		},

		addRows : function( c, $row, resort, callback ) {
			var txt, val, tbodyIndex, rowIndex, rows, cellIndex, len, order,
				cacheIndex, rowData, cells, cell, span,
				// allow passing a row string if only one non-info tbody exists in the table
				valid = typeof $row === 'string' && c.$tbodies.length === 1 && /<tr/.test( $row || '' ),
				table = c.table;
			if ( valid ) {
				$row = $( $row );
				c.$tbodies.append( $row );
			} else if (
				!$row ||
				// row is a jQuery object?
				!( $row instanceof $ ) ||
				// row contained in the table?
				( ts.getClosest( $row, 'table' )[ 0 ] !== c.table )
			) {
				if ( ts.debug(c, 'core') ) {
					console.error( 'addRows method requires (1) a jQuery selector reference to rows that have already ' +
						'been added to the table, or (2) row HTML string to be added to a table with only one tbody' );
				}
				return false;
			}
			table.isUpdating = true;
			if ( ts.isEmptyObject( c.cache ) ) {
				// empty table, do an update instead - fixes #450
				ts.updateHeader( c );
				ts.commonUpdate( c, resort, callback );
			} else {
				rows = $row.filter( 'tr' ).attr( 'role', 'row' ).length;
				tbodyIndex = c.$tbodies.index( $row.parents( 'tbody' ).filter( ':first' ) );
				// fixes adding rows to an empty table - see issue #179
				if ( !( c.parsers && c.parsers.length ) ) {
					ts.setupParsers( c );
				}
				// add each row
				for ( rowIndex = 0; rowIndex < rows; rowIndex++ ) {
					cacheIndex = 0;
					len = $row[ rowIndex ].cells.length;
					order = c.cache[ tbodyIndex ].normalized.length;
					cells = [];
					rowData = {
						child : [],
						raw : [],
						$row : $row.eq( rowIndex ),
						order : order
					};
					// add each cell
					for ( cellIndex = 0; cellIndex < len; cellIndex++ ) {
						cell = $row[ rowIndex ].cells[ cellIndex ];
						txt = ts.getElementText( c, cell, cacheIndex );
						rowData.raw[ cacheIndex ] = txt;
						val = ts.getParsedText( c, cell, cacheIndex, txt );
						cells[ cacheIndex ] = val;
						if ( ( c.parsers[ cacheIndex ].type || '' ).toLowerCase() === 'numeric' ) {
							// update column max value (ignore sign)
							c.cache[ tbodyIndex ].colMax[ cacheIndex ] =
								Math.max( Math.abs( val ) || 0, c.cache[ tbodyIndex ].colMax[ cacheIndex ] || 0 );
						}
						span = cell.colSpan - 1;
						if ( span > 0 ) {
							cacheIndex += span;
						}
						cacheIndex++;
					}
					// add the row data to the end
					cells[ c.columns ] = rowData;
					// update cache
					c.cache[ tbodyIndex ].normalized[ order ] = cells;
				}
				// resort using current settings
				ts.checkResort( c, resort, callback );
			}
		},

		updateCache : function( c, callback, $tbodies ) {
			// rebuild parsers
			if ( !( c.parsers && c.parsers.length ) ) {
				ts.setupParsers( c, $tbodies );
			}
			// rebuild the cache map
			ts.buildCache( c, callback, $tbodies );
		},

		// init flag (true) used by pager plugin to prevent widget application
		// renamed from appendToTable
		appendCache : function( c, init ) {
			var parsed, totalRows, $tbody, $curTbody, rowIndex, tbodyIndex, appendTime,
				table = c.table,
				$tbodies = c.$tbodies,
				rows = [],
				cache = c.cache;
			// empty table - fixes #206/#346
			if ( ts.isEmptyObject( cache ) ) {
				// run pager appender in case the table was just emptied
				return c.appender ? c.appender( table, rows ) :
					table.isUpdating ? c.$table.triggerHandler( 'updateComplete', table ) : ''; // Fixes #532
			}
			if ( ts.debug(c, 'core') ) {
				appendTime = new Date();
			}
			for ( tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ) {
				$tbody = $tbodies.eq( tbodyIndex );
				if ( $tbody.length ) {
					// detach tbody for manipulation
					$curTbody = ts.processTbody( table, $tbody, true );
					parsed = cache[ tbodyIndex ].normalized;
					totalRows = parsed.length;
					for ( rowIndex = 0; rowIndex < totalRows; rowIndex++ ) {
						rows[rows.length] = parsed[ rowIndex ][ c.columns ].$row;
						// removeRows used by the pager plugin; don't render if using ajax - fixes #411
						if ( !c.appender || ( c.pager && !c.pager.removeRows && !c.pager.ajax ) ) {
							$curTbody.append( parsed[ rowIndex ][ c.columns ].$row );
						}
					}
					// restore tbody
					ts.processTbody( table, $curTbody, false );
				}
			}
			if ( c.appender ) {
				c.appender( table, rows );
			}
			if ( ts.debug(c, 'core') ) {
				console.log( 'Rebuilt table' + ts.benchmark( appendTime ) );
			}
			// apply table widgets; but not before ajax completes
			if ( !init && !c.appender ) {
				ts.applyWidget( table );
			}
			if ( table.isUpdating ) {
				c.$table.triggerHandler( 'updateComplete', table );
			}
		},

		commonUpdate : function( c, resort, callback ) {
			// remove rows/elements before update
			c.$table.find( c.selectorRemove ).remove();
			// rebuild parsers
			ts.setupParsers( c );
			// rebuild the cache map
			ts.buildCache( c );
			ts.checkResort( c, resort, callback );
		},

		/*
		      
		                  
		                   
		              
		*/
		initSort : function( c, cell, event ) {
			if ( c.table.isUpdating ) {
				// let any updates complete before initializing a sort
				return setTimeout( function() {
					ts.initSort( c, cell, event );
				}, 50 );
			}

			var arry, indx, headerIndx, dir, temp, tmp, $header,
				notMultiSort = !event[ c.sortMultiSortKey ],
				table = c.table,
				len = c.$headers.length,
				th = ts.getClosest( $( cell ), 'th, td' ),
				col = parseInt( th.attr( 'data-column' ), 10 ),
				order = c.sortVars[ col ].order;
			th = th[0];
			// Only call sortStart if sorting is enabled
			c.$table.triggerHandler( 'sortStart', table );
			// get current column sort order
			tmp = ( c.sortVars[ col ].count + 1 ) % order.length;
			c.sortVars[ col ].count = event[ c.sortResetKey ] ? 2 : tmp;
			// reset all sorts on non-current column - issue #30
			if ( c.sortRestart ) {
				for ( headerIndx = 0; headerIndx < len; headerIndx++ ) {
					$header = c.$headers.eq( headerIndx );
					tmp = parseInt( $header.attr( 'data-column' ), 10 );
					// only reset counts on columns that weren't just clicked on and if not included in a multisort
					if ( col !== tmp && ( notMultiSort || $header.hasClass( ts.css.sortNone ) ) ) {
						c.sortVars[ tmp ].count = -1;
					}
				}
			}
			// user only wants to sort on one column
			if ( notMultiSort ) {
				// flush the sort list
				c.sortList = [];
				c.last.sortList = [];
				if ( c.sortForce !== null ) {
					arry = c.sortForce;
					for ( indx = 0; indx < arry.length; indx++ ) {
						if ( arry[ indx ][ 0 ] !== col ) {
							c.sortList[ c.sortList.length ] = arry[ indx ];
						}
					}
				}
				// add column to sort list
				dir = order[ c.sortVars[ col ].count ];
				if ( dir < 2 ) {
					c.sortList[ c.sortList.length ] = [ col, dir ];
					// add other columns if header spans across multiple
					if ( th.colSpan > 1 ) {
						for ( indx = 1; indx < th.colSpan; indx++ ) {
							c.sortList[ c.sortList.length ] = [ col + indx, dir ];
							// update count on columns in colSpan
							c.sortVars[ col + indx ].count = $.inArray( dir, order );
						}
					}
				}
				// multi column sorting
			} else {
				// get rid of the sortAppend before adding more - fixes issue #115 & #523
				c.sortList = $.extend( [], c.last.sortList );

				// the user has clicked on an already sorted column
				if ( ts.isValueInArray( col, c.sortList ) >= 0 ) {
					// reverse the sorting direction
					for ( indx = 0; indx < c.sortList.length; indx++ ) {
						tmp = c.sortList[ indx ];
						if ( tmp[ 0 ] === col ) {
							// order.count seems to be incorrect when compared to cell.count
							tmp[ 1 ] = order[ c.sortVars[ col ].count ];
							if ( tmp[1] === 2 ) {
								c.sortList.splice( indx, 1 );
								c.sortVars[ col ].count = -1;
							}
						}
					}
				} else {
					// add column to sort list array
					dir = order[ c.sortVars[ col ].count ];
					if ( dir < 2 ) {
						c.sortList[ c.sortList.length ] = [ col, dir ];
						// add other columns if header spans across multiple
						if ( th.colSpan > 1 ) {
							for ( indx = 1; indx < th.colSpan; indx++ ) {
								c.sortList[ c.sortList.length ] = [ col + indx, dir ];
								// update count on columns in colSpan
								c.sortVars[ col + indx ].count = $.inArray( dir, order );
							}
						}
					}
				}
			}
			// save sort before applying sortAppend
			c.last.sortList = $.extend( [], c.sortList );
			if ( c.sortList.length && c.sortAppend ) {
				arry = $.isArray( c.sortAppend ) ? c.sortAppend : c.sortAppend[ c.sortList[ 0 ][ 0 ] ];
				if ( !ts.isEmptyObject( arry ) ) {
					for ( indx = 0; indx < arry.length; indx++ ) {
						if ( arry[ indx ][ 0 ] !== col && ts.isValueInArray( arry[ indx ][ 0 ], c.sortList ) < 0 ) {
							dir = arry[ indx ][ 1 ];
							temp = ( '' + dir ).match( /^(a|d|s|o|n)/ );
							if ( temp ) {
								tmp = c.sortList[ 0 ][ 1 ];
								switch ( temp[ 0 ] ) {
									case 'd' :
										dir = 1;
										break;
									case 's' :
										dir = tmp;
										break;
									case 'o' :
										dir = tmp === 0 ? 1 : 0;
										break;
									case 'n' :
										dir = ( tmp + 1 ) % order.length;
										break;
									default:
										dir = 0;
										break;
								}
							}
							c.sortList[ c.sortList.length ] = [ arry[ indx ][ 0 ], dir ];
						}
					}
				}
			}
			// sortBegin event triggered immediately before the sort
			c.$table.triggerHandler( 'sortBegin', table );
			// setTimeout needed so the processing icon shows up
			setTimeout( function() {
				// set css for headers
				ts.setHeadersCss( c );
				ts.multisort( c );
				ts.appendCache( c );
				c.$table.triggerHandler( 'sortBeforeEnd', table );
				c.$table.triggerHandler( 'sortEnd', table );
			}, 1 );
		},

		// sort multiple columns
		multisort : function( c ) { /*jshint loopfunc:true */
			var tbodyIndex, sortTime, colMax, rows, tmp,
				table = c.table,
				sorter = [],
				dir = 0,
				textSorter = c.textSorter || '',
				sortList = c.sortList,
				sortLen = sortList.length,
				len = c.$tbodies.length;
			if ( c.serverSideSorting || ts.isEmptyObject( c.cache ) ) {
				// empty table - fixes #206/#346
				return;
			}
			if ( ts.debug(c, 'core') ) { sortTime = new Date(); }
			// cache textSorter to optimize speed
			if ( typeof textSorter === 'object' ) {
				colMax = c.columns;
				while ( colMax-- ) {
					tmp = ts.getColumnData( table, textSorter, colMax );
					if ( typeof tmp === 'function' ) {
						sorter[ colMax ] = tmp;
					}
				}
			}
			for ( tbodyIndex = 0; tbodyIndex < len; tbodyIndex++ ) {
				colMax = c.cache[ tbodyIndex ].colMax;
				rows = c.cache[ tbodyIndex ].normalized;

				rows.sort( function( a, b ) {
					var sortIndex, num, col, order, sort, x, y;
					// rows is undefined here in IE, so don't use it!
					for ( sortIndex = 0; sortIndex < sortLen; sortIndex++ ) {
						col = sortList[ sortIndex ][ 0 ];
						order = sortList[ sortIndex ][ 1 ];
						// sort direction, true = asc, false = desc
						dir = order === 0;

						if ( c.sortStable && a[ col ] === b[ col ] && sortLen === 1 ) {
							return a[ c.columns ].order - b[ c.columns ].order;
						}

						// fallback to natural sort since it is more robust
						num = /n/i.test( ts.getSortType( c.parsers, col ) );
						if ( num && c.strings[ col ] ) {
							// sort strings in numerical columns
							if ( typeof ( ts.string[ c.strings[ col ] ] ) === 'boolean' ) {
								num = ( dir ? 1 : -1 ) * ( ts.string[ c.strings[ col ] ] ? -1 : 1 );
							} else {
								num = ( c.strings[ col ] ) ? ts.string[ c.strings[ col ] ] || 0 : 0;
							}
							// fall back to built-in numeric sort
							// var sort = $.tablesorter['sort' + s]( a[col], b[col], dir, colMax[col], table );
							sort = c.numberSorter ? c.numberSorter( a[ col ], b[ col ], dir, colMax[ col ], table ) :
								ts[ 'sortNumeric' + ( dir ? 'Asc' : 'Desc' ) ]( a[ col ], b[ col ], num, colMax[ col ], col, c );
						} else {
							// set a & b depending on sort direction
							x = dir ? a : b;
							y = dir ? b : a;
							// text sort function
							if ( typeof textSorter === 'function' ) {
								// custom OVERALL text sorter
								sort = textSorter( x[ col ], y[ col ], dir, col, table );
							} else if ( typeof sorter[ col ] === 'function' ) {
								// custom text sorter for a SPECIFIC COLUMN
								sort = sorter[ col ]( x[ col ], y[ col ], dir, col, table );
							} else {
								// fall back to natural sort
								sort = ts[ 'sortNatural' + ( dir ? 'Asc' : 'Desc' ) ]( a[ col ], b[ col ], col, c );
							}
						}
						if ( sort ) { return sort; }
					}
					return a[ c.columns ].order - b[ c.columns ].order;
				});
			}
			if ( ts.debug(c, 'core') ) {
				console.log( 'Applying sort ' + sortList.toString() + ts.benchmark( sortTime ) );
			}
		},

		resortComplete : function( c, callback ) {
			if ( c.table.isUpdating ) {
				c.$table.triggerHandler( 'updateComplete', c.table );
			}
			if ( $.isFunction( callback ) ) {
				callback( c.table );
			}
		},

		checkResort : function( c, resort, callback ) {
			var sortList = $.isArray( resort ) ? resort : c.sortList,
				// if no resort parameter is passed, fallback to config.resort (true by default)
				resrt = typeof resort === 'undefined' ? c.resort : resort;
			// don't try to resort if the table is still processing
			// this will catch spamming of the updateCell method
			if ( resrt !== false && !c.serverSideSorting && !c.table.isProcessing ) {
				if ( sortList.length ) {
					ts.sortOn( c, sortList, function() {
						ts.resortComplete( c, callback );
					}, true );
				} else {
					ts.sortReset( c, function() {
						ts.resortComplete( c, callback );
						ts.applyWidget( c.table, false );
					} );
				}
			} else {
				ts.resortComplete( c, callback );
				ts.applyWidget( c.table, false );
			}
		},

		sortOn : function( c, list, callback, init ) {
			var table = c.table;
			c.$table.triggerHandler( 'sortStart', table );
			// update header count index
			ts.updateHeaderSortCount( c, list );
			// set css for headers
			ts.setHeadersCss( c );
			// fixes #346
			if ( c.delayInit && ts.isEmptyObject( c.cache ) ) {
				ts.buildCache( c );
			}
			c.$table.triggerHandler( 'sortBegin', table );
			// sort the table and append it to the dom
			ts.multisort( c );
			ts.appendCache( c, init );
			c.$table.triggerHandler( 'sortBeforeEnd', table );
			c.$table.triggerHandler( 'sortEnd', table );
			ts.applyWidget( table );
			if ( $.isFunction( callback ) ) {
				callback( table );
			}
		},

		sortReset : function( c, callback ) {
			c.sortList = [];
			ts.setHeadersCss( c );
			ts.multisort( c );
			ts.appendCache( c );
			var indx;
			for (indx = 0; indx < c.columns; indx++) {
				c.sortVars[ indx ].count = -1;
			}
			if ( $.isFunction( callback ) ) {
				callback( c.table );
			}
		},

		getSortType : function( parsers, column ) {
			return ( parsers && parsers[ column ] ) ? parsers[ column ].type || '' : '';
		},

		getOrder : function( val ) {
			// look for 'd' in 'desc' order; return true
			return ( /^d/i.test( val ) || val === 1 );
		},

		// Natural sort - https://github.com/overset/javascript-natural-sort (date sorting removed)
		sortNatural : function( a, b ) {
			if ( a === b ) { return 0; }
			a = a.toString();
			b = b.toString();
			var aNum, bNum, aFloat, bFloat, indx, max,
				regex = ts.regex;
			// first try and sort Hex codes
			if ( regex.hex.test( b ) ) {
				aNum = parseInt( ( a || '' ).match( regex.hex ), 16 );
				bNum = parseInt( ( b || '' ).match( regex.hex ), 16 );
				if ( aNum < bNum ) { return -1; }
				if ( aNum > bNum ) { return 1; }
			}
			// chunk/tokenize
			aNum = ( a || '' ).replace( regex.chunk, '\\0$1\\0' ).replace( regex.chunks, '' ).split( '\\0' );
			bNum = ( b || '' ).replace( regex.chunk, '\\0$1\\0' ).replace( regex.chunks, '' ).split( '\\0' );
			max = Math.max( aNum.length, bNum.length );
			// natural sorting through split numeric strings and default strings
			for ( indx = 0; indx < max; indx++ ) {
				// find floats not starting with '0', string or 0 if not defined
				aFloat = isNaN( aNum[ indx ] ) ? aNum[ indx ] || 0 : parseFloat( aNum[ indx ] ) || 0;
				bFloat = isNaN( bNum[ indx ] ) ? bNum[ indx ] || 0 : parseFloat( bNum[ indx ] ) || 0;
				// handle numeric vs string comparison - number < string - (Kyle Adams)
				if ( isNaN( aFloat ) !== isNaN( bFloat ) ) { return isNaN( aFloat ) ? 1 : -1; }
				// rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'
				if ( typeof aFloat !== typeof bFloat ) {
					aFloat += '';
					bFloat += '';
				}
				if ( aFloat < bFloat ) { return -1; }
				if ( aFloat > bFloat ) { return 1; }
			}
			return 0;
		},

		sortNaturalAsc : function( a, b, col, c ) {
			if ( a === b ) { return 0; }
			var empty = ts.string[ ( c.empties[ col ] || c.emptyTo ) ];
			if ( a === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? -1 : 1 ) : -empty || -1; }
			if ( b === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? 1 : -1 ) : empty || 1; }
			return ts.sortNatural( a, b );
		},

		sortNaturalDesc : function( a, b, col, c ) {
			if ( a === b ) { return 0; }
			var empty = ts.string[ ( c.empties[ col ] || c.emptyTo ) ];
			if ( a === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? -1 : 1 ) : empty || 1; }
			if ( b === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? 1 : -1 ) : -empty || -1; }
			return ts.sortNatural( b, a );
		},

		// basic alphabetical sort
		sortText : function( a, b ) {
			return a > b ? 1 : ( a < b ? -1 : 0 );
		},

		// return text string value by adding up ascii value
		// so the text is somewhat sorted when using a digital sort
		// this is NOT an alphanumeric sort
		getTextValue : function( val, num, max ) {
			if ( max ) {
				// make sure the text value is greater than the max numerical value (max)
				var indx,
					len = val ? val.length : 0,
					n = max + num;
				for ( indx = 0; indx < len; indx++ ) {
					n += val.charCodeAt( indx );
				}
				return num * n;
			}
			return 0;
		},

		sortNumericAsc : function( a, b, num, max, col, c ) {
			if ( a === b ) { return 0; }
			var empty = ts.string[ ( c.empties[ col ] || c.emptyTo ) ];
			if ( a === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? -1 : 1 ) : -empty || -1; }
			if ( b === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? 1 : -1 ) : empty || 1; }
			if ( isNaN( a ) ) { a = ts.getTextValue( a, num, max ); }
			if ( isNaN( b ) ) { b = ts.getTextValue( b, num, max ); }
			return a - b;
		},

		sortNumericDesc : function( a, b, num, max, col, c ) {
			if ( a === b ) { return 0; }
			var empty = ts.string[ ( c.empties[ col ] || c.emptyTo ) ];
			if ( a === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? -1 : 1 ) : empty || 1; }
			if ( b === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? 1 : -1 ) : -empty || -1; }
			if ( isNaN( a ) ) { a = ts.getTextValue( a, num, max ); }
			if ( isNaN( b ) ) { b = ts.getTextValue( b, num, max ); }
			return b - a;
		},

		sortNumeric : function( a, b ) {
			return a - b;
		},

		/*
		        
		                 
		                    
		          
		*/
		addWidget : function( widget ) {
			if ( widget.id && !ts.isEmptyObject( ts.getWidgetById( widget.id ) ) ) {
				console.warn( '"' + widget.id + '" widget was loaded more than once!' );
			}
			ts.widgets[ ts.widgets.length ] = widget;
		},

		hasWidget : function( $table, name ) {
			$table = $( $table );
			return $table.length && $table[ 0 ].config && $table[ 0 ].config.widgetInit[ name ] || false;
		},

		getWidgetById : function( name ) {
			var indx, widget,
				len = ts.widgets.length;
			for ( indx = 0; indx < len; indx++ ) {
				widget = ts.widgets[ indx ];
				if ( widget && widget.id && widget.id.toLowerCase() === name.toLowerCase() ) {
					return widget;
				}
			}
		},

		applyWidgetOptions : function( table ) {
			var indx, widget, wo,
				c = table.config,
				len = c.widgets.length;
			if ( len ) {
				for ( indx = 0; indx < len; indx++ ) {
					widget = ts.getWidgetById( c.widgets[ indx ] );
					if ( widget && widget.options ) {
						wo = $.extend( true, {}, widget.options );
						c.widgetOptions = $.extend( true, wo, c.widgetOptions );
						// add widgetOptions to defaults for option validator
						$.extend( true, ts.defaults.widgetOptions, widget.options );
					}
				}
			}
		},

		addWidgetFromClass : function( table ) {
			var len, indx,
				c = table.config,
				// look for widgets to apply from table class
				// don't match from 'ui-widget-content'; use \S instead of \w to include widgets
				// with dashes in the name, e.g. "widget-test-2" extracts out "test-2"
				regex = '^' + c.widgetClass.replace( ts.regex.templateName, '(\\S+)+' ) + '$',
				widgetClass = new RegExp( regex, 'g' ),
				// split up table class (widget id's can include dashes) - stop using match
				// otherwise only one widget gets extracted, see #1109
				widgets = ( table.className || '' ).split( ts.regex.spaces );
			if ( widgets.length ) {
				len = widgets.length;
				for ( indx = 0; indx < len; indx++ ) {
					if ( widgets[ indx ].match( widgetClass ) ) {
						c.widgets[ c.widgets.length ] = widgets[ indx ].replace( widgetClass, '$1' );
					}
				}
			}
		},

		applyWidgetId : function( table, id, init ) {
			table = $(table)[0];
			var applied, time, name,
				c = table.config,
				wo = c.widgetOptions,
				debug = ts.debug(c, 'core'),
				widget = ts.getWidgetById( id );
			if ( widget ) {
				name = widget.id;
				applied = false;
				// add widget name to option list so it gets reapplied after sorting, filtering, etc
				if ( $.inArray( name, c.widgets ) < 0 ) {
					c.widgets[ c.widgets.length ] = name;
				}
				if ( debug ) { time = new Date(); }

				if ( init || !( c.widgetInit[ name ] ) ) {
					// set init flag first to prevent calling init more than once (e.g. pager)
					c.widgetInit[ name ] = true;
					if ( table.hasInitialized ) {
						// don't reapply widget options on tablesorter init
						ts.applyWidgetOptions( table );
					}
					if ( typeof widget.init === 'function' ) {
						applied = true;
						if ( debug ) {
							console[ console.group ? 'group' : 'log' ]( 'Initializing ' + name + ' widget' );
						}
						widget.init( table, widget, c, wo );
					}
				}
				if ( !init && typeof widget.format === 'function' ) {
					applied = true;
					if ( debug ) {
						console[ console.group ? 'group' : 'log' ]( 'Updating ' + name + ' widget' );
					}
					widget.format( table, c, wo, false );
				}
				if ( debug ) {
					if ( applied ) {
						console.log( 'Completed ' + ( init ? 'initializing ' : 'applying ' ) + name + ' widget' + ts.benchmark( time ) );
						if ( console.groupEnd ) { console.groupEnd(); }
					}
				}
			}
		},

		applyWidget : function( table, init, callback ) {
			table = $( table )[ 0 ]; // in case this is called externally
			var indx, len, names, widget, time,
				c = table.config,
				debug = ts.debug(c, 'core'),
				widgets = [];
			// prevent numerous consecutive widget applications
			if ( init !== false && table.hasInitialized && ( table.isApplyingWidgets || table.isUpdating ) ) {
				return;
			}
			if ( debug ) { time = new Date(); }
			ts.addWidgetFromClass( table );
			// prevent "tablesorter-ready" from firing multiple times in a row
			clearTimeout( c.timerReady );
			if ( c.widgets.length ) {
				table.isApplyingWidgets = true;
				// ensure unique widget ids
				c.widgets = $.grep( c.widgets, function( val, index ) {
					return $.inArray( val, c.widgets ) === index;
				});
				names = c.widgets || [];
				len = names.length;
				// build widget array & add priority as needed
				for ( indx = 0; indx < len; indx++ ) {
					widget = ts.getWidgetById( names[ indx ] );
					if ( widget && widget.id ) {
						// set priority to 10 if not defined
						if ( !widget.priority ) { widget.priority = 10; }
						widgets[ indx ] = widget;
					} else if ( debug ) {
						console.warn( '"' + names[ indx ] + '" was enabled, but the widget code has not been loaded!' );
					}
				}
				// sort widgets by priority
				widgets.sort( function( a, b ) {
					return a.priority < b.priority ? -1 : a.priority === b.priority ? 0 : 1;
				});
				// add/update selected widgets
				len = widgets.length;
				if ( debug ) {
					console[ console.group ? 'group' : 'log' ]( 'Start ' + ( init ? 'initializing' : 'applying' ) + ' widgets' );
				}
				for ( indx = 0; indx < len; indx++ ) {
					widget = widgets[ indx ];
					if ( widget && widget.id ) {
						ts.applyWidgetId( table, widget.id, init );
					}
				}
				if ( debug && console.groupEnd ) { console.groupEnd(); }
			}
			c.timerReady = setTimeout( function() {
				table.isApplyingWidgets = false;
				$.data( table, 'lastWidgetApplication', new Date() );
				c.$table.triggerHandler( 'tablesorter-ready' );
				// callback executed on init only
				if ( !init && typeof callback === 'function' ) {
					callback( table );
				}
				if ( debug ) {
					widget = c.widgets.length;
					console.log( 'Completed ' +
						( init === true ? 'initializing ' : 'applying ' ) + widget +
						' widget' + ( widget !== 1 ? 's' : '' ) + ts.benchmark( time ) );
				}
			}, 10 );
		},

		removeWidget : function( table, name, refreshing ) {
			table = $( table )[ 0 ];
			var index, widget, indx, len,
				c = table.config;
			// if name === true, add all widgets from $.tablesorter.widgets
			if ( name === true ) {
				name = [];
				len = ts.widgets.length;
				for ( indx = 0; indx < len; indx++ ) {
					widget = ts.widgets[ indx ];
					if ( widget && widget.id ) {
						name[ name.length ] = widget.id;
					}
				}
			} else {
				// name can be either an array of widgets names,
				// or a space/comma separated list of widget names
				name = ( $.isArray( name ) ? name.join( ',' ) : name || '' ).toLowerCase().split( /[\s,]+/ );
			}
			len = name.length;
			for ( index = 0; index < len; index++ ) {
				widget = ts.getWidgetById( name[ index ] );
				indx = $.inArray( name[ index ], c.widgets );
				// don't remove the widget from config.widget if refreshing
				if ( indx >= 0 && refreshing !== true ) {
					c.widgets.splice( indx, 1 );
				}
				if ( widget && widget.remove ) {
					if ( ts.debug(c, 'core') ) {
						console.log( ( refreshing ? 'Refreshing' : 'Removing' ) + ' "' + name[ index ] + '" widget' );
					}
					widget.remove( table, c, c.widgetOptions, refreshing );
					c.widgetInit[ name[ index ] ] = false;
				}
			}
			c.$table.triggerHandler( 'widgetRemoveEnd', table );
		},

		refreshWidgets : function( table, doAll, dontapply ) {
			table = $( table )[ 0 ]; // see issue #243
			var indx, widget,
				c = table.config,
				curWidgets = c.widgets,
				widgets = ts.widgets,
				len = widgets.length,
				list = [],
				callback = function( table ) {
					$( table ).triggerHandler( 'refreshComplete' );
				};
			// remove widgets not defined in config.widgets, unless doAll is true
			for ( indx = 0; indx < len; indx++ ) {
				widget = widgets[ indx ];
				if ( widget && widget.id && ( doAll || $.inArray( widget.id, curWidgets ) < 0 ) ) {
					list[ list.length ] = widget.id;
				}
			}
			ts.removeWidget( table, list.join( ',' ), true );
			if ( dontapply !== true ) {
				// call widget init if
				ts.applyWidget( table, doAll || false, callback );
				if ( doAll ) {
					// apply widget format
					ts.applyWidget( table, false, callback );
				}
			} else {
				callback( table );
			}
		},

		/*
		              
		                        
		                           
		                
		*/
		benchmark : function( diff ) {
			return ( ' (' + ( new Date().getTime() - diff.getTime() ) + ' ms)' );
		},
		// deprecated ts.log
		log : function() {
			console.log( arguments );
		},
		debug : function(c, name) {
			return c && (
				c.debug === true ||
				typeof c.debug === 'string' && c.debug.indexOf(name) > -1
			);
		},

		// $.isEmptyObject from jQuery v1.4
		isEmptyObject : function( obj ) {
			/*jshint forin: false */
			for ( var name in obj ) {
				return false;
			}
			return true;
		},

		isValueInArray : function( column, arry ) {
			var indx,
				len = arry && arry.length || 0;
			for ( indx = 0; indx < len; indx++ ) {
				if ( arry[ indx ][ 0 ] === column ) {
					return indx;
				}
			}
			return -1;
		},

		formatFloat : function( str, table ) {
			if ( typeof str !== 'string' || str === '' ) { return str; }
			// allow using formatFloat without a table; defaults to US number format
			var num,
				usFormat = table && table.config ? table.config.usNumberFormat !== false :
					typeof table !== 'undefined' ? table : true;
			if ( usFormat ) {
				// US Format - 1,234,567.89 -> 1234567.89
				str = str.replace( ts.regex.comma, '' );
			} else {
				// German Format = 1.234.567,89 -> 1234567.89
				// French Format = 1 234 567,89 -> 1234567.89
				str = str.replace( ts.regex.digitNonUS, '' ).replace( ts.regex.comma, '.' );
			}
			if ( ts.regex.digitNegativeTest.test( str ) ) {
				// make (#) into a negative number -> (10) = -10
				str = str.replace( ts.regex.digitNegativeReplace, '-$1' );
			}
			num = parseFloat( str );
			// return the text instead of zero
			return isNaN( num ) ? $.trim( str ) : num;
		},

		isDigit : function( str ) {
			// replace all unwanted chars and match
			return isNaN( str ) ?
				ts.regex.digitTest.test( str.toString().replace( ts.regex.digitReplace, '' ) ) :
				str !== '';
		},

		// computeTableHeaderCellIndexes from:
		// http://www.javascripttoolbox.com/lib/table/examples.php
		// http://www.javascripttoolbox.com/temp/table_cellindex.html
		computeColumnIndex : function( $rows, c ) {
			var i, j, k, l, cell, cells, rowIndex, rowSpan, colSpan, firstAvailCol,
				// total columns has been calculated, use it to set the matrixrow
				columns = c && c.columns || 0,
				matrix = [],
				matrixrow = new Array( columns );
			for ( i = 0; i < $rows.length; i++ ) {
				cells = $rows[ i ].cells;
				for ( j = 0; j < cells.length; j++ ) {
					cell = cells[ j ];
					rowIndex = i;
					rowSpan = cell.rowSpan || 1;
					colSpan = cell.colSpan || 1;
					if ( typeof matrix[ rowIndex ] === 'undefined' ) {
						matrix[ rowIndex ] = [];
					}
					// Find first available column in the first row
					for ( k = 0; k < matrix[ rowIndex ].length + 1; k++ ) {
						if ( typeof matrix[ rowIndex ][ k ] === 'undefined' ) {
							firstAvailCol = k;
							break;
						}
					}
					// jscs:disable disallowEmptyBlocks
					if ( columns && cell.cellIndex === firstAvailCol ) {
						// don't to anything
					} else if ( cell.setAttribute ) {
						// jscs:enable disallowEmptyBlocks
						// add data-column (setAttribute = IE8+)
						cell.setAttribute( 'data-column', firstAvailCol );
					} else {
						// remove once we drop support for IE7 - 1/12/2016
						$( cell ).attr( 'data-column', firstAvailCol );
					}
					for ( k = rowIndex; k < rowIndex + rowSpan; k++ ) {
						if ( typeof matrix[ k ] === 'undefined' ) {
							matrix[ k ] = [];
						}
						matrixrow = matrix[ k ];
						for ( l = firstAvailCol; l < firstAvailCol + colSpan; l++ ) {
							matrixrow[ l ] = 'x';
						}
					}
				}
			}
			ts.checkColumnCount($rows, matrix, matrixrow.length);
			return matrixrow.length;
		},

		checkColumnCount : function($rows, matrix, columns) {
			// this DOES NOT report any tbody column issues, except for the math and
			// and column selector widgets
			var i, len,
				valid = true,
				cells = [];
			for ( i = 0; i < matrix.length; i++ ) {
				// some matrix entries are undefined when testing the footer because
				// it is using the rowIndex property
				if ( matrix[i] ) {
					len = matrix[i].length;
					if ( matrix[i].length !== columns ) {
						valid = false;
						break;
					}
				}
			}
			if ( !valid ) {
				$rows.each( function( indx, el ) {
					var cell = el.parentElement.nodeName;
					if ( cells.indexOf( cell ) < 0 ) {
						cells.push( cell );
					}
				});
				console.error(
					'Invalid or incorrect number of columns in the ' +
					cells.join( ' or ' ) + '; expected ' + columns +
					', but found ' + len + ' columns'
				);
			}
		},

		// automatically add a colgroup with col elements set to a percentage width
		fixColumnWidth : function( table ) {
			table = $( table )[ 0 ];
			var overallWidth, percent, $tbodies, len, index,
				c = table.config,
				$colgroup = c.$table.children( 'colgroup' );
			// remove plugin-added colgroup, in case we need to refresh the widths
			if ( $colgroup.length && $colgroup.hasClass( ts.css.colgroup ) ) {
				$colgroup.remove();
			}
			if ( c.widthFixed && c.$table.children( 'colgroup' ).length === 0 ) {
				$colgroup = $( '<colgroup class="' + ts.css.colgroup + '">' );
				overallWidth = c.$table.width();
				// only add col for visible columns - fixes #371
				$tbodies = c.$tbodies.find( 'tr:first' ).children( ':visible' );
				len = $tbodies.length;
				for ( index = 0; index < len; index++ ) {
					percent = parseInt( ( $tbodies.eq( index ).width() / overallWidth ) * 1000, 10 ) / 10 + '%';
					$colgroup.append( $( '<col>' ).css( 'width', percent ) );
				}
				c.$table.prepend( $colgroup );
			}
		},

		// get sorter, string, empty, etc options for each column from
		// jQuery data, metadata, header option or header class name ('sorter-false')
		// priority = jQuery data > meta > headers option > header class name
		getData : function( header, configHeader, key ) {
			var meta, cl4ss,
				val = '',
				$header = $( header );
			if ( !$header.length ) { return ''; }
			meta = $.metadata ? $header.metadata() : false;
			cl4ss = ' ' + ( $header.attr( 'class' ) || '' );
			if ( typeof $header.data( key ) !== 'undefined' ||
				typeof $header.data( key.toLowerCase() ) !== 'undefined' ) {
				// 'data-lockedOrder' is assigned to 'lockedorder'; but 'data-locked-order' is assigned to 'lockedOrder'
				// 'data-sort-initial-order' is assigned to 'sortInitialOrder'
				val += $header.data( key ) || $header.data( key.toLowerCase() );
			} else if ( meta && typeof meta[ key ] !== 'undefined' ) {
				val += meta[ key ];
			} else if ( configHeader && typeof configHeader[ key ] !== 'undefined' ) {
				val += configHeader[ key ];
			} else if ( cl4ss !== ' ' && cl4ss.match( ' ' + key + '-' ) ) {
				// include sorter class name 'sorter-text', etc; now works with 'sorter-my-custom-parser'
				val = cl4ss.match( new RegExp( '\\s' + key + '-([\\w-]+)' ) )[ 1 ] || '';
			}
			return $.trim( val );
		},

		getColumnData : function( table, obj, indx, getCell, $headers ) {
			if ( typeof obj !== 'object' || obj === null ) {
				return obj;
			}
			table = $( table )[ 0 ];
			var $header, key,
				c = table.config,
				$cells = ( $headers || c.$headers ),
				// c.$headerIndexed is not defined initially
				$cell = c.$headerIndexed && c.$headerIndexed[ indx ] ||
					$cells.find( '[data-column="' + indx + '"]:last' );
			if ( typeof obj[ indx ] !== 'undefined' ) {
				return getCell ? obj[ indx ] : obj[ $cells.index( $cell ) ];
			}
			for ( key in obj ) {
				if ( typeof key === 'string' ) {
					$header = $cell
						// header cell with class/id
						.filter( key )
						// find elements within the header cell with cell/id
						.add( $cell.find( key ) );
					if ( $header.length ) {
						return obj[ key ];
					}
				}
			}
			return;
		},

		// *** Process table ***
		// add processing indicator
		isProcessing : function( $table, toggle, $headers ) {
			$table = $( $table );
			var c = $table[ 0 ].config,
				// default to all headers
				$header = $headers || $table.find( '.' + ts.css.header );
			if ( toggle ) {
				// don't use sortList if custom $headers used
				if ( typeof $headers !== 'undefined' && c.sortList.length > 0 ) {
					// get headers from the sortList
					$header = $header.filter( function() {
						// get data-column from attr to keep compatibility with jQuery 1.2.6
						return this.sortDisabled ?
							false :
							ts.isValueInArray( parseFloat( $( this ).attr( 'data-column' ) ), c.sortList ) >= 0;
					});
				}
				$table.add( $header ).addClass( ts.css.processing + ' ' + c.cssProcessing );
			} else {
				$table.add( $header ).removeClass( ts.css.processing + ' ' + c.cssProcessing );
			}
		},

		// detach tbody but save the position
		// don't use tbody because there are portions that look for a tbody index (updateCell)
		processTbody : function( table, $tb, getIt ) {
			table = $( table )[ 0 ];
			if ( getIt ) {
				table.isProcessing = true;
				$tb.before( '<colgroup class="tablesorter-savemyplace"/>' );
				return $.fn.detach ? $tb.detach() : $tb.remove();
			}
			var holdr = $( table ).find( 'colgroup.tablesorter-savemyplace' );
			$tb.insertAfter( holdr );
			holdr.remove();
			table.isProcessing = false;
		},

		clearTableBody : function( table ) {
			$( table )[ 0 ].config.$tbodies.children().detach();
		},

		// used when replacing accented characters during sorting
		characterEquivalents : {
			'a' : '\u00e1\u00e0\u00e2\u00e3\u00e4\u0105\u00e5', // 
			'A' : '\u00c1\u00c0\u00c2\u00c3\u00c4\u0104\u00c5', // 
			'c' : '\u00e7\u0107\u010d', // 
			'C' : '\u00c7\u0106\u010c', // 
			'e' : '\u00e9\u00e8\u00ea\u00eb\u011b\u0119', // 
			'E' : '\u00c9\u00c8\u00ca\u00cb\u011a\u0118', // 
			'i' : '\u00ed\u00ec\u0130\u00ee\u00ef\u0131', // 
			'I' : '\u00cd\u00cc\u0130\u00ce\u00cf', // 
			'o' : '\u00f3\u00f2\u00f4\u00f5\u00f6\u014d', // 
			'O' : '\u00d3\u00d2\u00d4\u00d5\u00d6\u014c', // 
			'ss': '\u00df', //  (s sharp)
			'SS': '\u1e9e', //  (Capital sharp s)
			'u' : '\u00fa\u00f9\u00fb\u00fc\u016f', // 
			'U' : '\u00da\u00d9\u00db\u00dc\u016e' // 
		},

		replaceAccents : function( str ) {
			var chr,
				acc = '[',
				eq = ts.characterEquivalents;
			if ( !ts.characterRegex ) {
				ts.characterRegexArray = {};
				for ( chr in eq ) {
					if ( typeof chr === 'string' ) {
						acc += eq[ chr ];
						ts.characterRegexArray[ chr ] = new RegExp( '[' + eq[ chr ] + ']', 'g' );
					}
				}
				ts.characterRegex = new RegExp( acc + ']' );
			}
			if ( ts.characterRegex.test( str ) ) {
				for ( chr in eq ) {
					if ( typeof chr === 'string' ) {
						str = str.replace( ts.characterRegexArray[ chr ], chr );
					}
				}
			}
			return str;
		},

		validateOptions : function( c ) {
			var setting, setting2, typ, timer,
				// ignore options containing an array
				ignore = 'headers sortForce sortList sortAppend widgets'.split( ' ' ),
				orig = c.originalSettings;
			if ( orig ) {
				if ( ts.debug(c, 'core') ) {
					timer = new Date();
				}
				for ( setting in orig ) {
					typ = typeof ts.defaults[setting];
					if ( typ === 'undefined' ) {
						console.warn( 'Tablesorter Warning! "table.config.' + setting + '" option not recognized' );
					} else if ( typ === 'object' ) {
						for ( setting2 in orig[setting] ) {
							typ = ts.defaults[setting] && typeof ts.defaults[setting][setting2];
							if ( $.inArray( setting, ignore ) < 0 && typ === 'undefined' ) {
								console.warn( 'Tablesorter Warning! "table.config.' + setting + '.' + setting2 + '" option not recognized' );
							}
						}
					}
				}
				if ( ts.debug(c, 'core') ) {
					console.log( 'validate options time:' + ts.benchmark( timer ) );
				}
			}
		},

		// restore headers
		restoreHeaders : function( table ) {
			var index, $cell,
				c = $( table )[ 0 ].config,
				$headers = c.$table.find( c.selectorHeaders ),
				len = $headers.length;
			// don't use c.$headers here in case header cells were swapped
			for ( index = 0; index < len; index++ ) {
				$cell = $headers.eq( index );
				// only restore header cells if it is wrapped
				// because this is also used by the updateAll method
				if ( $cell.find( '.' + ts.css.headerIn ).length ) {
					$cell.html( c.headerContent[ index ] );
				}
			}
		},

		destroy : function( table, removeClasses, callback ) {
			table = $( table )[ 0 ];
			if ( !table.hasInitialized ) { return; }
			// remove all widgets
			ts.removeWidget( table, true, false );
			var events,
				$t = $( table ),
				c = table.config,
				$h = $t.find( 'thead:first' ),
				$r = $h.find( 'tr.' + ts.css.headerRow ).removeClass( ts.css.headerRow + ' ' + c.cssHeaderRow ),
				$f = $t.find( 'tfoot:first > tr' ).children( 'th, td' );
			if ( removeClasses === false && $.inArray( 'uitheme', c.widgets ) >= 0 ) {
				// reapply uitheme classes, in case we want to maintain appearance
				$t.triggerHandler( 'applyWidgetId', [ 'uitheme' ] );
				$t.triggerHandler( 'applyWidgetId', [ 'zebra' ] );
			}
			// remove widget added rows, just in case
			$h.find( 'tr' ).not( $r ).remove();
			// disable tablesorter - not using .unbind( namespace ) because namespacing was
			// added in jQuery v1.4.3 - see http://api.jquery.com/event.namespace/
			events = 'sortReset update updateRows updateAll updateHeaders updateCell addRows updateComplete sorton ' +
				'appendCache updateCache applyWidgetId applyWidgets refreshWidgets removeWidget destroy mouseup mouseleave ' +
				'keypress sortBegin sortEnd resetToLoadState '.split( ' ' )
				.join( c.namespace + ' ' );
			$t
				.removeData( 'tablesorter' )
				.unbind( events.replace( ts.regex.spaces, ' ' ) );
			c.$headers
				.add( $f )
				.removeClass( [ ts.css.header, c.cssHeader, c.cssAsc, c.cssDesc, ts.css.sortAsc, ts.css.sortDesc, ts.css.sortNone ].join( ' ' ) )
				.removeAttr( 'data-column' )
				.removeAttr( 'aria-label' )
				.attr( 'aria-disabled', 'true' );
			$r
				.find( c.selectorSort )
				.unbind( ( 'mousedown mouseup keypress '.split( ' ' ).join( c.namespace + ' ' ) ).replace( ts.regex.spaces, ' ' ) );
			ts.restoreHeaders( table );
			$t.toggleClass( ts.css.table + ' ' + c.tableClass + ' tablesorter-' + c.theme, removeClasses === false );
			$t.removeClass(c.namespace.slice(1));
			// clear flag in case the plugin is initialized again
			table.hasInitialized = false;
			delete table.config.cache;
			if ( typeof callback === 'function' ) {
				callback( table );
			}
			if ( ts.debug(c, 'core') ) {
				console.log( 'tablesorter has been removed' );
			}
		}

	};

	$.fn.tablesorter = function( settings ) {
		return this.each( function() {
			var table = this,
			// merge & extend config options
			c = $.extend( true, {}, ts.defaults, settings, ts.instanceMethods );
			// save initial settings
			c.originalSettings = settings;
			// create a table from data (build table widget)
			if ( !table.hasInitialized && ts.buildTable && this.nodeName !== 'TABLE' ) {
				// return the table (in case the original target is the table's container)
				ts.buildTable( table, c );
			} else {
				ts.setup( table, c );
			}
		});
	};

	// set up debug logs
	if ( !( window.console && window.console.log ) ) {
		// access $.tablesorter.logs for browsers that don't have a console...
		ts.logs = [];
		/*jshint -W020 */
		console = {};
		console.log = console.warn = console.error = console.table = function() {
			var arg = arguments.length > 1 ? arguments : arguments[0];
			ts.logs[ ts.logs.length ] = { date: Date.now(), log: arg };
		};
	}

	// add default parsers
	ts.addParser({
		id : 'no-parser',
		is : function() {
			return false;
		},
		format : function() {
			return '';
		},
		type : 'text'
	});

	ts.addParser({
		id : 'text',
		is : function() {
			return true;
		},
		format : function( str, table ) {
			var c = table.config;
			if ( str ) {
				str = $.trim( c.ignoreCase ? str.toLocaleLowerCase() : str );
				str = c.sortLocaleCompare ? ts.replaceAccents( str ) : str;
			}
			return str;
		},
		type : 'text'
	});

	ts.regex.nondigit = /[^\w,. \-()]/g;
	ts.addParser({
		id : 'digit',
		is : function( str ) {
			return ts.isDigit( str );
		},
		format : function( str, table ) {
			var num = ts.formatFloat( ( str || '' ).replace( ts.regex.nondigit, '' ), table );
			return str && typeof num === 'number' ? num :
				str ? $.trim( str && table.config.ignoreCase ? str.toLocaleLowerCase() : str ) : str;
		},
		type : 'numeric'
	});

	ts.regex.currencyReplace = /[+\-,. ]/g;
	ts.regex.currencyTest = /^\(?\d+[\u00a3$\u20ac\u00a4\u00a5\u00a2?.]|[\u00a3$\u20ac\u00a4\u00a5\u00a2?.]\d+\)?$/;
	ts.addParser({
		id : 'currency',
		is : function( str ) {
			str = ( str || '' ).replace( ts.regex.currencyReplace, '' );
			// test for $
			return ts.regex.currencyTest.test( str );
		},
		format : function( str, table ) {
			var num = ts.formatFloat( ( str || '' ).replace( ts.regex.nondigit, '' ), table );
			return str && typeof num === 'number' ? num :
				str ? $.trim( str && table.config.ignoreCase ? str.toLocaleLowerCase() : str ) : str;
		},
		type : 'numeric'
	});

	// too many protocols to add them all https://en.wikipedia.org/wiki/URI_scheme
	// now, this regex can be updated before initialization
	ts.regex.urlProtocolTest = /^(https?|ftp|file):\/\//;
	ts.regex.urlProtocolReplace = /(https?|ftp|file):\/\/(www\.)?/;
	ts.addParser({
		id : 'url',
		is : function( str ) {
			return ts.regex.urlProtocolTest.test( str );
		},
		format : function( str ) {
			return str ? $.trim( str.replace( ts.regex.urlProtocolReplace, '' ) ) : str;
		},
		type : 'text'
	});

	ts.regex.dash = /-/g;
	ts.regex.isoDate = /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}/;
	ts.addParser({
		id : 'isoDate',
		is : function( str ) {
			return ts.regex.isoDate.test( str );
		},
		format : function( str ) {
			var date = str ? new Date( str.replace( ts.regex.dash, '/' ) ) : str;
			return date instanceof Date && isFinite( date ) ? date.getTime() : str;
		},
		type : 'numeric'
	});

	ts.regex.percent = /%/g;
	ts.regex.percentTest = /(\d\s*?%|%\s*?\d)/;
	ts.addParser({
		id : 'percent',
		is : function( str ) {
			return ts.regex.percentTest.test( str ) && str.length < 15;
		},
		format : function( str, table ) {
			return str ? ts.formatFloat( str.replace( ts.regex.percent, '' ), table ) : str;
		},
		type : 'numeric'
	});

	// added image parser to core v2.17.9
	ts.addParser({
		id : 'image',
		is : function( str, table, node, $node ) {
			return $node.find( 'img' ).length > 0;
		},
		format : function( str, table, cell ) {
			return $( cell ).find( 'img' ).attr( table.config.imgAttr || 'alt' ) || str;
		},
		parsed : true, // filter widget flag
		type : 'text'
	});

	ts.regex.dateReplace = /(\S)([AP]M)$/i; // used by usLongDate & time parser
	ts.regex.usLongDateTest1 = /^[A-Z]{3,10}\.?\s+\d{1,2},?\s+(\d{4})(\s+\d{1,2}:\d{2}(:\d{2})?(\s+[AP]M)?)?$/i;
	ts.regex.usLongDateTest2 = /^\d{1,2}\s+[A-Z]{3,10}\s+\d{4}/i;
	ts.addParser({
		id : 'usLongDate',
		is : function( str ) {
			// two digit years are not allowed cross-browser
			// Jan 01, 2013 12:34:56 PM or 01 Jan 2013
			return ts.regex.usLongDateTest1.test( str ) || ts.regex.usLongDateTest2.test( str );
		},
		format : function( str ) {
			var date = str ? new Date( str.replace( ts.regex.dateReplace, '$1 $2' ) ) : str;
			return date instanceof Date && isFinite( date ) ? date.getTime() : str;
		},
		type : 'numeric'
	});

	// testing for ##-##-#### or ####-##-##, so it's not perfect; time can be included
	ts.regex.shortDateTest = /(^\d{1,2}[\/\s]\d{1,2}[\/\s]\d{4})|(^\d{4}[\/\s]\d{1,2}[\/\s]\d{1,2})/;
	// escaped "-" because JSHint in Firefox was showing it as an error
	ts.regex.shortDateReplace = /[\-.,]/g;
	// XXY covers MDY & DMY formats
	ts.regex.shortDateXXY = /(\d{1,2})[\/\s](\d{1,2})[\/\s](\d{4})/;
	ts.regex.shortDateYMD = /(\d{4})[\/\s](\d{1,2})[\/\s](\d{1,2})/;
	ts.convertFormat = function( dateString, format ) {
		dateString = ( dateString || '' )
			.replace( ts.regex.spaces, ' ' )
			.replace( ts.regex.shortDateReplace, '/' );
		if ( format === 'mmddyyyy' ) {
			dateString = dateString.replace( ts.regex.shortDateXXY, '$3/$1/$2' );
		} else if ( format === 'ddmmyyyy' ) {
			dateString = dateString.replace( ts.regex.shortDateXXY, '$3/$2/$1' );
		} else if ( format === 'yyyymmdd' ) {
			dateString = dateString.replace( ts.regex.shortDateYMD, '$1/$2/$3' );
		}
		var date = new Date( dateString );
		return date instanceof Date && isFinite( date ) ? date.getTime() : '';
	};

	ts.addParser({
		id : 'shortDate', // 'mmddyyyy', 'ddmmyyyy' or 'yyyymmdd'
		is : function( str ) {
			str = ( str || '' ).replace( ts.regex.spaces, ' ' ).replace( ts.regex.shortDateReplace, '/' );
			return ts.regex.shortDateTest.test( str );
		},
		format : function( str, table, cell, cellIndex ) {
			if ( str ) {
				var c = table.config,
					$header = c.$headerIndexed[ cellIndex ],
					format = $header.length && $header.data( 'dateFormat' ) ||
						ts.getData( $header, ts.getColumnData( table, c.headers, cellIndex ), 'dateFormat' ) ||
						c.dateFormat;
				// save format because getData can be slow...
				if ( $header.length ) {
					$header.data( 'dateFormat', format );
				}
				return ts.convertFormat( str, format ) || str;
			}
			return str;
		},
		type : 'numeric'
	});

	// match 24 hour time & 12 hours time + am/pm - see http://regexr.com/3c3tk
	ts.regex.timeTest = /^(0?[1-9]|1[0-2]):([0-5]\d)(\s[AP]M)$|^((?:[01]\d|[2][0-4]):[0-5]\d)$/i;
	ts.regex.timeMatch = /(0?[1-9]|1[0-2]):([0-5]\d)(\s[AP]M)|((?:[01]\d|[2][0-4]):[0-5]\d)/i;
	ts.addParser({
		id : 'time',
		is : function( str ) {
			return ts.regex.timeTest.test( str );
		},
		format : function( str ) {
			// isolate time... ignore month, day and year
			var temp,
				timePart = ( str || '' ).match( ts.regex.timeMatch ),
				orig = new Date( str ),
				// no time component? default to 00:00 by leaving it out, but only if str is defined
				time = str && ( timePart !== null ? timePart[ 0 ] : '00:00 AM' ),
				date = time ? new Date( '2000/01/01 ' + time.replace( ts.regex.dateReplace, '$1 $2' ) ) : time;
			if ( date instanceof Date && isFinite( date ) ) {
				temp = orig instanceof Date && isFinite( orig ) ? orig.getTime() : 0;
				// if original string was a valid date, add it to the decimal so the column sorts in some kind of order
				// luckily new Date() ignores the decimals
				return temp ? parseFloat( date.getTime() + '.' + orig.getTime() ) : date.getTime();
			}
			return str;
		},
		type : 'numeric'
	});

	ts.addParser({
		id : 'metadata',
		is : function() {
			return false;
		},
		format : function( str, table, cell ) {
			var c = table.config,
			p = ( !c.parserMetadataName ) ? 'sortValue' : c.parserMetadataName;
			return $( cell ).metadata()[ p ];
		},
		type : 'numeric'
	});

	/*
		    
		         
		          
		        
		*/
	// add default widgets
	ts.addWidget({
		id : 'zebra',
		priority : 90,
		format : function( table, c, wo ) {
			var $visibleRows, $row, count, isEven, tbodyIndex, rowIndex, len,
				child = new RegExp( c.cssChildRow, 'i' ),
				$tbodies = c.$tbodies.add( $( c.namespace + '_extra_table' ).children( 'tbody:not(.' + c.cssInfoBlock + ')' ) );
			for ( tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ) {
				// loop through the visible rows
				count = 0;
				$visibleRows = $tbodies.eq( tbodyIndex ).children( 'tr:visible' ).not( c.selectorRemove );
				len = $visibleRows.length;
				for ( rowIndex = 0; rowIndex < len; rowIndex++ ) {
					$row = $visibleRows.eq( rowIndex );
					// style child rows the same way the parent row was styled
					if ( !child.test( $row[ 0 ].className ) ) { count++; }
					isEven = ( count % 2 === 0 );
					$row
						.removeClass( wo.zebra[ isEven ? 1 : 0 ] )
						.addClass( wo.zebra[ isEven ? 0 : 1 ] );
				}
			}
		},
		remove : function( table, c, wo, refreshing ) {
			if ( refreshing ) { return; }
			var tbodyIndex, $tbody,
				$tbodies = c.$tbodies,
				toRemove = ( wo.zebra || [ 'even', 'odd' ] ).join( ' ' );
			for ( tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ) {
				$tbody = ts.processTbody( table, $tbodies.eq( tbodyIndex ), true ); // remove tbody
				$tbody.children().removeClass( toRemove );
				ts.processTbody( table, $tbody, false ); // restore tbody
			}
		}
	});

})( jQuery );

/*! Widget: storage - updated 2018-03-18 (v2.30.0) */
/*global JSON:false */
;(function ($, window, document) {
	'use strict';

	var ts = $.tablesorter || {};

	// update defaults for validator; these values must be falsy!
	$.extend(true, ts.defaults, {
		fixedUrl: '',
		widgetOptions: {
			storage_fixedUrl: '',
			storage_group: '',
			storage_page: '',
			storage_storageType: '',
			storage_tableId: '',
			storage_useSessionStorage: ''
		}
	});

	// *** Store data in local storage, with a cookie fallback ***
	/* IE7 needs JSON library for JSON.stringify - (http://caniuse.com/#search=json)
	   if you need it, then include https://github.com/douglascrockford/JSON-js

	   $.parseJSON is not available is jQuery versions older than 1.4.1, using older
	   versions will only allow storing information for one page at a time

	   // *** Save data (JSON format only) ***
	   // val must be valid JSON... use http://jsonlint.com/ to ensure it is valid
	   var val = { "mywidget" : "data1" }; // valid JSON uses double quotes
	   // $.tablesorter.storage(table, key, val);
	   $.tablesorter.storage(table, 'tablesorter-mywidget', val);

	   // *** Get data: $.tablesorter.storage(table, key); ***
	   v = $.tablesorter.storage(table, 'tablesorter-mywidget');
	   // val may be empty, so also check for your data
	   val = (v && v.hasOwnProperty('mywidget')) ? v.mywidget : '';
	   alert(val); // 'data1' if saved, or '' if not
	*/
	ts.storage = function(table, key, value, options) {
		table = $(table)[0];
		var cookieIndex, cookies, date,
			hasStorage = false,
			values = {},
			c = table.config,
			wo = c && c.widgetOptions,
			debug = ts.debug(c, 'storage'),
			storageType = (
				( options && options.storageType ) || ( wo && wo.storage_storageType )
			).toString().charAt(0).toLowerCase(),
			// deprecating "useSessionStorage"; any storageType setting overrides it
			session = storageType ? '' :
				( options && options.useSessionStorage ) || ( wo && wo.storage_useSessionStorage ),
			$table = $(table),
			// id from (1) options ID, (2) table 'data-table-group' attribute, (3) widgetOptions.storage_tableId,
			// (4) table ID, then (5) table index
			id = options && options.id ||
				$table.attr( options && options.group || wo && wo.storage_group || 'data-table-group') ||
				wo && wo.storage_tableId || table.id || $('.tablesorter').index( $table ),
			// url from (1) options url, (2) table 'data-table-page' attribute, (3) widgetOptions.storage_fixedUrl,
			// (4) table.config.fixedUrl (deprecated), then (5) window location path
			url = options && options.url ||
				$table.attr(options && options.page || wo && wo.storage_page || 'data-table-page') ||
				wo && wo.storage_fixedUrl || c && c.fixedUrl || window.location.pathname;

		// skip if using cookies
		if (storageType !== 'c') {
			storageType = (storageType === 's' || session) ? 'sessionStorage' : 'localStorage';
			// https://gist.github.com/paulirish/5558557
			if (storageType in window) {
				try {
					window[storageType].setItem('_tmptest', 'temp');
					hasStorage = true;
					window[storageType].removeItem('_tmptest');
				} catch (error) {
					console.warn( storageType + ' is not supported in this browser' );
				}
			}
		}
		if (debug) {
			console.log('Storage >> Using', hasStorage ? storageType : 'cookies');
		}
		// *** get value ***
		if ($.parseJSON) {
			if (hasStorage) {
				values = $.parseJSON( window[storageType][key] || 'null' ) || {};
			} else {
				// old browser, using cookies
				cookies = document.cookie.split(/[;\s|=]/);
				// add one to get from the key to the value
				cookieIndex = $.inArray(key, cookies) + 1;
				values = (cookieIndex !== 0) ? $.parseJSON(cookies[cookieIndex] || 'null') || {} : {};
			}
		}
		// allow value to be an empty string too
		if (typeof value !== 'undefined' && window.JSON && JSON.hasOwnProperty('stringify')) {
			// add unique identifiers = url pathname > table ID/index on page > data
			if (!values[url]) {
				values[url] = {};
			}
			values[url][id] = value;
			// *** set value ***
			if (hasStorage) {
				window[storageType][key] = JSON.stringify(values);
			} else {
				date = new Date();
				date.setTime(date.getTime() + (31536e+6)); // 365 days
				document.cookie = key + '=' + (JSON.stringify(values)).replace(/\"/g, '\"') + '; expires=' + date.toGMTString() + '; path=/';
			}
		} else {
			return values && values[url] ? values[url][id] : '';
		}
	};

})(jQuery, window, document);

/*! Widget: uitheme - updated 2018-03-18 (v2.30.0) */
;(function ($) {
	'use strict';
	var ts = $.tablesorter || {};

	ts.themes = {
		'bootstrap' : {
			table        : 'table table-bordered table-striped',
			caption      : 'caption',
			// header class names
			header       : 'bootstrap-header', // give the header a gradient background (theme.bootstrap_2.css)
			sortNone     : '',
			sortAsc      : '',
			sortDesc     : '',
			active       : '', // applied when column is sorted
			hover        : '', // custom css required - a defined bootstrap style may not override other classes
			// icon class names
			icons        : '', // add 'bootstrap-icon-white' to make them white; this icon class is added to the <i> in the header
			iconSortNone : 'bootstrap-icon-unsorted', // class name added to icon when column is not sorted
			iconSortAsc  : 'glyphicon glyphicon-chevron-up', // class name added to icon when column has ascending sort
			iconSortDesc : 'glyphicon glyphicon-chevron-down', // class name added to icon when column has descending sort
			filterRow    : '', // filter row class
			footerRow    : '',
			footerCells  : '',
			even         : '', // even row zebra striping
			odd          : ''  // odd row zebra striping
		},
		'jui' : {
			table        : 'ui-widget ui-widget-content ui-corner-all', // table classes
			caption      : 'ui-widget-content',
			// header class names
			header       : 'ui-widget-header ui-corner-all ui-state-default', // header classes
			sortNone     : '',
			sortAsc      : '',
			sortDesc     : '',
			active       : 'ui-state-active', // applied when column is sorted
			hover        : 'ui-state-hover',  // hover class
			// icon class names
			icons        : 'ui-icon', // icon class added to the <i> in the header
			iconSortNone : 'ui-icon-carat-2-n-s ui-icon-caret-2-n-s', // class name added to icon when column is not sorted
			iconSortAsc  : 'ui-icon-carat-1-n ui-icon-caret-1-n', // class name added to icon when column has ascending sort
			iconSortDesc : 'ui-icon-carat-1-s ui-icon-caret-1-s', // class name added to icon when column has descending sort
			filterRow    : '',
			footerRow    : '',
			footerCells  : '',
			even         : 'ui-widget-content', // even row zebra striping
			odd          : 'ui-state-default'   // odd row zebra striping
		}
	};

	$.extend(ts.css, {
		wrapper : 'tablesorter-wrapper' // ui theme & resizable
	});

	ts.addWidget({
		id: 'uitheme',
		priority: 10,
		format: function(table, c, wo) {
			var i, tmp, hdr, icon, time, $header, $icon, $tfoot, $h, oldtheme, oldremove, oldIconRmv, hasOldTheme,
				themesAll = ts.themes,
				$table = c.$table.add( $( c.namespace + '_extra_table' ) ),
				$headers = c.$headers.add( $( c.namespace + '_extra_headers' ) ),
				theme = c.theme || 'jui',
				themes = themesAll[theme] || {},
				remove = $.trim( [ themes.sortNone, themes.sortDesc, themes.sortAsc, themes.active ].join( ' ' ) ),
				iconRmv = $.trim( [ themes.iconSortNone, themes.iconSortDesc, themes.iconSortAsc ].join( ' ' ) ),
				debug = ts.debug(c, 'uitheme');
			if (debug) { time = new Date(); }
			// initialization code - run once
			if (!$table.hasClass('tablesorter-' + theme) || c.theme !== c.appliedTheme || !wo.uitheme_applied) {
				wo.uitheme_applied = true;
				oldtheme = themesAll[c.appliedTheme] || {};
				hasOldTheme = !$.isEmptyObject(oldtheme);
				oldremove =  hasOldTheme ? [ oldtheme.sortNone, oldtheme.sortDesc, oldtheme.sortAsc, oldtheme.active ].join( ' ' ) : '';
				oldIconRmv = hasOldTheme ? [ oldtheme.iconSortNone, oldtheme.iconSortDesc, oldtheme.iconSortAsc ].join( ' ' ) : '';
				if (hasOldTheme) {
					wo.zebra[0] = $.trim( ' ' + wo.zebra[0].replace(' ' + oldtheme.even, '') );
					wo.zebra[1] = $.trim( ' ' + wo.zebra[1].replace(' ' + oldtheme.odd, '') );
					c.$tbodies.children().removeClass( [ oldtheme.even, oldtheme.odd ].join(' ') );
				}
				// update zebra stripes
				if (themes.even) { wo.zebra[0] += ' ' + themes.even; }
				if (themes.odd) { wo.zebra[1] += ' ' + themes.odd; }
				// add caption style
				$table.children('caption')
					.removeClass(oldtheme.caption || '')
					.addClass(themes.caption);
				// add table/footer class names
				$tfoot = $table
					// remove other selected themes
					.removeClass( (c.appliedTheme ? 'tablesorter-' + (c.appliedTheme || '') : '') + ' ' + (oldtheme.table || '') )
					.addClass('tablesorter-' + theme + ' ' + (themes.table || '')) // add theme widget class name
					.children('tfoot');
				c.appliedTheme = c.theme;

				if ($tfoot.length) {
					$tfoot
						// if oldtheme.footerRow or oldtheme.footerCells are undefined, all class names are removed
						.children('tr').removeClass(oldtheme.footerRow || '').addClass(themes.footerRow)
						.children('th, td').removeClass(oldtheme.footerCells || '').addClass(themes.footerCells);
				}
				// update header classes
				$headers
					.removeClass( (hasOldTheme ? [ oldtheme.header, oldtheme.hover, oldremove ].join(' ') : '') || '' )
					.addClass(themes.header)
					.not('.sorter-false')
					.unbind('mouseenter.tsuitheme mouseleave.tsuitheme')
					.bind('mouseenter.tsuitheme mouseleave.tsuitheme', function(event) {
						// toggleClass with switch added in jQuery 1.3
						$(this)[ event.type === 'mouseenter' ? 'addClass' : 'removeClass' ](themes.hover || '');
					});

				$headers.each(function() {
					var $this = $(this);
					if (!$this.find('.' + ts.css.wrapper).length) {
						// Firefox needs this inner div to position the icon & resizer correctly
						$this.wrapInner('<div class="' + ts.css.wrapper + '" style="position:relative;height:100%;width:100%"></div>');
					}
				});
				if (c.cssIcon) {
					// if c.cssIcon is '', then no <i> is added to the header
					$headers
						.find('.' + ts.css.icon)
						.removeClass(hasOldTheme ? [ oldtheme.icons, oldIconRmv ].join(' ') : '')
						.addClass(themes.icons || '');
				}
				// filter widget initializes after uitheme
				if (ts.hasWidget( c.table, 'filter' )) {
					tmp = function() {
						$table.children('thead').children('.' + ts.css.filterRow)
							.removeClass(hasOldTheme ? oldtheme.filterRow || '' : '')
							.addClass(themes.filterRow || '');
					};
					if (wo.filter_initialized) {
						tmp();
					} else {
						$table.one('filterInit', function() {
							tmp();
						});
					}
				}
			}
			for (i = 0; i < c.columns; i++) {
				$header = c.$headers
					.add($(c.namespace + '_extra_headers'))
					.not('.sorter-false')
					.filter('[data-column="' + i + '"]');
				$icon = (ts.css.icon) ? $header.find('.' + ts.css.icon) : $();
				$h = $headers.not('.sorter-false').filter('[data-column="' + i + '"]:last');
				if ($h.length) {
					$header.removeClass(remove);
					$icon.removeClass(iconRmv);
					if ($h[0].sortDisabled) {
						// no sort arrows for disabled columns!
						$icon.removeClass(themes.icons || '');
					} else {
						hdr = themes.sortNone;
						icon = themes.iconSortNone;
						if ($h.hasClass(ts.css.sortAsc)) {
							hdr = [ themes.sortAsc, themes.active ].join(' ');
							icon = themes.iconSortAsc;
						} else if ($h.hasClass(ts.css.sortDesc)) {
							hdr = [ themes.sortDesc, themes.active ].join(' ');
							icon = themes.iconSortDesc;
						}
						$header.addClass(hdr);
						$icon.addClass(icon || '');
					}
				}
			}
			if (debug) {
				console.log('uitheme >> Applied ' + theme + ' theme' + ts.benchmark(time));
			}
		},
		remove: function(table, c, wo, refreshing) {
			if (!wo.uitheme_applied) { return; }
			var $table = c.$table,
				theme = c.appliedTheme || 'jui',
				themes = ts.themes[ theme ] || ts.themes.jui,
				$headers = $table.children('thead').children(),
				remove = themes.sortNone + ' ' + themes.sortDesc + ' ' + themes.sortAsc,
				iconRmv = themes.iconSortNone + ' ' + themes.iconSortDesc + ' ' + themes.iconSortAsc;
			$table.removeClass('tablesorter-' + theme + ' ' + themes.table);
			wo.uitheme_applied = false;
			if (refreshing) { return; }
			$table.find(ts.css.header).removeClass(themes.header);
			$headers
				.unbind('mouseenter.tsuitheme mouseleave.tsuitheme') // remove hover
				.removeClass(themes.hover + ' ' + remove + ' ' + themes.active)
				.filter('.' + ts.css.filterRow)
				.removeClass(themes.filterRow);
			$headers.find('.' + ts.css.icon).removeClass(themes.icons + ' ' + iconRmv);
		}
	});

})(jQuery);

/*! Widget: columns - updated 5/24/2017 (v2.28.11) */
;(function ($) {
	'use strict';
	var ts = $.tablesorter || {};

	ts.addWidget({
		id: 'columns',
		priority: 65,
		options : {
			columns : [ 'primary', 'secondary', 'tertiary' ]
		},
		format: function(table, c, wo) {
			var $tbody, tbodyIndex, $rows, rows, $row, $cells, remove, indx,
			$table = c.$table,
			$tbodies = c.$tbodies,
			sortList = c.sortList,
			len = sortList.length,
			// removed c.widgetColumns support
			css = wo && wo.columns || [ 'primary', 'secondary', 'tertiary' ],
			last = css.length - 1;
			remove = css.join(' ');
			// check if there is a sort (on initialization there may not be one)
			for (tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ) {
				$tbody = ts.processTbody(table, $tbodies.eq(tbodyIndex), true); // detach tbody
				$rows = $tbody.children('tr');
				// loop through the visible rows
				$rows.each(function() {
					$row = $(this);
					if (this.style.display !== 'none') {
						// remove all columns class names
						$cells = $row.children().removeClass(remove);
						// add appropriate column class names
						if (sortList && sortList[0]) {
							// primary sort column class
							$cells.eq(sortList[0][0]).addClass(css[0]);
							if (len > 1) {
								for (indx = 1; indx < len; indx++) {
									// secondary, tertiary, etc sort column classes
									$cells.eq(sortList[indx][0]).addClass( css[indx] || css[last] );
								}
							}
						}
					}
				});
				ts.processTbody(table, $tbody, false);
			}
			// add classes to thead and tfoot
			rows = wo.columns_thead !== false ? [ 'thead tr' ] : [];
			if (wo.columns_tfoot !== false) {
				rows.push('tfoot tr');
			}
			if (rows.length) {
				$rows = $table.find( rows.join(',') ).children().removeClass(remove);
				if (len) {
					for (indx = 0; indx < len; indx++) {
						// add primary. secondary, tertiary, etc sort column classes
						$rows.filter('[data-column="' + sortList[indx][0] + '"]').addClass(css[indx] || css[last]);
					}
				}
			}
		},
		remove: function(table, c, wo) {
			var tbodyIndex, $tbody,
				$tbodies = c.$tbodies,
				remove = (wo.columns || [ 'primary', 'secondary', 'tertiary' ]).join(' ');
			c.$headers.removeClass(remove);
			c.$table.children('tfoot').children('tr').children('th, td').removeClass(remove);
			for (tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ) {
				$tbody = ts.processTbody(table, $tbodies.eq(tbodyIndex), true); // remove tbody
				$tbody.children('tr').each(function() {
					$(this).children().removeClass(remove);
				});
				ts.processTbody(table, $tbody, false); // restore tbody
			}
		}
	});

})(jQuery);

/*! Widget: filter - updated 2018-03-18 (v2.30.0) *//*
 * Requires tablesorter v2.8+ and jQuery 1.7+
 * by Rob Garrison
 */
;( function ( $ ) {
	'use strict';
	var tsf, tsfRegex,
		ts = $.tablesorter || {},
		tscss = ts.css,
		tskeyCodes = ts.keyCodes;

	$.extend( tscss, {
		filterRow      : 'tablesorter-filter-row',
		filter         : 'tablesorter-filter',
		filterDisabled : 'disabled',
		filterRowHide  : 'hideme'
	});

	$.extend( tskeyCodes, {
		backSpace : 8,
		escape : 27,
		space : 32,
		left : 37,
		down : 40
	});

	ts.addWidget({
		id: 'filter',
		priority: 50,
		options : {
			filter_cellFilter    : '',    // css class name added to the filter cell ( string or array )
			filter_childRows     : false, // if true, filter includes child row content in the search
			filter_childByColumn : false, // ( filter_childRows must be true ) if true = search child rows by column; false = search all child row text grouped
			filter_childWithSibs : true,  // if true, include matching child row siblings
			filter_columnAnyMatch: true,  // if true, allows using '#:{query}' in AnyMatch searches ( column:query )
			filter_columnFilters : true,  // if true, a filter will be added to the top of each table column
			filter_cssFilter     : '',    // css class name added to the filter row & each input in the row ( tablesorter-filter is ALWAYS added )
			filter_defaultAttrib : 'data-value', // data attribute in the header cell that contains the default filter value
			filter_defaultFilter : {},    // add a default column filter type '~{query}' to make fuzzy searches default; '{q1} AND {q2}' to make all searches use a logical AND.
			filter_excludeFilter : {},    // filters to exclude, per column
			filter_external      : '',    // jQuery selector string ( or jQuery object ) of external filters
			filter_filteredRow   : 'filtered', // class added to filtered rows; define in css with "display:none" to hide the filtered-out rows
			filter_filterLabel   : 'Filter "{{label}}" column by...', // Aria-label added to filter input/select; see #1495
			filter_formatter     : null,  // add custom filter elements to the filter row
			filter_functions     : null,  // add custom filter functions using this option
			filter_hideEmpty     : true,  // hide filter row when table is empty
			filter_hideFilters   : false, // collapse filter row when mouse leaves the area
			filter_ignoreCase    : true,  // if true, make all searches case-insensitive
			filter_liveSearch    : true,  // if true, search column content while the user types ( with a delay )
			filter_matchType     : { 'input': 'exact', 'select': 'exact' }, // global query settings ('exact' or 'match'); overridden by "filter-match" or "filter-exact" class
			filter_onlyAvail     : 'filter-onlyAvail', // a header with a select dropdown & this class name will only show available ( visible ) options within the drop down
			filter_placeholder   : { search : '', select : '' }, // default placeholder text ( overridden by any header 'data-placeholder' setting )
			filter_reset         : null,  // jQuery selector string of an element used to reset the filters
			filter_resetOnEsc    : true,  // Reset filter input when the user presses escape - normalized across browsers
			filter_saveFilters   : false, // Use the $.tablesorter.storage utility to save the most recent filters
			filter_searchDelay   : 300,   // typing delay in milliseconds before starting a search
			filter_searchFiltered: true,  // allow searching through already filtered rows in special circumstances; will speed up searching in large tables if true
			filter_selectSource  : null,  // include a function to return an array of values to be added to the column filter select
			filter_selectSourceSeparator : '|', // filter_selectSource array text left of the separator is added to the option value, right into the option text
			filter_serversideFiltering : false, // if true, must perform server-side filtering b/c client-side filtering is disabled, but the ui and events will still be used.
			filter_startsWith    : false, // if true, filter start from the beginning of the cell contents
			filter_useParsedData : false  // filter all data using parsed content
		},
		format: function( table, c, wo ) {
			if ( !c.$table.hasClass( 'hasFilters' ) ) {
				tsf.init( table, c, wo );
			}
		},
		remove: function( table, c, wo, refreshing ) {
			var tbodyIndex, $tbody,
				$table = c.$table,
				$tbodies = c.$tbodies,
				events = (
					'addRows updateCell update updateRows updateComplete appendCache filterReset ' +
					'filterAndSortReset filterFomatterUpdate filterEnd search stickyHeadersInit '
				).split( ' ' ).join( c.namespace + 'filter ' );
			$table
				.removeClass( 'hasFilters' )
				// add filter namespace to all BUT search
				.unbind( events.replace( ts.regex.spaces, ' ' ) )
				// remove the filter row even if refreshing, because the column might have been moved
				.find( '.' + tscss.filterRow ).remove();
			wo.filter_initialized = false;
			if ( refreshing ) { return; }
			for ( tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ) {
				$tbody = ts.processTbody( table, $tbodies.eq( tbodyIndex ), true ); // remove tbody
				$tbody.children().removeClass( wo.filter_filteredRow ).show();
				ts.processTbody( table, $tbody, false ); // restore tbody
			}
			if ( wo.filter_reset ) {
				$( document ).undelegate( wo.filter_reset, 'click' + c.namespace + 'filter' );
			}
		}
	});

	tsf = ts.filter = {

		// regex used in filter 'check' functions - not for general use and not documented
		regex: {
			regex     : /^\/((?:\\\/|[^\/])+)\/([migyu]{0,5})?$/, // regex to test for regex
			child     : /tablesorter-childRow/, // child row class name; this gets updated in the script
			filtered  : /filtered/, // filtered (hidden) row class name; updated in the script
			type      : /undefined|number/, // check type
			exact     : /(^[\"\'=]+)|([\"\'=]+$)/g, // exact match (allow '==')
			operators : /[<>=]/g, // replace operators
			query     : '(q|query)', // replace filter queries
			wild01    : /\?/g, // wild card match 0 or 1
			wild0More : /\*/g, // wild care match 0 or more
			quote     : /\"/g,
			isNeg1    : /(>=?\s*-\d)/,
			isNeg2    : /(<=?\s*\d)/
		},
		// function( c, data ) { }
		// c = table.config
		// data.$row = jQuery object of the row currently being processed
		// data.$cells = jQuery object of all cells within the current row
		// data.filters = array of filters for all columns ( some may be undefined )
		// data.filter = filter for the current column
		// data.iFilter = same as data.filter, except lowercase ( if wo.filter_ignoreCase is true )
		// data.exact = table cell text ( or parsed data if column parser enabled; may be a number & not a string )
		// data.iExact = same as data.exact, except lowercase ( if wo.filter_ignoreCase is true; may be a number & not a string )
		// data.cache = table cell text from cache, so it has been parsed ( & in all lower case if c.ignoreCase is true )
		// data.cacheArray = An array of parsed content from each table cell in the row being processed
		// data.index = column index; table = table element ( DOM )
		// data.parsed = array ( by column ) of boolean values ( from filter_useParsedData or 'filter-parsed' class )
		types: {
			or : function( c, data, vars ) {
				// look for "|", but not if it is inside of a regular expression
				if ( ( tsfRegex.orTest.test( data.iFilter ) || tsfRegex.orSplit.test( data.filter ) ) &&
					// this test for regex has potential to slow down the overall search
					!tsfRegex.regex.test( data.filter ) ) {
					var indx, filterMatched, query, regex,
						// duplicate data but split filter
						data2 = $.extend( {}, data ),
						filter = data.filter.split( tsfRegex.orSplit ),
						iFilter = data.iFilter.split( tsfRegex.orSplit ),
						len = filter.length;
					for ( indx = 0; indx < len; indx++ ) {
						data2.nestedFilters = true;
						data2.filter = '' + ( tsf.parseFilter( c, filter[ indx ], data ) || '' );
						data2.iFilter = '' + ( tsf.parseFilter( c, iFilter[ indx ], data ) || '' );
						query = '(' + ( tsf.parseFilter( c, data2.filter, data ) || '' ) + ')';
						try {
							// use try/catch, because query may not be a valid regex if "|" is contained within a partial regex search,
							// e.g "/(Alex|Aar" -> Uncaught SyntaxError: Invalid regular expression: /(/(Alex)/: Unterminated group
							regex = new RegExp( data.isMatch ? query : '^' + query + '$', c.widgetOptions.filter_ignoreCase ? 'i' : '' );
							// filterMatched = data2.filter === '' && indx > 0 ? true
							// look for an exact match with the 'or' unless the 'filter-match' class is found
							filterMatched = regex.test( data2.exact ) || tsf.processTypes( c, data2, vars );
							if ( filterMatched ) {
								return filterMatched;
							}
						} catch ( error ) {
							return null;
						}
					}
					// may be null from processing types
					return filterMatched || false;
				}
				return null;
			},
			// Look for an AND or && operator ( logical and )
			and : function( c, data, vars ) {
				if ( tsfRegex.andTest.test( data.filter ) ) {
					var indx, filterMatched, result, query, regex,
						// duplicate data but split filter
						data2 = $.extend( {}, data ),
						filter = data.filter.split( tsfRegex.andSplit ),
						iFilter = data.iFilter.split( tsfRegex.andSplit ),
						len = filter.length;
					for ( indx = 0; indx < len; indx++ ) {
						data2.nestedFilters = true;
						data2.filter = '' + ( tsf.parseFilter( c, filter[ indx ], data ) || '' );
						data2.iFilter = '' + ( tsf.parseFilter( c, iFilter[ indx ], data ) || '' );
						query = ( '(' + ( tsf.parseFilter( c, data2.filter, data ) || '' ) + ')' )
							// replace wild cards since /(a*)/i will match anything
							.replace( tsfRegex.wild01, '\\S{1}' ).replace( tsfRegex.wild0More, '\\S*' );
						try {
							// use try/catch just in case RegExp is invalid
							regex = new RegExp( data.isMatch ? query : '^' + query + '$', c.widgetOptions.filter_ignoreCase ? 'i' : '' );
							// look for an exact match with the 'and' unless the 'filter-match' class is found
							result = ( regex.test( data2.exact ) || tsf.processTypes( c, data2, vars ) );
							if ( indx === 0 ) {
								filterMatched = result;
							} else {
								filterMatched = filterMatched && result;
							}
						} catch ( error ) {
							return null;
						}
					}
					// may be null from processing types
					return filterMatched || false;
				}
				return null;
			},
			// Look for regex
			regex: function( c, data ) {
				if ( tsfRegex.regex.test( data.filter ) ) {
					var matches,
						// cache regex per column for optimal speed
						regex = data.filter_regexCache[ data.index ] || tsfRegex.regex.exec( data.filter ),
						isRegex = regex instanceof RegExp;
					try {
						if ( !isRegex ) {
							// force case insensitive search if ignoreCase option set?
							// if ( c.ignoreCase && !regex[2] ) { regex[2] = 'i'; }
							data.filter_regexCache[ data.index ] = regex = new RegExp( regex[1], regex[2] );
						}
						matches = regex.test( data.exact );
					} catch ( error ) {
						matches = false;
					}
					return matches;
				}
				return null;
			},
			// Look for operators >, >=, < or <=
			operators: function( c, data ) {
				// ignore empty strings... because '' < 10 is true
				if ( tsfRegex.operTest.test( data.iFilter ) && data.iExact !== '' ) {
					var cachedValue, result, txt,
						table = c.table,
						parsed = data.parsed[ data.index ],
						query = ts.formatFloat( data.iFilter.replace( tsfRegex.operators, '' ), table ),
						parser = c.parsers[ data.index ] || {},
						savedSearch = query;
					// parse filter value in case we're comparing numbers ( dates )
					if ( parsed || parser.type === 'numeric' ) {
						txt = $.trim( '' + data.iFilter.replace( tsfRegex.operators, '' ) );
						result = tsf.parseFilter( c, txt, data, true );
						query = ( typeof result === 'number' && result !== '' && !isNaN( result ) ) ? result : query;
					}
					// iExact may be numeric - see issue #149;
					// check if cached is defined, because sometimes j goes out of range? ( numeric columns )
					if ( ( parsed || parser.type === 'numeric' ) && !isNaN( query ) &&
						typeof data.cache !== 'undefined' ) {
						cachedValue = data.cache;
					} else {
						txt = isNaN( data.iExact ) ? data.iExact.replace( ts.regex.nondigit, '' ) : data.iExact;
						cachedValue = ts.formatFloat( txt, table );
					}
					if ( tsfRegex.gtTest.test( data.iFilter ) ) {
						result = tsfRegex.gteTest.test( data.iFilter ) ? cachedValue >= query : cachedValue > query;
					} else if ( tsfRegex.ltTest.test( data.iFilter ) ) {
						result = tsfRegex.lteTest.test( data.iFilter ) ? cachedValue <= query : cachedValue < query;
					}
					// keep showing all rows if nothing follows the operator
					if ( !result && savedSearch === '' ) {
						result = true;
					}
					return result;
				}
				return null;
			},
			// Look for a not match
			notMatch: function( c, data ) {
				if ( tsfRegex.notTest.test( data.iFilter ) ) {
					var indx,
						txt = data.iFilter.replace( '!', '' ),
						filter = tsf.parseFilter( c, txt, data ) || '';
					if ( tsfRegex.exact.test( filter ) ) {
						// look for exact not matches - see #628
						filter = filter.replace( tsfRegex.exact, '' );
						return filter === '' ? true : $.trim( filter ) !== data.iExact;
					} else {
						indx = data.iExact.search( $.trim( filter ) );
						return filter === '' ? true :
							// return true if not found
							data.anyMatch ? indx < 0 :
							// return false if found
							!( c.widgetOptions.filter_startsWith ? indx === 0 : indx >= 0 );
					}
				}
				return null;
			},
			// Look for quotes or equals to get an exact match; ignore type since iExact could be numeric
			exact: function( c, data ) {
				/*jshint eqeqeq:false */
				if ( tsfRegex.exact.test( data.iFilter ) ) {
					var txt = data.iFilter.replace( tsfRegex.exact, '' ),
						filter = tsf.parseFilter( c, txt, data ) || '';
					// eslint-disable-next-line eqeqeq
					return data.anyMatch ? $.inArray( filter, data.rowArray ) >= 0 : filter == data.iExact;
				}
				return null;
			},
			// Look for a range ( using ' to ' or ' - ' ) - see issue #166; thanks matzhu!
			range : function( c, data ) {
				if ( tsfRegex.toTest.test( data.iFilter ) ) {
					var result, tmp, range1, range2,
						table = c.table,
						index = data.index,
						parsed = data.parsed[index],
						// make sure the dash is for a range and not indicating a negative number
						query = data.iFilter.split( tsfRegex.toSplit );

					tmp = query[0].replace( ts.regex.nondigit, '' ) || '';
					range1 = ts.formatFloat( tsf.parseFilter( c, tmp, data ), table );
					tmp = query[1].replace( ts.regex.nondigit, '' ) || '';
					range2 = ts.formatFloat( tsf.parseFilter( c, tmp, data ), table );
					// parse filter value in case we're comparing numbers ( dates )
					if ( parsed || c.parsers[ index ].type === 'numeric' ) {
						result = c.parsers[ index ].format( '' + query[0], table, c.$headers.eq( index ), index );
						range1 = ( result !== '' && !isNaN( result ) ) ? result : range1;
						result = c.parsers[ index ].format( '' + query[1], table, c.$headers.eq( index ), index );
						range2 = ( result !== '' && !isNaN( result ) ) ? result : range2;
					}
					if ( ( parsed || c.parsers[ index ].type === 'numeric' ) && !isNaN( range1 ) && !isNaN( range2 ) ) {
						result = data.cache;
					} else {
						tmp = isNaN( data.iExact ) ? data.iExact.replace( ts.regex.nondigit, '' ) : data.iExact;
						result = ts.formatFloat( tmp, table );
					}
					if ( range1 > range2 ) {
						tmp = range1; range1 = range2; range2 = tmp; // swap
					}
					return ( result >= range1 && result <= range2 ) || ( range1 === '' || range2 === '' );
				}
				return null;
			},
			// Look for wild card: ? = single, * = multiple, or | = logical OR
			wild : function( c, data ) {
				if ( tsfRegex.wildOrTest.test( data.iFilter ) ) {
					var query = '' + ( tsf.parseFilter( c, data.iFilter, data ) || '' );
					// look for an exact match with the 'or' unless the 'filter-match' class is found
					if ( !tsfRegex.wildTest.test( query ) && data.nestedFilters ) {
						query = data.isMatch ? query : '^(' + query + ')$';
					}
					// parsing the filter may not work properly when using wildcards =/
					try {
						return new RegExp(
							query.replace( tsfRegex.wild01, '\\S{1}' ).replace( tsfRegex.wild0More, '\\S*' ),
							c.widgetOptions.filter_ignoreCase ? 'i' : ''
						)
						.test( data.exact );
					} catch ( error ) {
						return null;
					}
				}
				return null;
			},
			// fuzzy text search; modified from https://github.com/mattyork/fuzzy ( MIT license )
			fuzzy: function( c, data ) {
				if ( tsfRegex.fuzzyTest.test( data.iFilter ) ) {
					var indx,
						patternIndx = 0,
						len = data.iExact.length,
						txt = data.iFilter.slice( 1 ),
						pattern = tsf.parseFilter( c, txt, data ) || '';
					for ( indx = 0; indx < len; indx++ ) {
						if ( data.iExact[ indx ] === pattern[ patternIndx ] ) {
							patternIndx += 1;
						}
					}
					return patternIndx === pattern.length;
				}
				return null;
			}
		},
		init: function( table ) {
			// filter language options
			ts.language = $.extend( true, {}, {
				to  : 'to',
				or  : 'or',
				and : 'and'
			}, ts.language );

			var options, string, txt, $header, column, val, fxn, noSelect,
				c = table.config,
				wo = c.widgetOptions,
				processStr = function(prefix, str, suffix) {
					str = str.trim();
					// don't include prefix/suffix if str is empty
					return str === '' ? '' : (prefix || '') + str + (suffix || '');
				};
			c.$table.addClass( 'hasFilters' );
			c.lastSearch = [];

			// define timers so using clearTimeout won't cause an undefined error
			wo.filter_searchTimer = null;
			wo.filter_initTimer = null;
			wo.filter_formatterCount = 0;
			wo.filter_formatterInit = [];
			wo.filter_anyColumnSelector = '[data-column="all"],[data-column="any"]';
			wo.filter_multipleColumnSelector = '[data-column*="-"],[data-column*=","]';

			val = '\\{' + tsfRegex.query + '\\}';
			$.extend( tsfRegex, {
				child : new RegExp( c.cssChildRow ),
				filtered : new RegExp( wo.filter_filteredRow ),
				alreadyFiltered : new RegExp( '(\\s+(-' + processStr('|', ts.language.or) + processStr('|', ts.language.to) + ')\\s+)', 'i' ),
				toTest : new RegExp( '\\s+(-' + processStr('|', ts.language.to) + ')\\s+', 'i' ),
				toSplit : new RegExp( '(?:\\s+(?:-' + processStr('|', ts.language.to) + ')\\s+)', 'gi' ),
				andTest : new RegExp( '\\s+(' + processStr('', ts.language.and, '|') + '&&)\\s+', 'i' ),
				andSplit : new RegExp( '(?:\\s+(?:' + processStr('', ts.language.and, '|') + '&&)\\s+)', 'gi' ),
				orTest : new RegExp( '(\\|' + processStr('|\\s+', ts.language.or, '\\s+') + ')', 'i' ),
				orSplit : new RegExp( '(?:\\|' + processStr('|\\s+(?:', ts.language.or, ')\\s+') + ')', 'gi' ),
				iQuery : new RegExp( val, 'i' ),
				igQuery : new RegExp( val, 'ig' ),
				operTest : /^[<>]=?/,
				gtTest  : />/,
				gteTest : />=/,
				ltTest  : /</,
				lteTest : /<=/,
				notTest : /^\!/,
				wildOrTest : /[\?\*\|]/,
				wildTest : /\?\*/,
				fuzzyTest : /^~/,
				exactTest : /[=\"\|!]/
			});

			// don't build filter row if columnFilters is false or all columns are set to 'filter-false'
			// see issue #156
			val = c.$headers.filter( '.filter-false, .parser-false' ).length;
			if ( wo.filter_columnFilters !== false && val !== c.$headers.length ) {
				// build filter row
				tsf.buildRow( table, c, wo );
			}

			txt = 'addRows updateCell update updateRows updateComplete appendCache filterReset ' +
				'filterAndSortReset filterResetSaved filterEnd search '.split( ' ' ).join( c.namespace + 'filter ' );
			c.$table.bind( txt, function( event, filter ) {
				val = wo.filter_hideEmpty &&
					$.isEmptyObject( c.cache ) &&
					!( c.delayInit && event.type === 'appendCache' );
				// hide filter row using the 'filtered' class name
				c.$table.find( '.' + tscss.filterRow ).toggleClass( wo.filter_filteredRow, val ); // fixes #450
				if ( !/(search|filter)/.test( event.type ) ) {
					event.stopPropagation();
					tsf.buildDefault( table, true );
				}
				// Add filterAndSortReset - see #1361
				if ( event.type === 'filterReset' || event.type === 'filterAndSortReset' ) {
					c.$table.find( '.' + tscss.filter ).add( wo.filter_$externalFilters ).val( '' );
					if ( event.type === 'filterAndSortReset' ) {
						ts.sortReset( this.config, function() {
							tsf.searching( table, [] );
						});
					} else {
						tsf.searching( table, [] );
					}
				} else if ( event.type === 'filterResetSaved' ) {
					ts.storage( table, 'tablesorter-filters', '' );
				} else if ( event.type === 'filterEnd' ) {
					tsf.buildDefault( table, true );
				} else {
					// send false argument to force a new search; otherwise if the filter hasn't changed,
					// it will return
					filter = event.type === 'search' ? filter :
						event.type === 'updateComplete' ? c.$table.data( 'lastSearch' ) : '';
					if ( /(update|add)/.test( event.type ) && event.type !== 'updateComplete' ) {
						// force a new search since content has changed
						c.lastCombinedFilter = null;
						c.lastSearch = [];
						// update filterFormatters after update (& small delay) - Fixes #1237
						setTimeout(function() {
							c.$table.triggerHandler( 'filterFomatterUpdate' );
						}, 100);
					}
					// pass true ( skipFirst ) to prevent the tablesorter.setFilters function from skipping the first
					// input ensures all inputs are updated when a search is triggered on the table
					// $( 'table' ).trigger( 'search', [...] );
					tsf.searching( table, filter, true );
				}
				return false;
			});

			// reset button/link
			if ( wo.filter_reset ) {
				if ( wo.filter_reset instanceof $ ) {
					// reset contains a jQuery object, bind to it
					wo.filter_reset.click( function() {
						c.$table.triggerHandler( 'filterReset' );
					});
				} else if ( $( wo.filter_reset ).length ) {
					// reset is a jQuery selector, use event delegation
					$( document )
						.undelegate( wo.filter_reset, 'click' + c.namespace + 'filter' )
						.delegate( wo.filter_reset, 'click' + c.namespace + 'filter', function() {
							// trigger a reset event, so other functions ( filter_formatter ) know when to reset
							c.$table.triggerHandler( 'filterReset' );
						});
				}
			}
			if ( wo.filter_functions ) {
				for ( column = 0; column < c.columns; column++ ) {
					fxn = ts.getColumnData( table, wo.filter_functions, column );
					if ( fxn ) {
						// remove 'filter-select' from header otherwise the options added here are replaced with
						// all options
						$header = c.$headerIndexed[ column ].removeClass( 'filter-select' );
						// don't build select if 'filter-false' or 'parser-false' set
						noSelect = !( $header.hasClass( 'filter-false' ) || $header.hasClass( 'parser-false' ) );
						options = '';
						if ( fxn === true && noSelect ) {
							tsf.buildSelect( table, column );
						} else if ( typeof fxn === 'object' && noSelect ) {
							// add custom drop down list
							for ( string in fxn ) {
								if ( typeof string === 'string' ) {
									options += options === '' ?
										'<option value="">' +
											( $header.data( 'placeholder' ) ||
												$header.attr( 'data-placeholder' ) ||
												wo.filter_placeholder.select ||
												''
											) +
										'</option>' : '';
									val = string;
									txt = string;
									if ( string.indexOf( wo.filter_selectSourceSeparator ) >= 0 ) {
										val = string.split( wo.filter_selectSourceSeparator );
										txt = val[1];
										val = val[0];
									}
									options += '<option ' +
										( txt === val ? '' : 'data-function-name="' + string + '" ' ) +
										'value="' + val + '">' + txt + '</option>';
								}
							}
							c.$table
								.find( 'thead' )
								.find( 'select.' + tscss.filter + '[data-column="' + column + '"]' )
								.append( options );
							txt = wo.filter_selectSource;
							fxn = typeof txt === 'function' ? true : ts.getColumnData( table, txt, column );
							if ( fxn ) {
								// updating so the extra options are appended
								tsf.buildSelect( c.table, column, '', true, $header.hasClass( wo.filter_onlyAvail ) );
							}
						}
					}
				}
			}
			// not really updating, but if the column has both the 'filter-select' class &
			// filter_functions set to true, it would append the same options twice.
			tsf.buildDefault( table, true );

			tsf.bindSearch( table, c.$table.find( '.' + tscss.filter ), true );
			if ( wo.filter_external ) {
				tsf.bindSearch( table, wo.filter_external );
			}

			if ( wo.filter_hideFilters ) {
				tsf.hideFilters( c );
			}

			// show processing icon
			if ( c.showProcessing ) {
				txt = 'filterStart filterEnd '.split( ' ' ).join( c.namespace + 'filter-sp ' );
				c.$table
					.unbind( txt.replace( ts.regex.spaces, ' ' ) )
					.bind( txt, function( event, columns ) {
					// only add processing to certain columns to all columns
					$header = ( columns ) ?
						c.$table
							.find( '.' + tscss.header )
							.filter( '[data-column]' )
							.filter( function() {
								return columns[ $( this ).data( 'column' ) ] !== '';
							}) : '';
					ts.isProcessing( table, event.type === 'filterStart', columns ? $header : '' );
				});
			}

			// set filtered rows count ( intially unfiltered )
			c.filteredRows = c.totalRows;

			// add default values
			txt = 'tablesorter-initialized pagerBeforeInitialized '.split( ' ' ).join( c.namespace + 'filter ' );
			c.$table
			.unbind( txt.replace( ts.regex.spaces, ' ' ) )
			.bind( txt, function() {
				tsf.completeInit( this );
			});
			// if filter widget is added after pager has initialized; then set filter init flag
			if ( c.pager && c.pager.initialized && !wo.filter_initialized ) {
				c.$table.triggerHandler( 'filterFomatterUpdate' );
				setTimeout( function() {
					tsf.filterInitComplete( c );
				}, 100 );
			} else if ( !wo.filter_initialized ) {
				tsf.completeInit( table );
			}
		},
		completeInit: function( table ) {
			// redefine 'c' & 'wo' so they update properly inside this callback
			var c = table.config,
				wo = c.widgetOptions,
				filters = tsf.setDefaults( table, c, wo ) || [];
			if ( filters.length ) {
				// prevent delayInit from triggering a cache build if filters are empty
				if ( !( c.delayInit && filters.join( '' ) === '' ) ) {
					ts.setFilters( table, filters, true );
				}
			}
			c.$table.triggerHandler( 'filterFomatterUpdate' );
			// trigger init after setTimeout to prevent multiple filterStart/End/Init triggers
			setTimeout( function() {
				if ( !wo.filter_initialized ) {
					tsf.filterInitComplete( c );
				}
			}, 100 );
		},

		// $cell parameter, but not the config, is passed to the filter_formatters,
		// so we have to work with it instead
		formatterUpdated: function( $cell, column ) {
			// prevent error if $cell is undefined - see #1056
			var $table = $cell && $cell.closest( 'table' );
			var config = $table.length && $table[0].config,
				wo = config && config.widgetOptions;
			if ( wo && !wo.filter_initialized ) {
				// add updates by column since this function
				// may be called numerous times before initialization
				wo.filter_formatterInit[ column ] = 1;
			}
		},
		filterInitComplete: function( c ) {
			var indx, len,
				wo = c.widgetOptions,
				count = 0,
				completed = function() {
					wo.filter_initialized = true;
					// update lastSearch - it gets cleared often
					c.lastSearch = c.$table.data( 'lastSearch' );
					c.$table.triggerHandler( 'filterInit', c );
					tsf.findRows( c.table, c.lastSearch || [] );
					if (ts.debug(c, 'filter')) {
						console.log('Filter >> Widget initialized');
					}
				};
			if ( $.isEmptyObject( wo.filter_formatter ) ) {
				completed();
			} else {
				len = wo.filter_formatterInit.length;
				for ( indx = 0; indx < len; indx++ ) {
					if ( wo.filter_formatterInit[ indx ] === 1 ) {
						count++;
					}
				}
				clearTimeout( wo.filter_initTimer );
				if ( !wo.filter_initialized && count === wo.filter_formatterCount ) {
					// filter widget initialized
					completed();
				} else if ( !wo.filter_initialized ) {
					// fall back in case a filter_formatter doesn't call
					// $.tablesorter.filter.formatterUpdated( $cell, column ), and the count is off
					wo.filter_initTimer = setTimeout( function() {
						completed();
					}, 500 );
				}
			}
		},
		// encode or decode filters for storage; see #1026
		processFilters: function( filters, encode ) {
			var indx,
				// fixes #1237; previously returning an encoded "filters" value
				result = [],
				mode = encode ? encodeURIComponent : decodeURIComponent,
				len = filters.length;
			for ( indx = 0; indx < len; indx++ ) {
				if ( filters[ indx ] ) {
					result[ indx ] = mode( filters[ indx ] );
				}
			}
			return result;
		},
		setDefaults: function( table, c, wo ) {
			var isArray, saved, indx, col, $filters,
				// get current ( default ) filters
				filters = ts.getFilters( table ) || [];
			if ( wo.filter_saveFilters && ts.storage ) {
				saved = ts.storage( table, 'tablesorter-filters' ) || [];
				isArray = $.isArray( saved );
				// make sure we're not just getting an empty array
				if ( !( isArray && saved.join( '' ) === '' || !isArray ) ) {
					filters = tsf.processFilters( saved );
				}
			}
			// if no filters saved, then check default settings
			if ( filters.join( '' ) === '' ) {
				// allow adding default setting to external filters
				$filters = c.$headers.add( wo.filter_$externalFilters )
					.filter( '[' + wo.filter_defaultAttrib + ']' );
				for ( indx = 0; indx <= c.columns; indx++ ) {
					// include data-column='all' external filters
					col = indx === c.columns ? 'all' : indx;
					filters[ indx ] = $filters
						.filter( '[data-column="' + col + '"]' )
						.attr( wo.filter_defaultAttrib ) || filters[indx] || '';
				}
			}
			c.$table.data( 'lastSearch', filters );
			return filters;
		},
		parseFilter: function( c, filter, data, parsed ) {
			return parsed || data.parsed[ data.index ] ?
				c.parsers[ data.index ].format( filter, c.table, [], data.index ) :
				filter;
		},
		buildRow: function( table, c, wo ) {
			var $filter, col, column, $header, makeSelect, disabled, name, ffxn, tmp,
				// c.columns defined in computeThIndexes()
				cellFilter = wo.filter_cellFilter,
				columns = c.columns,
				arry = $.isArray( cellFilter ),
				buildFilter = '<tr role="search" class="' + tscss.filterRow + ' ' + c.cssIgnoreRow + '">';
			for ( column = 0; column < columns; column++ ) {
				if ( c.$headerIndexed[ column ].length ) {
					// account for entire column set with colspan. See #1047
					tmp = c.$headerIndexed[ column ] && c.$headerIndexed[ column ][0].colSpan || 0;
					if ( tmp > 1 ) {
						buildFilter += '<td data-column="' + column + '-' + ( column + tmp - 1 ) + '" colspan="' + tmp + '"';
					} else {
						buildFilter += '<td data-column="' + column + '"';
					}
					if ( arry ) {
						buildFilter += ( cellFilter[ column ] ? ' class="' + cellFilter[ column ] + '"' : '' );
					} else {
						buildFilter += ( cellFilter !== '' ? ' class="' + cellFilter + '"' : '' );
					}
					buildFilter += '></td>';
				}
			}
			c.$filters = $( buildFilter += '</tr>' )
				.appendTo( c.$table.children( 'thead' ).eq( 0 ) )
				.children( 'td' );
			// build each filter input
			for ( column = 0; column < columns; column++ ) {
				disabled = false;
				// assuming last cell of a column is the main column
				$header = c.$headerIndexed[ column ];
				if ( $header && $header.length ) {
					// $filter = c.$filters.filter( '[data-column="' + column + '"]' );
					$filter = tsf.getColumnElm( c, c.$filters, column );
					ffxn = ts.getColumnData( table, wo.filter_functions, column );
					makeSelect = ( wo.filter_functions && ffxn && typeof ffxn !== 'function' ) ||
						$header.hasClass( 'filter-select' );
					// get data from jQuery data, metadata, headers option or header class name
					col = ts.getColumnData( table, c.headers, column );
					disabled = ts.getData( $header[0], col, 'filter' ) === 'false' ||
						ts.getData( $header[0], col, 'parser' ) === 'false';

					if ( makeSelect ) {
						buildFilter = $( '<select>' ).appendTo( $filter );
					} else {
						ffxn = ts.getColumnData( table, wo.filter_formatter, column );
						if ( ffxn ) {
							wo.filter_formatterCount++;
							buildFilter = ffxn( $filter, column );
							// no element returned, so lets go find it
							if ( buildFilter && buildFilter.length === 0 ) {
								buildFilter = $filter.children( 'input' );
							}
							// element not in DOM, so lets attach it
							if ( buildFilter && ( buildFilter.parent().length === 0 ||
								( buildFilter.parent().length && buildFilter.parent()[0] !== $filter[0] ) ) ) {
								$filter.append( buildFilter );
							}
						} else {
							buildFilter = $( '<input type="search">' ).appendTo( $filter );
						}
						if ( buildFilter ) {
							tmp = $header.data( 'placeholder' ) ||
								$header.attr( 'data-placeholder' ) ||
								wo.filter_placeholder.search || '';
							buildFilter.attr( 'placeholder', tmp );
						}
					}
					if ( buildFilter ) {
						// add filter class name
						name = ( $.isArray( wo.filter_cssFilter ) ?
							( typeof wo.filter_cssFilter[column] !== 'undefined' ? wo.filter_cssFilter[column] || '' : '' ) :
							wo.filter_cssFilter ) || '';
						// copy data-column from table cell (it will include colspan)
						buildFilter.addClass( tscss.filter + ' ' + name );
						name = wo.filter_filterLabel;
						tmp = name.match(/{{([^}]+?)}}/g);
						if (!tmp) {
							tmp = [ '{{label}}' ];
						}
						$.each(tmp, function(indx, attr) {
							var regex = new RegExp(attr, 'g'),
								data = $header.attr('data-' + attr.replace(/{{|}}/g, '')),
								text = typeof data === 'undefined' ? $header.text() : data;
							name = name.replace( regex, $.trim( text ) );
						});
						buildFilter.attr({
							'data-column': $filter.attr( 'data-column' ),
							'aria-label': name
						});
						if ( disabled ) {
							buildFilter.attr( 'placeholder', '' ).addClass( tscss.filterDisabled )[0].disabled = true;
						}
					}
				}
			}
		},
		bindSearch: function( table, $el, internal ) {
			table = $( table )[0];
			$el = $( $el ); // allow passing a selector string
			if ( !$el.length ) { return; }
			var tmp,
				c = table.config,
				wo = c.widgetOptions,
				namespace = c.namespace + 'filter',
				$ext = wo.filter_$externalFilters;
			if ( internal !== true ) {
				// save anyMatch element
				tmp = wo.filter_anyColumnSelector + ',' + wo.filter_multipleColumnSelector;
				wo.filter_$anyMatch = $el.filter( tmp );
				if ( $ext && $ext.length ) {
					wo.filter_$externalFilters = wo.filter_$externalFilters.add( $el );
				} else {
					wo.filter_$externalFilters = $el;
				}
				// update values ( external filters added after table initialization )
				ts.setFilters( table, c.$table.data( 'lastSearch' ) || [], internal === false );
			}
			// unbind events
			tmp = ( 'keypress keyup keydown search change input '.split( ' ' ).join( namespace + ' ' ) );
			$el
			// use data attribute instead of jQuery data since the head is cloned without including
			// the data/binding
			.attr( 'data-lastSearchTime', new Date().getTime() )
			.unbind( tmp.replace( ts.regex.spaces, ' ' ) )
			.bind( 'keydown' + namespace, function( event ) {
				if ( event.which === tskeyCodes.escape && !table.config.widgetOptions.filter_resetOnEsc ) {
					// prevent keypress event
					return false;
				}
			})
			.bind( 'keyup' + namespace, function( event ) {
				wo = table.config.widgetOptions; // make sure "wo" isn't cached
				var column = parseInt( $( this ).attr( 'data-column' ), 10 ),
					liveSearch = typeof wo.filter_liveSearch === 'boolean' ? wo.filter_liveSearch :
						ts.getColumnData( table, wo.filter_liveSearch, column );
				if ( typeof liveSearch === 'undefined' ) {
					liveSearch = wo.filter_liveSearch.fallback || false;
				}
				$( this ).attr( 'data-lastSearchTime', new Date().getTime() );
				// emulate what webkit does.... escape clears the filter
				if ( event.which === tskeyCodes.escape ) {
					// make sure to restore the last value on escape
					this.value = wo.filter_resetOnEsc ? '' : c.lastSearch[column];
					// don't return if the search value is empty ( all rows need to be revealed )
				} else if ( this.value !== '' && (
					// liveSearch can contain a min value length; ignore arrow and meta keys, but allow backspace
					( typeof liveSearch === 'number' && this.value.length < liveSearch ) ||
					// let return & backspace continue on, but ignore arrows & non-valid characters
					( event.which !== tskeyCodes.enter && event.which !== tskeyCodes.backSpace &&
						( event.which < tskeyCodes.space || ( event.which >= tskeyCodes.left && event.which <= tskeyCodes.down ) ) ) ) ) {
					return;
					// live search
				} else if ( liveSearch === false ) {
					if ( this.value !== '' && event.which !== tskeyCodes.enter ) {
						return;
					}
				}
				// change event = no delay; last true flag tells getFilters to skip newest timed input
				tsf.searching( table, true, true, column );
			})
			// include change for select - fixes #473
			.bind( 'search change keypress input blur '.split( ' ' ).join( namespace + ' ' ), function( event ) {
				// don't get cached data, in case data-column changes dynamically
				var column = parseInt( $( this ).attr( 'data-column' ), 10 ),
					eventType = event.type,
					liveSearch = typeof wo.filter_liveSearch === 'boolean' ?
						wo.filter_liveSearch :
						ts.getColumnData( table, wo.filter_liveSearch, column );
				if ( table.config.widgetOptions.filter_initialized &&
					// immediate search if user presses enter
					( event.which === tskeyCodes.enter ||
						// immediate search if a "search" or "blur" is triggered on the input
						( eventType === 'search' || eventType === 'blur' ) ||
						// change & input events must be ignored if liveSearch !== true
						( eventType === 'change' || eventType === 'input' ) &&
						// prevent search if liveSearch is a number
						( liveSearch === true || liveSearch !== true && event.target.nodeName !== 'INPUT' ) &&
						// don't allow 'change' or 'input' event to process if the input value
						// is the same - fixes #685
						this.value !== c.lastSearch[column]
					)
				) {
					event.preventDefault();
					// init search with no delay
					$( this ).attr( 'data-lastSearchTime', new Date().getTime() );
					tsf.searching( table, eventType !== 'keypress', true, column );
				}
			});
		},
		searching: function( table, filter, skipFirst, column ) {
			var liveSearch,
				wo = table.config.widgetOptions;
			if (typeof column === 'undefined') {
				// no delay
				liveSearch = false;
			} else {
				liveSearch = typeof wo.filter_liveSearch === 'boolean' ?
					wo.filter_liveSearch :
					// get column setting, or set to fallback value, or default to false
					ts.getColumnData( table, wo.filter_liveSearch, column );
				if ( typeof liveSearch === 'undefined' ) {
					liveSearch = wo.filter_liveSearch.fallback || false;
				}
			}
			clearTimeout( wo.filter_searchTimer );
			if ( typeof filter === 'undefined' || filter === true ) {
				// delay filtering
				wo.filter_searchTimer = setTimeout( function() {
					tsf.checkFilters( table, filter, skipFirst );
				}, liveSearch ? wo.filter_searchDelay : 10 );
			} else {
				// skip delay
				tsf.checkFilters( table, filter, skipFirst );
			}
		},
		equalFilters: function (c, filter1, filter2) {
			var indx,
				f1 = [],
				f2 = [],
				len = c.columns + 1; // add one to include anyMatch filter
			filter1 = $.isArray(filter1) ? filter1 : [];
			filter2 = $.isArray(filter2) ? filter2 : [];
			for (indx = 0; indx < len; indx++) {
				f1[indx] = filter1[indx] || '';
				f2[indx] = filter2[indx] || '';
			}
			return f1.join(',') === f2.join(',');
		},
		checkFilters: function( table, filter, skipFirst ) {
			var c = table.config,
				wo = c.widgetOptions,
				filterArray = $.isArray( filter ),
				filters = ( filterArray ) ? filter : ts.getFilters( table, true ),
				currentFilters = filters || []; // current filter values
			// prevent errors if delay init is set
			if ( $.isEmptyObject( c.cache ) ) {
				// update cache if delayInit set & pager has initialized ( after user initiates a search )
				if ( c.delayInit && ( !c.pager || c.pager && c.pager.initialized ) ) {
					ts.updateCache( c, function() {
						tsf.checkFilters( table, false, skipFirst );
					});
				}
				return;
			}
			// add filter array back into inputs
			if ( filterArray ) {
				ts.setFilters( table, filters, false, skipFirst !== true );
				if ( !wo.filter_initialized ) {
					c.lastSearch = [];
					c.lastCombinedFilter = '';
				}
			}
			if ( wo.filter_hideFilters ) {
				// show/hide filter row as needed
				c.$table
					.find( '.' + tscss.filterRow )
					.triggerHandler( tsf.hideFiltersCheck( c ) ? 'mouseleave' : 'mouseenter' );
			}
			// return if the last search is the same; but filter === false when updating the search
			// see example-widget-filter.html filter toggle buttons
			if ( tsf.equalFilters(c, c.lastSearch, currentFilters) && filter !== false ) {
				return;
			} else if ( filter === false ) {
				// force filter refresh
				c.lastCombinedFilter = '';
				c.lastSearch = [];
			}
			// define filter inside it is false
			filters = filters || [];
			// convert filters to strings - see #1070
			filters = Array.prototype.map ?
				filters.map( String ) :
				// for IE8 & older browsers - maybe not the best method
				filters.join( '\ufffd' ).split( '\ufffd' );

			if ( wo.filter_initialized ) {
				c.$table.triggerHandler( 'filterStart', [ filters ] );
			}
			if ( c.showProcessing ) {
				// give it time for the processing icon to kick in
				setTimeout( function() {
					tsf.findRows( table, filters, currentFilters );
					return false;
				}, 30 );
			} else {
				tsf.findRows( table, filters, currentFilters );
				return false;
			}
		},
		hideFiltersCheck: function( c ) {
			if (typeof c.widgetOptions.filter_hideFilters === 'function') {
				var val = c.widgetOptions.filter_hideFilters( c );
				if (typeof val === 'boolean') {
					return val;
				}
			}
			return ts.getFilters( c.$table ).join( '' ) === '';
		},
		hideFilters: function( c, $table ) {
			var timer;
			( $table || c.$table )
				.find( '.' + tscss.filterRow )
				.addClass( tscss.filterRowHide )
				.bind( 'mouseenter mouseleave', function( e ) {
					// save event object - http://bugs.jquery.com/ticket/12140
					var event = e,
						$row = $( this );
					clearTimeout( timer );
					timer = setTimeout( function() {
						if ( /enter|over/.test( event.type ) ) {
							$row.removeClass( tscss.filterRowHide );
						} else {
							// don't hide if input has focus
							// $( ':focus' ) needs jQuery 1.6+
							if ( $( document.activeElement ).closest( 'tr' )[0] !== $row[0] ) {
								// don't hide row if any filter has a value
								$row.toggleClass( tscss.filterRowHide, tsf.hideFiltersCheck( c ) );
							}
						}
					}, 200 );
				})
				.find( 'input, select' ).bind( 'focus blur', function( e ) {
					var event = e,
						$row = $( this ).closest( 'tr' );
					clearTimeout( timer );
					timer = setTimeout( function() {
						clearTimeout( timer );
						// don't hide row if any filter has a value
						$row.toggleClass( tscss.filterRowHide, tsf.hideFiltersCheck( c ) && event.type !== 'focus' );
					}, 200 );
				});
		},
		defaultFilter: function( filter, mask ) {
			if ( filter === '' ) { return filter; }
			var regex = tsfRegex.iQuery,
				maskLen = mask.match( tsfRegex.igQuery ).length,
				query = maskLen > 1 ? $.trim( filter ).split( /\s/ ) : [ $.trim( filter ) ],
				len = query.length - 1,
				indx = 0,
				val = mask;
			if ( len < 1 && maskLen > 1 ) {
				// only one 'word' in query but mask has >1 slots
				query[1] = query[0];
			}
			// replace all {query} with query words...
			// if query = 'Bob', then convert mask from '!{query}' to '!Bob'
			// if query = 'Bob Joe Frank', then convert mask '{q} OR {q}' to 'Bob OR Joe OR Frank'
			while ( regex.test( val ) ) {
				val = val.replace( regex, query[indx++] || '' );
				if ( regex.test( val ) && indx < len && ( query[indx] || '' ) !== '' ) {
					val = mask.replace( regex, val );
				}
			}
			return val;
		},
		getLatestSearch: function( $input ) {
			if ( $input ) {
				return $input.sort( function( a, b ) {
					return $( b ).attr( 'data-lastSearchTime' ) - $( a ).attr( 'data-lastSearchTime' );
				});
			}
			return $input || $();
		},
		findRange: function( c, val, ignoreRanges ) {
			// look for multiple columns '1-3,4-6,8' in data-column
			var temp, ranges, range, start, end, singles, i, indx, len,
				columns = [];
			if ( /^[0-9]+$/.test( val ) ) {
				// always return an array
				return [ parseInt( val, 10 ) ];
			}
			// process column range
			if ( !ignoreRanges && /-/.test( val ) ) {
				ranges = val.match( /(\d+)\s*-\s*(\d+)/g );
				len = ranges ? ranges.length : 0;
				for ( indx = 0; indx < len; indx++ ) {
					range = ranges[indx].split( /\s*-\s*/ );
					start = parseInt( range[0], 10 ) || 0;
					end = parseInt( range[1], 10 ) || ( c.columns - 1 );
					if ( start > end ) {
						temp = start; start = end; end = temp; // swap
					}
					if ( end >= c.columns ) {
						end = c.columns - 1;
					}
					for ( ; start <= end; start++ ) {
						columns[ columns.length ] = start;
					}
					// remove processed range from val
					val = val.replace( ranges[ indx ], '' );
				}
			}
			// process single columns
			if ( !ignoreRanges && /,/.test( val ) ) {
				singles = val.split( /\s*,\s*/ );
				len = singles.length;
				for ( i = 0; i < len; i++ ) {
					if ( singles[ i ] !== '' ) {
						indx = parseInt( singles[ i ], 10 );
						if ( indx < c.columns ) {
							columns[ columns.length ] = indx;
						}
					}
				}
			}
			// return all columns
			if ( !columns.length ) {
				for ( indx = 0; indx < c.columns; indx++ ) {
					columns[ columns.length ] = indx;
				}
			}
			return columns;
		},
		getColumnElm: function( c, $elements, column ) {
			// data-column may contain multiple columns '1-3,5-6,8'
			// replaces: c.$filters.filter( '[data-column="' + column + '"]' );
			return $elements.filter( function() {
				var cols = tsf.findRange( c, $( this ).attr( 'data-column' ) );
				return $.inArray( column, cols ) > -1;
			});
		},
		multipleColumns: function( c, $input ) {
			// look for multiple columns '1-3,4-6,8' in data-column
			var wo = c.widgetOptions,
				// only target 'all' column inputs on initialization
				// & don't target 'all' column inputs if they don't exist
				targets = wo.filter_initialized || !$input.filter( wo.filter_anyColumnSelector ).length,
				val = $.trim( tsf.getLatestSearch( $input ).attr( 'data-column' ) || '' );
			return tsf.findRange( c, val, !targets );
		},
		processTypes: function( c, data, vars ) {
			var ffxn,
				filterMatched = null,
				matches = null;
			for ( ffxn in tsf.types ) {
				if ( $.inArray( ffxn, vars.excludeMatch ) < 0 && matches === null ) {
					matches = tsf.types[ffxn]( c, data, vars );
					if ( matches !== null ) {
						data.matchedOn = ffxn;
						filterMatched = matches;
					}
				}
			}
			return filterMatched;
		},
		matchType: function( c, columnIndex ) {
			var isMatch,
				wo = c.widgetOptions,
				$el = c.$headerIndexed[ columnIndex ];
			// filter-exact > filter-match > filter_matchType for type
			if ( $el.hasClass( 'filter-exact' ) ) {
				isMatch = false;
			} else if ( $el.hasClass( 'filter-match' ) ) {
				isMatch = true;
			} else {
				// filter-select is not applied when filter_functions are used, so look for a select
				if ( wo.filter_columnFilters ) {
					$el = c.$filters
						.find( '.' + tscss.filter )
						.add( wo.filter_$externalFilters )
						.filter( '[data-column="' + columnIndex + '"]' );
				} else if ( wo.filter_$externalFilters ) {
					$el = wo.filter_$externalFilters.filter( '[data-column="' + columnIndex + '"]' );
				}
				isMatch = $el.length ?
					c.widgetOptions.filter_matchType[ ( $el[ 0 ].nodeName || '' ).toLowerCase() ] === 'match' :
					// default to exact, if no inputs found
					false;
			}
			return isMatch;
		},
		processRow: function( c, data, vars ) {
			var result, filterMatched,
				fxn, ffxn, txt,
				wo = c.widgetOptions,
				showRow = true,
				hasAnyMatchInput = wo.filter_$anyMatch && wo.filter_$anyMatch.length,

				// if wo.filter_$anyMatch data-column attribute is changed dynamically
				// we don't want to do an "anyMatch" search on one column using data
				// for the entire row - see #998
				columnIndex = wo.filter_$anyMatch && wo.filter_$anyMatch.length ?
					// look for multiple columns '1-3,4-6,8'
					tsf.multipleColumns( c, wo.filter_$anyMatch ) :
					[];
			data.$cells = data.$row.children();
			data.matchedOn = null;
			if ( data.anyMatchFlag && columnIndex.length > 1 || ( data.anyMatchFilter && !hasAnyMatchInput ) ) {
				data.anyMatch = true;
				data.isMatch = true;
				data.rowArray = data.$cells.map( function( i ) {
					if ( $.inArray( i, columnIndex ) > -1 || ( data.anyMatchFilter && !hasAnyMatchInput ) ) {
						if ( data.parsed[ i ] ) {
							txt = data.cacheArray[ i ];
						} else {
							txt = data.rawArray[ i ];
							txt = $.trim( wo.filter_ignoreCase ? txt.toLowerCase() : txt );
							if ( c.sortLocaleCompare ) {
								txt = ts.replaceAccents( txt );
							}
						}
						return txt;
					}
				}).get();
				data.filter = data.anyMatchFilter;
				data.iFilter = data.iAnyMatchFilter;
				data.exact = data.rowArray.join( ' ' );
				data.iExact = wo.filter_ignoreCase ? data.exact.toLowerCase() : data.exact;
				data.cache = data.cacheArray.slice( 0, -1 ).join( ' ' );
				vars.excludeMatch = vars.noAnyMatch;
				filterMatched = tsf.processTypes( c, data, vars );
				if ( filterMatched !== null ) {
					showRow = filterMatched;
				} else {
					if ( wo.filter_startsWith ) {
						showRow = false;
						// data.rowArray may not contain all columns
						columnIndex = Math.min( c.columns, data.rowArray.length );
						while ( !showRow && columnIndex > 0 ) {
							columnIndex--;
							showRow = showRow || data.rowArray[ columnIndex ].indexOf( data.iFilter ) === 0;
						}
					} else {
						showRow = ( data.iExact + data.childRowText ).indexOf( data.iFilter ) >= 0;
					}
				}
				data.anyMatch = false;
				// no other filters to process
				if ( data.filters.join( '' ) === data.filter ) {
					return showRow;
				}
			}

			for ( columnIndex = 0; columnIndex < c.columns; columnIndex++ ) {
				data.filter = data.filters[ columnIndex ];
				data.index = columnIndex;

				// filter types to exclude, per column
				vars.excludeMatch = vars.excludeFilter[ columnIndex ];

				// ignore if filter is empty or disabled
				if ( data.filter ) {
					data.cache = data.cacheArray[ columnIndex ];
					result = data.parsed[ columnIndex ] ? data.cache : data.rawArray[ columnIndex ] || '';
					data.exact = c.sortLocaleCompare ? ts.replaceAccents( result ) : result; // issue #405
					data.iExact = !tsfRegex.type.test( typeof data.exact ) && wo.filter_ignoreCase ?
						data.exact.toLowerCase() : data.exact;
					data.isMatch = tsf.matchType( c, columnIndex );

					result = showRow; // if showRow is true, show that row

					// in case select filter option has a different value vs text 'a - z|A through Z'
					ffxn = wo.filter_columnFilters ?
						c.$filters.add( wo.filter_$externalFilters )
							.filter( '[data-column="' + columnIndex + '"]' )
							.find( 'select option:selected' )
							.attr( 'data-function-name' ) || '' : '';
					// replace accents - see #357
					if ( c.sortLocaleCompare ) {
						data.filter = ts.replaceAccents( data.filter );
					}

					// replace column specific default filters - see #1088
					if ( wo.filter_defaultFilter && tsfRegex.iQuery.test( vars.defaultColFilter[ columnIndex ] ) ) {
						data.filter = tsf.defaultFilter( data.filter, vars.defaultColFilter[ columnIndex ] );
					}

					// data.iFilter = case insensitive ( if wo.filter_ignoreCase is true ),
					// data.filter = case sensitive
					data.iFilter = wo.filter_ignoreCase ? ( data.filter || '' ).toLowerCase() : data.filter;
					fxn = vars.functions[ columnIndex ];
					filterMatched = null;
					if ( fxn ) {
						if ( typeof fxn === 'function' ) {
							// filter callback( exact cell content, parser normalized content,
							// filter input value, column index, jQuery row object )
							filterMatched = fxn( data.exact, data.cache, data.filter, columnIndex, data.$row, c, data );
						} else if ( typeof fxn[ ffxn || data.filter ] === 'function' ) {
							// selector option function
							txt = ffxn || data.filter;
							filterMatched =
								fxn[ txt ]( data.exact, data.cache, data.filter, columnIndex, data.$row, c, data );
						}
					}
					if ( filterMatched === null ) {
						// cycle through the different filters
						// filters return a boolean or null if nothing matches
						filterMatched = tsf.processTypes( c, data, vars );
						// select with exact match; ignore "and" or "or" within the text; fixes #1486
						txt = fxn === true && (data.matchedOn === 'and' || data.matchedOn === 'or');
						if ( filterMatched !== null && !txt) {
							result = filterMatched;
						// Look for match, and add child row data for matching
						} else {
							// check fxn (filter-select in header) after filter types are checked
							// without this, the filter + jQuery UI selectmenu demo was breaking
							if ( fxn === true ) {
								// default selector uses exact match unless 'filter-match' class is found
								result = data.isMatch ?
									// data.iExact may be a number
									( '' + data.iExact ).search( data.iFilter ) >= 0 :
									data.filter === data.exact;
							} else {
								txt = ( data.iExact + data.childRowText ).indexOf( tsf.parseFilter( c, data.iFilter, data ) );
								result = ( ( !wo.filter_startsWith && txt >= 0 ) || ( wo.filter_startsWith && txt === 0 ) );
							}
						}
					} else {
						result = filterMatched;
					}
					showRow = ( result ) ? showRow : false;
				}
			}
			return showRow;
		},
		findRows: function( table, filters, currentFilters ) {
			if (
				tsf.equalFilters(table.config, table.config.lastSearch, currentFilters) ||
				!table.config.widgetOptions.filter_initialized
			) {
				return;
			}
			var len, norm_rows, rowData, $rows, $row, rowIndex, tbodyIndex, $tbody, columnIndex,
				isChild, childRow, lastSearch, showRow, showParent, time, val, indx,
				notFiltered, searchFiltered, query, injected, res, id, txt,
				storedFilters = $.extend( [], filters ),
				c = table.config,
				wo = c.widgetOptions,
				debug = ts.debug(c, 'filter'),
				// data object passed to filters; anyMatch is a flag for the filters
				data = {
					anyMatch: false,
					filters: filters,
					// regex filter type cache
					filter_regexCache : []
				},
				vars = {
					// anyMatch really screws up with these types of filters
					noAnyMatch: [ 'range',  'operators' ],
					// cache filter variables that use ts.getColumnData in the main loop
					functions : [],
					excludeFilter : [],
					defaultColFilter : [],
					defaultAnyFilter : ts.getColumnData( table, wo.filter_defaultFilter, c.columns, true ) || ''
				};
			// parse columns after formatter, in case the class is added at that point
			data.parsed = [];
			for ( columnIndex = 0; columnIndex < c.columns; columnIndex++ ) {
				data.parsed[ columnIndex ] = wo.filter_useParsedData ||
					// parser has a "parsed" parameter
					( c.parsers && c.parsers[ columnIndex ] && c.parsers[ columnIndex ].parsed ||
					// getData may not return 'parsed' if other 'filter-' class names exist
					// ( e.g. <th class="filter-select filter-parsed"> )
					ts.getData && ts.getData( c.$headerIndexed[ columnIndex ],
						ts.getColumnData( table, c.headers, columnIndex ), 'filter' ) === 'parsed' ||
					c.$headerIndexed[ columnIndex ].hasClass( 'filter-parsed' ) );

				vars.functions[ columnIndex ] =
					ts.getColumnData( table, wo.filter_functions, columnIndex ) ||
					c.$headerIndexed[ columnIndex ].hasClass( 'filter-select' );
				vars.defaultColFilter[ columnIndex ] =
					ts.getColumnData( table, wo.filter_defaultFilter, columnIndex ) || '';
				vars.excludeFilter[ columnIndex ] =
					( ts.getColumnData( table, wo.filter_excludeFilter, columnIndex, true ) || '' ).split( /\s+/ );
			}

			if ( debug ) {
				console.log( 'Filter >> Starting filter widget search', filters );
				time = new Date();
			}
			// filtered rows count
			c.filteredRows = 0;
			c.totalRows = 0;
			currentFilters = ( storedFilters || [] );

			for ( tbodyIndex = 0; tbodyIndex < c.$tbodies.length; tbodyIndex++ ) {
				$tbody = ts.processTbody( table, c.$tbodies.eq( tbodyIndex ), true );
				// skip child rows & widget added ( removable ) rows - fixes #448 thanks to @hempel!
				// $rows = $tbody.children( 'tr' ).not( c.selectorRemove );
				columnIndex = c.columns;
				// convert stored rows into a jQuery object
				norm_rows = c.cache[ tbodyIndex ].normalized;
				$rows = $( $.map( norm_rows, function( el ) {
					return el[ columnIndex ].$row.get();
				}) );

				if ( currentFilters.join('') === '' || wo.filter_serversideFiltering ) {
					$rows
						.removeClass( wo.filter_filteredRow )
						.not( '.' + c.cssChildRow )
						.css( 'display', '' );
				} else {
					// filter out child rows
					$rows = $rows.not( '.' + c.cssChildRow );
					len = $rows.length;

					if ( ( wo.filter_$anyMatch && wo.filter_$anyMatch.length ) ||
						typeof filters[c.columns] !== 'undefined' ) {
						data.anyMatchFlag = true;
						data.anyMatchFilter = '' + (
							filters[ c.columns ] ||
							wo.filter_$anyMatch && tsf.getLatestSearch( wo.filter_$anyMatch ).val() ||
							''
						);
						if ( wo.filter_columnAnyMatch ) {
							// specific columns search
							query = data.anyMatchFilter.split( tsfRegex.andSplit );
							injected = false;
							for ( indx = 0; indx < query.length; indx++ ) {
								res = query[ indx ].split( ':' );
								if ( res.length > 1 ) {
									// make the column a one-based index ( non-developers start counting from one :P )
									if ( isNaN( res[0] ) ) {
										$.each( c.headerContent, function( i, txt ) {
											// multiple matches are possible
											if ( txt.toLowerCase().indexOf( res[0] ) > -1 ) {
												id = i;
												filters[ id ] = res[1];
											}
										});
									} else {
										id = parseInt( res[0], 10 ) - 1;
									}
									if ( id >= 0 && id < c.columns ) { // if id is an integer
										filters[ id ] = res[1];
										query.splice( indx, 1 );
										indx--;
										injected = true;
									}
								}
							}
							if ( injected ) {
								data.anyMatchFilter = query.join( ' && ' );
							}
						}
					}

					// optimize searching only through already filtered rows - see #313
					searchFiltered = wo.filter_searchFiltered;
					lastSearch = c.lastSearch || c.$table.data( 'lastSearch' ) || [];
					if ( searchFiltered ) {
						// cycle through all filters; include last ( columnIndex + 1 = match any column ). Fixes #669
						for ( indx = 0; indx < columnIndex + 1; indx++ ) {
							val = filters[indx] || '';
							// break out of loop if we've already determined not to search filtered rows
							if ( !searchFiltered ) { indx = columnIndex; }
							// search already filtered rows if...
							searchFiltered = searchFiltered && lastSearch.length &&
								// there are no changes from beginning of filter
								val.indexOf( lastSearch[indx] || '' ) === 0 &&
								// if there is NOT a logical 'or', or range ( 'to' or '-' ) in the string
								!tsfRegex.alreadyFiltered.test( val ) &&
								// if we are not doing exact matches, using '|' ( logical or ) or not '!'
								!tsfRegex.exactTest.test( val ) &&
								// don't search only filtered if the value is negative
								// ( '> -10' => '> -100' will ignore hidden rows )
								!( tsfRegex.isNeg1.test( val ) || tsfRegex.isNeg2.test( val ) ) &&
								// if filtering using a select without a 'filter-match' class ( exact match ) - fixes #593
								!( val !== '' && c.$filters && c.$filters.filter( '[data-column="' + indx + '"]' ).find( 'select' ).length &&
									!tsf.matchType( c, indx ) );
						}
					}
					notFiltered = $rows.not( '.' + wo.filter_filteredRow ).length;
					// can't search when all rows are hidden - this happens when looking for exact matches
					if ( searchFiltered && notFiltered === 0 ) { searchFiltered = false; }
					if ( debug ) {
						console.log( 'Filter >> Searching through ' +
							( searchFiltered && notFiltered < len ? notFiltered : 'all' ) + ' rows' );
					}
					if ( data.anyMatchFlag ) {
						if ( c.sortLocaleCompare ) {
							// replace accents
							data.anyMatchFilter = ts.replaceAccents( data.anyMatchFilter );
						}
						if ( wo.filter_defaultFilter && tsfRegex.iQuery.test( vars.defaultAnyFilter ) ) {
							data.anyMatchFilter = tsf.defaultFilter( data.anyMatchFilter, vars.defaultAnyFilter );
							// clear search filtered flag because default filters are not saved to the last search
							searchFiltered = false;
						}
						// make iAnyMatchFilter lowercase unless both filter widget & core ignoreCase options are true
						// when c.ignoreCase is true, the cache contains all lower case data
						data.iAnyMatchFilter = !( wo.filter_ignoreCase && c.ignoreCase ) ?
							data.anyMatchFilter :
							data.anyMatchFilter.toLowerCase();
					}

					// loop through the rows
					for ( rowIndex = 0; rowIndex < len; rowIndex++ ) {

						txt = $rows[ rowIndex ].className;
						// the first row can never be a child row
						isChild = rowIndex && tsfRegex.child.test( txt );
						// skip child rows & already filtered rows
						if ( isChild || ( searchFiltered && tsfRegex.filtered.test( txt ) ) ) {
							continue;
						}

						data.$row = $rows.eq( rowIndex );
						data.rowIndex = rowIndex;
						data.cacheArray = norm_rows[ rowIndex ];
						rowData = data.cacheArray[ c.columns ];
						data.rawArray = rowData.raw;
						data.childRowText = '';

						if ( !wo.filter_childByColumn ) {
							txt = '';
							// child row cached text
							childRow = rowData.child;
							// so, if 'table.config.widgetOptions.filter_childRows' is true and there is
							// a match anywhere in the child row, then it will make the row visible
							// checked here so the option can be changed dynamically
							for ( indx = 0; indx < childRow.length; indx++ ) {
								txt += ' ' + childRow[indx].join( ' ' ) || '';
							}
							data.childRowText = wo.filter_childRows ?
								( wo.filter_ignoreCase ? txt.toLowerCase() : txt ) :
								'';
						}

						showRow = false;
						showParent = tsf.processRow( c, data, vars );
						$row = rowData.$row;

						// don't pass reference to val
						val = showParent ? true : false;
						childRow = rowData.$row.filter( ':gt(0)' );
						if ( wo.filter_childRows && childRow.length ) {
							if ( wo.filter_childByColumn ) {
								if ( !wo.filter_childWithSibs ) {
									// hide all child rows
									childRow.addClass( wo.filter_filteredRow );
									// if only showing resulting child row, only include parent
									$row = $row.eq( 0 );
								}
								// cycle through each child row
								for ( indx = 0; indx < childRow.length; indx++ ) {
									data.$row = childRow.eq( indx );
									data.cacheArray = rowData.child[ indx ];
									data.rawArray = data.cacheArray;
									val = tsf.processRow( c, data, vars );
									// use OR comparison on child rows
									showRow = showRow || val;
									if ( !wo.filter_childWithSibs && val ) {
										childRow.eq( indx ).removeClass( wo.filter_filteredRow );
									}
								}
							}
							// keep parent row match even if no child matches... see #1020
							showRow = showRow || showParent;
						} else {
							showRow = val;
						}
						$row
							.toggleClass( wo.filter_filteredRow, !showRow )[0]
							.display = showRow ? '' : 'none';
					}
				}
				c.filteredRows += $rows.not( '.' + wo.filter_filteredRow ).length;
				c.totalRows += $rows.length;
				ts.processTbody( table, $tbody, false );
			}
			// lastCombinedFilter is no longer used internally
			c.lastCombinedFilter = storedFilters.join(''); // save last search
			// don't save 'filters' directly since it may have altered ( AnyMatch column searches )
			c.lastSearch = storedFilters;
			c.$table.data( 'lastSearch', storedFilters );
			if ( wo.filter_saveFilters && ts.storage ) {
				ts.storage( table, 'tablesorter-filters', tsf.processFilters( storedFilters, true ) );
			}
			if ( debug ) {
				console.log( 'Filter >> Completed search' + ts.benchmark(time) );
			}
			if ( wo.filter_initialized ) {
				c.$table.triggerHandler( 'filterBeforeEnd', c );
				c.$table.triggerHandler( 'filterEnd', c );
			}
			setTimeout( function() {
				ts.applyWidget( c.table ); // make sure zebra widget is applied
			}, 0 );
		},
		getOptionSource: function( table, column, onlyAvail ) {
			table = $( table )[0];
			var c = table.config,
				wo = c.widgetOptions,
				arry = false,
				source = wo.filter_selectSource,
				last = c.$table.data( 'lastSearch' ) || [],
				fxn = typeof source === 'function' ? true : ts.getColumnData( table, source, column );

			if ( onlyAvail && last[column] !== '' ) {
				onlyAvail = false;
			}

			// filter select source option
			if ( fxn === true ) {
				// OVERALL source
				arry = source( table, column, onlyAvail );
			} else if ( fxn instanceof $ || ( $.type( fxn ) === 'string' && fxn.indexOf( '</option>' ) >= 0 ) ) {
				// selectSource is a jQuery object or string of options
				return fxn;
			} else if ( $.isArray( fxn ) ) {
				arry = fxn;
			} else if ( $.type( source ) === 'object' && fxn ) {
				// custom select source function for a SPECIFIC COLUMN
				arry = fxn( table, column, onlyAvail );
				// abort - updating the selects from an external method
				if (arry === null) {
					return null;
				}
			}
			if ( arry === false ) {
				// fall back to original method
				arry = tsf.getOptions( table, column, onlyAvail );
			}

			return tsf.processOptions( table, column, arry );

		},
		processOptions: function( table, column, arry ) {
			if ( !$.isArray( arry ) ) {
				return false;
			}
			table = $( table )[0];
			var cts, txt, indx, len, parsedTxt, str,
				c = table.config,
				validColumn = typeof column !== 'undefined' && column !== null && column >= 0 && column < c.columns,
				direction = validColumn ? c.$headerIndexed[ column ].hasClass( 'filter-select-sort-desc' ) : false,
				parsed = [];
			// get unique elements and sort the list
			// if $.tablesorter.sortText exists ( not in the original tablesorter ),
			// then natural sort the list otherwise use a basic sort
			arry = $.grep( arry, function( value, indx ) {
				if ( value.text ) {
					return true;
				}
				return $.inArray( value, arry ) === indx;
			});
			if ( validColumn && c.$headerIndexed[ column ].hasClass( 'filter-select-nosort' ) ) {
				// unsorted select options
				return arry;
			} else {
				len = arry.length;
				// parse select option values
				for ( indx = 0; indx < len; indx++ ) {
					txt = arry[ indx ];
					// check for object
					str = txt.text ? txt.text : txt;
					// sortNatural breaks if you don't pass it strings
					parsedTxt = ( validColumn && c.parsers && c.parsers.length &&
						c.parsers[ column ].format( str, table, [], column ) || str ).toString();
					parsedTxt = c.widgetOptions.filter_ignoreCase ? parsedTxt.toLowerCase() : parsedTxt;
					// parse array data using set column parser; this DOES NOT pass the original
					// table cell to the parser format function
					if ( txt.text ) {
						txt.parsed = parsedTxt;
						parsed[ parsed.length ] = txt;
					} else {
						parsed[ parsed.length ] = {
							text : txt,
							// check parser length - fixes #934
							parsed : parsedTxt
						};
					}
				}
				// sort parsed select options
				cts = c.textSorter || '';
				parsed.sort( function( a, b ) {
					var x = direction ? b.parsed : a.parsed,
						y = direction ? a.parsed : b.parsed;
					if ( validColumn && typeof cts === 'function' ) {
						// custom OVERALL text sorter
						return cts( x, y, true, column, table );
					} else if ( validColumn && typeof cts === 'object' && cts.hasOwnProperty( column ) ) {
						// custom text sorter for a SPECIFIC COLUMN
						return cts[column]( x, y, true, column, table );
					} else if ( ts.sortNatural ) {
						// fall back to natural sort
						return ts.sortNatural( x, y );
					}
					// using an older version! do a basic sort
					return true;
				});
				// rebuild arry from sorted parsed data
				arry = [];
				len = parsed.length;
				for ( indx = 0; indx < len; indx++ ) {
					arry[ arry.length ] = parsed[indx];
				}
				return arry;
			}
		},
		getOptions: function( table, column, onlyAvail ) {
			table = $( table )[0];
			var rowIndex, tbodyIndex, len, row, cache, indx, child, childLen,
				c = table.config,
				wo = c.widgetOptions,
				arry = [];
			for ( tbodyIndex = 0; tbodyIndex < c.$tbodies.length; tbodyIndex++ ) {
				cache = c.cache[tbodyIndex];
				len = c.cache[tbodyIndex].normalized.length;
				// loop through the rows
				for ( rowIndex = 0; rowIndex < len; rowIndex++ ) {
					// get cached row from cache.row ( old ) or row data object
					// ( new; last item in normalized array )
					row = cache.row ?
						cache.row[ rowIndex ] :
						cache.normalized[ rowIndex ][ c.columns ].$row[0];
					// check if has class filtered
					if ( onlyAvail && row.className.match( wo.filter_filteredRow ) ) {
						continue;
					}
					// get non-normalized cell content
					if ( wo.filter_useParsedData ||
						c.parsers[column].parsed ||
						c.$headerIndexed[column].hasClass( 'filter-parsed' ) ) {
						arry[ arry.length ] = '' + cache.normalized[ rowIndex ][ column ];
						// child row parsed data
						if ( wo.filter_childRows && wo.filter_childByColumn ) {
							childLen = cache.normalized[ rowIndex ][ c.columns ].$row.length - 1;
							for ( indx = 0; indx < childLen; indx++ ) {
								arry[ arry.length ] = '' + cache.normalized[ rowIndex ][ c.columns ].child[ indx ][ column ];
							}
						}
					} else {
						// get raw cached data instead of content directly from the cells
						arry[ arry.length ] = cache.normalized[ rowIndex ][ c.columns ].raw[ column ];
						// child row unparsed data
						if ( wo.filter_childRows && wo.filter_childByColumn ) {
							childLen = cache.normalized[ rowIndex ][ c.columns ].$row.length;
							for ( indx = 1; indx < childLen; indx++ ) {
								child =  cache.normalized[ rowIndex ][ c.columns ].$row.eq( indx ).children().eq( column );
								arry[ arry.length ] = '' + ts.getElementText( c, child, column );
							}
						}
					}
				}
			}
			return arry;
		},
		buildSelect: function( table, column, arry, updating, onlyAvail ) {
			table = $( table )[0];
			column = parseInt( column, 10 );
			if ( !table.config.cache || $.isEmptyObject( table.config.cache ) ) {
				return;
			}

			var indx, val, txt, t, $filters, $filter, option,
				c = table.config,
				wo = c.widgetOptions,
				node = c.$headerIndexed[ column ],
				// t.data( 'placeholder' ) won't work in jQuery older than 1.4.3
				options = '<option value="">' +
					( node.data( 'placeholder' ) ||
						node.attr( 'data-placeholder' ) ||
						wo.filter_placeholder.select || ''
					) + '</option>',
				// Get curent filter value
				currentValue = c.$table
					.find( 'thead' )
					.find( 'select.' + tscss.filter + '[data-column="' + column + '"]' )
					.val();

			// nothing included in arry ( external source ), so get the options from
			// filter_selectSource or column data
			if ( typeof arry === 'undefined' || arry === '' ) {
				arry = tsf.getOptionSource( table, column, onlyAvail );
				// abort, selects are updated by an external method
				if (arry === null) {
					return;
				}
			}

			if ( $.isArray( arry ) ) {
				// build option list
				for ( indx = 0; indx < arry.length; indx++ ) {
					option = arry[ indx ];
					if ( option.text ) {
						// OBJECT!! add data-function-name in case the value is set in filter_functions
						option['data-function-name'] = typeof option.value === 'undefined' ? option.text : option.value;

						// support jQuery < v1.8, otherwise the below code could be shortened to
						// options += $( '<option>', option )[ 0 ].outerHTML;
						options += '<option';
						for ( val in option ) {
							if ( option.hasOwnProperty( val ) && val !== 'text' ) {
								options += ' ' + val + '="' + option[ val ].replace( tsfRegex.quote, '&quot;' ) + '"';
							}
						}
						if ( !option.value ) {
							options += ' value="' + option.text.replace( tsfRegex.quote, '&quot;' ) + '"';
						}
						options += '>' + option.text.replace( tsfRegex.quote, '&quot;' ) + '</option>';
						// above code is needed in jQuery < v1.8

						// make sure we don't turn an object into a string (objects without a "text" property)
					} else if ( '' + option !== '[object Object]' ) {
						txt = option = ( '' + option ).replace( tsfRegex.quote, '&quot;' );
						val = txt;
						// allow including a symbol in the selectSource array
						// 'a-z|A through Z' so that 'a-z' becomes the option value
						// and 'A through Z' becomes the option text
						if ( txt.indexOf( wo.filter_selectSourceSeparator ) >= 0 ) {
							t = txt.split( wo.filter_selectSourceSeparator );
							val = t[0];
							txt = t[1];
						}
						// replace quotes - fixes #242 & ignore empty strings
						// see http://stackoverflow.com/q/14990971/145346
						options += option !== '' ?
							'<option ' +
								( val === txt ? '' : 'data-function-name="' + option + '" ' ) +
								'value="' + val + '">' + txt +
							'</option>' : '';
					}
				}
				// clear arry so it doesn't get appended twice
				arry = [];
			}

			// update all selects in the same column ( clone thead in sticky headers &
			// any external selects ) - fixes 473
			$filters = ( c.$filters ? c.$filters : c.$table.children( 'thead' ) )
				.find( '.' + tscss.filter );
			if ( wo.filter_$externalFilters ) {
				$filters = $filters && $filters.length ?
					$filters.add( wo.filter_$externalFilters ) :
					wo.filter_$externalFilters;
			}
			$filter = $filters.filter( 'select[data-column="' + column + '"]' );

			// make sure there is a select there!
			if ( $filter.length ) {
				$filter[ updating ? 'html' : 'append' ]( options );
				if ( !$.isArray( arry ) ) {
					// append options if arry is provided externally as a string or jQuery object
					// options ( default value ) was already added
					$filter.append( arry ).val( currentValue );
				}
				$filter.val( currentValue );
			}
		},
		buildDefault: function( table, updating ) {
			var columnIndex, $header, noSelect,
				c = table.config,
				wo = c.widgetOptions,
				columns = c.columns;
			// build default select dropdown
			for ( columnIndex = 0; columnIndex < columns; columnIndex++ ) {
				$header = c.$headerIndexed[columnIndex];
				noSelect = !( $header.hasClass( 'filter-false' ) || $header.hasClass( 'parser-false' ) );
				// look for the filter-select class; build/update it if found
				if ( ( $header.hasClass( 'filter-select' ) ||
					ts.getColumnData( table, wo.filter_functions, columnIndex ) === true ) && noSelect ) {
					tsf.buildSelect( table, columnIndex, '', updating, $header.hasClass( wo.filter_onlyAvail ) );
				}
			}
		}
	};

	// filter regex variable
	tsfRegex = tsf.regex;

	ts.getFilters = function( table, getRaw, setFilters, skipFirst ) {
		var i, $filters, $column, cols,
			filters = [],
			c = table ? $( table )[0].config : '',
			wo = c ? c.widgetOptions : '';
		if ( ( getRaw !== true && wo && !wo.filter_columnFilters ) ||
			// setFilters called, but last search is exactly the same as the current
			// fixes issue #733 & #903 where calling update causes the input values to reset
			( $.isArray(setFilters) && tsf.equalFilters(c, setFilters, c.lastSearch) )
		) {
			return $( table ).data( 'lastSearch' ) || [];
		}
		if ( c ) {
			if ( c.$filters ) {
				$filters = c.$filters.find( '.' + tscss.filter );
			}
			if ( wo.filter_$externalFilters ) {
				$filters = $filters && $filters.length ?
					$filters.add( wo.filter_$externalFilters ) :
					wo.filter_$externalFilters;
			}
			if ( $filters && $filters.length ) {
				filters = setFilters || [];
				for ( i = 0; i < c.columns + 1; i++ ) {
					cols = ( i === c.columns ?
						// 'all' columns can now include a range or set of columms ( data-column='0-2,4,6-7' )
						wo.filter_anyColumnSelector + ',' + wo.filter_multipleColumnSelector :
						'[data-column="' + i + '"]' );
					$column = $filters.filter( cols );
					if ( $column.length ) {
						// move the latest search to the first slot in the array
						$column = tsf.getLatestSearch( $column );
						if ( $.isArray( setFilters ) ) {
							// skip first ( latest input ) to maintain cursor position while typing
							if ( skipFirst && $column.length > 1 ) {
								$column = $column.slice( 1 );
							}
							if ( i === c.columns ) {
								// prevent data-column='all' from filling data-column='0,1' ( etc )
								cols = $column.filter( wo.filter_anyColumnSelector );
								$column = cols.length ? cols : $column;
							}
							$column
								.val( setFilters[ i ] )
								// must include a namespace here; but not c.namespace + 'filter'?
								.trigger( 'change' + c.namespace );
						} else {
							filters[i] = $column.val() || '';
							// don't change the first... it will move the cursor
							if ( i === c.columns ) {
								// don't update range columns from 'all' setting
								$column
									.slice( 1 )
									.filter( '[data-column*="' + $column.attr( 'data-column' ) + '"]' )
									.val( filters[ i ] );
							} else {
								$column
									.slice( 1 )
									.val( filters[ i ] );
							}
						}
						// save any match input dynamically
						if ( i === c.columns && $column.length ) {
							wo.filter_$anyMatch = $column;
						}
					}
				}
			}
		}
		return filters;
	};

	ts.setFilters = function( table, filter, apply, skipFirst ) {
		var c = table ? $( table )[0].config : '',
			valid = ts.getFilters( table, true, filter, skipFirst );
		// default apply to "true"
		if ( typeof apply === 'undefined' ) {
			apply = true;
		}
		if ( c && apply ) {
			// ensure new set filters are applied, even if the search is the same
			c.lastCombinedFilter = null;
			c.lastSearch = [];
			tsf.searching( c.table, filter, skipFirst );
			c.$table.triggerHandler( 'filterFomatterUpdate' );
		}
		return valid.length !== 0;
	};

})( jQuery );

/*! Widget: stickyHeaders - updated 9/27/2017 (v2.29.0) *//*
 * Requires tablesorter v2.8+ and jQuery 1.4.3+
 * by Rob Garrison
 */
;(function ($, window) {
	'use strict';
	var ts = $.tablesorter || {};

	$.extend(ts.css, {
		sticky    : 'tablesorter-stickyHeader', // stickyHeader
		stickyVis : 'tablesorter-sticky-visible',
		stickyHide: 'tablesorter-sticky-hidden',
		stickyWrap: 'tablesorter-sticky-wrapper'
	});

	// Add a resize event to table headers
	ts.addHeaderResizeEvent = function(table, disable, settings) {
		table = $(table)[0]; // make sure we're using a dom element
		if ( !table.config ) { return; }
		var defaults = {
				timer : 250
			},
			options = $.extend({}, defaults, settings),
			c = table.config,
			wo = c.widgetOptions,
			checkSizes = function( triggerEvent ) {
				var index, headers, $header, sizes, width, height,
					len = c.$headers.length;
				wo.resize_flag = true;
				headers = [];
				for ( index = 0; index < len; index++ ) {
					$header = c.$headers.eq( index );
					sizes = $header.data( 'savedSizes' ) || [ 0, 0 ]; // fixes #394
					width = $header[0].offsetWidth;
					height = $header[0].offsetHeight;
					if ( width !== sizes[0] || height !== sizes[1] ) {
						$header.data( 'savedSizes', [ width, height ] );
						headers.push( $header[0] );
					}
				}
				if ( headers.length && triggerEvent !== false ) {
					c.$table.triggerHandler( 'resize', [ headers ] );
				}
				wo.resize_flag = false;
			};
		clearInterval(wo.resize_timer);
		if (disable) {
			wo.resize_flag = false;
			return false;
		}
		checkSizes( false );
		wo.resize_timer = setInterval(function() {
			if (wo.resize_flag) { return; }
			checkSizes();
		}, options.timer);
	};

	function getStickyOffset(c, wo) {
		var $el = isNaN(wo.stickyHeaders_offset) ? $(wo.stickyHeaders_offset) : [];
		return $el.length ?
			$el.height() || 0 :
			parseInt(wo.stickyHeaders_offset, 10) || 0;
	}

	// Sticky headers based on this awesome article:
	// http://css-tricks.com/13465-persistent-headers/
	// and https://github.com/jmosbech/StickyTableHeaders by Jonas Mosbech
	// **************************
	ts.addWidget({
		id: 'stickyHeaders',
		priority: 54, // sticky widget must be initialized after the filter & before pager widget!
		options: {
			stickyHeaders : '',       // extra class name added to the sticky header row
			stickyHeaders_appendTo : null, // jQuery selector or object to phycially attach the sticky headers
			stickyHeaders_attachTo : null, // jQuery selector or object to attach scroll listener to (overridden by xScroll & yScroll settings)
			stickyHeaders_xScroll : null, // jQuery selector or object to monitor horizontal scroll position (defaults: xScroll > attachTo > window)
			stickyHeaders_yScroll : null, // jQuery selector or object to monitor vertical scroll position (defaults: yScroll > attachTo > window)
			stickyHeaders_offset : 0, // number or jquery selector targeting the position:fixed element
			stickyHeaders_filteredToTop: true, // scroll table top into view after filtering
			stickyHeaders_cloneId : '-sticky', // added to table ID, if it exists
			stickyHeaders_addResizeEvent : true, // trigger 'resize' event on headers
			stickyHeaders_includeCaption : true, // if false and a caption exist, it won't be included in the sticky header
			stickyHeaders_zIndex : 2 // The zIndex of the stickyHeaders, allows the user to adjust this to their needs
		},
		format: function(table, c, wo) {
			// filter widget doesn't initialize on an empty table. Fixes #449
			if ( c.$table.hasClass('hasStickyHeaders') || ($.inArray('filter', c.widgets) >= 0 && !c.$table.hasClass('hasFilters')) ) {
				return;
			}
			var index, len, $t,
				$table = c.$table,
				// add position: relative to attach element, hopefully it won't cause trouble.
				$attach = $(wo.stickyHeaders_attachTo || wo.stickyHeaders_appendTo),
				namespace = c.namespace + 'stickyheaders ',
				// element to watch for the scroll event
				$yScroll = $(wo.stickyHeaders_yScroll || wo.stickyHeaders_attachTo || window),
				$xScroll = $(wo.stickyHeaders_xScroll || wo.stickyHeaders_attachTo || window),
				$thead = $table.children('thead:first'),
				$header = $thead.children('tr').not('.sticky-false').children(),
				$tfoot = $table.children('tfoot'),
				stickyOffset = getStickyOffset(c, wo),
				// is this table nested? If so, find parent sticky header wrapper (div, not table)
				$nestedSticky = $table.parent().closest('.' + ts.css.table).hasClass('hasStickyHeaders') ?
					$table.parent().closest('table.tablesorter')[0].config.widgetOptions.$sticky.parent() : [],
				nestedStickyTop = $nestedSticky.length ? $nestedSticky.height() : 0,
				// clone table, then wrap to make sticky header
				$stickyTable = wo.$sticky = $table.clone()
					.addClass('containsStickyHeaders ' + ts.css.sticky + ' ' + wo.stickyHeaders + ' ' + c.namespace.slice(1) + '_extra_table' )
					.wrap('<div class="' + ts.css.stickyWrap + '">'),
				$stickyWrap = $stickyTable.parent()
					.addClass(ts.css.stickyHide)
					.css({
						position   : $attach.length ? 'absolute' : 'fixed',
						padding    : parseInt( $stickyTable.parent().parent().css('padding-left'), 10 ),
						top        : stickyOffset + nestedStickyTop,
						left       : 0,
						visibility : 'hidden',
						zIndex     : wo.stickyHeaders_zIndex || 2
					}),
				$stickyThead = $stickyTable.children('thead:first'),
				$stickyCells,
				laststate = '',
				setWidth = function($orig, $clone) {
					var index, width, border, $cell, $this,
						$cells = $orig.filter(':visible'),
						len = $cells.length;
					for ( index = 0; index < len; index++ ) {
						$cell = $clone.filter(':visible').eq(index);
						$this = $cells.eq(index);
						// code from https://github.com/jmosbech/StickyTableHeaders
						if ($this.css('box-sizing') === 'border-box') {
							width = $this.outerWidth();
						} else {
							if ($cell.css('border-collapse') === 'collapse') {
								if (window.getComputedStyle) {
									width = parseFloat( window.getComputedStyle($this[0], null).width );
								} else {
									// ie8 only
									border = parseFloat( $this.css('border-width') );
									width = $this.outerWidth() - parseFloat( $this.css('padding-left') ) - parseFloat( $this.css('padding-right') ) - border;
								}
							} else {
								width = $this.width();
							}
						}
						$cell.css({
							'width': width,
							'min-width': width,
							'max-width': width
						});
					}
				},
				getLeftPosition = function(yWindow) {
					if (yWindow === false && $nestedSticky.length) {
						return $table.position().left;
					}
					return $attach.length ?
						parseInt($attach.css('padding-left'), 10) || 0 :
						$table.offset().left - parseInt($table.css('margin-left'), 10) - $(window).scrollLeft();
				},
				resizeHeader = function() {
					$stickyWrap.css({
						left : getLeftPosition(),
						width: $table.outerWidth()
					});
					setWidth( $table, $stickyTable );
					setWidth( $header, $stickyCells );
				},
				scrollSticky = function( resizing ) {
					if (!$table.is(':visible')) { return; } // fixes #278
					// Detect nested tables - fixes #724
					nestedStickyTop = $nestedSticky.length ? $nestedSticky.offset().top - $yScroll.scrollTop() + $nestedSticky.height() : 0;
					var tmp,
						offset = $table.offset(),
						stickyOffset = getStickyOffset(c, wo),
						yWindow = $.isWindow( $yScroll[0] ), // $.isWindow needs jQuery 1.4.3
						yScroll = yWindow ?
							$yScroll.scrollTop() :
							// use parent sticky position if nested AND inside of a scrollable element - see #1512
							$nestedSticky.length ? parseInt($nestedSticky[0].style.top, 10) : $yScroll.offset().top,
						attachTop = $attach.length ? yScroll : $yScroll.scrollTop(),
						captionHeight = wo.stickyHeaders_includeCaption ? 0 : $table.children( 'caption' ).height() || 0,
						scrollTop = attachTop + stickyOffset + nestedStickyTop - captionHeight,
						tableHeight = $table.height() - ($stickyWrap.height() + ($tfoot.height() || 0)) - captionHeight,
						isVisible = ( scrollTop > offset.top ) && ( scrollTop < offset.top + tableHeight ) ? 'visible' : 'hidden',
						state = isVisible === 'visible' ? ts.css.stickyVis : ts.css.stickyHide,
						needsUpdating = !$stickyWrap.hasClass( state ),
						cssSettings = { visibility : isVisible };
					if ($attach.length) {
						// attached sticky headers always need updating
						needsUpdating = true;
						cssSettings.top = yWindow ? scrollTop - $attach.offset().top : $attach.scrollTop();
					}
					// adjust when scrolling horizontally - fixes issue #143
					tmp = getLeftPosition(yWindow);
					if (tmp !== parseInt($stickyWrap.css('left'), 10)) {
						needsUpdating = true;
						cssSettings.left = tmp;
					}
					cssSettings.top = ( cssSettings.top || 0 ) +
						// If nested AND inside of a scrollable element, only add parent sticky height
						(!yWindow && $nestedSticky.length ? $nestedSticky.height() : stickyOffset + nestedStickyTop);
					if (needsUpdating) {
						$stickyWrap
							.removeClass( ts.css.stickyVis + ' ' + ts.css.stickyHide )
							.addClass( state )
							.css(cssSettings);
					}
					if (isVisible !== laststate || resizing) {
						// make sure the column widths match
						resizeHeader();
						laststate = isVisible;
					}
				};
			// only add a position relative if a position isn't already defined
			if ($attach.length && !$attach.css('position')) {
				$attach.css('position', 'relative');
			}
			// fix clone ID, if it exists - fixes #271
			if ($stickyTable.attr('id')) { $stickyTable[0].id += wo.stickyHeaders_cloneId; }
			// clear out cloned table, except for sticky header
			// include caption & filter row (fixes #126 & #249) - don't remove cells to get correct cell indexing
			$stickyTable.find('> thead:gt(0), tr.sticky-false').hide();
			$stickyTable.find('> tbody, > tfoot').remove();
			$stickyTable.find('caption').toggle(wo.stickyHeaders_includeCaption);
			// issue #172 - find td/th in sticky header
			$stickyCells = $stickyThead.children().children();
			$stickyTable.css({ height:0, width:0, margin: 0 });
			// remove resizable block
			$stickyCells.find('.' + ts.css.resizer).remove();
			// update sticky header class names to match real header after sorting
			$table
				.addClass('hasStickyHeaders')
				.bind('pagerComplete' + namespace, function() {
					resizeHeader();
				});

			ts.bindEvents(table, $stickyThead.children().children('.' + ts.css.header));

			if (wo.stickyHeaders_appendTo) {
				$(wo.stickyHeaders_appendTo).append( $stickyWrap );
			} else {
				// add stickyheaders AFTER the table. If the table is selected by ID, the original one (first) will be returned.
				$table.after( $stickyWrap );
			}

			// onRenderHeader is defined, we need to do something about it (fixes #641)
			if (c.onRenderHeader) {
				$t = $stickyThead.children('tr').children();
				len = $t.length;
				for ( index = 0; index < len; index++ ) {
					// send second parameter
					c.onRenderHeader.apply( $t.eq( index ), [ index, c, $stickyTable ] );
				}
			}
			// make it sticky!
			$xScroll.add($yScroll)
				.unbind( ('scroll resize '.split(' ').join( namespace )).replace(/\s+/g, ' ') )
				.bind('scroll resize '.split(' ').join( namespace ), function( event ) {
					scrollSticky( event.type === 'resize' );
				});
			c.$table
				.unbind('stickyHeadersUpdate' + namespace)
				.bind('stickyHeadersUpdate' + namespace, function() {
					scrollSticky( true );
				});

			if (wo.stickyHeaders_addResizeEvent) {
				ts.addHeaderResizeEvent(table);
			}

			// look for filter widget
			if ($table.hasClass('hasFilters') && wo.filter_columnFilters) {
				// scroll table into view after filtering, if sticky header is active - #482
				$table.bind('filterEnd' + namespace, function() {
					// $(':focus') needs jQuery 1.6+
					var $td = $(document.activeElement).closest('td'),
						column = $td.parent().children().index($td);
					// only scroll if sticky header is active
					if ($stickyWrap.hasClass(ts.css.stickyVis) && wo.stickyHeaders_filteredToTop) {
						// scroll to original table (not sticky clone)
						window.scrollTo(0, $table.position().top);
						// give same input/select focus; check if c.$filters exists; fixes #594
						if (column >= 0 && c.$filters) {
							c.$filters.eq(column).find('a, select, input').filter(':visible').focus();
						}
					}
				});
				ts.filter.bindSearch( $table, $stickyCells.find('.' + ts.css.filter) );
				// support hideFilters
				if (wo.filter_hideFilters) {
					ts.filter.hideFilters(c, $stickyTable);
				}
			}

			// resize table (Firefox)
			if (wo.stickyHeaders_addResizeEvent) {
				$table.bind('resize' + c.namespace + 'stickyheaders', function() {
					resizeHeader();
				});
			}

			// make sure sticky is visible if page is partially scrolled
			scrollSticky( true );
			$table.triggerHandler('stickyHeadersInit');

		},
		remove: function(table, c, wo) {
			var namespace = c.namespace + 'stickyheaders ';
			c.$table
				.removeClass('hasStickyHeaders')
				.unbind( ('pagerComplete resize filterEnd stickyHeadersUpdate '.split(' ').join(namespace)).replace(/\s+/g, ' ') )
				.next('.' + ts.css.stickyWrap).remove();
			if (wo.$sticky && wo.$sticky.length) { wo.$sticky.remove(); } // remove cloned table
			$(window)
				.add(wo.stickyHeaders_xScroll)
				.add(wo.stickyHeaders_yScroll)
				.add(wo.stickyHeaders_attachTo)
				.unbind( ('scroll resize '.split(' ').join(namespace)).replace(/\s+/g, ' ') );
			ts.addHeaderResizeEvent(table, true);
		}
	});

})(jQuery, window);

/*! Widget: resizable - updated 2018-03-26 (v2.30.2) */
/*jshint browser:true, jquery:true, unused:false */
;(function ($, window) {
	'use strict';
	var ts = $.tablesorter || {};

	$.extend(ts.css, {
		resizableContainer : 'tablesorter-resizable-container',
		resizableHandle    : 'tablesorter-resizable-handle',
		resizableNoSelect  : 'tablesorter-disableSelection',
		resizableStorage   : 'tablesorter-resizable'
	});

	// Add extra scroller css
	$(function() {
		var s = '<style>' +
			'body.' + ts.css.resizableNoSelect + ' { -ms-user-select: none; -moz-user-select: -moz-none;' +
				'-khtml-user-select: none; -webkit-user-select: none; user-select: none; }' +
			'.' + ts.css.resizableContainer + ' { position: relative; height: 1px; }' +
			// make handle z-index > than stickyHeader z-index, so the handle stays above sticky header
			'.' + ts.css.resizableHandle + ' { position: absolute; display: inline-block; width: 8px;' +
				'top: 1px; cursor: ew-resize; z-index: 3; user-select: none; -moz-user-select: none; }' +
			'</style>';
		$('head').append(s);
	});

	ts.resizable = {
		init : function( c, wo ) {
			if ( c.$table.hasClass( 'hasResizable' ) ) { return; }
			c.$table.addClass( 'hasResizable' );

			var noResize, $header, column, storedSizes, tmp,
				$table = c.$table,
				$parent = $table.parent(),
				marginTop = parseInt( $table.css( 'margin-top' ), 10 ),

			// internal variables
			vars = wo.resizable_vars = {
				useStorage : ts.storage && wo.resizable !== false,
				$wrap : $parent,
				mouseXPosition : 0,
				$target : null,
				$next : null,
				overflow : $parent.css('overflow') === 'auto' ||
					$parent.css('overflow') === 'scroll' ||
					$parent.css('overflow-x') === 'auto' ||
					$parent.css('overflow-x') === 'scroll',
				storedSizes : []
			};

			// set default widths
			ts.resizableReset( c.table, true );

			// now get measurements!
			vars.tableWidth = $table.width();
			// attempt to autodetect
			vars.fullWidth = Math.abs( $parent.width() - vars.tableWidth ) < 20;

			/*
			// Hacky method to determine if table width is set to 'auto'
			// http://stackoverflow.com/a/20892048/145346
			if ( !vars.fullWidth ) {
				tmp = $table.width();
				$header = $table.wrap('<span>').parent(); // temp variable
				storedSizes = parseInt( $table.css( 'margin-left' ), 10 ) || 0;
				$table.css( 'margin-left', storedSizes + 50 );
				vars.tableWidth = $header.width() > tmp ? 'auto' : tmp;
				$table.css( 'margin-left', storedSizes ? storedSizes : '' );
				$header = null;
				$table.unwrap('<span>');
			}
			*/

			if ( vars.useStorage && vars.overflow ) {
				// save table width
				ts.storage( c.table, 'tablesorter-table-original-css-width', vars.tableWidth );
				tmp = ts.storage( c.table, 'tablesorter-table-resized-width' ) || 'auto';
				ts.resizable.setWidth( $table, tmp, true );
			}
			wo.resizable_vars.storedSizes = storedSizes = ( vars.useStorage ?
				ts.storage( c.table, ts.css.resizableStorage ) :
				[] ) || [];
			ts.resizable.setWidths( c, wo, storedSizes );
			ts.resizable.updateStoredSizes( c, wo );

			wo.$resizable_container = $( '<div class="' + ts.css.resizableContainer + '">' )
				.css({ top : marginTop })
				.insertBefore( $table );
			// add container
			for ( column = 0; column < c.columns; column++ ) {
				$header = c.$headerIndexed[ column ];
				tmp = ts.getColumnData( c.table, c.headers, column );
				noResize = ts.getData( $header, tmp, 'resizable' ) === 'false';
				if ( !noResize ) {
					$( '<div class="' + ts.css.resizableHandle + '">' )
						.appendTo( wo.$resizable_container )
						.attr({
							'data-column' : column,
							'unselectable' : 'on'
						})
						.data( 'header', $header )
						.bind( 'selectstart', false );
				}
			}
			ts.resizable.bindings( c, wo );
		},

		updateStoredSizes : function( c, wo ) {
			var column, $header,
				len = c.columns,
				vars = wo.resizable_vars;
			vars.storedSizes = [];
			for ( column = 0; column < len; column++ ) {
				$header = c.$headerIndexed[ column ];
				vars.storedSizes[ column ] = $header.is(':visible') ? $header.width() : 0;
			}
		},

		setWidth : function( $el, width, overflow ) {
			// overflow tables need min & max width set as well
			$el.css({
				'width' : width,
				'min-width' : overflow ? width : '',
				'max-width' : overflow ? width : ''
			});
		},

		setWidths : function( c, wo, storedSizes ) {
			var column, $temp,
				vars = wo.resizable_vars,
				$extra = $( c.namespace + '_extra_headers' ),
				$col = c.$table.children( 'colgroup' ).children( 'col' );
			storedSizes = storedSizes || vars.storedSizes || [];
			// process only if table ID or url match
			if ( storedSizes.length ) {
				for ( column = 0; column < c.columns; column++ ) {
					// set saved resizable widths
					ts.resizable.setWidth( c.$headerIndexed[ column ], storedSizes[ column ], vars.overflow );
					if ( $extra.length ) {
						// stickyHeaders needs to modify min & max width as well
						$temp = $extra.eq( column ).add( $col.eq( column ) );
						ts.resizable.setWidth( $temp, storedSizes[ column ], vars.overflow );
					}
				}
				$temp = $( c.namespace + '_extra_table' );
				if ( $temp.length && !ts.hasWidget( c.table, 'scroller' ) ) {
					ts.resizable.setWidth( $temp, c.$table.outerWidth(), vars.overflow );
				}
			}
		},

		setHandlePosition : function( c, wo ) {
			var startPosition,
				tableHeight = c.$table.height(),
				$handles = wo.$resizable_container.children(),
				handleCenter = Math.floor( $handles.width() / 2 );

			if ( ts.hasWidget( c.table, 'scroller' ) ) {
				tableHeight = 0;
				c.$table.closest( '.' + ts.css.scrollerWrap ).children().each(function() {
					var $this = $(this);
					// center table has a max-height set
					tableHeight += $this.filter('[style*="height"]').length ? $this.height() : $this.children('table').height();
				});
			}

			if ( !wo.resizable_includeFooter && c.$table.children('tfoot').length ) {
				tableHeight -= c.$table.children('tfoot').height();
			}
			// subtract out table left position from resizable handles. Fixes #864
			// jQuery v3.3.0+ appears to include the start position with the $header.position().left; see #1544
			startPosition = parseFloat($.fn.jquery) >= 3.3 ? 0 : c.$table.position().left;
			$handles.each( function() {
				var $this = $(this),
					column = parseInt( $this.attr( 'data-column' ), 10 ),
					columns = c.columns - 1,
					$header = $this.data( 'header' );
				if ( !$header ) { return; } // see #859
				if (
					!$header.is(':visible') ||
					( !wo.resizable_addLastColumn && ts.resizable.checkVisibleColumns(c, column) )
				) {
					$this.hide();
				} else if ( column < columns || column === columns && wo.resizable_addLastColumn ) {
					$this.css({
						display: 'inline-block',
						height : tableHeight,
						left : $header.position().left - startPosition + $header.outerWidth() - handleCenter
					});
				}
			});
		},

		// Fixes #1485
		checkVisibleColumns: function( c, column ) {
			var i,
				len = 0;
			for ( i = column + 1; i < c.columns; i++ ) {
				len += c.$headerIndexed[i].is( ':visible' ) ? 1 : 0;
			}
			return len === 0;
		},

		// prevent text selection while dragging resize bar
		toggleTextSelection : function( c, wo, toggle ) {
			var namespace = c.namespace + 'tsresize';
			wo.resizable_vars.disabled = toggle;
			$( 'body' ).toggleClass( ts.css.resizableNoSelect, toggle );
			if ( toggle ) {
				$( 'body' )
					.attr( 'unselectable', 'on' )
					.bind( 'selectstart' + namespace, false );
			} else {
				$( 'body' )
					.removeAttr( 'unselectable' )
					.unbind( 'selectstart' + namespace );
			}
		},

		bindings : function( c, wo ) {
			var namespace = c.namespace + 'tsresize';
			wo.$resizable_container.children().bind( 'mousedown', function( event ) {
				// save header cell and mouse position
				var column,
					vars = wo.resizable_vars,
					$extras = $( c.namespace + '_extra_headers' ),
					$header = $( event.target ).data( 'header' );

				column = parseInt( $header.attr( 'data-column' ), 10 );
				vars.$target = $header = $header.add( $extras.filter('[data-column="' + column + '"]') );
				vars.target = column;

				// if table is not as wide as it's parent, then resize the table
				vars.$next = event.shiftKey || wo.resizable_targetLast ?
					$header.parent().children().not( '.resizable-false' ).filter( ':last' ) :
					$header.nextAll( ':not(.resizable-false)' ).eq( 0 );

				column = parseInt( vars.$next.attr( 'data-column' ), 10 );
				vars.$next = vars.$next.add( $extras.filter('[data-column="' + column + '"]') );
				vars.next = column;

				vars.mouseXPosition = event.pageX;
				ts.resizable.updateStoredSizes( c, wo );
				ts.resizable.toggleTextSelection(c, wo, true );
			});

			$( document )
				.bind( 'mousemove' + namespace, function( event ) {
					var vars = wo.resizable_vars;
					// ignore mousemove if no mousedown
					if ( !vars.disabled || vars.mouseXPosition === 0 || !vars.$target ) { return; }
					if ( wo.resizable_throttle ) {
						clearTimeout( vars.timer );
						vars.timer = setTimeout( function() {
							ts.resizable.mouseMove( c, wo, event );
						}, isNaN( wo.resizable_throttle ) ? 5 : wo.resizable_throttle );
					} else {
						ts.resizable.mouseMove( c, wo, event );
					}
				})
				.bind( 'mouseup' + namespace, function() {
					if (!wo.resizable_vars.disabled) { return; }
					ts.resizable.toggleTextSelection( c, wo, false );
					ts.resizable.stopResize( c, wo );
					ts.resizable.setHandlePosition( c, wo );
				});

			// resizeEnd event triggered by scroller widget
			$( window ).bind( 'resize' + namespace + ' resizeEnd' + namespace, function() {
				ts.resizable.setHandlePosition( c, wo );
			});

			// right click to reset columns to default widths
			c.$table
				.bind( 'columnUpdate pagerComplete resizableUpdate '.split( ' ' ).join( namespace + ' ' ), function() {
					ts.resizable.setHandlePosition( c, wo );
				})
				.bind( 'resizableReset' + namespace, function() {
					ts.resizableReset( c.table );
				})
				.find( 'thead:first' )
				.add( $( c.namespace + '_extra_table' ).find( 'thead:first' ) )
				.bind( 'contextmenu' + namespace, function() {
					// $.isEmptyObject() needs jQuery 1.4+; allow right click if already reset
					var allowClick = wo.resizable_vars.storedSizes.length === 0;
					ts.resizableReset( c.table );
					ts.resizable.setHandlePosition( c, wo );
					wo.resizable_vars.storedSizes = [];
					return allowClick;
				});

		},

		mouseMove : function( c, wo, event ) {
			if ( wo.resizable_vars.mouseXPosition === 0 || !wo.resizable_vars.$target ) { return; }
			// resize columns
			var column,
				total = 0,
				vars = wo.resizable_vars,
				$next = vars.$next,
				tar = vars.storedSizes[ vars.target ],
				leftEdge = event.pageX - vars.mouseXPosition;
			if ( vars.overflow ) {
				if ( tar + leftEdge > 0 ) {
					vars.storedSizes[ vars.target ] += leftEdge;
					ts.resizable.setWidth( vars.$target, vars.storedSizes[ vars.target ], true );
					// update the entire table width
					for ( column = 0; column < c.columns; column++ ) {
						total += vars.storedSizes[ column ];
					}
					ts.resizable.setWidth( c.$table.add( $( c.namespace + '_extra_table' ) ), total );
				}
				if ( !$next.length ) {
					// if expanding right-most column, scroll the wrapper
					vars.$wrap[0].scrollLeft = c.$table.width();
				}
			} else if ( vars.fullWidth ) {
				vars.storedSizes[ vars.target ] += leftEdge;
				vars.storedSizes[ vars.next ] -= leftEdge;
				ts.resizable.setWidths( c, wo );
			} else {
				vars.storedSizes[ vars.target ] += leftEdge;
				ts.resizable.setWidths( c, wo );
			}
			vars.mouseXPosition = event.pageX;
			// dynamically update sticky header widths
			c.$table.triggerHandler('stickyHeadersUpdate');
		},

		stopResize : function( c, wo ) {
			var vars = wo.resizable_vars;
			ts.resizable.updateStoredSizes( c, wo );
			if ( vars.useStorage ) {
				// save all column widths
				ts.storage( c.table, ts.css.resizableStorage, vars.storedSizes );
				ts.storage( c.table, 'tablesorter-table-resized-width', c.$table.width() );
			}
			vars.mouseXPosition = 0;
			vars.$target = vars.$next = null;
			// will update stickyHeaders, just in case, see #912
			c.$table.triggerHandler('stickyHeadersUpdate');
			c.$table.triggerHandler('resizableComplete');
		}
	};

	// this widget saves the column widths if
	// $.tablesorter.storage function is included
	// **************************
	ts.addWidget({
		id: 'resizable',
		priority: 40,
		options: {
			resizable : true, // save column widths to storage
			resizable_addLastColumn : false,
			resizable_includeFooter: true,
			resizable_widths : [],
			resizable_throttle : false, // set to true (5ms) or any number 0-10 range
			resizable_targetLast : false
		},
		init: function(table, thisWidget, c, wo) {
			ts.resizable.init( c, wo );
		},
		format: function( table, c, wo ) {
			ts.resizable.setHandlePosition( c, wo );
		},
		remove: function( table, c, wo, refreshing ) {
			if (wo.$resizable_container) {
				var namespace = c.namespace + 'tsresize';
				c.$table.add( $( c.namespace + '_extra_table' ) )
					.removeClass('hasResizable')
					.children( 'thead' )
					.unbind( 'contextmenu' + namespace );

				wo.$resizable_container.remove();
				ts.resizable.toggleTextSelection( c, wo, false );
				ts.resizableReset( table, refreshing );
				$( document ).unbind( 'mousemove' + namespace + ' mouseup' + namespace );
			}
		}
	});

	ts.resizableReset = function( table, refreshing ) {
		$( table ).each(function() {
			var index, $t,
				c = this.config,
				wo = c && c.widgetOptions,
				vars = wo.resizable_vars;
			if ( table && c && c.$headerIndexed.length ) {
				// restore the initial table width
				if ( vars.overflow && vars.tableWidth ) {
					ts.resizable.setWidth( c.$table, vars.tableWidth, true );
					if ( vars.useStorage ) {
						ts.storage( table, 'tablesorter-table-resized-width', vars.tableWidth );
					}
				}
				for ( index = 0; index < c.columns; index++ ) {
					$t = c.$headerIndexed[ index ];
					if ( wo.resizable_widths && wo.resizable_widths[ index ] ) {
						ts.resizable.setWidth( $t, wo.resizable_widths[ index ], vars.overflow );
					} else if ( !$t.hasClass( 'resizable-false' ) ) {
						// don't clear the width of any column that is not resizable
						ts.resizable.setWidth( $t, '', vars.overflow );
					}
				}

				// reset stickyHeader widths
				c.$table.triggerHandler( 'stickyHeadersUpdate' );
				if ( ts.storage && !refreshing ) {
					ts.storage( this, ts.css.resizableStorage, [] );
				}
			}
		});
	};

})( jQuery, window );

/*! Widget: saveSort - updated 2018-03-19 (v2.30.1) *//*
* Requires tablesorter v2.16+
* by Rob Garrison
*/
;(function ($) {
	'use strict';
	var ts = $.tablesorter || {};

	function getStoredSortList(c) {
		var stored = ts.storage( c.table, 'tablesorter-savesort' );
		return (stored && stored.hasOwnProperty('sortList') && $.isArray(stored.sortList)) ? stored.sortList : [];
	}

	function sortListChanged(c, sortList) {
		return (sortList || getStoredSortList(c)).join(',') !== c.sortList.join(',');
	}

	// this widget saves the last sort only if the
	// saveSort widget option is true AND the
	// $.tablesorter.storage function is included
	// **************************
	ts.addWidget({
		id: 'saveSort',
		priority: 20,
		options: {
			saveSort : true
		},
		init: function(table, thisWidget, c, wo) {
			// run widget format before all other widgets are applied to the table
			thisWidget.format(table, c, wo, true);
		},
		format: function(table, c, wo, init) {
			var time,
				$table = c.$table,
				saveSort = wo.saveSort !== false, // make saveSort active/inactive; default to true
				sortList = { 'sortList' : c.sortList },
				debug = ts.debug(c, 'saveSort');
			if (debug) {
				time = new Date();
			}
			if ($table.hasClass('hasSaveSort')) {
				if (saveSort && table.hasInitialized && ts.storage && sortListChanged(c)) {
					ts.storage( table, 'tablesorter-savesort', sortList );
					if (debug) {
						console.log('saveSort >> Saving last sort: ' + c.sortList + ts.benchmark(time));
					}
				}
			} else {
				// set table sort on initial run of the widget
				$table.addClass('hasSaveSort');
				sortList = '';
				// get data
				if (ts.storage) {
					sortList = getStoredSortList(c);
					if (debug) {
						console.log('saveSort >> Last sort loaded: "' + sortList + '"' + ts.benchmark(time));
					}
					$table.bind('saveSortReset', function(event) {
						event.stopPropagation();
						ts.storage( table, 'tablesorter-savesort', '' );
					});
				}
				// init is true when widget init is run, this will run this widget before all other widgets have initialized
				// this method allows using this widget in the original tablesorter plugin; but then it will run all widgets twice.
				if (init && sortList && sortList.length > 0) {
					c.sortList = sortList;
				} else if (table.hasInitialized && sortList && sortList.length > 0) {
					// update sort change
					if (sortListChanged(c, sortList)) {
						ts.sortOn(c, sortList);
					}
				}
			}
		},
		remove: function(table, c) {
			c.$table.removeClass('hasSaveSort');
			// clear storage
			if (ts.storage) { ts.storage( table, 'tablesorter-savesort', '' ); }
		}
	});

})(jQuery);

return jQuery.tablesorter;
}));


/***/ }),

/***/ "../../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./dashboard.js":
/*!**********************!*\
  !*** ./dashboard.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "../../../node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var bootstrap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bootstrap */ "../../../node_modules/bootstrap/dist/js/bootstrap.js");
/* harmony import */ var bootstrap__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bootstrap__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var sparkline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sparkline */ "../../../node_modules/sparkline/lib/sparkline.js");
/* harmony import */ var sparkline__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(sparkline__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var selectize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! selectize */ "../../../node_modules/selectize/dist/js/selectize.js");
/* harmony import */ var selectize__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(selectize__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var tablesorter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tablesorter */ "../../../node_modules/tablesorter/dist/js/jquery.tablesorter.combined.js");
/* harmony import */ var tablesorter__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(tablesorter__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var jvectormap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jvectormap */ "../../../node_modules/jvectormap/jquery-jvectormap.min.js");
/* harmony import */ var jvectormap__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(jvectormap__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var jquery_circle_progress__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! jquery-circle-progress */ "../../../node_modules/jquery-circle-progress/dist/circle-progress.js");
/* harmony import */ var jquery_circle_progress__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(jquery_circle_progress__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var c3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! c3 */ "../../../node_modules/c3/c3.js");
/* harmony import */ var c3__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(c3__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var jquery_mask_plugin__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! jquery-mask-plugin */ "../../../node_modules/jquery-mask-plugin/dist/jquery.mask.js");
/* harmony import */ var jquery_mask_plugin__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(jquery_mask_plugin__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core */ "./core.js");










window.c3 = c3__WEBPACK_IMPORTED_MODULE_7__;
window.$ = jquery__WEBPACK_IMPORTED_MODULE_0__;



/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9mbGV4L0xhYi90YWJsZXIvbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9kaXN0L2pzL2Jvb3RzdHJhcC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2ZsZXgvTGFiL3RhYmxlci9ub2RlX21vZHVsZXMvYzMvYzMuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9mbGV4L0xhYi90YWJsZXIvbm9kZV9tb2R1bGVzL2QzL2QzLmpzIiwid2VicGFjazovLy8vVXNlcnMvZmxleC9MYWIvdGFibGVyL25vZGVfbW9kdWxlcy9qcXVlcnktY2lyY2xlLXByb2dyZXNzL2Rpc3QvY2lyY2xlLXByb2dyZXNzLmpzIiwid2VicGFjazovLy8vVXNlcnMvZmxleC9MYWIvdGFibGVyL25vZGVfbW9kdWxlcy9qcXVlcnktbWFzay1wbHVnaW4vZGlzdC9qcXVlcnkubWFzay5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2ZsZXgvTGFiL3RhYmxlci9ub2RlX21vZHVsZXMvanZlY3Rvcm1hcC9qcXVlcnktanZlY3Rvcm1hcC5taW4uanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9mbGV4L0xhYi90YWJsZXIvbm9kZV9tb2R1bGVzL21pY3JvcGx1Z2luL3NyYy9taWNyb3BsdWdpbi5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2ZsZXgvTGFiL3RhYmxlci9ub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvZXNtL3BvcHBlci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2ZsZXgvTGFiL3RhYmxlci9ub2RlX21vZHVsZXMvc2VsZWN0aXplL2Rpc3QvanMvc2VsZWN0aXplLmpzIiwid2VicGFjazovLy8vVXNlcnMvZmxleC9MYWIvdGFibGVyL25vZGVfbW9kdWxlcy9zaWZ0ZXIvc2lmdGVyLmpzIiwid2VicGFjazovLy8vVXNlcnMvZmxleC9MYWIvdGFibGVyL25vZGVfbW9kdWxlcy9zcGFya2xpbmUvbGliL3NwYXJrbGluZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL2ZsZXgvTGFiL3RhYmxlci9ub2RlX21vZHVsZXMvdGFibGVzb3J0ZXIvZGlzdC9qcy9qcXVlcnkudGFibGVzb3J0ZXIuY29tYmluZWQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9kYXNoYm9hcmQuanMiXSwibmFtZXMiOlsid2luZG93IiwiYzMiLCIkIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFRLG9CQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0EsMEJBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxlQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKOztBQUVBO0FBQ0Esc0RBQThDO0FBQzlDO0FBQ0E7QUFDQSxvQ0FBNEI7QUFDNUIscUNBQTZCO0FBQzdCLHlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQTZCO0FBQzdCLHFDQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxlQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBaUIsdUNBQXVDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQWlCLHVDQUF1QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsZ0JBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFjLHdDQUF3QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBaUQsY0FBYztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBLDhDQUFzQyx1QkFBdUI7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQWdCLHVCQUF1QjtBQUN2Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUNpQztBQUNqQyxDQUFDLHFDQUFxQzs7QUFFdEM7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQyxpQ0FBaUM7O0FBRWpDLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87OztBQUdQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBLHdDQUF3Qzs7QUFFeEM7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsK0JBQStCO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsaUNBQWlDO0FBQ2pDLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QywyRUFBMkU7O0FBRW5IO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCLDJCQUEyQjs7QUFFM0Isd0JBQXdCOztBQUV4Qiw4QkFBOEI7O0FBRTlCLGdDQUFnQzs7QUFFaEMscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87OztBQUdQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyx5REFBeUQ7QUFDcEc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxFQUFFOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxFQUFFOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLGdGQUFnRjs7QUFFeEg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRFQUE0RTs7QUFFNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87OztBQUdQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMseUdBQXlHOztBQUUxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHNDQUFzQztBQUN0QztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7O0FBRTlDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxPQUFPOzs7QUFHUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxpQ0FBaUMsNkRBQTZEOztBQUU5RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQyxLQUFLO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxnREFBZ0Q7OztBQUdoRDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQSxrSUFBa0k7O0FBRWxJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxxQ0FBcUMsS0FBSztBQUMxQzs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELGNBQWM7O0FBRTlELENBQUM7QUFDRDs7Ozs7Ozs7Ozs7O0FDdDFIQTtBQUNBO0FBQ0E7QUFDQSxhQUNBO0FBQ0EsQ0FBQyxxQkFBcUI7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGVBQWU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1Q0FBdUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsNENBQTRDLHlEQUF5RDtBQUNyRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLGlCQUFpQjtBQUNqQixnQ0FBZ0M7QUFDaEMsaUJBQWlCLG9CQUFvQjtBQUNyQyw4RUFBOEU7QUFDOUU7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLGlCQUFpQjtBQUNqQixnQ0FBZ0M7QUFDaEMsaUJBQWlCLG9CQUFvQjtBQUNyQyw4RUFBOEU7QUFDOUU7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLGlCQUFpQjtBQUNqQixnQ0FBZ0M7QUFDaEMsaUJBQWlCLG9CQUFvQjtBQUNyQyw4RUFBOEU7QUFDOUU7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLGlCQUFpQjtBQUNqQixnQ0FBZ0M7QUFDaEMsaUJBQWlCLG9CQUFvQjtBQUNyQyw4RUFBOEU7QUFDOUU7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0EsaUJBQWlCO0FBQ2pCLGdDQUFnQztBQUNoQyxpQkFBaUIsb0JBQW9CO0FBQ3JDLG9GQUFvRjtBQUNwRjtBQUNBLGlCQUFpQjtBQUNqQixnQ0FBZ0M7QUFDaEMsaUJBQWlCLG9CQUFvQjtBQUNyQyxxRkFBcUY7QUFDckY7QUFDQSxpQkFBaUI7QUFDakIsa0NBQWtDO0FBQ2xDLGlCQUFpQixvQkFBb0I7QUFDckMscUZBQXFGO0FBQ3JGO0FBQ0EsaUJBQWlCO0FBQ2pCLGtDQUFrQztBQUNsQyxpQkFBaUIsb0JBQW9CO0FBQ3JDLHFGQUFxRjtBQUNyRjtBQUNBLGlCQUFpQjtBQUNqQixrQ0FBa0M7QUFDbEMsaUJBQWlCLG9CQUFvQjtBQUNyQyxxRkFBcUY7QUFDckY7QUFDQSxpQkFBaUI7QUFDakIsa0NBQWtDO0FBQ2xDLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0EsaUJBQWlCO0FBQ2pCLGdDQUFnQztBQUNoQyxpQkFBaUIsb0JBQW9CO0FBQ3JDLG9GQUFvRjtBQUNwRjtBQUNBLGlCQUFpQjtBQUNqQixnQ0FBZ0M7QUFDaEMsaUJBQWlCLG9CQUFvQjtBQUNyQyxxRkFBcUY7QUFDckY7QUFDQSxpQkFBaUI7QUFDakIsa0NBQWtDO0FBQ2xDLGlCQUFpQixvQkFBb0I7QUFDckMscUZBQXFGO0FBQ3JGO0FBQ0EsaUJBQWlCO0FBQ2pCLGtDQUFrQztBQUNsQyxpQkFBaUIsb0JBQW9CO0FBQ3JDLHFGQUFxRjtBQUNyRjtBQUNBLGlCQUFpQjtBQUNqQixrQ0FBa0M7QUFDbEMsaUJBQWlCLG9CQUFvQjtBQUNyQyxxRkFBcUY7QUFDckY7QUFDQSxpQkFBaUI7QUFDakIsa0NBQWtDO0FBQ2xDLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGlCQUFpQixvQkFBb0I7QUFDckMsd0ZBQXdGO0FBQ3hGO0FBQ0EsaUJBQWlCO0FBQ2pCLGdDQUFnQztBQUNoQyxpQkFBaUIsb0JBQW9CO0FBQ3JDLHlGQUF5RjtBQUN6RjtBQUNBLGlCQUFpQjtBQUNqQixrQ0FBa0M7QUFDbEMsaUJBQWlCLG9CQUFvQjtBQUNyQyx5RkFBeUY7QUFDekY7QUFDQSxpQkFBaUI7QUFDakIsa0NBQWtDO0FBQ2xDLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGlCQUFpQixvQkFBb0I7QUFDckMsd0ZBQXdGO0FBQ3hGO0FBQ0EsaUJBQWlCO0FBQ2pCLGdDQUFnQztBQUNoQyxpQkFBaUIsb0JBQW9CO0FBQ3JDLHlGQUF5RjtBQUN6RjtBQUNBLGlCQUFpQjtBQUNqQixrQ0FBa0M7QUFDbEMsaUJBQWlCLG9CQUFvQjtBQUNyQyx5RkFBeUY7QUFDekY7QUFDQSxpQkFBaUI7QUFDakIsa0NBQWtDO0FBQ2xDLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGlCQUFpQixvQkFBb0I7QUFDckMsMkVBQTJFO0FBQzNFO0FBQ0EsaUJBQWlCO0FBQ2pCLGdDQUFnQztBQUNoQyxpQkFBaUIsb0JBQW9CO0FBQ3JDLDRFQUE0RTtBQUM1RTtBQUNBLGlCQUFpQjtBQUNqQixrQ0FBa0M7QUFDbEMsaUJBQWlCLG9CQUFvQjtBQUNyQyw0RUFBNEU7QUFDNUU7QUFDQSxpQkFBaUI7QUFDakIsa0NBQWtDO0FBQ2xDLGlCQUFpQixvQkFBb0I7QUFDckMsK0VBQStFO0FBQy9FO0FBQ0EsaUJBQWlCO0FBQ2pCLHdDQUF3QztBQUN4QyxpQkFBaUIsb0JBQW9CO0FBQ3JDLHNGQUFzRjtBQUN0RjtBQUNBLGlCQUFpQjtBQUNqQixzREFBc0Q7QUFDdEQsaUJBQWlCLG9CQUFvQjtBQUNyQyxtRkFBbUY7QUFDbkY7QUFDQSxpQkFBaUI7QUFDakIsZ0RBQWdEO0FBQ2hELGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGlCQUFpQixvQkFBb0I7QUFDckMsMkVBQTJFO0FBQzNFO0FBQ0EsaUJBQWlCO0FBQ2pCLGdDQUFnQztBQUNoQyxpQkFBaUIsb0JBQW9CO0FBQ3JDLDRFQUE0RTtBQUM1RTtBQUNBLGlCQUFpQjtBQUNqQixrQ0FBa0M7QUFDbEMsaUJBQWlCLG9CQUFvQjtBQUNyQyw0RUFBNEU7QUFDNUU7QUFDQSxpQkFBaUI7QUFDakIsa0NBQWtDO0FBQ2xDLGlCQUFpQixvQkFBb0I7QUFDckMsK0VBQStFO0FBQy9FO0FBQ0EsaUJBQWlCO0FBQ2pCLHdDQUF3QztBQUN4QyxpQkFBaUIsb0JBQW9CO0FBQ3JDLHNGQUFzRjtBQUN0RjtBQUNBLGlCQUFpQjtBQUNqQixzREFBc0Q7QUFDdEQsaUJBQWlCLG9CQUFvQjtBQUNyQyxtRkFBbUY7QUFDbkY7QUFDQSxpQkFBaUI7QUFDakIsZ0RBQWdEO0FBQ2hELGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGlCQUFpQixvQkFBb0I7QUFDckMsMEZBQTBGO0FBQzFGO0FBQ0EsaUJBQWlCO0FBQ2pCLGdDQUFnQztBQUNoQyxpQkFBaUIsb0JBQW9CO0FBQ3JDLDJGQUEyRjtBQUMzRjtBQUNBLGlCQUFpQjtBQUNqQixrQ0FBa0M7QUFDbEMsaUJBQWlCLG9CQUFvQjtBQUNyQywyRkFBMkY7QUFDM0Y7QUFDQSxpQkFBaUI7QUFDakIsa0NBQWtDO0FBQ2xDLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGlCQUFpQixvQkFBb0I7QUFDckMsMEZBQTBGO0FBQzFGO0FBQ0EsaUJBQWlCO0FBQ2pCLGdDQUFnQztBQUNoQyxpQkFBaUIsb0JBQW9CO0FBQ3JDLDJGQUEyRjtBQUMzRjtBQUNBLGlCQUFpQjtBQUNqQixrQ0FBa0M7QUFDbEMsaUJBQWlCLG9CQUFvQjtBQUNyQywyRkFBMkY7QUFDM0Y7QUFDQSxpQkFBaUI7QUFDakIsa0NBQWtDO0FBQ2xDLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBLGlCQUFpQjtBQUNqQixnQ0FBZ0M7QUFDaEMsaUJBQWlCLG9CQUFvQjtBQUNyQyw4RkFBOEY7QUFDOUY7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBLGlCQUFpQjtBQUNqQixnQ0FBZ0M7QUFDaEMsaUJBQWlCLG9CQUFvQjtBQUNyQyw4RkFBOEY7QUFDOUY7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDLDJGQUEyRjtBQUMzRjtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckMscUdBQXFHO0FBQ3JHO0FBQ0EsaUJBQWlCLG9CQUFvQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0lBQW9JO0FBQ3BJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHNDQUFzQzs7QUFFNUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQXNEO0FBQzdFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVCQUF1QixzREFBc0Q7QUFDN0UsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qiw2RUFBNkU7QUFDekc7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLDBEQUEwRDs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLFNBQVM7QUFDVCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHVCQUF1Qix3RUFBd0U7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzQ0FBc0M7QUFDdEMsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHdFQUF3RTtBQUMzRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0VBQXdFO0FBQzNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZELHNCQUFzQjtBQUNuRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBc0Q7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQXNEO0FBQzdFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHVCQUF1Qix5REFBeUQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw2RUFBNkU7QUFDdkgsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixXQUFXO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsNERBQTREO0FBQzVELHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxnREFBZ0Q7QUFDaEQsNENBQTRDO0FBQzVDLDhDQUE4QztBQUM5Qyx3Q0FBd0M7QUFDeEMsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCw0REFBNEQ7QUFDNUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0NBQW9DLDJCQUEyQjtBQUMvRCx3REFBd0Q7QUFDeEQsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usd0JBQXdCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELHVDQUF1QztBQUN2QztBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHdFQUF3RTs7QUFFM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTLGtCQUFrQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTLGtCQUFrQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGlGQUFpRjtBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtDQUFrQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGNBQWM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixXQUFXO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQ0FBc0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7Ozs7Ozs7Ozs7O0FDem9TRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUsS0FBSztBQUNMLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLFNBQVM7QUFDL0YsNERBQTRELFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLHdFQUF3RTtBQUN4RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQsc0JBQXNCO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDLDRFQUE0RSxVQUFVO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0MsZ0VBQWdFLE9BQU87QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDLHdEQUF3RCxPQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxPQUFPO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsd0NBQXdDO0FBQzlGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRkFBaUY7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsRUFBRTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsNkJBQTZCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxRQUFRO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsT0FBTztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCLG9FQUFvRSxPQUFPO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQ0FBaUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4Qyx5QkFBeUIsOEJBQThCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4QkFBOEI7QUFDNUQ7QUFDQSwrQ0FBK0M7QUFDL0MsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlCQUFpQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCx3QkFBd0IsT0FBTztBQUMvQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw4QkFBOEI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsOEJBQThCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU8sMkRBQTJELGlCQUFpQixPQUFPO0FBQ25KO0FBQ0EseURBQXlELE9BQU8sMkRBQTJELGlCQUFpQixPQUFPO0FBQ25KO0FBQ0EsbURBQW1ELE9BQU8sbURBQW1ELGlCQUFpQixPQUFPO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QiwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsMkJBQTJCLE9BQU87QUFDbEMsdURBQXVELE9BQU87QUFDOUQsMEVBQTBFLE9BQU87QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsMEJBQTBCLE9BQU87QUFDakMsMEJBQTBCLE9BQU8seUJBQXlCLGlCQUFpQixPQUFPO0FBQ2xGO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsOEVBQThFLE9BQU87QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU0scUJBQXFCLE9BQU87QUFDbEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxnQkFBZ0IsUUFBUSxzQkFBc0IsT0FBTztBQUNyRDtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQSx5REFBeUQsU0FBUztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQSx5REFBeUQsU0FBUztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5Qyx5REFBeUQsU0FBUztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBLHdEQUF3RCxPQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCwwQkFBMEI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFBQTtBQUFBO0FBQUE7QUFBQSxxR0FBMkUsUUFBNEU7QUFDdkosQ0FBQyxHOzs7Ozs7Ozs7OztBQ2oxU0Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxHQUFHLGdCQVFIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0VBQWtFLDBCQUEwQjtBQUM1RixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLG1DQUFtQztBQUNsRDtBQUNBLGVBQWUsK0RBQStEO0FBQzlFLGVBQWUsMEVBQTBFO0FBQ3pGLGVBQWUsdURBQXVEO0FBQ3RFO0FBQ0EsZUFBZSwwQ0FBMEM7QUFDekQsZUFBZSxxQkFBcUI7QUFDcEMsZUFBZSx5REFBeUQ7QUFDeEU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHdGQUF3RjtBQUMzRyxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRSx3QkFBd0I7QUFDbEc7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RSwwQkFBMEI7QUFDdEc7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGdGQUFnRiwwQkFBMEI7QUFDMUc7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsdUNBQXVDLDZCQUE2QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQyxrQkFBa0IscUJBQXFCLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRCwyQkFBMkIsMEJBQTBCLHdCQUF3QixrQ0FBa0M7QUFDL0c7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsMENBQTBDO0FBQzFDLGlDQUFpQztBQUNqQyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs0RUN2aUJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsS0FBSyxRQUlMOztBQUVBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQSwrQkFBK0IsaUJBQWlCO0FBQ2hEOztBQUVBOztBQUVBLDRFQUE0RSxFQUFFLEtBQUssRUFBRTtBQUNyRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLG9GQUFvRjtBQUNwRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiwwQ0FBMEMsMENBQTBDO0FBQ3BGO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0QkFBNEI7QUFDekQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhELHFDQUFxQzs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxpQkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQyxrQkFBa0IsOEJBQThCO0FBQ2hELGtCQUFrQiwrQkFBK0I7QUFDakQsa0JBQWtCLHVCQUF1QjtBQUN6QyxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7Ozs7Ozs7Ozs7OztpREMzbEJELDZHQUFhLGVBQWUsS0FBSyw4RUFBOEUsTUFBTSwrREFBK0QsaUNBQWlDLGdGQUFnRiw4REFBOEQsS0FBSyxpT0FBaU8sbUJBQW1CLGlEQUFpRCxhQUFhLDJCQUEyQjtBQUFBO0FBQUE7QUFBQSwrR0FBaUksYUFBYSx3QkFBd0IsbUdBQW1HLDJpQkFBMmlCLDJCQUEyQixxREFBcUQsd0RBQXdELGdDQUFnQyxxREFBcUQsd0RBQXdELHF0QkFBcXRCLDJCQUEyQixpQkFBaUIsa0RBQWtELHdGQUF3Riw2UEFBNlAsMkNBQTJDLEVBQUUsaURBQWlELHdDQUF3QyxpQ0FBaUMsaURBQWlELEVBQUUsK0NBQStDLCtCQUErQixvSUFBb0kscUJBQXFCLG9EQUFvRCxFQUFFLGtEQUFrRCw0QkFBNEIsOEJBQThCLDZGQUE2Riw4QkFBOEIsd0JBQXdCLFdBQVcscUJBQXFCLGFBQWEsd0JBQXdCLGdFQUFnRSwyQkFBMkIscUNBQXFDLEVBQUUsRUFBRSxTQUFTLGdDQUFnQyxpQkFBaUIsb0hBQW9ILCtCQUErQixTQUFTLG9IQUFvSCxzQkFBc0IsMkJBQTJCLG1DQUFtQyxnQkFBZ0IsbUNBQW1DLG9EQUFvRCxXQUFXLHNCQUFzQiwyQkFBMkIsbUNBQW1DLGdCQUFnQixtQ0FBbUMsb0RBQW9ELFdBQVcsdUJBQXVCLGdCQUFnQixpQ0FBaUMsWUFBWSx5QkFBeUIsb0JBQW9CLFFBQVEsbUJBQW1CLEtBQUssb0JBQW9CLDJDQUEyQyxjQUFjLCtCQUErQixvREFBb0QsNEJBQTRCLGtCQUFrQixrQkFBa0Isc0JBQXNCLCtCQUErQix3QkFBd0IsWUFBWSxJQUFJLGFBQWEsaUdBQWlHLE1BQU0sbUVBQW1FLG9DQUFvQyxvQkFBb0Isb0JBQW9CLDRDQUE0Qyx5Q0FBeUMsTUFBTSxFQUFFLHlDQUF5QyxJQUFJLFNBQVMsNENBQTRDLG9FQUFvRSwwQkFBMEIsNERBQTRELFFBQVEsc0hBQXNILG9FQUFvRSxzREFBc0QsaUNBQWlDLGtFQUFrRSx1Q0FBdUMsaURBQWlELDBCQUEwQiw0REFBNEQsaU1BQWlNLGlFQUFpRSxxRUFBcUUsMEVBQTBFLDZEQUE2RCw2QkFBNkIsNEVBQTRFLCtEQUErRCw2QkFBNkIsMkVBQTJFLDhEQUE4RCw2QkFBNkIsMEVBQTBFLDZEQUE2RCw2QkFBNkIsb0VBQW9FLGdEQUFnRCwwR0FBMEcsc0RBQXNELG9CQUFvQiwwQ0FBMEMseURBQXlELHNFQUFzRSxjQUFjLDRIQUE0SCwyREFBMkQsYUFBYSxtWUFBbVksaUVBQWlFLFFBQVEsd0JBQXdCLHlGQUF5RiwyQkFBMkIsaURBQWlELDZKQUE2Siw4REFBOEQsdURBQXVELDBDQUEwQyxzREFBc0Qsc0JBQXNCLDZDQUE2QywyQkFBMkIsZ0NBQWdDLCtDQUErQyxzR0FBc0csb0NBQW9DLGlDQUFpQyxrTkFBa04sMktBQTJLLGtIQUFrSCxtRkFBbUYsNEpBQTRKLDJDQUEyQyxzR0FBc0csdUtBQXVLLGdDQUFnQywrTEFBK0wsMjFCQUEyMUIsNEVBQTRFLGlFQUFpRSwyQ0FBMkMsNEdBQTRHLGtHQUFrRyxrRUFBa0UsbUdBQW1HLGdFQUFnRSxvSEFBb0gsY0FBYyw0REFBNEQsaVVBQWlVLDBPQUEwTywyQ0FBMkMsOERBQThELGtIQUFrSCxtSEFBbUgsMkJBQTJCLCtHQUErRywySEFBMkgsSUFBSSxtSkFBbUosa0VBQWtFLFNBQVMseURBQXlELG1HQUFtRywyR0FBMkcsc0RBQXNELHNCQUFzQix1REFBdUQscUNBQXFDLHlEQUF5RCxzQkFBc0IsNkNBQTZDLDBCQUEwQixPQUFPLDhKQUE4SixnQ0FBZ0Msb0lBQW9JLHNHQUFzRyxvQ0FBb0MsaUNBQWlDLCtKQUErSiwyS0FBMksscUJBQXFCLDhMQUE4TCxpRkFBaUYsSUFBSSwwR0FBMEcsdUVBQXVFLElBQUksOEdBQThHLG1GQUFtRiwwT0FBME8sMkNBQTJDLG1UQUFtVCx1S0FBdUssYUFBYSxxQ0FBcUMsTUFBTSwyRUFBMkUsTUFBTSxnRkFBZ0YsTUFBTSwrRUFBK0UsTUFBTSwrRkFBK0YsTUFBTSw4REFBOEQsTUFBTSxtRkFBbUYsMkNBQTJDLHFDQUFxQyw0TUFBNE0sa0hBQWtILCtIQUErSCxnREFBZ0QsMEJBQTBCLG1KQUFtSix3SUFBd0ksNEJBQTRCLElBQUksd0NBQXdDLGVBQWUsZ0VBQWdFLDhEQUE4RCxnRUFBZ0UsOERBQThELGdEQUFnRCwwQ0FBMEMsNkNBQTZDLDBDQUEwQyw4SkFBOEosc0pBQXNKLGdOQUFnTiw4TUFBOE0sU0FBUyxvQkFBb0IsNkNBQTZDLGdFQUFnRSxzSEFBc0gsYUFBYSw2SkFBNkosTUFBTSwwQkFBMEIsbURBQW1ELE1BQU0sMEJBQTBCLGtEQUFrRCxNQUFNLG9GQUFvRixtREFBbUQsNk1BQTZNLGlDQUFpQyxpQkFBaUIsb0RBQW9ELGFBQWEsa0NBQWtDLGlCQUFpQixxREFBcUQseUJBQXlCLGdEQUFnRCxpQkFBaUIsa0NBQWtDLGdDQUFnQyxFQUFFLGFBQWEsc0VBQXNFLGdRQUFnUSw2QkFBNkIscUJBQXFCLCtGQUErRixzQkFBc0IsK0ZBQStGLDBCQUEwQixNQUFNLHNCQUFzQixlQUFlLDZCQUE2QixrQ0FBa0MsZ0RBQWdELDBCQUEwQixxSEFBcUgsMEJBQTBCLHFDQUFxQyx5RUFBeUUsc0JBQXNCLDJHQUEyRyxtREFBbUQsa0JBQWtCLG1CQUFtQiw2QkFBNkIscUJBQXFCLHdCQUF3Qix3TEFBd0wsOEJBQThCLFlBQVksUUFBUSxnQkFBZ0IsK0RBQStELFdBQVcsMENBQTBDLGdCQUFnQixRQUFRLGlCQUFpQixvQ0FBb0MsY0FBYyxxQ0FBcUMsZ0JBQWdCLFFBQVEsaUJBQWlCLG9DQUFvQyxjQUFjLGlDQUFpQyxnQkFBZ0IsUUFBUSxnQkFBZ0IsNEJBQTRCLGNBQWMsK0JBQStCLGVBQWUsUUFBUSxnQkFBZ0IsZ0NBQWdDLHlCQUF5QixxQkFBcUIseUtBQXlLLDZKQUE2SixnQkFBZ0IsMEZBQTBGLGtDQUFrQyxhQUFhLGNBQWMsMkJBQTJCLGlEQUFpRCxpR0FBaUcsTUFBTSxRQUFRLGVBQWUsc0RBQXNELG1EQUFtRCwrRkFBK0Ysd0NBQXdDLGdCQUFnQixRQUFRLFlBQVksa0RBQWtELFdBQVcsdUNBQXVDLHlCQUF5QixhQUFhLGFBQWEsY0FBYyx5Q0FBeUMsa0hBQWtILDZCQUE2QixzQkFBc0Isb1RBQW9ULHdDQUF3QyxxSEFBcUgsb0tBQW9LLGVBQWUsS0FBSyw4SkFBOEoscUlBQXFJLE1BQU0scURBQXFELE1BQU0sdUZBQXVGLE1BQU0sNkJBQTZCLGlRQUFpUSxtQkFBbUIsZ05BQWdOLGtEQUFrRCw4Q0FBOEMscUJBQXFCLGlCQUFpQix3ZkFBd2YsdUZBQXVGLHlCQUF5Qix1QkFBdUIsMkJBQTJCLGlDQUFpQyxtQkFBbUIsb0dBQW9HLG9IQUFvSCw0QkFBNEIsK0RBQStELHNOQUFzTixLQUFLLDhKQUE4Six3T0FBd08sMEtBQTBLLDJEQUEyRCxrQkFBa0IsaUJBQWlCLDhIQUE4SCx5Q0FBeUMsMEJBQTBCLG9FQUFvRSxrQ0FBa0MsNkVBQTZFLFdBQVcscUVBQXFFLHNCQUFzQiwwQkFBMEIsT0FBTyxpR0FBaUcsMEJBQTBCLE9BQU8sdUhBQXVILDBCQUEwQixPQUFPLGdHQUFnRywwQkFBMEIsT0FBTyxnSEFBZ0gseUJBQXlCLHVTQUF1UyxPQUFPLDBFQUEwRSxtQ0FBbUMsd1NBQXdTLE9BQU8sa0ZBQWtGLHlCQUF5QixnWEFBZ1gsT0FBTyxvR0FBb0csbUNBQW1DLDZZQUE2WSxPQUFPLGdHQUFnRywyQkFBMkIsb0RBQW9ELFNBQVMsaUhBQWlILHVEQUF1RCxZQUFZLG9OQUFvTix3REFBd0QscUxBQXFMLDBEQUEwRCxnUEFBZ1AsNkNBQTZDLGdEQUFnRCwyQ0FBMkMsb0RBQW9ELDZCQUE2QixzQkFBc0IsOEVBQThFLHNDQUFzQztBQUNwbStCLDZMQUE2TCxvSEFBb0gsb0dBQW9HLDRGQUE0Riw0QkFBNEIsd0hBQXdILEVBQUUsNkJBQTZCLFNBQVMseVdBQXlXLDJFQUEyRSxvR0FBb0csb0ZBQW9GLGNBQWMsb0dBQW9HLG1FQUFtRSxtS0FBbUssMkJBQTJCLEVBQUUscURBQXFELDRCQUE0Qix5TkFBeU4sRUFBRSxrREFBa0QsWUFBWSw4TkFBOE4sdUNBQXVDLDBCQUEwQixlQUFlLGlDQUFpQywySUFBMkksMERBQTBELGdCQUFnQixzQkFBc0Isb0JBQW9CLG9VQUFvVSxpQkFBaUIscUNBQXFDLGtIQUFrSCxtY0FBbWMsb0dBQW9HLDJCQUEyQiwyREFBMkQsNEJBQTRCLG9oQkFBb2hCLG9CQUFvQiw4SEFBOEgsdURBQXVELG1CQUFtQixnQ0FBZ0Msd2NBQXdjLHVCQUF1QixzSkFBc0osa0JBQWtCLFVBQVUsK0JBQStCLDBCQUEwQixnQ0FBZ0Msd0dBQXdHLDJCQUEyQiw0Q0FBNEMsMjVCQUEyNUIsZ0NBQWdDLDRDQUE0Qyw2REFBNkQsZ0tBQWdLLHdCQUF3Qix5REFBeUQscUNBQXFDLGFBQWEscUhBQXFILDZMQUE2TCx1RkFBdUYsRUFBRSxxQ0FBcUMsdUlBQXVJLHFFQUFxRSwrc0NBQStzQyxtSEFBbUgsdUNBQXVDLGdHQUFnRyxnQ0FBZ0MsZ0NBQWdDLHdCQUF3QiwwV0FBMFcsMkpBQTJKLDhCQUE4QixvQ0FBb0MscUNBQXFDLG1FQUFtRSwyRkFBMkYsNGNBQTRjLDBZQUEwWSxrRkFBa0YsMENBQTBDLCtFQUErRSxxV0FBcVcsb1NBQW9TLEVBQUUsNEJBQTRCLGFBQWEsOElBQThJLHVGQUF1RiwrRkFBK0YsOERBQThELCtGQUErRixFQUFFLHNCQUFzQixhQUFhLGlIQUFpSCw4REFBOEQsK0RBQStELGtCQUFrQixFQUFFLEVBQUUsNkRBQTZELHdRQUF3USwrd0JBQSt3QiwyUkFBMlIsb0xBQW9MLDJCQUEyQix3Q0FBd0Msb0JBQW9CLG1GQUFtRixRQUFRLGVBQWUsaUpBQWlKLCtPQUErTyxpQkFBaUIsK0lBQStJLGdVQUFnVSw0QkFBNEIsb0JBQW9CLDZFQUE2RSxnQkFBZ0IsK0JBQStCLG1DQUFtQywrQkFBK0IsbUNBQW1DLGlDQUFpQyxNQUFNLG9FQUFvRSxjQUFjLGdEQUFnRCxnRUFBZ0UsbUNBQW1DLGlDQUFpQyxtQ0FBbUMsaUNBQWlDLDhCQUE4QixlQUFlLGlDQUFpQyxRQUFRLGtCQUFrQiwyQkFBMkIsOEJBQThCLGlDQUFpQyw4QkFBOEIsaUNBQWlDLDhCQUE4Qix5QkFBeUIsWUFBWSw4QkFBOEIscUNBQXFDLDBCQUEwQix3QkFBd0Isc0VBQXNFLHFEQUFxRCw0RUFBNEUsdURBQXVELHVLQUF1Syw2REFBNkQsNEhBQTRILHFCQUFxQiwrQ0FBK0MsaUNBQWlDLHNEQUFzRCx1TUFBdU0sS0FBSyxzQkFBc0IsK0JBQStCLDBEQUEwRCxrQkFBa0IsMkZBQTJGLGlDQUFpQywwQkFBMEIsK0JBQStCLCtCQUErQiw2TkFBNk4sNkRBQTZELDZIQUE2SCw0REFBNEQsbUNBQW1DLEVBQUUsOEJBQThCLFlBQVkseUhBQXlILHNCQUFzQixFQUFFLDZCQUE2QixRQUFRLHdFQUF3RSx3RUFBd0UsMENBQTBDLDJHQUEyRyx1SEFBdUgsMkNBQTJDLHVCQUF1QixtQ0FBbUMsNEJBQTRCLG9CQUFvQixhQUFhLGtGQUFrRiw4QkFBOEIseUNBQXlDLE1BQU0sOERBQThELG9CQUFvQixzREFBc0QsRUFBRSxpQ0FBaUMsTUFBTSxRQUFRLGlCQUFpQiw4RUFBOEUsNkJBQTZCLGlCQUFpQixzQ0FBc0MsNEJBQTRCLGlDQUFpQyx3R0FBd0csc1RBQXNULDZHQUE2RyxLQUFLLDZCQUE2QixzSkFBc0osUUFBUSxnQkFBZ0IsOFhBQThYLFNBQVMsZ0NBQWdDLHVEQUF1RCxRQUFRLGdCQUFnQiwrRkFBK0YseUJBQXlCLFVBQVUsYUFBYSx1QkFBdUIsc0NBQXNDLGlDQUFpQyxzRkFBc0YsbUJBQW1CLGdKQUFnSixnQkFBZ0Isd0JBQXdCLHdPQUF3TyxTQUFTLGdGQUFnRixRQUFRLG1DQUFtQyxXQUFXLGNBQWMsa0JBQWtCLG1CQUFtQixTQUFTLDRGQUE0RixRQUFRLGtCQUFrQixjQUFjLFNBQVMsc0ZBQXNGLFFBQVEsaURBQWlELFdBQVcsWUFBWSxrQkFBa0IsbUJBQW1CLFNBQVMsNEZBQTRGLFFBQVEsbUJBQW1CLG9CQUFvQixrVUFBa1UsK0JBQStCLGNBQWMsWUFBWSwrQkFBK0IscUlBQXFJLHFMQUFxTCw0QkFBNEIsb0JBQW9CLHFLQUFxSyxjQUFjLGtIQUFrSCx5QkFBeUIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsRUFBRSwwRkFBMEYsY0FBYyxxR0FBcUcsV0FBVyxrQkFBa0IsK0VBQStFLDJHQUEyRyxrQkFBa0IsNEJBQTRCLHdDQUF3QywrR0FBK0csNENBQTRDLFlBQVksa0JBQWtCLFdBQVcsK0JBQStCLCtGQUErRix1QkFBdUIseUNBQXlDLDZCQUE2Qix5REFBeUQsb0NBQW9DLG9CQUFvQix1R0FBdUcsNkdBQTZHLHlEQUF5RCw0REFBNEQsRUFBRSxtQkFBbUIsd0ZBQXdGLHFCQUFxQiw2QkFBNkIsa0JBQWtCLDBKQUEwSiw2QkFBNkIsRUFBRSxHQUFHLDZCQUE2QixzQ0FBc0MsK0RBQStELHNDQUFzQyw2Rjs7Ozs7Ozs7Ozs7O0FDRHY3d0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSxFQUFFLFFBSUY7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5QkFBeUIsR0FBRyx5QkFBeUI7QUFDOUQ7QUFDQTtBQUNBLFFBQVEsTUFBTSxNQUFNLFFBQVEsTUFBTSxRQUFRO0FBQzFDO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxHOzs7Ozs7Ozs7Ozs7O0FDdElEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGtDQUFrQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7OztBQU1EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGdCQUFnQjs7QUFFdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQix5REFBeUQ7O0FBRTlFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0IsMkJBQTJCO0FBQzNCLGdDQUFnQzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLFFBQVE7QUFDdEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsY0FBYztBQUM1QjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCOztBQUVBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsT0FBTztBQUNyQixhQUFhLFdBQVc7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFlBQVk7QUFDMUIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxJQUFJO0FBQ0o7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsWUFBWTtBQUN6QixhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZCw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixpREFBaUQsdUNBQXVDLGtEQUFrRDtBQUMxSSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3Y5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxFQUFFLFFBSUY7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0NBQWdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLElBQUk7QUFDaEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksTUFBTTtBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBDQUEwQyxnQ0FBZ0M7O0FBRTFFO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0RBQStELGtEQUFrRCxFQUFFO0FBQ25ILG9FQUFvRSxtREFBbUQsRUFBRTtBQUN6SCxzRUFBc0UsaURBQWlELEVBQUU7QUFDekg7O0FBRUE7QUFDQSw0QkFBNEIsZ0RBQWdELEVBQUU7QUFDOUUsNEJBQTRCLDRDQUE0QztBQUN4RSxJQUFJOztBQUVKO0FBQ0EsNkJBQTZCLHFCQUFxQixFQUFFO0FBQ3BELDRCQUE0Qiw4Q0FBOEMsRUFBRTtBQUM1RSw0QkFBNEIsNENBQTRDLEVBQUU7QUFDMUUsNEJBQTRCLCtDQUErQyxFQUFFO0FBQzdFLDRCQUE0Qix1Q0FBdUMsRUFBRTtBQUNyRSw0QkFBNEIsMkNBQTJDLEVBQUU7QUFDekUsNEJBQTRCLHlCQUF5Qiw0Q0FBNEMsRUFBRTtBQUNuRyw0QkFBNEIsNENBQTRDO0FBQ3hFLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBOztBQUVBLHFDQUFxQztBQUNyQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0NBQWtDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0NBQWtDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLHlCQUF5QjtBQUNyRSxLQUFLO0FBQ0wsNENBQTRDLHNCQUFzQjtBQUNsRTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGtFQUFrRTtBQUM5RjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMENBQTBDO0FBQ3RFO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxzQkFBc0I7QUFDaEY7QUFDQSxJQUFJO0FBQ0osOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGFBQWE7QUFDekU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RCxJQUFJO0FBQ0o7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsSUFBSTtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1Q0FBdUM7QUFDOUQ7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixlQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUzs7QUFFakMsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0NBQWtDO0FBQzdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDZEQUE2RDtBQUM3RCxvREFBb0Q7QUFDcEQsOENBQThDO0FBQzlDLG1EQUFtRDtBQUNuRCwwREFBMEQ7QUFDMUQsbURBQW1EO0FBQ25ELDhDQUE4QztBQUM5Qyx5REFBeUQ7QUFDekQsbURBQW1EO0FBQ25ELDhDQUE4QztBQUM5QyxzREFBc0Q7QUFDdEQsZ0RBQWdEO0FBQ2hELDhDQUE4QztBQUM5Qyx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELGlEQUFpRDtBQUNqRCxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QyxNQUFNO0FBQ047QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWSxrQkFBa0IsV0FBVyxVQUFVLGNBQWMsd0JBQXdCLGFBQWE7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0EsQ0FBQyxHOzs7Ozs7Ozs7Ozt5Q0N4bkdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsRUFBRSxRQUlGO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxPQUFPO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUNBQW1DO0FBQ3ZEO0FBQ0EsR0FBRztBQUNILGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUMsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7OztBQ2hmRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87O0FBRXZCLGVBQWUsb0JBQW9CO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHlGQUEyQyxrQkFBa0IsRUFBRTtBQUFBO0FBQy9EO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7QUNuREQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLEVBQUUsUUFJRjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RCxNQUFNO0FBQzdEO0FBQ0E7O0FBRUEsd0JBQXdCLFFBQVEsc0NBQXNDLEVBQUUsUUFBUSxlQUFlLEtBQUs7QUFDcEcsa0VBQWtFLGlCQUFpQixFQUFFO0FBQ3JGLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSw0REFBNEQ7QUFDNUQsd0RBQXdELG1CQUFtQjtBQUMzRSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRixzRUFBc0U7O0FBRXRFLGdGQUFnRixLQUFLO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2Q7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDLHdCQUF3QixNQUFNO0FBQzlCLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsWUFBWTs7QUFFWjtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0JBQW9CLDZDQUE2QztBQUNqRTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxpQ0FBaUM7QUFDakM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxvQkFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxRQUFRO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRCxnQkFBZ0I7QUFDaEI7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQ7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QywwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBOEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGlDQUFpQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkMsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLG1DQUFtQyx1RUFBdUU7QUFDMUcsbUNBQW1DLHFFQUFxRTtBQUN4RztBQUNBLEdBQUc7O0FBRUg7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLG1DQUFtQyxxRUFBcUU7QUFDeEcsbUNBQW1DLHVFQUF1RTtBQUMxRztBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0EsbUNBQW1DLHVFQUF1RTtBQUMxRyxtQ0FBbUMscUVBQXFFO0FBQ3hHLHNCQUFzQixvQ0FBb0M7QUFDMUQsc0JBQXNCLG9DQUFvQztBQUMxRDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLG1DQUFtQyxxRUFBcUU7QUFDeEcsbUNBQW1DLHVFQUF1RTtBQUMxRyxzQkFBc0Isb0NBQW9DO0FBQzFELHNCQUFzQixvQ0FBb0M7QUFDMUQ7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0JBQW9CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsaURBQWlELFlBQVk7QUFDN0QsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQ0FBbUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2QkFBNkI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSixvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQSx5QkFBeUIsRUFBRSxTQUFTLElBQUksU0FBUyxJQUFJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRix3Q0FBd0M7QUFDeEMsb0NBQW9DLEtBQUssU0FBUyxJQUFJLFNBQVMsRUFBRSxRQUFRLElBQUksSUFBSSxFQUFFLEtBQUssRUFBRTtBQUMxRixpQ0FBaUMsSUFBSSxTQUFTLEtBQUssTUFBTSxFQUFFO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGLDhEQUE4RDtBQUM5RCxnQ0FBZ0MsSUFBSSxTQUFTLElBQUksU0FBUyxFQUFFLE9BQU8sRUFBRSxTQUFTLElBQUksU0FBUyxJQUFJO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixJQUFJLFdBQVcsSUFBSSxXQUFXLEVBQUU7QUFDOUQsOEJBQThCLEVBQUUsV0FBVyxJQUFJLFdBQVcsSUFBSTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RCx1RUFBdUU7QUFDdkU7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLEVBQUU7O0FBRUYsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7O0FBRUEsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLDhDQUE4QztBQUM5QyxvRkFBb0Ysb0NBQW9DO0FBQ3hIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtDQUFrQztBQUN4RCxxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixZQUFZO0FBQ2hHO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsQ0FBQzs7QUFFRDtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4QkFBOEI7QUFDckQsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhCQUE4QjtBQUNyRCxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLEtBQUs7QUFDTCwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLEVBQUU7O0FBRUYsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQSw4REFBOEQsTUFBTTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNENBQTRDLE1BQU0saUNBQWlDLEdBQUcsR0FBRyxNQUFNLEdBQUc7QUFDOUgsNEJBQTRCO0FBQzVCO0FBQ0Esc0VBQXNFO0FBQ3RFLHFDQUFxQyxPQUFPLDREQUE0RDtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0NBQXNDLGdEQUFnRDtBQUNqSDtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5Qix3QkFBd0IsOEJBQThCO0FBQ3RELHVFQUF1RTtBQUN2RTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLElBQUk7QUFDbkQsK0RBQStEO0FBQy9ELCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RSwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsRUFBRTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUIsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNILDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLElBQUksTUFBTTtBQUNwQztBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxHQUFHO0FBQ3pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCLGtEQUFrRCxNQUFNO0FBQ3hELHNEQUFzRCxFQUFFLEtBQUssRUFBRTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWEsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0NBQXNDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBLCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHdCQUF3QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGdCQUFnQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSxtRUFBbUU7QUFDbkU7O0FBRUE7QUFDQSxNQUFNO0FBQ04scUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxJQUFJO0FBQ0osd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0NBQWtDLFFBQVEsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdEQUFnRDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0QkFBNEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFCQUFxQixFQUFFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUJBQXVCLDZCQUE2QjtBQUMvRiw4QkFBOEIsMkJBQTJCLG1CQUFtQixFQUFFO0FBQzlFLHdDQUF3QyxvQkFBb0IsYUFBYSxFQUFFO0FBQzNFO0FBQ0EscUNBQXFDLG9CQUFvQix1QkFBdUIsWUFBWTtBQUM1RixjQUFjLG1CQUFtQixZQUFZLG1CQUFtQix3QkFBd0IsRUFBRTtBQUMxRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVEsRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsUUFBUTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHOztBQUVIO0FBQ0EsZ0ZBQWdGLFFBQVE7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpREFBaUQ7QUFDckU7QUFDQSxFQUFFOztBQUVGLENBQUM7O0FBRUQ7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7QUMzN0xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQUEsT0FBT0MsRUFBUCxHQUFZLCtCQUFaO0FBQ0FELE9BQU9FLENBQVAsR0FBVyxtQ0FBWCIsImZpbGUiOiJqcy9kYXNoYm9hcmQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBpbnN0YWxsIGEgSlNPTlAgY2FsbGJhY2sgZm9yIGNodW5rIGxvYWRpbmdcbiBcdGZ1bmN0aW9uIHdlYnBhY2tKc29ucENhbGxiYWNrKGRhdGEpIHtcbiBcdFx0dmFyIGNodW5rSWRzID0gZGF0YVswXTtcbiBcdFx0dmFyIG1vcmVNb2R1bGVzID0gZGF0YVsxXTtcbiBcdFx0dmFyIGV4ZWN1dGVNb2R1bGVzID0gZGF0YVsyXTtcbiBcdFx0Ly8gYWRkIFwibW9yZU1vZHVsZXNcIiB0byB0aGUgbW9kdWxlcyBvYmplY3QsXG4gXHRcdC8vIHRoZW4gZmxhZyBhbGwgXCJjaHVua0lkc1wiIGFzIGxvYWRlZCBhbmQgZmlyZSBjYWxsYmFja1xuIFx0XHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwLCByZXNvbHZlcyA9IFtdO1xuIFx0XHRmb3IoO2kgPCBjaHVua0lkcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdGNodW5rSWQgPSBjaHVua0lkc1tpXTtcbiBcdFx0XHRpZihpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcbiBcdFx0XHRcdHJlc29sdmVzLnB1c2goaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdWzBdKTtcbiBcdFx0XHR9XG4gXHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcbiBcdFx0fVxuIFx0XHRmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuIFx0XHRcdFx0bW9kdWxlc1ttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0fVxuIFx0XHR9XG4gXHRcdGlmKHBhcmVudEpzb25wRnVuY3Rpb24pIHBhcmVudEpzb25wRnVuY3Rpb24oZGF0YSk7XG4gXHRcdHdoaWxlKHJlc29sdmVzLmxlbmd0aCkge1xuIFx0XHRcdHJlc29sdmVzLnNoaWZ0KCkoKTtcbiBcdFx0fVxuXG4gXHRcdC8vIGFkZCBlbnRyeSBtb2R1bGVzIGZyb20gbG9hZGVkIGNodW5rIHRvIGRlZmVycmVkIGxpc3RcbiBcdFx0ZGVmZXJyZWRNb2R1bGVzLnB1c2guYXBwbHkoZGVmZXJyZWRNb2R1bGVzLCBleGVjdXRlTW9kdWxlcyB8fCBbXSk7XG5cbiBcdFx0Ly8gcnVuIGRlZmVycmVkIG1vZHVsZXMgd2hlbiBhbGwgY2h1bmtzIHJlYWR5XG4gXHRcdHJldHVybiBjaGVja0RlZmVycmVkTW9kdWxlcygpO1xuIFx0fTtcbiBcdGZ1bmN0aW9uIGNoZWNrRGVmZXJyZWRNb2R1bGVzKCkge1xuIFx0XHR2YXIgcmVzdWx0O1xuIFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGVmZXJyZWRNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0dmFyIGRlZmVycmVkTW9kdWxlID0gZGVmZXJyZWRNb2R1bGVzW2ldO1xuIFx0XHRcdHZhciBmdWxmaWxsZWQgPSB0cnVlO1xuIFx0XHRcdGZvcih2YXIgaiA9IDE7IGogPCBkZWZlcnJlZE1vZHVsZS5sZW5ndGg7IGorKykge1xuIFx0XHRcdFx0dmFyIGRlcElkID0gZGVmZXJyZWRNb2R1bGVbal07XG4gXHRcdFx0XHRpZihpbnN0YWxsZWRDaHVua3NbZGVwSWRdICE9PSAwKSBmdWxmaWxsZWQgPSBmYWxzZTtcbiBcdFx0XHR9XG4gXHRcdFx0aWYoZnVsZmlsbGVkKSB7XG4gXHRcdFx0XHRkZWZlcnJlZE1vZHVsZXMuc3BsaWNlKGktLSwgMSk7XG4gXHRcdFx0XHRyZXN1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IGRlZmVycmVkTW9kdWxlWzBdKTtcbiBcdFx0XHR9XG4gXHRcdH1cbiBcdFx0cmV0dXJuIHJlc3VsdDtcbiBcdH1cbiBcdGZ1bmN0aW9uIGhvdERpc3Bvc2VDaHVuayhjaHVua0lkKSB7XG4gXHRcdGRlbGV0ZSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG4gXHR9XG4gXHR2YXIgcGFyZW50SG90VXBkYXRlQ2FsbGJhY2sgPSB3aW5kb3dbXCJ3ZWJwYWNrSG90VXBkYXRlXCJdO1xuIFx0d2luZG93W1wid2VicGFja0hvdFVwZGF0ZVwiXSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0ZnVuY3Rpb24gd2VicGFja0hvdFVwZGF0ZUNhbGxiYWNrKGNodW5rSWQsIG1vcmVNb2R1bGVzKSB7XG4gXHRcdGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKTtcbiBcdFx0aWYgKHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrKSBwYXJlbnRIb3RVcGRhdGVDYWxsYmFjayhjaHVua0lkLCBtb3JlTW9kdWxlcyk7XG4gXHR9IDtcblxuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpIHtcbiBcdFx0dmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG4gXHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuIFx0XHRzY3JpcHQuY2hhcnNldCA9IFwidXRmLThcIjtcbiBcdFx0c2NyaXB0LnNyYyA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIFwiXCIgKyBjaHVua0lkICsgXCIuXCIgKyBob3RDdXJyZW50SGFzaCArIFwiLmhvdC11cGRhdGUuanNcIjtcbiBcdFx0O1xuIFx0XHRoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gXHR9XG5cbiBcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0ZnVuY3Rpb24gaG90RG93bmxvYWRNYW5pZmVzdChyZXF1ZXN0VGltZW91dCkge1xuIFx0XHRyZXF1ZXN0VGltZW91dCA9IHJlcXVlc3RUaW1lb3V0IHx8IDEwMDAwO1xuIFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gXHRcdFx0aWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gXCJ1bmRlZmluZWRcIilcbiBcdFx0XHRcdHJldHVybiByZWplY3QobmV3IEVycm9yKFwiTm8gYnJvd3NlciBzdXBwb3J0XCIpKTtcbiBcdFx0XHR0cnkge1xuIFx0XHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiBcdFx0XHRcdHZhciByZXF1ZXN0UGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIFwiXCIgKyBob3RDdXJyZW50SGFzaCArIFwiLmhvdC11cGRhdGUuanNvblwiO1xuIFx0XHRcdFx0cmVxdWVzdC5vcGVuKFwiR0VUXCIsIHJlcXVlc3RQYXRoLCB0cnVlKTtcbiBcdFx0XHRcdHJlcXVlc3QudGltZW91dCA9IHJlcXVlc3RUaW1lb3V0O1xuIFx0XHRcdFx0cmVxdWVzdC5zZW5kKG51bGwpO1xuIFx0XHRcdH0gY2F0Y2ggKGVycikge1xuIFx0XHRcdFx0cmV0dXJuIHJlamVjdChlcnIpO1xuIFx0XHRcdH1cbiBcdFx0XHRyZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuIFx0XHRcdFx0aWYgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkgcmV0dXJuO1xuIFx0XHRcdFx0aWYgKHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XG4gXHRcdFx0XHRcdC8vIHRpbWVvdXRcbiBcdFx0XHRcdFx0cmVqZWN0KFxuIFx0XHRcdFx0XHRcdG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIHRpbWVkIG91dC5cIilcbiBcdFx0XHRcdFx0KTtcbiBcdFx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDQwNCkge1xuIFx0XHRcdFx0XHQvLyBubyB1cGRhdGUgYXZhaWxhYmxlXG4gXHRcdFx0XHRcdHJlc29sdmUoKTtcbiBcdFx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyAhPT0gMzA0KSB7XG4gXHRcdFx0XHRcdC8vIG90aGVyIGZhaWx1cmVcbiBcdFx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIGZhaWxlZC5cIikpO1xuIFx0XHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdFx0Ly8gc3VjY2Vzc1xuIFx0XHRcdFx0XHR0cnkge1xuIFx0XHRcdFx0XHRcdHZhciB1cGRhdGUgPSBKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiBcdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuIFx0XHRcdFx0XHRcdHJlamVjdChlKTtcbiBcdFx0XHRcdFx0XHRyZXR1cm47XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0cmVzb2x2ZSh1cGRhdGUpO1xuIFx0XHRcdFx0fVxuIFx0XHRcdH07XG4gXHRcdH0pO1xuIFx0fVxuXG4gXHR2YXIgaG90QXBwbHlPblVwZGF0ZSA9IHRydWU7XG4gXHR2YXIgaG90Q3VycmVudEhhc2ggPSBcImUzNjUxMjkwMjU2YzcyNzk5YjQ1XCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdHZhciBob3RSZXF1ZXN0VGltZW91dCA9IDEwMDAwO1xuIFx0dmFyIGhvdEN1cnJlbnRNb2R1bGVEYXRhID0ge307XG4gXHR2YXIgaG90Q3VycmVudENoaWxkTW9kdWxlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gXHR2YXIgaG90Q3VycmVudFBhcmVudHMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0dmFyIGhvdEN1cnJlbnRQYXJlbnRzVGVtcCA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiBcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0ZnVuY3Rpb24gaG90Q3JlYXRlUmVxdWlyZShtb2R1bGVJZCkge1xuIFx0XHR2YXIgbWUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0aWYgKCFtZSkgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX187XG4gXHRcdHZhciBmbiA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiBcdFx0XHRpZiAobWUuaG90LmFjdGl2ZSkge1xuIFx0XHRcdFx0aWYgKGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0pIHtcbiBcdFx0XHRcdFx0aWYgKGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKSA9PT0gLTEpXG4gXHRcdFx0XHRcdFx0aW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XS5wYXJlbnRzLnB1c2gobW9kdWxlSWQpO1xuIFx0XHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xuIFx0XHRcdFx0XHRob3RDdXJyZW50Q2hpbGRNb2R1bGUgPSByZXF1ZXN0O1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0aWYgKG1lLmNoaWxkcmVuLmluZGV4T2YocmVxdWVzdCkgPT09IC0xKSBtZS5jaGlsZHJlbi5wdXNoKHJlcXVlc3QpO1xuIFx0XHRcdH0gZWxzZSB7XG4gXHRcdFx0XHRjb25zb2xlLndhcm4oXG4gXHRcdFx0XHRcdFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICtcbiBcdFx0XHRcdFx0XHRyZXF1ZXN0ICtcbiBcdFx0XHRcdFx0XHRcIikgZnJvbSBkaXNwb3NlZCBtb2R1bGUgXCIgK1xuIFx0XHRcdFx0XHRcdG1vZHVsZUlkXG4gXHRcdFx0XHQpO1xuIFx0XHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbXTtcbiBcdFx0XHR9XG4gXHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18ocmVxdWVzdCk7XG4gXHRcdH07XG4gXHRcdHZhciBPYmplY3RGYWN0b3J5ID0gZnVuY3Rpb24gT2JqZWN0RmFjdG9yeShuYW1lKSB7XG4gXHRcdFx0cmV0dXJuIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuIFx0XHRcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfX1tuYW1lXTtcbiBcdFx0XHRcdH0sXG4gXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gXHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX19bbmFtZV0gPSB2YWx1ZTtcbiBcdFx0XHRcdH1cbiBcdFx0XHR9O1xuIFx0XHR9O1xuIFx0XHRmb3IgKHZhciBuYW1lIGluIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiBcdFx0XHRpZiAoXG4gXHRcdFx0XHRPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX193ZWJwYWNrX3JlcXVpcmVfXywgbmFtZSkgJiZcbiBcdFx0XHRcdG5hbWUgIT09IFwiZVwiXG4gXHRcdFx0KSB7XG4gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIG5hbWUsIE9iamVjdEZhY3RvcnkobmFtZSkpO1xuIFx0XHRcdH1cbiBcdFx0fVxuIFx0XHRmbi5lID0gZnVuY3Rpb24oY2h1bmtJZCkge1xuIFx0XHRcdGlmIChob3RTdGF0dXMgPT09IFwicmVhZHlcIikgaG90U2V0U3RhdHVzKFwicHJlcGFyZVwiKTtcbiBcdFx0XHRob3RDaHVua3NMb2FkaW5nKys7XG4gXHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uZShjaHVua0lkKS50aGVuKGZpbmlzaENodW5rTG9hZGluZywgZnVuY3Rpb24oZXJyKSB7XG4gXHRcdFx0XHRmaW5pc2hDaHVua0xvYWRpbmcoKTtcbiBcdFx0XHRcdHRocm93IGVycjtcbiBcdFx0XHR9KTtcblxuIFx0XHRcdGZ1bmN0aW9uIGZpbmlzaENodW5rTG9hZGluZygpIHtcbiBcdFx0XHRcdGhvdENodW5rc0xvYWRpbmctLTtcbiBcdFx0XHRcdGlmIChob3RTdGF0dXMgPT09IFwicHJlcGFyZVwiKSB7XG4gXHRcdFx0XHRcdGlmICghaG90V2FpdGluZ0ZpbGVzTWFwW2NodW5rSWRdKSB7XG4gXHRcdFx0XHRcdFx0aG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0aWYgKGhvdENodW5rc0xvYWRpbmcgPT09IDAgJiYgaG90V2FpdGluZ0ZpbGVzID09PSAwKSB7XG4gXHRcdFx0XHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9O1xuIFx0XHRyZXR1cm4gZm47XG4gXHR9XG5cbiBcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0ZnVuY3Rpb24gaG90Q3JlYXRlTW9kdWxlKG1vZHVsZUlkKSB7XG4gXHRcdHZhciBob3QgPSB7XG4gXHRcdFx0Ly8gcHJpdmF0ZSBzdHVmZlxuIFx0XHRcdF9hY2NlcHRlZERlcGVuZGVuY2llczoge30sXG4gXHRcdFx0X2RlY2xpbmVkRGVwZW5kZW5jaWVzOiB7fSxcbiBcdFx0XHRfc2VsZkFjY2VwdGVkOiBmYWxzZSxcbiBcdFx0XHRfc2VsZkRlY2xpbmVkOiBmYWxzZSxcbiBcdFx0XHRfZGlzcG9zZUhhbmRsZXJzOiBbXSxcbiBcdFx0XHRfbWFpbjogaG90Q3VycmVudENoaWxkTW9kdWxlICE9PSBtb2R1bGVJZCxcblxuIFx0XHRcdC8vIE1vZHVsZSBBUElcbiBcdFx0XHRhY3RpdmU6IHRydWUsXG4gXHRcdFx0YWNjZXB0OiBmdW5jdGlvbihkZXAsIGNhbGxiYWNrKSB7XG4gXHRcdFx0XHRpZiAodHlwZW9mIGRlcCA9PT0gXCJ1bmRlZmluZWRcIikgaG90Ll9zZWxmQWNjZXB0ZWQgPSB0cnVlO1xuIFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGRlcCA9PT0gXCJmdW5jdGlvblwiKSBob3QuX3NlbGZBY2NlcHRlZCA9IGRlcDtcbiBcdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiBkZXAgPT09IFwib2JqZWN0XCIpXG4gXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxuIFx0XHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG4gXHRcdFx0XHRlbHNlIGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG4gXHRcdFx0fSxcbiBcdFx0XHRkZWNsaW5lOiBmdW5jdGlvbihkZXApIHtcbiBcdFx0XHRcdGlmICh0eXBlb2YgZGVwID09PSBcInVuZGVmaW5lZFwiKSBob3QuX3NlbGZEZWNsaW5lZCA9IHRydWU7XG4gXHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiKVxuIFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKylcbiBcdFx0XHRcdFx0XHRob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcFtpXV0gPSB0cnVlO1xuIFx0XHRcdFx0ZWxzZSBob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcF0gPSB0cnVlO1xuIFx0XHRcdH0sXG4gXHRcdFx0ZGlzcG9zZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiBcdFx0XHRcdGhvdC5fZGlzcG9zZUhhbmRsZXJzLnB1c2goY2FsbGJhY2spO1xuIFx0XHRcdH0sXG4gXHRcdFx0YWRkRGlzcG9zZUhhbmRsZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcbiBcdFx0XHR9LFxuIFx0XHRcdHJlbW92ZURpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdC5fZGlzcG9zZUhhbmRsZXJzLmluZGV4T2YoY2FsbGJhY2spO1xuIFx0XHRcdFx0aWYgKGlkeCA+PSAwKSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcbiBcdFx0XHR9LFxuXG4gXHRcdFx0Ly8gTWFuYWdlbWVudCBBUElcbiBcdFx0XHRjaGVjazogaG90Q2hlY2ssXG4gXHRcdFx0YXBwbHk6IGhvdEFwcGx5LFxuIFx0XHRcdHN0YXR1czogZnVuY3Rpb24obCkge1xuIFx0XHRcdFx0aWYgKCFsKSByZXR1cm4gaG90U3RhdHVzO1xuIFx0XHRcdFx0aG90U3RhdHVzSGFuZGxlcnMucHVzaChsKTtcbiBcdFx0XHR9LFxuIFx0XHRcdGFkZFN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uKGwpIHtcbiBcdFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XG4gXHRcdFx0fSxcbiBcdFx0XHRyZW1vdmVTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbihsKSB7XG4gXHRcdFx0XHR2YXIgaWR4ID0gaG90U3RhdHVzSGFuZGxlcnMuaW5kZXhPZihsKTtcbiBcdFx0XHRcdGlmIChpZHggPj0gMCkgaG90U3RhdHVzSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gXHRcdFx0fSxcblxuIFx0XHRcdC8vaW5oZXJpdCBmcm9tIHByZXZpb3VzIGRpc3Bvc2UgY2FsbFxuIFx0XHRcdGRhdGE6IGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXVxuIFx0XHR9O1xuIFx0XHRob3RDdXJyZW50Q2hpbGRNb2R1bGUgPSB1bmRlZmluZWQ7XG4gXHRcdHJldHVybiBob3Q7XG4gXHR9XG5cbiBcdHZhciBob3RTdGF0dXNIYW5kbGVycyA9IFtdO1xuIFx0dmFyIGhvdFN0YXR1cyA9IFwiaWRsZVwiO1xuXG4gXHRmdW5jdGlvbiBob3RTZXRTdGF0dXMobmV3U3RhdHVzKSB7XG4gXHRcdGhvdFN0YXR1cyA9IG5ld1N0YXR1cztcbiBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBob3RTdGF0dXNIYW5kbGVycy5sZW5ndGg7IGkrKylcbiBcdFx0XHRob3RTdGF0dXNIYW5kbGVyc1tpXS5jYWxsKG51bGwsIG5ld1N0YXR1cyk7XG4gXHR9XG5cbiBcdC8vIHdoaWxlIGRvd25sb2FkaW5nXG4gXHR2YXIgaG90V2FpdGluZ0ZpbGVzID0gMDtcbiBcdHZhciBob3RDaHVua3NMb2FkaW5nID0gMDtcbiBcdHZhciBob3RXYWl0aW5nRmlsZXNNYXAgPSB7fTtcbiBcdHZhciBob3RSZXF1ZXN0ZWRGaWxlc01hcCA9IHt9O1xuIFx0dmFyIGhvdEF2YWlsYWJsZUZpbGVzTWFwID0ge307XG4gXHR2YXIgaG90RGVmZXJyZWQ7XG5cbiBcdC8vIFRoZSB1cGRhdGUgaW5mb1xuIFx0dmFyIGhvdFVwZGF0ZSwgaG90VXBkYXRlTmV3SGFzaDtcblxuIFx0ZnVuY3Rpb24gdG9Nb2R1bGVJZChpZCkge1xuIFx0XHR2YXIgaXNOdW1iZXIgPSAraWQgKyBcIlwiID09PSBpZDtcbiBcdFx0cmV0dXJuIGlzTnVtYmVyID8gK2lkIDogaWQ7XG4gXHR9XG5cbiBcdGZ1bmN0aW9uIGhvdENoZWNrKGFwcGx5KSB7XG4gXHRcdGlmIChob3RTdGF0dXMgIT09IFwiaWRsZVwiKVxuIFx0XHRcdHRocm93IG5ldyBFcnJvcihcImNoZWNrKCkgaXMgb25seSBhbGxvd2VkIGluIGlkbGUgc3RhdHVzXCIpO1xuIFx0XHRob3RBcHBseU9uVXBkYXRlID0gYXBwbHk7XG4gXHRcdGhvdFNldFN0YXR1cyhcImNoZWNrXCIpO1xuIFx0XHRyZXR1cm4gaG90RG93bmxvYWRNYW5pZmVzdChob3RSZXF1ZXN0VGltZW91dCkudGhlbihmdW5jdGlvbih1cGRhdGUpIHtcbiBcdFx0XHRpZiAoIXVwZGF0ZSkge1xuIFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiaWRsZVwiKTtcbiBcdFx0XHRcdHJldHVybiBudWxsO1xuIFx0XHRcdH1cbiBcdFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcCA9IHt9O1xuIFx0XHRcdGhvdFdhaXRpbmdGaWxlc01hcCA9IHt9O1xuIFx0XHRcdGhvdEF2YWlsYWJsZUZpbGVzTWFwID0gdXBkYXRlLmM7XG4gXHRcdFx0aG90VXBkYXRlTmV3SGFzaCA9IHVwZGF0ZS5oO1xuXG4gXHRcdFx0aG90U2V0U3RhdHVzKFwicHJlcGFyZVwiKTtcbiBcdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuIFx0XHRcdFx0aG90RGVmZXJyZWQgPSB7XG4gXHRcdFx0XHRcdHJlc29sdmU6IHJlc29sdmUsXG4gXHRcdFx0XHRcdHJlamVjdDogcmVqZWN0XG4gXHRcdFx0XHR9O1xuIFx0XHRcdH0pO1xuIFx0XHRcdGhvdFVwZGF0ZSA9IHt9O1xuIFx0XHRcdGZvcih2YXIgY2h1bmtJZCBpbiBpbnN0YWxsZWRDaHVua3MpXG4gXHRcdFx0e1xuIFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lLWJsb2Nrc1xuIFx0XHRcdFx0LypnbG9iYWxzIGNodW5rSWQgKi9cbiBcdFx0XHRcdGhvdEVuc3VyZVVwZGF0ZUNodW5rKGNodW5rSWQpO1xuIFx0XHRcdH1cbiBcdFx0XHRpZiAoXG4gXHRcdFx0XHRob3RTdGF0dXMgPT09IFwicHJlcGFyZVwiICYmXG4gXHRcdFx0XHRob3RDaHVua3NMb2FkaW5nID09PSAwICYmXG4gXHRcdFx0XHRob3RXYWl0aW5nRmlsZXMgPT09IDBcbiBcdFx0XHQpIHtcbiBcdFx0XHRcdGhvdFVwZGF0ZURvd25sb2FkZWQoKTtcbiBcdFx0XHR9XG4gXHRcdFx0cmV0dXJuIHByb21pc2U7XG4gXHRcdH0pO1xuIFx0fVxuXG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdGZ1bmN0aW9uIGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKSB7XG4gXHRcdGlmICghaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0gfHwgIWhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdKVxuIFx0XHRcdHJldHVybjtcbiBcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0gPSBmYWxzZTtcbiBcdFx0Zm9yICh2YXIgbW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcbiBcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcbiBcdFx0XHRcdGhvdFVwZGF0ZVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0fVxuIFx0XHR9XG4gXHRcdGlmICgtLWhvdFdhaXRpbmdGaWxlcyA9PT0gMCAmJiBob3RDaHVua3NMb2FkaW5nID09PSAwKSB7XG4gXHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xuIFx0XHR9XG4gXHR9XG5cbiBcdGZ1bmN0aW9uIGhvdEVuc3VyZVVwZGF0ZUNodW5rKGNodW5rSWQpIHtcbiBcdFx0aWYgKCFob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSkge1xuIFx0XHRcdGhvdFdhaXRpbmdGaWxlc01hcFtjaHVua0lkXSA9IHRydWU7XG4gXHRcdH0gZWxzZSB7XG4gXHRcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0gPSB0cnVlO1xuIFx0XHRcdGhvdFdhaXRpbmdGaWxlcysrO1xuIFx0XHRcdGhvdERvd25sb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XG4gXHRcdH1cbiBcdH1cblxuIFx0ZnVuY3Rpb24gaG90VXBkYXRlRG93bmxvYWRlZCgpIHtcbiBcdFx0aG90U2V0U3RhdHVzKFwicmVhZHlcIik7XG4gXHRcdHZhciBkZWZlcnJlZCA9IGhvdERlZmVycmVkO1xuIFx0XHRob3REZWZlcnJlZCA9IG51bGw7XG4gXHRcdGlmICghZGVmZXJyZWQpIHJldHVybjtcbiBcdFx0aWYgKGhvdEFwcGx5T25VcGRhdGUpIHtcbiBcdFx0XHQvLyBXcmFwIGRlZmVycmVkIG9iamVjdCBpbiBQcm9taXNlIHRvIG1hcmsgaXQgYXMgYSB3ZWxsLWhhbmRsZWQgUHJvbWlzZSB0b1xuIFx0XHRcdC8vIGF2b2lkIHRyaWdnZXJpbmcgdW5jYXVnaHQgZXhjZXB0aW9uIHdhcm5pbmcgaW4gQ2hyb21lLlxuIFx0XHRcdC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NjU2NjZcbiBcdFx0XHRQcm9taXNlLnJlc29sdmUoKVxuIFx0XHRcdFx0LnRoZW4oZnVuY3Rpb24oKSB7XG4gXHRcdFx0XHRcdHJldHVybiBob3RBcHBseShob3RBcHBseU9uVXBkYXRlKTtcbiBcdFx0XHRcdH0pXG4gXHRcdFx0XHQudGhlbihcbiBcdFx0XHRcdFx0ZnVuY3Rpb24ocmVzdWx0KSB7XG4gXHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuIFx0XHRcdFx0XHR9LFxuIFx0XHRcdFx0XHRmdW5jdGlvbihlcnIpIHtcbiBcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0KTtcbiBcdFx0fSBlbHNlIHtcbiBcdFx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XG4gXHRcdFx0Zm9yICh2YXIgaWQgaW4gaG90VXBkYXRlKSB7XG4gXHRcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhvdFVwZGF0ZSwgaWQpKSB7XG4gXHRcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHRvTW9kdWxlSWQoaWQpKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZShvdXRkYXRlZE1vZHVsZXMpO1xuIFx0XHR9XG4gXHR9XG5cbiBcdGZ1bmN0aW9uIGhvdEFwcGx5KG9wdGlvbnMpIHtcbiBcdFx0aWYgKGhvdFN0YXR1cyAhPT0gXCJyZWFkeVwiKVxuIFx0XHRcdHRocm93IG5ldyBFcnJvcihcImFwcGx5KCkgaXMgb25seSBhbGxvd2VkIGluIHJlYWR5IHN0YXR1c1wiKTtcbiBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiBcdFx0dmFyIGNiO1xuIFx0XHR2YXIgaTtcbiBcdFx0dmFyIGo7XG4gXHRcdHZhciBtb2R1bGU7XG4gXHRcdHZhciBtb2R1bGVJZDtcblxuIFx0XHRmdW5jdGlvbiBnZXRBZmZlY3RlZFN0dWZmKHVwZGF0ZU1vZHVsZUlkKSB7XG4gXHRcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFt1cGRhdGVNb2R1bGVJZF07XG4gXHRcdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XG5cbiBcdFx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMuc2xpY2UoKS5tYXAoZnVuY3Rpb24oaWQpIHtcbiBcdFx0XHRcdHJldHVybiB7XG4gXHRcdFx0XHRcdGNoYWluOiBbaWRdLFxuIFx0XHRcdFx0XHRpZDogaWRcbiBcdFx0XHRcdH07XG4gXHRcdFx0fSk7XG4gXHRcdFx0d2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiBcdFx0XHRcdHZhciBxdWV1ZUl0ZW0gPSBxdWV1ZS5wb3AoKTtcbiBcdFx0XHRcdHZhciBtb2R1bGVJZCA9IHF1ZXVlSXRlbS5pZDtcbiBcdFx0XHRcdHZhciBjaGFpbiA9IHF1ZXVlSXRlbS5jaGFpbjtcbiBcdFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdFx0aWYgKCFtb2R1bGUgfHwgbW9kdWxlLmhvdC5fc2VsZkFjY2VwdGVkKSBjb250aW51ZTtcbiBcdFx0XHRcdGlmIChtb2R1bGUuaG90Ll9zZWxmRGVjbGluZWQpIHtcbiBcdFx0XHRcdFx0cmV0dXJuIHtcbiBcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtZGVjbGluZWRcIixcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXG4gXHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXG4gXHRcdFx0XHRcdH07XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRpZiAobW9kdWxlLmhvdC5fbWFpbikge1xuIFx0XHRcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0XHRcdHR5cGU6IFwidW5hY2NlcHRlZFwiLFxuIFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbixcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcbiBcdFx0XHRcdFx0fTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbW9kdWxlLnBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRcdFx0dmFyIHBhcmVudElkID0gbW9kdWxlLnBhcmVudHNbaV07XG4gXHRcdFx0XHRcdHZhciBwYXJlbnQgPSBpbnN0YWxsZWRNb2R1bGVzW3BhcmVudElkXTtcbiBcdFx0XHRcdFx0aWYgKCFwYXJlbnQpIGNvbnRpbnVlO1xuIFx0XHRcdFx0XHRpZiAocGFyZW50LmhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0XHRcdFx0cmV0dXJuIHtcbiBcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZGVjbGluZWRcIixcbiBcdFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbi5jb25jYXQoW3BhcmVudElkXSksXG4gXHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG4gXHRcdFx0XHRcdFx0XHRwYXJlbnRJZDogcGFyZW50SWRcbiBcdFx0XHRcdFx0XHR9O1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdGlmIChvdXRkYXRlZE1vZHVsZXMuaW5kZXhPZihwYXJlbnRJZCkgIT09IC0xKSBjb250aW51ZTtcbiBcdFx0XHRcdFx0aWYgKHBhcmVudC5ob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSkge1xuIFx0XHRcdFx0XHRcdGlmICghb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdKVxuIFx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdID0gW107XG4gXHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdLCBbbW9kdWxlSWRdKTtcbiBcdFx0XHRcdFx0XHRjb250aW51ZTtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRkZWxldGUgb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdO1xuIFx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaChwYXJlbnRJZCk7XG4gXHRcdFx0XHRcdHF1ZXVlLnB1c2goe1xuIFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbi5jb25jYXQoW3BhcmVudElkXSksXG4gXHRcdFx0XHRcdFx0aWQ6IHBhcmVudElkXG4gXHRcdFx0XHRcdH0pO1xuIFx0XHRcdFx0fVxuIFx0XHRcdH1cblxuIFx0XHRcdHJldHVybiB7XG4gXHRcdFx0XHR0eXBlOiBcImFjY2VwdGVkXCIsXG4gXHRcdFx0XHRtb2R1bGVJZDogdXBkYXRlTW9kdWxlSWQsXG4gXHRcdFx0XHRvdXRkYXRlZE1vZHVsZXM6IG91dGRhdGVkTW9kdWxlcyxcbiBcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzOiBvdXRkYXRlZERlcGVuZGVuY2llc1xuIFx0XHRcdH07XG4gXHRcdH1cblxuIFx0XHRmdW5jdGlvbiBhZGRBbGxUb1NldChhLCBiKSB7XG4gXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0XHR2YXIgaXRlbSA9IGJbaV07XG4gXHRcdFx0XHRpZiAoYS5pbmRleE9mKGl0ZW0pID09PSAtMSkgYS5wdXNoKGl0ZW0pO1xuIFx0XHRcdH1cbiBcdFx0fVxuXG4gXHRcdC8vIGF0IGJlZ2luIGFsbCB1cGRhdGVzIG1vZHVsZXMgYXJlIG91dGRhdGVkXG4gXHRcdC8vIHRoZSBcIm91dGRhdGVkXCIgc3RhdHVzIGNhbiBwcm9wYWdhdGUgdG8gcGFyZW50cyBpZiB0aGV5IGRvbid0IGFjY2VwdCB0aGUgY2hpbGRyZW5cbiBcdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XG4gXHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbXTtcbiBcdFx0dmFyIGFwcGxpZWRVcGRhdGUgPSB7fTtcblxuIFx0XHR2YXIgd2FyblVuZXhwZWN0ZWRSZXF1aXJlID0gZnVuY3Rpb24gd2FyblVuZXhwZWN0ZWRSZXF1aXJlKCkge1xuIFx0XHRcdGNvbnNvbGUud2FybihcbiBcdFx0XHRcdFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICsgcmVzdWx0Lm1vZHVsZUlkICsgXCIpIHRvIGRpc3Bvc2VkIG1vZHVsZVwiXG4gXHRcdFx0KTtcbiBcdFx0fTtcblxuIFx0XHRmb3IgKHZhciBpZCBpbiBob3RVcGRhdGUpIHtcbiBcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhvdFVwZGF0ZSwgaWQpKSB7XG4gXHRcdFx0XHRtb2R1bGVJZCA9IHRvTW9kdWxlSWQoaWQpO1xuIFx0XHRcdFx0LyoqIEB0eXBlIHtUT0RPfSAqL1xuIFx0XHRcdFx0dmFyIHJlc3VsdDtcbiBcdFx0XHRcdGlmIChob3RVcGRhdGVbaWRdKSB7XG4gXHRcdFx0XHRcdHJlc3VsdCA9IGdldEFmZmVjdGVkU3R1ZmYobW9kdWxlSWQpO1xuIFx0XHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdFx0cmVzdWx0ID0ge1xuIFx0XHRcdFx0XHRcdHR5cGU6IFwiZGlzcG9zZWRcIixcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogaWRcbiBcdFx0XHRcdFx0fTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdC8qKiBAdHlwZSB7RXJyb3J8ZmFsc2V9ICovXG4gXHRcdFx0XHR2YXIgYWJvcnRFcnJvciA9IGZhbHNlO1xuIFx0XHRcdFx0dmFyIGRvQXBwbHkgPSBmYWxzZTtcbiBcdFx0XHRcdHZhciBkb0Rpc3Bvc2UgPSBmYWxzZTtcbiBcdFx0XHRcdHZhciBjaGFpbkluZm8gPSBcIlwiO1xuIFx0XHRcdFx0aWYgKHJlc3VsdC5jaGFpbikge1xuIFx0XHRcdFx0XHRjaGFpbkluZm8gPSBcIlxcblVwZGF0ZSBwcm9wYWdhdGlvbjogXCIgKyByZXN1bHQuY2hhaW4uam9pbihcIiAtPiBcIik7XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRzd2l0Y2ggKHJlc3VsdC50eXBlKSB7XG4gXHRcdFx0XHRcdGNhc2UgXCJzZWxmLWRlY2xpbmVkXCI6XG4gXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25EZWNsaW5lZCkgb3B0aW9ucy5vbkRlY2xpbmVkKHJlc3VsdCk7XG4gXHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxuIFx0XHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcbiBcdFx0XHRcdFx0XHRcdFx0XCJBYm9ydGVkIGJlY2F1c2Ugb2Ygc2VsZiBkZWNsaW5lOiBcIiArXG4gXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0Lm1vZHVsZUlkICtcbiBcdFx0XHRcdFx0XHRcdFx0XHRjaGFpbkluZm9cbiBcdFx0XHRcdFx0XHRcdCk7XG4gXHRcdFx0XHRcdFx0YnJlYWs7XG4gXHRcdFx0XHRcdGNhc2UgXCJkZWNsaW5lZFwiOlxuIFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRGVjbGluZWQpIG9wdGlvbnMub25EZWNsaW5lZChyZXN1bHQpO1xuIFx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVEZWNsaW5lZClcbiBcdFx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXG4gXHRcdFx0XHRcdFx0XHRcdFwiQWJvcnRlZCBiZWNhdXNlIG9mIGRlY2xpbmVkIGRlcGVuZGVuY3k6IFwiICtcbiBcdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQubW9kdWxlSWQgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdFwiIGluIFwiICtcbiBcdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQucGFyZW50SWQgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdGNoYWluSW5mb1xuIFx0XHRcdFx0XHRcdFx0KTtcbiBcdFx0XHRcdFx0XHRicmVhaztcbiBcdFx0XHRcdFx0Y2FzZSBcInVuYWNjZXB0ZWRcIjpcbiBcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vblVuYWNjZXB0ZWQpIG9wdGlvbnMub25VbmFjY2VwdGVkKHJlc3VsdCk7XG4gXHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZVVuYWNjZXB0ZWQpXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFxuIFx0XHRcdFx0XHRcdFx0XHRcIkFib3J0ZWQgYmVjYXVzZSBcIiArIG1vZHVsZUlkICsgXCIgaXMgbm90IGFjY2VwdGVkXCIgKyBjaGFpbkluZm9cbiBcdFx0XHRcdFx0XHRcdCk7XG4gXHRcdFx0XHRcdFx0YnJlYWs7XG4gXHRcdFx0XHRcdGNhc2UgXCJhY2NlcHRlZFwiOlxuIFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uQWNjZXB0ZWQpIG9wdGlvbnMub25BY2NlcHRlZChyZXN1bHQpO1xuIFx0XHRcdFx0XHRcdGRvQXBwbHkgPSB0cnVlO1xuIFx0XHRcdFx0XHRcdGJyZWFrO1xuIFx0XHRcdFx0XHRjYXNlIFwiZGlzcG9zZWRcIjpcbiBcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkRpc3Bvc2VkKSBvcHRpb25zLm9uRGlzcG9zZWQocmVzdWx0KTtcbiBcdFx0XHRcdFx0XHRkb0Rpc3Bvc2UgPSB0cnVlO1xuIFx0XHRcdFx0XHRcdGJyZWFrO1xuIFx0XHRcdFx0XHRkZWZhdWx0OlxuIFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVuZXhjZXB0aW9uIHR5cGUgXCIgKyByZXN1bHQudHlwZSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRpZiAoYWJvcnRFcnJvcikge1xuIFx0XHRcdFx0XHRob3RTZXRTdGF0dXMoXCJhYm9ydFwiKTtcbiBcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGFib3J0RXJyb3IpO1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0aWYgKGRvQXBwbHkpIHtcbiBcdFx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSBob3RVcGRhdGVbbW9kdWxlSWRdO1xuIFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZE1vZHVsZXMsIHJlc3VsdC5vdXRkYXRlZE1vZHVsZXMpO1xuIFx0XHRcdFx0XHRmb3IgKG1vZHVsZUlkIGluIHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llcykge1xuIFx0XHRcdFx0XHRcdGlmIChcbiBcdFx0XHRcdFx0XHRcdE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcbiBcdFx0XHRcdFx0XHRcdFx0cmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzLFxuIFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZFxuIFx0XHRcdFx0XHRcdFx0KVxuIFx0XHRcdFx0XHRcdCkge1xuIFx0XHRcdFx0XHRcdFx0aWYgKCFvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pXG4gXHRcdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSA9IFtdO1xuIFx0XHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQoXG4gXHRcdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSxcbiBcdFx0XHRcdFx0XHRcdFx0cmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXVxuIFx0XHRcdFx0XHRcdFx0KTtcbiBcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGlmIChkb0Rpc3Bvc2UpIHtcbiBcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCBbcmVzdWx0Lm1vZHVsZUlkXSk7XG4gXHRcdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdID0gd2FyblVuZXhwZWN0ZWRSZXF1aXJlO1xuIFx0XHRcdFx0fVxuIFx0XHRcdH1cbiBcdFx0fVxuXG4gXHRcdC8vIFN0b3JlIHNlbGYgYWNjZXB0ZWQgb3V0ZGF0ZWQgbW9kdWxlcyB0byByZXF1aXJlIHRoZW0gbGF0ZXIgYnkgdGhlIG1vZHVsZSBzeXN0ZW1cbiBcdFx0dmFyIG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcyA9IFtdO1xuIFx0XHRmb3IgKGkgPSAwOyBpIDwgb3V0ZGF0ZWRNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0bW9kdWxlSWQgPSBvdXRkYXRlZE1vZHVsZXNbaV07XG4gXHRcdFx0aWYgKFxuIFx0XHRcdFx0aW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gJiZcbiBcdFx0XHRcdGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkFjY2VwdGVkXG4gXHRcdFx0KVxuIFx0XHRcdFx0b3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzLnB1c2goe1xuIFx0XHRcdFx0XHRtb2R1bGU6IG1vZHVsZUlkLFxuIFx0XHRcdFx0XHRlcnJvckhhbmRsZXI6IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkFjY2VwdGVkXG4gXHRcdFx0XHR9KTtcbiBcdFx0fVxuXG4gXHRcdC8vIE5vdyBpbiBcImRpc3Bvc2VcIiBwaGFzZVxuIFx0XHRob3RTZXRTdGF0dXMoXCJkaXNwb3NlXCIpO1xuIFx0XHRPYmplY3Qua2V5cyhob3RBdmFpbGFibGVGaWxlc01hcCkuZm9yRWFjaChmdW5jdGlvbihjaHVua0lkKSB7XG4gXHRcdFx0aWYgKGhvdEF2YWlsYWJsZUZpbGVzTWFwW2NodW5rSWRdID09PSBmYWxzZSkge1xuIFx0XHRcdFx0aG90RGlzcG9zZUNodW5rKGNodW5rSWQpO1xuIFx0XHRcdH1cbiBcdFx0fSk7XG5cbiBcdFx0dmFyIGlkeDtcbiBcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCk7XG4gXHRcdHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gXHRcdFx0bW9kdWxlSWQgPSBxdWV1ZS5wb3AoKTtcbiBcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHRpZiAoIW1vZHVsZSkgY29udGludWU7XG5cbiBcdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG4gXHRcdFx0Ly8gQ2FsbCBkaXNwb3NlIGhhbmRsZXJzXG4gXHRcdFx0dmFyIGRpc3Bvc2VIYW5kbGVycyA9IG1vZHVsZS5ob3QuX2Rpc3Bvc2VIYW5kbGVycztcbiBcdFx0XHRmb3IgKGogPSAwOyBqIDwgZGlzcG9zZUhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XG4gXHRcdFx0XHRjYiA9IGRpc3Bvc2VIYW5kbGVyc1tqXTtcbiBcdFx0XHRcdGNiKGRhdGEpO1xuIFx0XHRcdH1cbiBcdFx0XHRob3RDdXJyZW50TW9kdWxlRGF0YVttb2R1bGVJZF0gPSBkYXRhO1xuXG4gXHRcdFx0Ly8gZGlzYWJsZSBtb2R1bGUgKHRoaXMgZGlzYWJsZXMgcmVxdWlyZXMgZnJvbSB0aGlzIG1vZHVsZSlcbiBcdFx0XHRtb2R1bGUuaG90LmFjdGl2ZSA9IGZhbHNlO1xuXG4gXHRcdFx0Ly8gcmVtb3ZlIG1vZHVsZSBmcm9tIGNhY2hlXG4gXHRcdFx0ZGVsZXRlIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuXG4gXHRcdFx0Ly8gd2hlbiBkaXNwb3NpbmcgdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGRpc3Bvc2UgaGFuZGxlclxuIFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XG5cbiBcdFx0XHQvLyByZW1vdmUgXCJwYXJlbnRzXCIgcmVmZXJlbmNlcyBmcm9tIGFsbCBjaGlsZHJlblxuIFx0XHRcdGZvciAoaiA9IDA7IGogPCBtb2R1bGUuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiBcdFx0XHRcdHZhciBjaGlsZCA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlLmNoaWxkcmVuW2pdXTtcbiBcdFx0XHRcdGlmICghY2hpbGQpIGNvbnRpbnVlO1xuIFx0XHRcdFx0aWR4ID0gY2hpbGQucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKTtcbiBcdFx0XHRcdGlmIChpZHggPj0gMCkge1xuIFx0XHRcdFx0XHRjaGlsZC5wYXJlbnRzLnNwbGljZShpZHgsIDEpO1xuIFx0XHRcdFx0fVxuIFx0XHRcdH1cbiBcdFx0fVxuXG4gXHRcdC8vIHJlbW92ZSBvdXRkYXRlZCBkZXBlbmRlbmN5IGZyb20gbW9kdWxlIGNoaWxkcmVuXG4gXHRcdHZhciBkZXBlbmRlbmN5O1xuIFx0XHR2YXIgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXM7XG4gXHRcdGZvciAobW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcbiBcdFx0XHRpZiAoXG4gXHRcdFx0XHRPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG1vZHVsZUlkKVxuIFx0XHRcdCkge1xuIFx0XHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0XHRpZiAobW9kdWxlKSB7XG4gXHRcdFx0XHRcdG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzID0gb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdO1xuIFx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcbiBcdFx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbal07XG4gXHRcdFx0XHRcdFx0aWR4ID0gbW9kdWxlLmNoaWxkcmVuLmluZGV4T2YoZGVwZW5kZW5jeSk7XG4gXHRcdFx0XHRcdFx0aWYgKGlkeCA+PSAwKSBtb2R1bGUuY2hpbGRyZW4uc3BsaWNlKGlkeCwgMSk7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyBOb3QgaW4gXCJhcHBseVwiIHBoYXNlXG4gXHRcdGhvdFNldFN0YXR1cyhcImFwcGx5XCIpO1xuXG4gXHRcdGhvdEN1cnJlbnRIYXNoID0gaG90VXBkYXRlTmV3SGFzaDtcblxuIFx0XHQvLyBpbnNlcnQgbmV3IGNvZGVcbiBcdFx0Zm9yIChtb2R1bGVJZCBpbiBhcHBsaWVkVXBkYXRlKSB7XG4gXHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcHBsaWVkVXBkYXRlLCBtb2R1bGVJZCkpIHtcbiBcdFx0XHRcdG1vZHVsZXNbbW9kdWxlSWRdID0gYXBwbGllZFVwZGF0ZVttb2R1bGVJZF07XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gY2FsbCBhY2NlcHQgaGFuZGxlcnNcbiBcdFx0dmFyIGVycm9yID0gbnVsbDtcbiBcdFx0Zm9yIChtb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xuIFx0XHRcdGlmIChcbiBcdFx0XHRcdE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpXG4gXHRcdFx0KSB7XG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdGlmIChtb2R1bGUpIHtcbiBcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XG4gXHRcdFx0XHRcdHZhciBjYWxsYmFja3MgPSBbXTtcbiBcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2ldO1xuIFx0XHRcdFx0XHRcdGNiID0gbW9kdWxlLmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwZW5kZW5jeV07XG4gXHRcdFx0XHRcdFx0aWYgKGNiKSB7XG4gXHRcdFx0XHRcdFx0XHRpZiAoY2FsbGJhY2tzLmluZGV4T2YoY2IpICE9PSAtMSkgY29udGludWU7XG4gXHRcdFx0XHRcdFx0XHRjYWxsYmFja3MucHVzaChjYik7XG4gXHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRcdFx0XHRjYiA9IGNhbGxiYWNrc1tpXTtcbiBcdFx0XHRcdFx0XHR0cnkge1xuIFx0XHRcdFx0XHRcdFx0Y2IobW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMpO1xuIFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuIFx0XHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG4gXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcbiBcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImFjY2VwdC1lcnJvcmVkXCIsXG4gXHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuIFx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lJZDogbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV0sXG4gXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxuIFx0XHRcdFx0XHRcdFx0XHR9KTtcbiBcdFx0XHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG4gXHRcdFx0XHRcdFx0XHRcdGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuIFx0XHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fVxuIFx0XHRcdH1cbiBcdFx0fVxuXG4gXHRcdC8vIExvYWQgc2VsZiBhY2NlcHRlZCBtb2R1bGVzXG4gXHRcdGZvciAoaSA9IDA7IGkgPCBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHR2YXIgaXRlbSA9IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlc1tpXTtcbiBcdFx0XHRtb2R1bGVJZCA9IGl0ZW0ubW9kdWxlO1xuIFx0XHRcdGhvdEN1cnJlbnRQYXJlbnRzID0gW21vZHVsZUlkXTtcbiBcdFx0XHR0cnkge1xuIFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCk7XG4gXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG4gXHRcdFx0XHRpZiAodHlwZW9mIGl0ZW0uZXJyb3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiBcdFx0XHRcdFx0dHJ5IHtcbiBcdFx0XHRcdFx0XHRpdGVtLmVycm9ySGFuZGxlcihlcnIpO1xuIFx0XHRcdFx0XHR9IGNhdGNoIChlcnIyKSB7XG4gXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XG4gXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1hY2NlcHQtZXJyb3ItaGFuZGxlci1lcnJvcmVkXCIsXG4gXHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcbiBcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVycjIsXG4gXHRcdFx0XHRcdFx0XHRcdG9yaWdpbmFsRXJyb3I6IGVyclxuIFx0XHRcdFx0XHRcdFx0fSk7XG4gXHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG4gXHRcdFx0XHRcdFx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGVycjI7XG4gXHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRcdGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9IGVsc2Uge1xuIFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XG4gXHRcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtYWNjZXB0LWVycm9yZWRcIixcbiBcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcbiBcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnJcbiBcdFx0XHRcdFx0XHR9KTtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuIFx0XHRcdFx0XHRcdGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gaGFuZGxlIGVycm9ycyBpbiBhY2NlcHQgaGFuZGxlcnMgYW5kIHNlbGYgYWNjZXB0ZWQgbW9kdWxlIGxvYWRcbiBcdFx0aWYgKGVycm9yKSB7XG4gXHRcdFx0aG90U2V0U3RhdHVzKFwiZmFpbFwiKTtcbiBcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuIFx0XHR9XG5cbiBcdFx0aG90U2V0U3RhdHVzKFwiaWRsZVwiKTtcbiBcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiBcdFx0XHRyZXNvbHZlKG91dGRhdGVkTW9kdWxlcyk7XG4gXHRcdH0pO1xuIFx0fVxuXG4gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuIFx0Ly8gdW5kZWZpbmVkID0gY2h1bmsgbm90IGxvYWRlZCwgbnVsbCA9IGNodW5rIHByZWxvYWRlZC9wcmVmZXRjaGVkXG4gXHQvLyBQcm9taXNlID0gY2h1bmsgbG9hZGluZywgMCA9IGNodW5rIGxvYWRlZFxuIFx0dmFyIGluc3RhbGxlZENodW5rcyA9IHtcbiBcdFx0XCJkYXNoYm9hcmRcIjogMFxuIFx0fTtcblxuIFx0dmFyIGRlZmVycmVkTW9kdWxlcyA9IFtdO1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRob3Q6IGhvdENyZWF0ZU1vZHVsZShtb2R1bGVJZCksXG4gXHRcdFx0cGFyZW50czogKGhvdEN1cnJlbnRQYXJlbnRzVGVtcCA9IGhvdEN1cnJlbnRQYXJlbnRzLCBob3RDdXJyZW50UGFyZW50cyA9IFtdLCBob3RDdXJyZW50UGFyZW50c1RlbXApLFxuIFx0XHRcdGNoaWxkcmVuOiBbXVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBob3RDcmVhdGVSZXF1aXJlKG1vZHVsZUlkKSk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2Fzc2V0cy9cIjtcblxuIFx0Ly8gX193ZWJwYWNrX2hhc2hfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5oID0gZnVuY3Rpb24oKSB7IHJldHVybiBob3RDdXJyZW50SGFzaDsgfTtcblxuIFx0dmFyIGpzb25wQXJyYXkgPSB3aW5kb3dbXCJ3ZWJwYWNrSnNvbnBcIl0gPSB3aW5kb3dbXCJ3ZWJwYWNrSnNvbnBcIl0gfHwgW107XG4gXHR2YXIgb2xkSnNvbnBGdW5jdGlvbiA9IGpzb25wQXJyYXkucHVzaC5iaW5kKGpzb25wQXJyYXkpO1xuIFx0anNvbnBBcnJheS5wdXNoID0gd2VicGFja0pzb25wQ2FsbGJhY2s7XG4gXHRqc29ucEFycmF5ID0ganNvbnBBcnJheS5zbGljZSgpO1xuIFx0Zm9yKHZhciBpID0gMDsgaSA8IGpzb25wQXJyYXkubGVuZ3RoOyBpKyspIHdlYnBhY2tKc29ucENhbGxiYWNrKGpzb25wQXJyYXlbaV0pO1xuIFx0dmFyIHBhcmVudEpzb25wRnVuY3Rpb24gPSBvbGRKc29ucEZ1bmN0aW9uO1xuXG5cbiBcdC8vIGFkZCBlbnRyeSBtb2R1bGUgdG8gZGVmZXJyZWQgbGlzdFxuIFx0ZGVmZXJyZWRNb2R1bGVzLnB1c2goW1wiLi9kYXNoYm9hcmQuanNcIixcInZlbmRvclwiXSk7XG4gXHQvLyBydW4gZGVmZXJyZWQgbW9kdWxlcyB3aGVuIHJlYWR5XG4gXHRyZXR1cm4gY2hlY2tEZWZlcnJlZE1vZHVsZXMoKTtcbiIsIi8qIVxuICAqIEJvb3RzdHJhcCB2NC4xLjEgKGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS8pXG4gICogQ29weXJpZ2h0IDIwMTEtMjAxOCBUaGUgQm9vdHN0cmFwIEF1dGhvcnMgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ncmFwaHMvY29udHJpYnV0b3JzKVxuICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2pxdWVyeScpLCByZXF1aXJlKCdwb3BwZXIuanMnKSkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2pxdWVyeScsICdwb3BwZXIuanMnXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLmJvb3RzdHJhcCA9IHt9KSxnbG9iYWwualF1ZXJ5LGdsb2JhbC5Qb3BwZXIpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCQsUG9wcGVyKSB7ICd1c2Ugc3RyaWN0JztcblxuICAkID0gJCAmJiAkLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyAkWydkZWZhdWx0J10gOiAkO1xuICBQb3BwZXIgPSBQb3BwZXIgJiYgUG9wcGVyLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBQb3BwZXJbJ2RlZmF1bHQnXSA6IFBvcHBlcjtcblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICAgIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICAgIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG4gIH1cblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwICh2NC4xLjEpOiB1dGlsLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBVdGlsID0gZnVuY3Rpb24gKCQkJDEpIHtcbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBQcml2YXRlIFRyYW5zaXRpb25FbmQgSGVscGVyc1xuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuICAgIHZhciBUUkFOU0lUSU9OX0VORCA9ICd0cmFuc2l0aW9uZW5kJztcbiAgICB2YXIgTUFYX1VJRCA9IDEwMDAwMDA7XG4gICAgdmFyIE1JTExJU0VDT05EU19NVUxUSVBMSUVSID0gMTAwMDsgLy8gU2hvdXRvdXQgQW5ndXNDcm9sbCAoaHR0cHM6Ly9nb28uZ2wvcHh3UUdwKVxuXG4gICAgZnVuY3Rpb24gdG9UeXBlKG9iaikge1xuICAgICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTcGVjaWFsVHJhbnNpdGlvbkVuZEV2ZW50KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmluZFR5cGU6IFRSQU5TSVRJT05fRU5ELFxuICAgICAgICBkZWxlZ2F0ZVR5cGU6IFRSQU5TSVRJT05fRU5ELFxuICAgICAgICBoYW5kbGU6IGZ1bmN0aW9uIGhhbmRsZShldmVudCkge1xuICAgICAgICAgIGlmICgkJCQxKGV2ZW50LnRhcmdldCkuaXModGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudC5oYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZEVtdWxhdG9yKGR1cmF0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgICAkJCQxKHRoaXMpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgIFV0aWwudHJpZ2dlclRyYW5zaXRpb25FbmQoX3RoaXMpO1xuICAgICAgICB9XG4gICAgICB9LCBkdXJhdGlvbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uRW5kU3VwcG9ydCgpIHtcbiAgICAgICQkJDEuZm4uZW11bGF0ZVRyYW5zaXRpb25FbmQgPSB0cmFuc2l0aW9uRW5kRW11bGF0b3I7XG4gICAgICAkJCQxLmV2ZW50LnNwZWNpYWxbVXRpbC5UUkFOU0lUSU9OX0VORF0gPSBnZXRTcGVjaWFsVHJhbnNpdGlvbkVuZEV2ZW50KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogUHVibGljIFV0aWwgQXBpXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuXG4gICAgdmFyIFV0aWwgPSB7XG4gICAgICBUUkFOU0lUSU9OX0VORDogJ2JzVHJhbnNpdGlvbkVuZCcsXG4gICAgICBnZXRVSUQ6IGZ1bmN0aW9uIGdldFVJRChwcmVmaXgpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgcHJlZml4ICs9IH5+KE1hdGgucmFuZG9tKCkgKiBNQVhfVUlEKTsgLy8gXCJ+flwiIGFjdHMgbGlrZSBhIGZhc3RlciBNYXRoLmZsb29yKCkgaGVyZVxuICAgICAgICB9IHdoaWxlIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwcmVmaXgpKTtcblxuICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgfSxcbiAgICAgIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQ6IGZ1bmN0aW9uIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKTtcblxuICAgICAgICBpZiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSAnIycpIHtcbiAgICAgICAgICBzZWxlY3RvciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciAkc2VsZWN0b3IgPSAkJCQxKGRvY3VtZW50KS5maW5kKHNlbGVjdG9yKTtcbiAgICAgICAgICByZXR1cm4gJHNlbGVjdG9yLmxlbmd0aCA+IDAgPyBzZWxlY3RvciA6IG51bGw7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQ6IGZ1bmN0aW9uIGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gLy8gR2V0IHRyYW5zaXRpb24tZHVyYXRpb24gb2YgdGhlIGVsZW1lbnRcblxuXG4gICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSAkJCQxKGVsZW1lbnQpLmNzcygndHJhbnNpdGlvbi1kdXJhdGlvbicpO1xuICAgICAgICB2YXIgZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gPSBwYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbik7IC8vIFJldHVybiAwIGlmIGVsZW1lbnQgb3IgdHJhbnNpdGlvbiBkdXJhdGlvbiBpcyBub3QgZm91bmRcblxuICAgICAgICBpZiAoIWZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gLy8gSWYgbXVsdGlwbGUgZHVyYXRpb25zIGFyZSBkZWZpbmVkLCB0YWtlIHRoZSBmaXJzdFxuXG5cbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gdHJhbnNpdGlvbkR1cmF0aW9uLnNwbGl0KCcsJylbMF07XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbikgKiBNSUxMSVNFQ09ORFNfTVVMVElQTElFUjtcbiAgICAgIH0sXG4gICAgICByZWZsb3c6IGZ1bmN0aW9uIHJlZmxvdyhlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gdHJpZ2dlclRyYW5zaXRpb25FbmQoZWxlbWVudCkge1xuICAgICAgICAkJCQxKGVsZW1lbnQpLnRyaWdnZXIoVFJBTlNJVElPTl9FTkQpO1xuICAgICAgfSxcbiAgICAgIC8vIFRPRE86IFJlbW92ZSBpbiB2NVxuICAgICAgc3VwcG9ydHNUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiBzdXBwb3J0c1RyYW5zaXRpb25FbmQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKFRSQU5TSVRJT05fRU5EKTtcbiAgICAgIH0sXG4gICAgICBpc0VsZW1lbnQ6IGZ1bmN0aW9uIGlzRWxlbWVudChvYmopIHtcbiAgICAgICAgcmV0dXJuIChvYmpbMF0gfHwgb2JqKS5ub2RlVHlwZTtcbiAgICAgIH0sXG4gICAgICB0eXBlQ2hlY2tDb25maWc6IGZ1bmN0aW9uIHR5cGVDaGVja0NvbmZpZyhjb21wb25lbnROYW1lLCBjb25maWcsIGNvbmZpZ1R5cGVzKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGNvbmZpZ1R5cGVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maWdUeXBlcywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IGNvbmZpZ1R5cGVzW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbmZpZ1twcm9wZXJ0eV07XG4gICAgICAgICAgICB2YXIgdmFsdWVUeXBlID0gdmFsdWUgJiYgVXRpbC5pc0VsZW1lbnQodmFsdWUpID8gJ2VsZW1lbnQnIDogdG9UeXBlKHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKCFuZXcgUmVnRXhwKGV4cGVjdGVkVHlwZXMpLnRlc3QodmFsdWVUeXBlKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY29tcG9uZW50TmFtZS50b1VwcGVyQ2FzZSgpICsgXCI6IFwiICsgKFwiT3B0aW9uIFxcXCJcIiArIHByb3BlcnR5ICsgXCJcXFwiIHByb3ZpZGVkIHR5cGUgXFxcIlwiICsgdmFsdWVUeXBlICsgXCJcXFwiIFwiKSArIChcImJ1dCBleHBlY3RlZCB0eXBlIFxcXCJcIiArIGV4cGVjdGVkVHlwZXMgKyBcIlxcXCIuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHNldFRyYW5zaXRpb25FbmRTdXBwb3J0KCk7XG4gICAgcmV0dXJuIFV0aWw7XG4gIH0oJCk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCAodjQuMS4xKTogYWxlcnQuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIEFsZXJ0ID0gZnVuY3Rpb24gKCQkJDEpIHtcbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBDb25zdGFudHNcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cbiAgICB2YXIgTkFNRSA9ICdhbGVydCc7XG4gICAgdmFyIFZFUlNJT04gPSAnNC4xLjEnO1xuICAgIHZhciBEQVRBX0tFWSA9ICdicy5hbGVydCc7XG4gICAgdmFyIEVWRU5UX0tFWSA9IFwiLlwiICsgREFUQV9LRVk7XG4gICAgdmFyIERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknO1xuICAgIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkJCQxLmZuW05BTUVdO1xuICAgIHZhciBTZWxlY3RvciA9IHtcbiAgICAgIERJU01JU1M6ICdbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nXG4gICAgfTtcbiAgICB2YXIgRXZlbnQgPSB7XG4gICAgICBDTE9TRTogXCJjbG9zZVwiICsgRVZFTlRfS0VZLFxuICAgICAgQ0xPU0VEOiBcImNsb3NlZFwiICsgRVZFTlRfS0VZLFxuICAgICAgQ0xJQ0tfREFUQV9BUEk6IFwiY2xpY2tcIiArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWVxuICAgIH07XG4gICAgdmFyIENsYXNzTmFtZSA9IHtcbiAgICAgIEFMRVJUOiAnYWxlcnQnLFxuICAgICAgRkFERTogJ2ZhZGUnLFxuICAgICAgU0hPVzogJ3Nob3cnXG4gICAgICAvKipcbiAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgKi9cblxuICAgIH07XG5cbiAgICB2YXIgQWxlcnQgPVxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBBbGVydChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgfSAvLyBHZXR0ZXJzXG5cblxuICAgICAgdmFyIF9wcm90byA9IEFsZXJ0LnByb3RvdHlwZTtcblxuICAgICAgLy8gUHVibGljXG4gICAgICBfcHJvdG8uY2xvc2UgPSBmdW5jdGlvbiBjbG9zZShlbGVtZW50KSB7XG4gICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG5cbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICByb290RWxlbWVudCA9IHRoaXMuX2dldFJvb3RFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1c3RvbUV2ZW50ID0gdGhpcy5fdHJpZ2dlckNsb3NlRXZlbnQocm9vdEVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChjdXN0b21FdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnQocm9vdEVsZW1lbnQpO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAkJCQxLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICAgIH07IC8vIFByaXZhdGVcblxuXG4gICAgICBfcHJvdG8uX2dldFJvb3RFbGVtZW50ID0gZnVuY3Rpb24gX2dldFJvb3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB2YXIgcGFyZW50ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgcGFyZW50ID0gJCQkMShzZWxlY3RvcilbMF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgIHBhcmVudCA9ICQkJDEoZWxlbWVudCkuY2xvc2VzdChcIi5cIiArIENsYXNzTmFtZS5BTEVSVClbMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl90cmlnZ2VyQ2xvc2VFdmVudCA9IGZ1bmN0aW9uIF90cmlnZ2VyQ2xvc2VFdmVudChlbGVtZW50KSB7XG4gICAgICAgIHZhciBjbG9zZUV2ZW50ID0gJCQkMS5FdmVudChFdmVudC5DTE9TRSk7XG4gICAgICAgICQkJDEoZWxlbWVudCkudHJpZ2dlcihjbG9zZUV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGNsb3NlRXZlbnQ7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uX3JlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiBfcmVtb3ZlRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgJCQkMShlbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG5cbiAgICAgICAgaWYgKCEkJCQxKGVsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5GQURFKSkge1xuICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICQkJDEoZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fZGVzdHJveUVsZW1lbnQoZWxlbWVudCwgZXZlbnQpO1xuICAgICAgICB9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9kZXN0cm95RWxlbWVudCA9IGZ1bmN0aW9uIF9kZXN0cm95RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgICQkJDEoZWxlbWVudCkuZGV0YWNoKCkudHJpZ2dlcihFdmVudC5DTE9TRUQpLnJlbW92ZSgpO1xuICAgICAgfTsgLy8gU3RhdGljXG5cblxuICAgICAgQWxlcnQuX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciAkZWxlbWVudCA9ICQkJDEodGhpcyk7XG4gICAgICAgICAgdmFyIGRhdGEgPSAkZWxlbWVudC5kYXRhKERBVEFfS0VZKTtcblxuICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgZGF0YSA9IG5ldyBBbGVydCh0aGlzKTtcbiAgICAgICAgICAgICRlbGVtZW50LmRhdGEoREFUQV9LRVksIGRhdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb25maWcgPT09ICdjbG9zZScpIHtcbiAgICAgICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgQWxlcnQuX2hhbmRsZURpc21pc3MgPSBmdW5jdGlvbiBfaGFuZGxlRGlzbWlzcyhhbGVydEluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWxlcnRJbnN0YW5jZS5jbG9zZSh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIF9jcmVhdGVDbGFzcyhBbGVydCwgbnVsbCwgW3tcbiAgICAgICAga2V5OiBcIlZFUlNJT05cIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEFsZXJ0O1xuICAgIH0oKTtcbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG5cbiAgICAkJCQxKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuRElTTUlTUywgQWxlcnQuX2hhbmRsZURpc21pc3MobmV3IEFsZXJ0KCkpKTtcbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBqUXVlcnlcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuICAgICQkJDEuZm5bTkFNRV0gPSBBbGVydC5falF1ZXJ5SW50ZXJmYWNlO1xuICAgICQkJDEuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBBbGVydDtcblxuICAgICQkJDEuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICQkJDEuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XG4gICAgICByZXR1cm4gQWxlcnQuX2pRdWVyeUludGVyZmFjZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFsZXJ0O1xuICB9KCQpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgKHY0LjEuMSk6IGJ1dHRvbi5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgQnV0dG9uID0gZnVuY3Rpb24gKCQkJDEpIHtcbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBDb25zdGFudHNcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cbiAgICB2YXIgTkFNRSA9ICdidXR0b24nO1xuICAgIHZhciBWRVJTSU9OID0gJzQuMS4xJztcbiAgICB2YXIgREFUQV9LRVkgPSAnYnMuYnV0dG9uJztcbiAgICB2YXIgRVZFTlRfS0VZID0gXCIuXCIgKyBEQVRBX0tFWTtcbiAgICB2YXIgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XG4gICAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQkJDEuZm5bTkFNRV07XG4gICAgdmFyIENsYXNzTmFtZSA9IHtcbiAgICAgIEFDVElWRTogJ2FjdGl2ZScsXG4gICAgICBCVVRUT046ICdidG4nLFxuICAgICAgRk9DVVM6ICdmb2N1cydcbiAgICB9O1xuICAgIHZhciBTZWxlY3RvciA9IHtcbiAgICAgIERBVEFfVE9HR0xFX0NBUlJPVDogJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLFxuICAgICAgREFUQV9UT0dHTEU6ICdbZGF0YS10b2dnbGU9XCJidXR0b25zXCJdJyxcbiAgICAgIElOUFVUOiAnaW5wdXQnLFxuICAgICAgQUNUSVZFOiAnLmFjdGl2ZScsXG4gICAgICBCVVRUT046ICcuYnRuJ1xuICAgIH07XG4gICAgdmFyIEV2ZW50ID0ge1xuICAgICAgQ0xJQ0tfREFUQV9BUEk6IFwiY2xpY2tcIiArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWSxcbiAgICAgIEZPQ1VTX0JMVVJfREFUQV9BUEk6IFwiZm9jdXNcIiArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWSArIFwiIFwiICsgKFwiYmx1clwiICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZKVxuICAgICAgLyoqXG4gICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAqIENsYXNzIERlZmluaXRpb25cbiAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICovXG5cbiAgICB9O1xuXG4gICAgdmFyIEJ1dHRvbiA9XG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEJ1dHRvbihlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgfSAvLyBHZXR0ZXJzXG5cblxuICAgICAgdmFyIF9wcm90byA9IEJ1dHRvbi5wcm90b3R5cGU7XG5cbiAgICAgIC8vIFB1YmxpY1xuICAgICAgX3Byb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgICAgdmFyIHRyaWdnZXJDaGFuZ2VFdmVudCA9IHRydWU7XG4gICAgICAgIHZhciBhZGRBcmlhUHJlc3NlZCA9IHRydWU7XG4gICAgICAgIHZhciByb290RWxlbWVudCA9ICQkJDEodGhpcy5fZWxlbWVudCkuY2xvc2VzdChTZWxlY3Rvci5EQVRBX1RPR0dMRSlbMF07XG5cbiAgICAgICAgaWYgKHJvb3RFbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGlucHV0ID0gJCQkMSh0aGlzLl9lbGVtZW50KS5maW5kKFNlbGVjdG9yLklOUFVUKVswXTtcblxuICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoZWNrZWQgJiYgJCQkMSh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuQUNUSVZFKSkge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2VFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gJCQkMShyb290RWxlbWVudCkuZmluZChTZWxlY3Rvci5BQ1RJVkUpWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICQkJDEoYWN0aXZlRWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCByb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgaW5wdXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpIHx8IHJvb3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSAhJCQkMSh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgICAgICAgICAgJCQkMShpbnB1dCkudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBhZGRBcmlhUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZGRBcmlhUHJlc3NlZCkge1xuICAgICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXByZXNzZWQnLCAhJCQkMSh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuQUNUSVZFKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJpZ2dlckNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgJCQkMSh0aGlzLl9lbGVtZW50KS50b2dnbGVDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3Byb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAkJCQxLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICAgIH07IC8vIFN0YXRpY1xuXG5cbiAgICAgIEJ1dHRvbi5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSAkJCQxKHRoaXMpLmRhdGEoREFUQV9LRVkpO1xuXG4gICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBkYXRhID0gbmV3IEJ1dHRvbih0aGlzKTtcbiAgICAgICAgICAgICQkJDEodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbmZpZyA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBfY3JlYXRlQ2xhc3MoQnV0dG9uLCBudWxsLCBbe1xuICAgICAgICBrZXk6IFwiVkVSU0lPTlwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gQnV0dG9uO1xuICAgIH0oKTtcbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG5cbiAgICAkJCQxKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEVfQ0FSUk9ULCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgYnV0dG9uID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICBpZiAoISQkJDEoYnV0dG9uKS5oYXNDbGFzcyhDbGFzc05hbWUuQlVUVE9OKSkge1xuICAgICAgICBidXR0b24gPSAkJCQxKGJ1dHRvbikuY2xvc2VzdChTZWxlY3Rvci5CVVRUT04pO1xuICAgICAgfVxuXG4gICAgICBCdXR0b24uX2pRdWVyeUludGVyZmFjZS5jYWxsKCQkJDEoYnV0dG9uKSwgJ3RvZ2dsZScpO1xuICAgIH0pLm9uKEV2ZW50LkZPQ1VTX0JMVVJfREFUQV9BUEksIFNlbGVjdG9yLkRBVEFfVE9HR0xFX0NBUlJPVCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgYnV0dG9uID0gJCQkMShldmVudC50YXJnZXQpLmNsb3Nlc3QoU2VsZWN0b3IuQlVUVE9OKVswXTtcbiAgICAgICQkJDEoYnV0dG9uKS50b2dnbGVDbGFzcyhDbGFzc05hbWUuRk9DVVMsIC9eZm9jdXMoaW4pPyQvLnRlc3QoZXZlbnQudHlwZSkpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIGpRdWVyeVxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG4gICAgJCQkMS5mbltOQU1FXSA9IEJ1dHRvbi5falF1ZXJ5SW50ZXJmYWNlO1xuICAgICQkJDEuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBCdXR0b247XG5cbiAgICAkJCQxLmZuW05BTUVdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAkJCQxLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgICAgcmV0dXJuIEJ1dHRvbi5falF1ZXJ5SW50ZXJmYWNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gQnV0dG9uO1xuICB9KCQpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgKHY0LjEuMSk6IGNhcm91c2VsLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uICgkJCQxKSB7XG4gICAgLyoqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogQ29uc3RhbnRzXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG4gICAgdmFyIE5BTUUgPSAnY2Fyb3VzZWwnO1xuICAgIHZhciBWRVJTSU9OID0gJzQuMS4xJztcbiAgICB2YXIgREFUQV9LRVkgPSAnYnMuY2Fyb3VzZWwnO1xuICAgIHZhciBFVkVOVF9LRVkgPSBcIi5cIiArIERBVEFfS0VZO1xuICAgIHZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbiAgICB2YXIgSlFVRVJZX05PX0NPTkZMSUNUID0gJCQkMS5mbltOQU1FXTtcbiAgICB2YXIgQVJST1dfTEVGVF9LRVlDT0RFID0gMzc7IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIGxlZnQgYXJyb3cga2V5XG5cbiAgICB2YXIgQVJST1dfUklHSFRfS0VZQ09ERSA9IDM5OyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciByaWdodCBhcnJvdyBrZXlcblxuICAgIHZhciBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUID0gNTAwOyAvLyBUaW1lIGZvciBtb3VzZSBjb21wYXQgZXZlbnRzIHRvIGZpcmUgYWZ0ZXIgdG91Y2hcblxuICAgIHZhciBEZWZhdWx0ID0ge1xuICAgICAgaW50ZXJ2YWw6IDUwMDAsXG4gICAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICAgIHNsaWRlOiBmYWxzZSxcbiAgICAgIHBhdXNlOiAnaG92ZXInLFxuICAgICAgd3JhcDogdHJ1ZVxuICAgIH07XG4gICAgdmFyIERlZmF1bHRUeXBlID0ge1xuICAgICAgaW50ZXJ2YWw6ICcobnVtYmVyfGJvb2xlYW4pJyxcbiAgICAgIGtleWJvYXJkOiAnYm9vbGVhbicsXG4gICAgICBzbGlkZTogJyhib29sZWFufHN0cmluZyknLFxuICAgICAgcGF1c2U6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgICAgIHdyYXA6ICdib29sZWFuJ1xuICAgIH07XG4gICAgdmFyIERpcmVjdGlvbiA9IHtcbiAgICAgIE5FWFQ6ICduZXh0JyxcbiAgICAgIFBSRVY6ICdwcmV2JyxcbiAgICAgIExFRlQ6ICdsZWZ0JyxcbiAgICAgIFJJR0hUOiAncmlnaHQnXG4gICAgfTtcbiAgICB2YXIgRXZlbnQgPSB7XG4gICAgICBTTElERTogXCJzbGlkZVwiICsgRVZFTlRfS0VZLFxuICAgICAgU0xJRDogXCJzbGlkXCIgKyBFVkVOVF9LRVksXG4gICAgICBLRVlET1dOOiBcImtleWRvd25cIiArIEVWRU5UX0tFWSxcbiAgICAgIE1PVVNFRU5URVI6IFwibW91c2VlbnRlclwiICsgRVZFTlRfS0VZLFxuICAgICAgTU9VU0VMRUFWRTogXCJtb3VzZWxlYXZlXCIgKyBFVkVOVF9LRVksXG4gICAgICBUT1VDSEVORDogXCJ0b3VjaGVuZFwiICsgRVZFTlRfS0VZLFxuICAgICAgTE9BRF9EQVRBX0FQSTogXCJsb2FkXCIgKyBFVkVOVF9LRVkgKyBEQVRBX0FQSV9LRVksXG4gICAgICBDTElDS19EQVRBX0FQSTogXCJjbGlja1wiICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZXG4gICAgfTtcbiAgICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgICAgQ0FST1VTRUw6ICdjYXJvdXNlbCcsXG4gICAgICBBQ1RJVkU6ICdhY3RpdmUnLFxuICAgICAgU0xJREU6ICdzbGlkZScsXG4gICAgICBSSUdIVDogJ2Nhcm91c2VsLWl0ZW0tcmlnaHQnLFxuICAgICAgTEVGVDogJ2Nhcm91c2VsLWl0ZW0tbGVmdCcsXG4gICAgICBORVhUOiAnY2Fyb3VzZWwtaXRlbS1uZXh0JyxcbiAgICAgIFBSRVY6ICdjYXJvdXNlbC1pdGVtLXByZXYnLFxuICAgICAgSVRFTTogJ2Nhcm91c2VsLWl0ZW0nXG4gICAgfTtcbiAgICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgICBBQ1RJVkU6ICcuYWN0aXZlJyxcbiAgICAgIEFDVElWRV9JVEVNOiAnLmFjdGl2ZS5jYXJvdXNlbC1pdGVtJyxcbiAgICAgIElURU06ICcuY2Fyb3VzZWwtaXRlbScsXG4gICAgICBORVhUX1BSRVY6ICcuY2Fyb3VzZWwtaXRlbS1uZXh0LCAuY2Fyb3VzZWwtaXRlbS1wcmV2JyxcbiAgICAgIElORElDQVRPUlM6ICcuY2Fyb3VzZWwtaW5kaWNhdG9ycycsXG4gICAgICBEQVRBX1NMSURFOiAnW2RhdGEtc2xpZGVdLCBbZGF0YS1zbGlkZS10b10nLFxuICAgICAgREFUQV9SSURFOiAnW2RhdGEtcmlkZT1cImNhcm91c2VsXCJdJ1xuICAgICAgLyoqXG4gICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAqIENsYXNzIERlZmluaXRpb25cbiAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICovXG5cbiAgICB9O1xuXG4gICAgdmFyIENhcm91c2VsID1cbiAgICAvKiNfX1BVUkVfXyovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ2Fyb3VzZWwoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSAkJCQxKGVsZW1lbnQpWzBdO1xuICAgICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9ICQkJDEodGhpcy5fZWxlbWVudCkuZmluZChTZWxlY3Rvci5JTkRJQ0FUT1JTKVswXTtcblxuICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgICAgfSAvLyBHZXR0ZXJzXG5cblxuICAgICAgdmFyIF9wcm90byA9IENhcm91c2VsLnByb3RvdHlwZTtcblxuICAgICAgLy8gUHVibGljXG4gICAgICBfcHJvdG8ubmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICAgICAgdGhpcy5fc2xpZGUoRGlyZWN0aW9uLk5FWFQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8ubmV4dFdoZW5WaXNpYmxlID0gZnVuY3Rpb24gbmV4dFdoZW5WaXNpYmxlKCkge1xuICAgICAgICAvLyBEb24ndCBjYWxsIG5leHQgd2hlbiB0aGUgcGFnZSBpc24ndCB2aXNpYmxlXG4gICAgICAgIC8vIG9yIHRoZSBjYXJvdXNlbCBvciBpdHMgcGFyZW50IGlzbid0IHZpc2libGVcbiAgICAgICAgaWYgKCFkb2N1bWVudC5oaWRkZW4gJiYgJCQkMSh0aGlzLl9lbGVtZW50KS5pcygnOnZpc2libGUnKSAmJiAkJCQxKHRoaXMuX2VsZW1lbnQpLmNzcygndmlzaWJpbGl0eScpICE9PSAnaGlkZGVuJykge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8ucHJldiA9IGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICAgICAgdGhpcy5fc2xpZGUoRGlyZWN0aW9uLlBSRVYpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8ucGF1c2UgPSBmdW5jdGlvbiBwYXVzZShldmVudCkge1xuICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCQkJDEodGhpcy5fZWxlbWVudCkuZmluZChTZWxlY3Rvci5ORVhUX1BSRVYpWzBdKSB7XG4gICAgICAgICAgVXRpbC50cmlnZ2VyVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgICB0aGlzLmN5Y2xlKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5jeWNsZSA9IGZ1bmN0aW9uIGN5Y2xlKGV2ZW50KSB7XG4gICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ludGVydmFsKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XG4gICAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5pbnRlcnZhbCAmJiAhdGhpcy5faXNQYXVzZWQpIHtcbiAgICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPyB0aGlzLm5leHRXaGVuVmlzaWJsZSA6IHRoaXMubmV4dCkuYmluZCh0aGlzKSwgdGhpcy5fY29uZmlnLmludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3Byb3RvLnRvID0gZnVuY3Rpb24gdG8oaW5kZXgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gJCQkMSh0aGlzLl9lbGVtZW50KS5maW5kKFNlbGVjdG9yLkFDVElWRV9JVEVNKVswXTtcblxuICAgICAgICB2YXIgYWN0aXZlSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgodGhpcy5fYWN0aXZlRWxlbWVudCk7XG5cbiAgICAgICAgaWYgKGluZGV4ID4gdGhpcy5faXRlbXMubGVuZ3RoIC0gMSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICAgICAgJCQkMSh0aGlzLl9lbGVtZW50KS5vbmUoRXZlbnQuU0xJRCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRvKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aXZlSW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgIHRoaXMuY3ljbGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5kZXggPiBhY3RpdmVJbmRleCA/IERpcmVjdGlvbi5ORVhUIDogRGlyZWN0aW9uLlBSRVY7XG5cbiAgICAgICAgdGhpcy5fc2xpZGUoZGlyZWN0aW9uLCB0aGlzLl9pdGVtc1tpbmRleF0pO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAkJCQxKHRoaXMuX2VsZW1lbnQpLm9mZihFVkVOVF9LRVkpO1xuICAgICAgICAkJCQxLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNTbGlkaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50ID0gbnVsbDtcbiAgICAgIH07IC8vIFByaXZhdGVcblxuXG4gICAgICBfcHJvdG8uX2dldENvbmZpZyA9IGZ1bmN0aW9uIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZyA9IF9vYmplY3RTcHJlYWQoe30sIERlZmF1bHQsIGNvbmZpZyk7XG4gICAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgRGVmYXVsdFR5cGUpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xuICAgICAgICAgICQkJDEodGhpcy5fZWxlbWVudCkub24oRXZlbnQuS0VZRE9XTiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9rZXlkb3duKGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgPT09ICdob3ZlcicpIHtcbiAgICAgICAgICAkJCQxKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50Lk1PVVNFRU5URVIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5wYXVzZShldmVudCk7XG4gICAgICAgICAgfSkub24oRXZlbnQuTU9VU0VMRUFWRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLmN5Y2xlKGV2ZW50KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIElmIGl0J3MgYSB0b3VjaC1lbmFibGVkIGRldmljZSwgbW91c2VlbnRlci9sZWF2ZSBhcmUgZmlyZWQgYXNcbiAgICAgICAgICAgIC8vIHBhcnQgb2YgdGhlIG1vdXNlIGNvbXBhdGliaWxpdHkgZXZlbnRzIG9uIGZpcnN0IHRhcCAtIHRoZSBjYXJvdXNlbFxuICAgICAgICAgICAgLy8gd291bGQgc3RvcCBjeWNsaW5nIHVudGlsIHVzZXIgdGFwcGVkIG91dCBvZiBpdDtcbiAgICAgICAgICAgIC8vIGhlcmUsIHdlIGxpc3RlbiBmb3IgdG91Y2hlbmQsIGV4cGxpY2l0bHkgcGF1c2UgdGhlIGNhcm91c2VsXG4gICAgICAgICAgICAvLyAoYXMgaWYgaXQncyB0aGUgc2Vjb25kIHRpbWUgd2UgdGFwIG9uIGl0LCBtb3VzZWVudGVyIGNvbXBhdCBldmVudFxuICAgICAgICAgICAgLy8gaXMgTk9UIGZpcmVkKSBhbmQgYWZ0ZXIgYSB0aW1lb3V0ICh0byBhbGxvdyBmb3IgbW91c2UgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgLy8gZXZlbnRzIHRvIGZpcmUpIHdlIGV4cGxpY2l0bHkgcmVzdGFydCBjeWNsaW5nXG4gICAgICAgICAgICAkJCQxKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50LlRPVUNIRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5wYXVzZSgpO1xuXG4gICAgICAgICAgICAgIGlmIChfdGhpczIudG91Y2hUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzMi50b3VjaFRpbWVvdXQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX3RoaXMyLnRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5jeWNsZShldmVudCk7XG4gICAgICAgICAgICAgIH0sIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyBfdGhpczIuX2NvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5fa2V5ZG93biA9IGZ1bmN0aW9uIF9rZXlkb3duKGV2ZW50KSB7XG4gICAgICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQud2hpY2gpIHtcbiAgICAgICAgICBjYXNlIEFSUk9XX0xFRlRfS0VZQ09ERTpcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLnByZXYoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBBUlJPV19SSUdIVF9LRVlDT0RFOlxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uX2dldEl0ZW1JbmRleCA9IGZ1bmN0aW9uIF9nZXRJdGVtSW5kZXgoZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9pdGVtcyA9ICQkJDEubWFrZUFycmF5KCQkJDEoZWxlbWVudCkucGFyZW50KCkuZmluZChTZWxlY3Rvci5JVEVNKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9nZXRJdGVtQnlEaXJlY3Rpb24gPSBmdW5jdGlvbiBfZ2V0SXRlbUJ5RGlyZWN0aW9uKGRpcmVjdGlvbiwgYWN0aXZlRWxlbWVudCkge1xuICAgICAgICB2YXIgaXNOZXh0RGlyZWN0aW9uID0gZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uTkVYVDtcbiAgICAgICAgdmFyIGlzUHJldkRpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLlBSRVY7XG5cbiAgICAgICAgdmFyIGFjdGl2ZUluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KGFjdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgIHZhciBsYXN0SXRlbUluZGV4ID0gdGhpcy5faXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGlzR29pbmdUb1dyYXAgPSBpc1ByZXZEaXJlY3Rpb24gJiYgYWN0aXZlSW5kZXggPT09IDAgfHwgaXNOZXh0RGlyZWN0aW9uICYmIGFjdGl2ZUluZGV4ID09PSBsYXN0SXRlbUluZGV4O1xuXG4gICAgICAgIGlmIChpc0dvaW5nVG9XcmFwICYmICF0aGlzLl9jb25maWcud3JhcCkge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlbHRhID0gZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uUFJFViA/IC0xIDogMTtcbiAgICAgICAgdmFyIGl0ZW1JbmRleCA9IChhY3RpdmVJbmRleCArIGRlbHRhKSAlIHRoaXMuX2l0ZW1zLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGl0ZW1JbmRleCA9PT0gLTEgPyB0aGlzLl9pdGVtc1t0aGlzLl9pdGVtcy5sZW5ndGggLSAxXSA6IHRoaXMuX2l0ZW1zW2l0ZW1JbmRleF07XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uX3RyaWdnZXJTbGlkZUV2ZW50ID0gZnVuY3Rpb24gX3RyaWdnZXJTbGlkZUV2ZW50KHJlbGF0ZWRUYXJnZXQsIGV2ZW50RGlyZWN0aW9uTmFtZSkge1xuICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgocmVsYXRlZFRhcmdldCk7XG5cbiAgICAgICAgdmFyIGZyb21JbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCgkJCQxKHRoaXMuX2VsZW1lbnQpLmZpbmQoU2VsZWN0b3IuQUNUSVZFX0lURU0pWzBdKTtcblxuICAgICAgICB2YXIgc2xpZGVFdmVudCA9ICQkJDEuRXZlbnQoRXZlbnQuU0xJREUsIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LFxuICAgICAgICAgIGRpcmVjdGlvbjogZXZlbnREaXJlY3Rpb25OYW1lLFxuICAgICAgICAgIGZyb206IGZyb21JbmRleCxcbiAgICAgICAgICB0bzogdGFyZ2V0SW5kZXhcbiAgICAgICAgfSk7XG4gICAgICAgICQkJDEodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzbGlkZUV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHNsaWRlRXZlbnQ7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQgPSBmdW5jdGlvbiBfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkge1xuICAgICAgICAgICQkJDEodGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpLmZpbmQoU2VsZWN0b3IuQUNUSVZFKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcblxuICAgICAgICAgIHZhciBuZXh0SW5kaWNhdG9yID0gdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQuY2hpbGRyZW5bdGhpcy5fZ2V0SXRlbUluZGV4KGVsZW1lbnQpXTtcblxuICAgICAgICAgIGlmIChuZXh0SW5kaWNhdG9yKSB7XG4gICAgICAgICAgICAkJCQxKG5leHRJbmRpY2F0b3IpLmFkZENsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9zbGlkZSA9IGZ1bmN0aW9uIF9zbGlkZShkaXJlY3Rpb24sIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSAkJCQxKHRoaXMuX2VsZW1lbnQpLmZpbmQoU2VsZWN0b3IuQUNUSVZFX0lURU0pWzBdO1xuXG4gICAgICAgIHZhciBhY3RpdmVFbGVtZW50SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgoYWN0aXZlRWxlbWVudCk7XG5cbiAgICAgICAgdmFyIG5leHRFbGVtZW50ID0gZWxlbWVudCB8fCBhY3RpdmVFbGVtZW50ICYmIHRoaXMuX2dldEl0ZW1CeURpcmVjdGlvbihkaXJlY3Rpb24sIGFjdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgIHZhciBuZXh0RWxlbWVudEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KG5leHRFbGVtZW50KTtcblxuICAgICAgICB2YXIgaXNDeWNsaW5nID0gQm9vbGVhbih0aGlzLl9pbnRlcnZhbCk7XG4gICAgICAgIHZhciBkaXJlY3Rpb25hbENsYXNzTmFtZTtcbiAgICAgICAgdmFyIG9yZGVyQ2xhc3NOYW1lO1xuICAgICAgICB2YXIgZXZlbnREaXJlY3Rpb25OYW1lO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IERpcmVjdGlvbi5ORVhUKSB7XG4gICAgICAgICAgZGlyZWN0aW9uYWxDbGFzc05hbWUgPSBDbGFzc05hbWUuTEVGVDtcbiAgICAgICAgICBvcmRlckNsYXNzTmFtZSA9IENsYXNzTmFtZS5ORVhUO1xuICAgICAgICAgIGV2ZW50RGlyZWN0aW9uTmFtZSA9IERpcmVjdGlvbi5MRUZUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gQ2xhc3NOYW1lLlJJR0hUO1xuICAgICAgICAgIG9yZGVyQ2xhc3NOYW1lID0gQ2xhc3NOYW1lLlBSRVY7XG4gICAgICAgICAgZXZlbnREaXJlY3Rpb25OYW1lID0gRGlyZWN0aW9uLlJJR0hUO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRFbGVtZW50ICYmICQkJDEobmV4dEVsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5BQ1RJVkUpKSB7XG4gICAgICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNsaWRlRXZlbnQgPSB0aGlzLl90cmlnZ2VyU2xpZGVFdmVudChuZXh0RWxlbWVudCwgZXZlbnREaXJlY3Rpb25OYW1lKTtcblxuICAgICAgICBpZiAoc2xpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWN0aXZlRWxlbWVudCB8fCAhbmV4dEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBTb21lIHdlaXJkbmVzcyBpcyBoYXBwZW5pbmcsIHNvIHdlIGJhaWxcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSB0cnVlO1xuXG4gICAgICAgIGlmIChpc0N5Y2xpbmcpIHtcbiAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50KTtcblxuICAgICAgICB2YXIgc2xpZEV2ZW50ID0gJCQkMS5FdmVudChFdmVudC5TTElELCB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogbmV4dEVsZW1lbnQsXG4gICAgICAgICAgZGlyZWN0aW9uOiBldmVudERpcmVjdGlvbk5hbWUsXG4gICAgICAgICAgZnJvbTogYWN0aXZlRWxlbWVudEluZGV4LFxuICAgICAgICAgIHRvOiBuZXh0RWxlbWVudEluZGV4XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICgkJCQxKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TTElERSkpIHtcbiAgICAgICAgICAkJCQxKG5leHRFbGVtZW50KS5hZGRDbGFzcyhvcmRlckNsYXNzTmFtZSk7XG4gICAgICAgICAgVXRpbC5yZWZsb3cobmV4dEVsZW1lbnQpO1xuICAgICAgICAgICQkJDEoYWN0aXZlRWxlbWVudCkuYWRkQ2xhc3MoZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xuICAgICAgICAgICQkJDEobmV4dEVsZW1lbnQpLmFkZENsYXNzKGRpcmVjdGlvbmFsQ2xhc3NOYW1lKTtcbiAgICAgICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudChhY3RpdmVFbGVtZW50KTtcbiAgICAgICAgICAkJCQxKGFjdGl2ZUVsZW1lbnQpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkJCQxKG5leHRFbGVtZW50KS5yZW1vdmVDbGFzcyhkaXJlY3Rpb25hbENsYXNzTmFtZSArIFwiIFwiICsgb3JkZXJDbGFzc05hbWUpLmFkZENsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgICAgICAgJCQkMShhY3RpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQUNUSVZFICsgXCIgXCIgKyBvcmRlckNsYXNzTmFtZSArIFwiIFwiICsgZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xuICAgICAgICAgICAgX3RoaXMzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gJCQkMShfdGhpczMuX2VsZW1lbnQpLnRyaWdnZXIoc2xpZEV2ZW50KTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH0pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJCQkMShhY3RpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgICAgICAkJCQxKG5leHRFbGVtZW50KS5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAkJCQxKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2xpZEV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0N5Y2xpbmcpIHtcbiAgICAgICAgICB0aGlzLmN5Y2xlKCk7XG4gICAgICAgIH1cbiAgICAgIH07IC8vIFN0YXRpY1xuXG5cbiAgICAgIENhcm91c2VsLl9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9ICQkJDEodGhpcykuZGF0YShEQVRBX0tFWSk7XG5cbiAgICAgICAgICB2YXIgX2NvbmZpZyA9IF9vYmplY3RTcHJlYWQoe30sIERlZmF1bHQsICQkJDEodGhpcykuZGF0YSgpKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgX2NvbmZpZyA9IF9vYmplY3RTcHJlYWQoe30sIF9jb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGFjdGlvbiA9IHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnID8gY29uZmlnIDogX2NvbmZpZy5zbGlkZTtcblxuICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgZGF0YSA9IG5ldyBDYXJvdXNlbCh0aGlzLCBfY29uZmlnKTtcbiAgICAgICAgICAgICQkJDEodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkYXRhLnRvKGNvbmZpZyk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2FjdGlvbl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyBtZXRob2QgbmFtZWQgXFxcIlwiICsgYWN0aW9uICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhW2FjdGlvbl0oKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF9jb25maWcuaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGRhdGEucGF1c2UoKTtcbiAgICAgICAgICAgIGRhdGEuY3ljbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgQ2Fyb3VzZWwuX2RhdGFBcGlDbGlja0hhbmRsZXIgPSBmdW5jdGlvbiBfZGF0YUFwaUNsaWNrSGFuZGxlcihldmVudCkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcyk7XG5cbiAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0YXJnZXQgPSAkJCQxKHNlbGVjdG9yKVswXTtcblxuICAgICAgICBpZiAoIXRhcmdldCB8fCAhJCQkMSh0YXJnZXQpLmhhc0NsYXNzKENsYXNzTmFtZS5DQVJPVVNFTCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29uZmlnID0gX29iamVjdFNwcmVhZCh7fSwgJCQkMSh0YXJnZXQpLmRhdGEoKSwgJCQkMSh0aGlzKS5kYXRhKCkpO1xuXG4gICAgICAgIHZhciBzbGlkZUluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xpZGUtdG8nKTtcblxuICAgICAgICBpZiAoc2xpZGVJbmRleCkge1xuICAgICAgICAgIGNvbmZpZy5pbnRlcnZhbCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgQ2Fyb3VzZWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQkJDEodGFyZ2V0KSwgY29uZmlnKTtcblxuICAgICAgICBpZiAoc2xpZGVJbmRleCkge1xuICAgICAgICAgICQkJDEodGFyZ2V0KS5kYXRhKERBVEFfS0VZKS50byhzbGlkZUluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9O1xuXG4gICAgICBfY3JlYXRlQ2xhc3MoQ2Fyb3VzZWwsIG51bGwsIFt7XG4gICAgICAgIGtleTogXCJWRVJTSU9OXCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJEZWZhdWx0XCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBDYXJvdXNlbDtcbiAgICB9KCk7XG4gICAgLyoqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuXG4gICAgJCQkMShkb2N1bWVudCkub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkRBVEFfU0xJREUsIENhcm91c2VsLl9kYXRhQXBpQ2xpY2tIYW5kbGVyKTtcbiAgICAkJCQxKHdpbmRvdykub24oRXZlbnQuTE9BRF9EQVRBX0FQSSwgZnVuY3Rpb24gKCkge1xuICAgICAgJCQkMShTZWxlY3Rvci5EQVRBX1JJREUpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGNhcm91c2VsID0gJCQkMSh0aGlzKTtcblxuICAgICAgICBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJGNhcm91c2VsLCAkY2Fyb3VzZWwuZGF0YSgpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIGpRdWVyeVxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG4gICAgJCQkMS5mbltOQU1FXSA9IENhcm91c2VsLl9qUXVlcnlJbnRlcmZhY2U7XG4gICAgJCQkMS5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IENhcm91c2VsO1xuXG4gICAgJCQkMS5mbltOQU1FXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgJCQkMS5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVDtcbiAgICAgIHJldHVybiBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2Fyb3VzZWw7XG4gIH0oJCk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCAodjQuMS4xKTogY29sbGFwc2UuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIENvbGxhcHNlID0gZnVuY3Rpb24gKCQkJDEpIHtcbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBDb25zdGFudHNcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cbiAgICB2YXIgTkFNRSA9ICdjb2xsYXBzZSc7XG4gICAgdmFyIFZFUlNJT04gPSAnNC4xLjEnO1xuICAgIHZhciBEQVRBX0tFWSA9ICdicy5jb2xsYXBzZSc7XG4gICAgdmFyIEVWRU5UX0tFWSA9IFwiLlwiICsgREFUQV9LRVk7XG4gICAgdmFyIERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknO1xuICAgIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkJCQxLmZuW05BTUVdO1xuICAgIHZhciBEZWZhdWx0ID0ge1xuICAgICAgdG9nZ2xlOiB0cnVlLFxuICAgICAgcGFyZW50OiAnJ1xuICAgIH07XG4gICAgdmFyIERlZmF1bHRUeXBlID0ge1xuICAgICAgdG9nZ2xlOiAnYm9vbGVhbicsXG4gICAgICBwYXJlbnQ6ICcoc3RyaW5nfGVsZW1lbnQpJ1xuICAgIH07XG4gICAgdmFyIEV2ZW50ID0ge1xuICAgICAgU0hPVzogXCJzaG93XCIgKyBFVkVOVF9LRVksXG4gICAgICBTSE9XTjogXCJzaG93blwiICsgRVZFTlRfS0VZLFxuICAgICAgSElERTogXCJoaWRlXCIgKyBFVkVOVF9LRVksXG4gICAgICBISURERU46IFwiaGlkZGVuXCIgKyBFVkVOVF9LRVksXG4gICAgICBDTElDS19EQVRBX0FQSTogXCJjbGlja1wiICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZXG4gICAgfTtcbiAgICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgICAgU0hPVzogJ3Nob3cnLFxuICAgICAgQ09MTEFQU0U6ICdjb2xsYXBzZScsXG4gICAgICBDT0xMQVBTSU5HOiAnY29sbGFwc2luZycsXG4gICAgICBDT0xMQVBTRUQ6ICdjb2xsYXBzZWQnXG4gICAgfTtcbiAgICB2YXIgRGltZW5zaW9uID0ge1xuICAgICAgV0lEVEg6ICd3aWR0aCcsXG4gICAgICBIRUlHSFQ6ICdoZWlnaHQnXG4gICAgfTtcbiAgICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgICBBQ1RJVkVTOiAnLnNob3csIC5jb2xsYXBzaW5nJyxcbiAgICAgIERBVEFfVE9HR0xFOiAnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nXG4gICAgICAvKipcbiAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgKi9cblxuICAgIH07XG5cbiAgICB2YXIgQ29sbGFwc2UgPVxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb2xsYXBzZShlbGVtZW50LCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckFycmF5ID0gJCQkMS5tYWtlQXJyYXkoJCQkMShcIltkYXRhLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiXVtocmVmPVxcXCIjXCIgKyBlbGVtZW50LmlkICsgXCJcXFwiXSxcIiArIChcIltkYXRhLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiXVtkYXRhLXRhcmdldD1cXFwiI1wiICsgZWxlbWVudC5pZCArIFwiXFxcIl1cIikpKTtcbiAgICAgICAgdmFyIHRhYlRvZ2dsZXMgPSAkJCQxKFNlbGVjdG9yLkRBVEFfVE9HR0xFKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYlRvZ2dsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlbSA9IHRhYlRvZ2dsZXNbaV07XG4gICAgICAgICAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW0pO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdG9yICE9PSBudWxsICYmICQkJDEoc2VsZWN0b3IpLmZpbHRlcihlbGVtZW50KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xuXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyQXJyYXkucHVzaChlbGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50ID8gdGhpcy5fZ2V0UGFyZW50KCkgOiBudWxsO1xuXG4gICAgICAgIGlmICghdGhpcy5fY29uZmlnLnBhcmVudCkge1xuICAgICAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl90cmlnZ2VyQXJyYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy50b2dnbGUpIHtcbiAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICB9XG4gICAgICB9IC8vIEdldHRlcnNcblxuXG4gICAgICB2YXIgX3Byb3RvID0gQ29sbGFwc2UucHJvdG90eXBlO1xuXG4gICAgICAvLyBQdWJsaWNcbiAgICAgIF9wcm90by50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICAgIGlmICgkJCQxKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCAkJCQxKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3RpdmVzO1xuICAgICAgICB2YXIgYWN0aXZlc0RhdGE7XG5cbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICAgIGFjdGl2ZXMgPSAkJCQxLm1ha2VBcnJheSgkJCQxKHRoaXMuX3BhcmVudCkuZmluZChTZWxlY3Rvci5BQ1RJVkVTKS5maWx0ZXIoXCJbZGF0YS1wYXJlbnQ9XFxcIlwiICsgdGhpcy5fY29uZmlnLnBhcmVudCArIFwiXFxcIl1cIikpO1xuXG4gICAgICAgICAgaWYgKGFjdGl2ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBhY3RpdmVzID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aXZlcykge1xuICAgICAgICAgIGFjdGl2ZXNEYXRhID0gJCQkMShhY3RpdmVzKS5ub3QodGhpcy5fc2VsZWN0b3IpLmRhdGEoREFUQV9LRVkpO1xuXG4gICAgICAgICAgaWYgKGFjdGl2ZXNEYXRhICYmIGFjdGl2ZXNEYXRhLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRFdmVudCA9ICQkJDEuRXZlbnQoRXZlbnQuU0hPVyk7XG4gICAgICAgICQkJDEodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzdGFydEV2ZW50KTtcblxuICAgICAgICBpZiAoc3RhcnRFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3RpdmVzKSB7XG4gICAgICAgICAgQ29sbGFwc2UuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQkJDEoYWN0aXZlcykubm90KHRoaXMuX3NlbGVjdG9yKSwgJ2hpZGUnKTtcblxuICAgICAgICAgIGlmICghYWN0aXZlc0RhdGEpIHtcbiAgICAgICAgICAgICQkJDEoYWN0aXZlcykuZGF0YShEQVRBX0tFWSwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpO1xuXG4gICAgICAgICQkJDEodGhpcy5fZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFKS5hZGRDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0lORyk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgJCQkMSh0aGlzLl90cmlnZ2VyQXJyYXkpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5DT0xMQVBTRUQpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyh0cnVlKTtcblxuICAgICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgICAkJCQxKF90aGlzLl9lbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0lORykuYWRkQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFKS5hZGRDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG4gICAgICAgICAgX3RoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnO1xuXG4gICAgICAgICAgX3RoaXMuc2V0VHJhbnNpdGlvbmluZyhmYWxzZSk7XG5cbiAgICAgICAgICAkJCQxKF90aGlzLl9lbGVtZW50KS50cmlnZ2VyKEV2ZW50LlNIT1dOKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2FwaXRhbGl6ZWREaW1lbnNpb24gPSBkaW1lbnNpb25bMF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSgxKTtcbiAgICAgICAgdmFyIHNjcm9sbFNpemUgPSBcInNjcm9sbFwiICsgY2FwaXRhbGl6ZWREaW1lbnNpb247XG4gICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICAkJCQxKHRoaXMuX2VsZW1lbnQpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gdGhpcy5fZWxlbWVudFtzY3JvbGxTaXplXSArIFwicHhcIjtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCAhJCQkMSh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRFdmVudCA9ICQkJDEuRXZlbnQoRXZlbnQuSElERSk7XG4gICAgICAgICQkJDEodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzdGFydEV2ZW50KTtcblxuICAgICAgICBpZiAoc3RhcnRFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcblxuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSB0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RpbWVuc2lvbl0gKyBcInB4XCI7XG4gICAgICAgIFV0aWwucmVmbG93KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICAkJCQxKHRoaXMuX2VsZW1lbnQpLmFkZENsYXNzKENsYXNzTmFtZS5DT0xMQVBTSU5HKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0UpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5TSE9XKTtcblxuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRyaWdnZXIgPSB0aGlzLl90cmlnZ2VyQXJyYXlbaV07XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodHJpZ2dlcik7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgJGVsZW0gPSAkJCQxKHNlbGVjdG9yKTtcblxuICAgICAgICAgICAgICBpZiAoISRlbGVtLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICAgICAgICAgICQkJDEodHJpZ2dlcikuYWRkQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFRCkuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyh0cnVlKTtcblxuICAgICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgICBfdGhpczIuc2V0VHJhbnNpdGlvbmluZyhmYWxzZSk7XG5cbiAgICAgICAgICAkJCQxKF90aGlzMi5fZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNJTkcpLmFkZENsYXNzKENsYXNzTmFtZS5DT0xMQVBTRSkudHJpZ2dlcihFdmVudC5ISURERU4pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnO1xuICAgICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgJCQkMSh0aGlzLl9lbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uc2V0VHJhbnNpdGlvbmluZyA9IGZ1bmN0aW9uIHNldFRyYW5zaXRpb25pbmcoaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGlzVHJhbnNpdGlvbmluZztcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgJCQkMS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKTtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJBcnJheSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IG51bGw7XG4gICAgICB9OyAvLyBQcml2YXRlXG5cblxuICAgICAgX3Byb3RvLl9nZXRDb25maWcgPSBmdW5jdGlvbiBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgICBjb25maWcgPSBfb2JqZWN0U3ByZWFkKHt9LCBEZWZhdWx0LCBjb25maWcpO1xuICAgICAgICBjb25maWcudG9nZ2xlID0gQm9vbGVhbihjb25maWcudG9nZ2xlKTsgLy8gQ29lcmNlIHN0cmluZyB2YWx1ZXNcblxuICAgICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5fZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gX2dldERpbWVuc2lvbigpIHtcbiAgICAgICAgdmFyIGhhc1dpZHRoID0gJCQkMSh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhEaW1lbnNpb24uV0lEVEgpO1xuICAgICAgICByZXR1cm4gaGFzV2lkdGggPyBEaW1lbnNpb24uV0lEVEggOiBEaW1lbnNpb24uSEVJR0hUO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9nZXRQYXJlbnQgPSBmdW5jdGlvbiBfZ2V0UGFyZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB2YXIgcGFyZW50ID0gbnVsbDtcblxuICAgICAgICBpZiAoVXRpbC5pc0VsZW1lbnQodGhpcy5fY29uZmlnLnBhcmVudCkpIHtcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50OyAvLyBJdCdzIGEgalF1ZXJ5IG9iamVjdFxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcucGFyZW50LmpxdWVyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IHRoaXMuX2NvbmZpZy5wYXJlbnRbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudCA9ICQkJDEodGhpcy5fY29uZmlnLnBhcmVudClbMF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZWN0b3IgPSBcIltkYXRhLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiXVtkYXRhLXBhcmVudD1cXFwiXCIgKyB0aGlzLl9jb25maWcucGFyZW50ICsgXCJcXFwiXVwiO1xuICAgICAgICAkJCQxKHBhcmVudCkuZmluZChzZWxlY3RvcikuZWFjaChmdW5jdGlvbiAoaSwgZWxlbWVudCkge1xuICAgICAgICAgIF90aGlzMy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKENvbGxhcHNlLl9nZXRUYXJnZXRGcm9tRWxlbWVudChlbGVtZW50KSwgW2VsZW1lbnRdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyA9IGZ1bmN0aW9uIF9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoZWxlbWVudCwgdHJpZ2dlckFycmF5KSB7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGlzT3BlbiA9ICQkJDEoZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuXG4gICAgICAgICAgaWYgKHRyaWdnZXJBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAkJCQxKHRyaWdnZXJBcnJheSkudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFRCwgIWlzT3BlbikuYXR0cignYXJpYS1leHBhbmRlZCcsIGlzT3Blbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9OyAvLyBTdGF0aWNcblxuXG4gICAgICBDb2xsYXBzZS5fZ2V0VGFyZ2V0RnJvbUVsZW1lbnQgPSBmdW5jdGlvbiBfZ2V0VGFyZ2V0RnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIHJldHVybiBzZWxlY3RvciA/ICQkJDEoc2VsZWN0b3IpWzBdIDogbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIENvbGxhcHNlLl9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgJHRoaXMgPSAkJCQxKHRoaXMpO1xuICAgICAgICAgIHZhciBkYXRhID0gJHRoaXMuZGF0YShEQVRBX0tFWSk7XG5cbiAgICAgICAgICB2YXIgX2NvbmZpZyA9IF9vYmplY3RTcHJlYWQoe30sIERlZmF1bHQsICR0aGlzLmRhdGEoKSwgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pO1xuXG4gICAgICAgICAgaWYgKCFkYXRhICYmIF9jb25maWcudG9nZ2xlICYmIC9zaG93fGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgICAgICAgX2NvbmZpZy50b2dnbGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgQ29sbGFwc2UodGhpcywgX2NvbmZpZyk7XG4gICAgICAgICAgICAkdGhpcy5kYXRhKERBVEFfS0VZLCBkYXRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gbWV0aG9kIG5hbWVkIFxcXCJcIiArIGNvbmZpZyArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIF9jcmVhdGVDbGFzcyhDb2xsYXBzZSwgbnVsbCwgW3tcbiAgICAgICAga2V5OiBcIlZFUlNJT05cIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcIkRlZmF1bHRcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIERlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIENvbGxhcHNlO1xuICAgIH0oKTtcbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG5cbiAgICAkJCQxKGRvY3VtZW50KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gcHJldmVudERlZmF1bHQgb25seSBmb3IgPGE+IGVsZW1lbnRzICh3aGljaCBjaGFuZ2UgdGhlIFVSTCkgbm90IGluc2lkZSB0aGUgY29sbGFwc2libGUgZWxlbWVudFxuICAgICAgaWYgKGV2ZW50LmN1cnJlbnRUYXJnZXQudGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciAkdHJpZ2dlciA9ICQkJDEodGhpcyk7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcyk7XG4gICAgICAkJCQxKHNlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICR0YXJnZXQgPSAkJCQxKHRoaXMpO1xuICAgICAgICB2YXIgZGF0YSA9ICR0YXJnZXQuZGF0YShEQVRBX0tFWSk7XG4gICAgICAgIHZhciBjb25maWcgPSBkYXRhID8gJ3RvZ2dsZScgOiAkdHJpZ2dlci5kYXRhKCk7XG5cbiAgICAgICAgQ29sbGFwc2UuX2pRdWVyeUludGVyZmFjZS5jYWxsKCR0YXJnZXQsIGNvbmZpZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBqUXVlcnlcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuICAgICQkJDEuZm5bTkFNRV0gPSBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlO1xuICAgICQkJDEuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBDb2xsYXBzZTtcblxuICAgICQkJDEuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICQkJDEuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XG4gICAgICByZXR1cm4gQ29sbGFwc2UuX2pRdWVyeUludGVyZmFjZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbGxhcHNlO1xuICB9KCQpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgKHY0LjEuMSk6IGRyb3Bkb3duLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBEcm9wZG93biA9IGZ1bmN0aW9uICgkJCQxKSB7XG4gICAgLyoqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogQ29uc3RhbnRzXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG4gICAgdmFyIE5BTUUgPSAnZHJvcGRvd24nO1xuICAgIHZhciBWRVJTSU9OID0gJzQuMS4xJztcbiAgICB2YXIgREFUQV9LRVkgPSAnYnMuZHJvcGRvd24nO1xuICAgIHZhciBFVkVOVF9LRVkgPSBcIi5cIiArIERBVEFfS0VZO1xuICAgIHZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbiAgICB2YXIgSlFVRVJZX05PX0NPTkZMSUNUID0gJCQkMS5mbltOQU1FXTtcbiAgICB2YXIgRVNDQVBFX0tFWUNPREUgPSAyNzsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgRXNjYXBlIChFc2MpIGtleVxuXG4gICAgdmFyIFNQQUNFX0tFWUNPREUgPSAzMjsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3Igc3BhY2Uga2V5XG5cbiAgICB2YXIgVEFCX0tFWUNPREUgPSA5OyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciB0YWIga2V5XG5cbiAgICB2YXIgQVJST1dfVVBfS0VZQ09ERSA9IDM4OyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciB1cCBhcnJvdyBrZXlcblxuICAgIHZhciBBUlJPV19ET1dOX0tFWUNPREUgPSA0MDsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgZG93biBhcnJvdyBrZXlcblxuICAgIHZhciBSSUdIVF9NT1VTRV9CVVRUT05fV0hJQ0ggPSAzOyAvLyBNb3VzZUV2ZW50LndoaWNoIHZhbHVlIGZvciB0aGUgcmlnaHQgYnV0dG9uIChhc3N1bWluZyBhIHJpZ2h0LWhhbmRlZCBtb3VzZSlcblxuICAgIHZhciBSRUdFWFBfS0VZRE9XTiA9IG5ldyBSZWdFeHAoQVJST1dfVVBfS0VZQ09ERSArIFwifFwiICsgQVJST1dfRE9XTl9LRVlDT0RFICsgXCJ8XCIgKyBFU0NBUEVfS0VZQ09ERSk7XG4gICAgdmFyIEV2ZW50ID0ge1xuICAgICAgSElERTogXCJoaWRlXCIgKyBFVkVOVF9LRVksXG4gICAgICBISURERU46IFwiaGlkZGVuXCIgKyBFVkVOVF9LRVksXG4gICAgICBTSE9XOiBcInNob3dcIiArIEVWRU5UX0tFWSxcbiAgICAgIFNIT1dOOiBcInNob3duXCIgKyBFVkVOVF9LRVksXG4gICAgICBDTElDSzogXCJjbGlja1wiICsgRVZFTlRfS0VZLFxuICAgICAgQ0xJQ0tfREFUQV9BUEk6IFwiY2xpY2tcIiArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWSxcbiAgICAgIEtFWURPV05fREFUQV9BUEk6IFwia2V5ZG93blwiICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZLFxuICAgICAgS0VZVVBfREFUQV9BUEk6IFwia2V5dXBcIiArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWVxuICAgIH07XG4gICAgdmFyIENsYXNzTmFtZSA9IHtcbiAgICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgICAgU0hPVzogJ3Nob3cnLFxuICAgICAgRFJPUFVQOiAnZHJvcHVwJyxcbiAgICAgIERST1BSSUdIVDogJ2Ryb3ByaWdodCcsXG4gICAgICBEUk9QTEVGVDogJ2Ryb3BsZWZ0JyxcbiAgICAgIE1FTlVSSUdIVDogJ2Ryb3Bkb3duLW1lbnUtcmlnaHQnLFxuICAgICAgTUVOVUxFRlQ6ICdkcm9wZG93bi1tZW51LWxlZnQnLFxuICAgICAgUE9TSVRJT05fU1RBVElDOiAncG9zaXRpb24tc3RhdGljJ1xuICAgIH07XG4gICAgdmFyIFNlbGVjdG9yID0ge1xuICAgICAgREFUQV9UT0dHTEU6ICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXScsXG4gICAgICBGT1JNX0NISUxEOiAnLmRyb3Bkb3duIGZvcm0nLFxuICAgICAgTUVOVTogJy5kcm9wZG93bi1tZW51JyxcbiAgICAgIE5BVkJBUl9OQVY6ICcubmF2YmFyLW5hdicsXG4gICAgICBWSVNJQkxFX0lURU1TOiAnLmRyb3Bkb3duLW1lbnUgLmRyb3Bkb3duLWl0ZW06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZCknXG4gICAgfTtcbiAgICB2YXIgQXR0YWNobWVudE1hcCA9IHtcbiAgICAgIFRPUDogJ3RvcC1zdGFydCcsXG4gICAgICBUT1BFTkQ6ICd0b3AtZW5kJyxcbiAgICAgIEJPVFRPTTogJ2JvdHRvbS1zdGFydCcsXG4gICAgICBCT1RUT01FTkQ6ICdib3R0b20tZW5kJyxcbiAgICAgIFJJR0hUOiAncmlnaHQtc3RhcnQnLFxuICAgICAgUklHSFRFTkQ6ICdyaWdodC1lbmQnLFxuICAgICAgTEVGVDogJ2xlZnQtc3RhcnQnLFxuICAgICAgTEVGVEVORDogJ2xlZnQtZW5kJ1xuICAgIH07XG4gICAgdmFyIERlZmF1bHQgPSB7XG4gICAgICBvZmZzZXQ6IDAsXG4gICAgICBmbGlwOiB0cnVlLFxuICAgICAgYm91bmRhcnk6ICdzY3JvbGxQYXJlbnQnLFxuICAgICAgcmVmZXJlbmNlOiAndG9nZ2xlJyxcbiAgICAgIGRpc3BsYXk6ICdkeW5hbWljJ1xuICAgIH07XG4gICAgdmFyIERlZmF1bHRUeXBlID0ge1xuICAgICAgb2Zmc2V0OiAnKG51bWJlcnxzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgICAgIGZsaXA6ICdib29sZWFuJyxcbiAgICAgIGJvdW5kYXJ5OiAnKHN0cmluZ3xlbGVtZW50KScsXG4gICAgICByZWZlcmVuY2U6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgICAgIGRpc3BsYXk6ICdzdHJpbmcnXG4gICAgICAvKipcbiAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgKi9cblxuICAgIH07XG5cbiAgICB2YXIgRHJvcGRvd24gPVxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBEcm9wZG93bihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgICB0aGlzLl9tZW51ID0gdGhpcy5fZ2V0TWVudUVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKTtcblxuICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgICAgfSAvLyBHZXR0ZXJzXG5cblxuICAgICAgdmFyIF9wcm90byA9IERyb3Bkb3duLnByb3RvdHlwZTtcblxuICAgICAgLy8gUHVibGljXG4gICAgICBfcHJvdG8udG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgICBpZiAodGhpcy5fZWxlbWVudC5kaXNhYmxlZCB8fCAkJCQxKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5ESVNBQkxFRCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50ID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgICAgIHZhciBpc0FjdGl2ZSA9ICQkJDEodGhpcy5fbWVudSkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuXG4gICAgICAgIERyb3Bkb3duLl9jbGVhck1lbnVzKCk7XG5cbiAgICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2hvd0V2ZW50ID0gJCQkMS5FdmVudChFdmVudC5TSE9XLCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgJCQkMShwYXJlbnQpLnRyaWdnZXIoc2hvd0V2ZW50KTtcblxuICAgICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIERpc2FibGUgdG90YWxseSBQb3BwZXIuanMgZm9yIERyb3Bkb3duIGluIE5hdmJhclxuXG5cbiAgICAgICAgaWYgKCF0aGlzLl9pbk5hdmJhcikge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIENoZWNrIGZvciBQb3BwZXIgZGVwZW5kZW5jeVxuICAgICAgICAgICAqIFBvcHBlciAtIGh0dHBzOi8vcG9wcGVyLmpzLm9yZ1xuICAgICAgICAgICAqL1xuICAgICAgICAgIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwIGRyb3Bkb3duIHJlcXVpcmUgUG9wcGVyLmpzIChodHRwczovL3BvcHBlci5qcy5vcmcpJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuXG4gICAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09ICdwYXJlbnQnKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gcGFyZW50O1xuICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbC5pc0VsZW1lbnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlOyAvLyBDaGVjayBpZiBpdCdzIGpRdWVyeSBlbGVtZW50XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5fY29uZmlnLnJlZmVyZW5jZS5qcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gSWYgYm91bmRhcnkgaXMgbm90IGBzY3JvbGxQYXJlbnRgLCB0aGVuIHNldCBwb3NpdGlvbiB0byBgc3RhdGljYFxuICAgICAgICAgIC8vIHRvIGFsbG93IHRoZSBtZW51IHRvIFwiZXNjYXBlXCIgdGhlIHNjcm9sbCBwYXJlbnQncyBib3VuZGFyaWVzXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2lzc3Vlcy8yNDI1MVxuXG5cbiAgICAgICAgICBpZiAodGhpcy5fY29uZmlnLmJvdW5kYXJ5ICE9PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgICAgICAgICAgJCQkMShwYXJlbnQpLmFkZENsYXNzKENsYXNzTmFtZS5QT1NJVElPTl9TVEFUSUMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3BvcHBlciA9IG5ldyBQb3BwZXIocmVmZXJlbmNlRWxlbWVudCwgdGhpcy5fbWVudSwgdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKCkpO1xuICAgICAgICB9IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcbiAgICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlbjtcbiAgICAgICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXG5cblxuICAgICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICQkJDEocGFyZW50KS5jbG9zZXN0KFNlbGVjdG9yLk5BVkJBUl9OQVYpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICQkJDEoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vbignbW91c2VvdmVyJywgbnVsbCwgJCQkMS5ub29wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuZm9jdXMoKTtcblxuICAgICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuXG4gICAgICAgICQkJDEodGhpcy5fbWVudSkudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuICAgICAgICAkJCQxKHBhcmVudCkudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpLnRyaWdnZXIoJCQkMS5FdmVudChFdmVudC5TSE9XTiwgcmVsYXRlZFRhcmdldCkpO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAkJCQxLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuICAgICAgICAkJCQxKHRoaXMuX2VsZW1lbnQpLm9mZihFVkVOVF9LRVkpO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWVudSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuX3BvcHBlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XG5cbiAgICAgICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xuXG4gICAgICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9wb3BwZXIuc2NoZWR1bGVVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfTsgLy8gUHJpdmF0ZVxuXG5cbiAgICAgIF9wcm90by5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgJCQkMSh0aGlzLl9lbGVtZW50KS5vbihFdmVudC5DTElDSywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgIF90aGlzLnRvZ2dsZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgY29uZmlnID0gX29iamVjdFNwcmVhZCh7fSwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LCAkJCQxKHRoaXMuX2VsZW1lbnQpLmRhdGEoKSwgY29uZmlnKTtcbiAgICAgICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5fZ2V0TWVudUVsZW1lbnQgPSBmdW5jdGlvbiBfZ2V0TWVudUVsZW1lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWVudSkge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG5cbiAgICAgICAgICB0aGlzLl9tZW51ID0gJCQkMShwYXJlbnQpLmZpbmQoU2VsZWN0b3IuTUVOVSlbMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbWVudTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5fZ2V0UGxhY2VtZW50ID0gZnVuY3Rpb24gX2dldFBsYWNlbWVudCgpIHtcbiAgICAgICAgdmFyICRwYXJlbnREcm9wZG93biA9ICQkJDEodGhpcy5fZWxlbWVudCkucGFyZW50KCk7XG4gICAgICAgIHZhciBwbGFjZW1lbnQgPSBBdHRhY2htZW50TWFwLkJPVFRPTTsgLy8gSGFuZGxlIGRyb3B1cFxuXG4gICAgICAgIGlmICgkcGFyZW50RHJvcGRvd24uaGFzQ2xhc3MoQ2xhc3NOYW1lLkRST1BVUCkpIHtcbiAgICAgICAgICBwbGFjZW1lbnQgPSBBdHRhY2htZW50TWFwLlRPUDtcblxuICAgICAgICAgIGlmICgkJCQxKHRoaXMuX21lbnUpLmhhc0NsYXNzKENsYXNzTmFtZS5NRU5VUklHSFQpKSB7XG4gICAgICAgICAgICBwbGFjZW1lbnQgPSBBdHRhY2htZW50TWFwLlRPUEVORDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoJHBhcmVudERyb3Bkb3duLmhhc0NsYXNzKENsYXNzTmFtZS5EUk9QUklHSFQpKSB7XG4gICAgICAgICAgcGxhY2VtZW50ID0gQXR0YWNobWVudE1hcC5SSUdIVDtcbiAgICAgICAgfSBlbHNlIGlmICgkcGFyZW50RHJvcGRvd24uaGFzQ2xhc3MoQ2xhc3NOYW1lLkRST1BMRUZUKSkge1xuICAgICAgICAgIHBsYWNlbWVudCA9IEF0dGFjaG1lbnRNYXAuTEVGVDtcbiAgICAgICAgfSBlbHNlIGlmICgkJCQxKHRoaXMuX21lbnUpLmhhc0NsYXNzKENsYXNzTmFtZS5NRU5VUklHSFQpKSB7XG4gICAgICAgICAgcGxhY2VtZW50ID0gQXR0YWNobWVudE1hcC5CT1RUT01FTkQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGxhY2VtZW50O1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9kZXRlY3ROYXZiYXIgPSBmdW5jdGlvbiBfZGV0ZWN0TmF2YmFyKCkge1xuICAgICAgICByZXR1cm4gJCQkMSh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KCcubmF2YmFyJykubGVuZ3RoID4gMDtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5fZ2V0UG9wcGVyQ29uZmlnID0gZnVuY3Rpb24gX2dldFBvcHBlckNvbmZpZygpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG9mZnNldENvbmYgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5vZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvZmZzZXRDb25mLmZuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEub2Zmc2V0cyA9IF9vYmplY3RTcHJlYWQoe30sIGRhdGEub2Zmc2V0cywgX3RoaXMyLl9jb25maWcub2Zmc2V0KGRhdGEub2Zmc2V0cykgfHwge30pO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXRDb25mLm9mZnNldCA9IHRoaXMuX2NvbmZpZy5vZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9wcGVyQ29uZmlnID0ge1xuICAgICAgICAgIHBsYWNlbWVudDogdGhpcy5fZ2V0UGxhY2VtZW50KCksXG4gICAgICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldENvbmYsXG4gICAgICAgICAgICBmbGlwOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRoaXMuX2NvbmZpZy5mbGlwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIERpc2FibGUgUG9wcGVyLmpzIGlmIHdlIGhhdmUgYSBzdGF0aWMgZGlzcGxheVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5kaXNwbGF5ID09PSAnc3RhdGljJykge1xuICAgICAgICAgIHBvcHBlckNvbmZpZy5tb2RpZmllcnMuYXBwbHlTdHlsZSA9IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3BwZXJDb25maWc7XG4gICAgICB9OyAvLyBTdGF0aWNcblxuXG4gICAgICBEcm9wZG93bi5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSAkJCQxKHRoaXMpLmRhdGEoREFUQV9LRVkpO1xuXG4gICAgICAgICAgdmFyIF9jb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IG51bGw7XG5cbiAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgRHJvcGRvd24odGhpcywgX2NvbmZpZyk7XG4gICAgICAgICAgICAkJCQxKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyBtZXRob2QgbmFtZWQgXFxcIlwiICsgY29uZmlnICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgRHJvcGRvd24uX2NsZWFyTWVudXMgPSBmdW5jdGlvbiBfY2xlYXJNZW51cyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQgJiYgKGV2ZW50LndoaWNoID09PSBSSUdIVF9NT1VTRV9CVVRUT05fV0hJQ0ggfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC53aGljaCAhPT0gVEFCX0tFWUNPREUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvZ2dsZXMgPSAkJCQxLm1ha2VBcnJheSgkJCQxKFNlbGVjdG9yLkRBVEFfVE9HR0xFKSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2dnbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IERyb3Bkb3duLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0b2dnbGVzW2ldKTtcblxuICAgICAgICAgIHZhciBjb250ZXh0ID0gJCQkMSh0b2dnbGVzW2ldKS5kYXRhKERBVEFfS0VZKTtcbiAgICAgICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRvZ2dsZXNbaV1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZHJvcGRvd25NZW51ID0gY29udGV4dC5fbWVudTtcblxuICAgICAgICAgIGlmICghJCQkMShwYXJlbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGV2ZW50ICYmIChldmVudC50eXBlID09PSAnY2xpY2snICYmIC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQud2hpY2ggPT09IFRBQl9LRVlDT0RFKSAmJiAkJCQxLmNvbnRhaW5zKHBhcmVudCwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGhpZGVFdmVudCA9ICQkJDEuRXZlbnQoRXZlbnQuSElERSwgcmVsYXRlZFRhcmdldCk7XG4gICAgICAgICAgJCQkMShwYXJlbnQpLnRyaWdnZXIoaGlkZUV2ZW50KTtcblxuICAgICAgICAgIGlmIChoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcbiAgICAgICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxuXG5cbiAgICAgICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAkJCQxKGRvY3VtZW50LmJvZHkpLmNoaWxkcmVuKCkub2ZmKCdtb3VzZW92ZXInLCBudWxsLCAkJCQxLm5vb3ApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvZ2dsZXNbaV0uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgJCQkMShkcm9wZG93bk1lbnUpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5TSE9XKTtcbiAgICAgICAgICAkJCQxKHBhcmVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpLnRyaWdnZXIoJCQkMS5FdmVudChFdmVudC5ISURERU4sIHJlbGF0ZWRUYXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50ID0gZnVuY3Rpb24gX2dldFBhcmVudEZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHBhcmVudDtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgIHBhcmVudCA9ICQkJDEoc2VsZWN0b3IpWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudCB8fCBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG5cbiAgICAgIERyb3Bkb3duLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIgPSBmdW5jdGlvbiBfZGF0YUFwaUtleWRvd25IYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIC8vIElmIG5vdCBpbnB1dC90ZXh0YXJlYTpcbiAgICAgICAgLy8gIC0gQW5kIG5vdCBhIGtleSBpbiBSRUdFWFBfS0VZRE9XTiA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgICAgIC8vIElmIGlucHV0L3RleHRhcmVhOlxuICAgICAgICAvLyAgLSBJZiBzcGFjZSBrZXkgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgICAgICAvLyAgLSBJZiBrZXkgaXMgb3RoZXIgdGhhbiBlc2NhcGVcbiAgICAgICAgLy8gICAgLSBJZiBrZXkgaXMgbm90IHVwIG9yIGRvd24gPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgICAgICAvLyAgICAtIElmIHRyaWdnZXIgaW5zaWRlIHRoZSBtZW51ID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcbiAgICAgICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpID8gZXZlbnQud2hpY2ggPT09IFNQQUNFX0tFWUNPREUgfHwgZXZlbnQud2hpY2ggIT09IEVTQ0FQRV9LRVlDT0RFICYmIChldmVudC53aGljaCAhPT0gQVJST1dfRE9XTl9LRVlDT0RFICYmIGV2ZW50LndoaWNoICE9PSBBUlJPV19VUF9LRVlDT0RFIHx8ICQkJDEoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFNlbGVjdG9yLk1FTlUpLmxlbmd0aCkgOiAhUkVHRVhQX0tFWURPV04udGVzdChldmVudC53aGljaCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAkJCQxKHRoaXMpLmhhc0NsYXNzKENsYXNzTmFtZS5ESVNBQkxFRCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50ID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMpO1xuXG4gICAgICAgIHZhciBpc0FjdGl2ZSA9ICQkJDEocGFyZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG5cbiAgICAgICAgaWYgKCFpc0FjdGl2ZSAmJiAoZXZlbnQud2hpY2ggIT09IEVTQ0FQRV9LRVlDT0RFIHx8IGV2ZW50LndoaWNoICE9PSBTUEFDRV9LRVlDT0RFKSB8fCBpc0FjdGl2ZSAmJiAoZXZlbnQud2hpY2ggPT09IEVTQ0FQRV9LRVlDT0RFIHx8IGV2ZW50LndoaWNoID09PSBTUEFDRV9LRVlDT0RFKSkge1xuICAgICAgICAgIGlmIChldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUpIHtcbiAgICAgICAgICAgIHZhciB0b2dnbGUgPSAkJCQxKHBhcmVudCkuZmluZChTZWxlY3Rvci5EQVRBX1RPR0dMRSlbMF07XG4gICAgICAgICAgICAkJCQxKHRvZ2dsZSkudHJpZ2dlcignZm9jdXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkJCQxKHRoaXMpLnRyaWdnZXIoJ2NsaWNrJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZW1zID0gJCQkMShwYXJlbnQpLmZpbmQoU2VsZWN0b3IuVklTSUJMRV9JVEVNUykuZ2V0KCk7XG5cbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IGl0ZW1zLmluZGV4T2YoZXZlbnQudGFyZ2V0KTtcblxuICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IEFSUk9XX1VQX0tFWUNPREUgJiYgaW5kZXggPiAwKSB7XG4gICAgICAgICAgLy8gVXBcbiAgICAgICAgICBpbmRleC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBBUlJPV19ET1dOX0tFWUNPREUgJiYgaW5kZXggPCBpdGVtcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgLy8gRG93blxuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbXNbaW5kZXhdLmZvY3VzKCk7XG4gICAgICB9O1xuXG4gICAgICBfY3JlYXRlQ2xhc3MoRHJvcGRvd24sIG51bGwsIFt7XG4gICAgICAgIGtleTogXCJWRVJTSU9OXCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJEZWZhdWx0XCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJEZWZhdWx0VHlwZVwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gRGVmYXVsdFR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIERyb3Bkb3duO1xuICAgIH0oKTtcbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG5cbiAgICAkJCQxKGRvY3VtZW50KS5vbihFdmVudC5LRVlET1dOX0RBVEFfQVBJLCBTZWxlY3Rvci5EQVRBX1RPR0dMRSwgRHJvcGRvd24uX2RhdGFBcGlLZXlkb3duSGFuZGxlcikub24oRXZlbnQuS0VZRE9XTl9EQVRBX0FQSSwgU2VsZWN0b3IuTUVOVSwgRHJvcGRvd24uX2RhdGFBcGlLZXlkb3duSGFuZGxlcikub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEkgKyBcIiBcIiArIEV2ZW50LktFWVVQX0RBVEFfQVBJLCBEcm9wZG93bi5fY2xlYXJNZW51cykub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkRBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZS5jYWxsKCQkJDEodGhpcyksICd0b2dnbGUnKTtcbiAgICB9KS5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuRk9STV9DSElMRCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogalF1ZXJ5XG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG5cbiAgICAkJCQxLmZuW05BTUVdID0gRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZTtcbiAgICAkJCQxLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gRHJvcGRvd247XG5cbiAgICAkJCQxLmZuW05BTUVdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAkJCQxLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgICAgcmV0dXJuIERyb3Bkb3duLl9qUXVlcnlJbnRlcmZhY2U7XG4gICAgfTtcblxuICAgIHJldHVybiBEcm9wZG93bjtcbiAgfSgkLCBQb3BwZXIpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgKHY0LjEuMSk6IG1vZGFsLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBNb2RhbCA9IGZ1bmN0aW9uICgkJCQxKSB7XG4gICAgLyoqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogQ29uc3RhbnRzXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG4gICAgdmFyIE5BTUUgPSAnbW9kYWwnO1xuICAgIHZhciBWRVJTSU9OID0gJzQuMS4xJztcbiAgICB2YXIgREFUQV9LRVkgPSAnYnMubW9kYWwnO1xuICAgIHZhciBFVkVOVF9LRVkgPSBcIi5cIiArIERBVEFfS0VZO1xuICAgIHZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbiAgICB2YXIgSlFVRVJZX05PX0NPTkZMSUNUID0gJCQkMS5mbltOQU1FXTtcbiAgICB2YXIgRVNDQVBFX0tFWUNPREUgPSAyNzsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgRXNjYXBlIChFc2MpIGtleVxuXG4gICAgdmFyIERlZmF1bHQgPSB7XG4gICAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICAgIGtleWJvYXJkOiB0cnVlLFxuICAgICAgZm9jdXM6IHRydWUsXG4gICAgICBzaG93OiB0cnVlXG4gICAgfTtcbiAgICB2YXIgRGVmYXVsdFR5cGUgPSB7XG4gICAgICBiYWNrZHJvcDogJyhib29sZWFufHN0cmluZyknLFxuICAgICAga2V5Ym9hcmQ6ICdib29sZWFuJyxcbiAgICAgIGZvY3VzOiAnYm9vbGVhbicsXG4gICAgICBzaG93OiAnYm9vbGVhbidcbiAgICB9O1xuICAgIHZhciBFdmVudCA9IHtcbiAgICAgIEhJREU6IFwiaGlkZVwiICsgRVZFTlRfS0VZLFxuICAgICAgSElEREVOOiBcImhpZGRlblwiICsgRVZFTlRfS0VZLFxuICAgICAgU0hPVzogXCJzaG93XCIgKyBFVkVOVF9LRVksXG4gICAgICBTSE9XTjogXCJzaG93blwiICsgRVZFTlRfS0VZLFxuICAgICAgRk9DVVNJTjogXCJmb2N1c2luXCIgKyBFVkVOVF9LRVksXG4gICAgICBSRVNJWkU6IFwicmVzaXplXCIgKyBFVkVOVF9LRVksXG4gICAgICBDTElDS19ESVNNSVNTOiBcImNsaWNrLmRpc21pc3NcIiArIEVWRU5UX0tFWSxcbiAgICAgIEtFWURPV05fRElTTUlTUzogXCJrZXlkb3duLmRpc21pc3NcIiArIEVWRU5UX0tFWSxcbiAgICAgIE1PVVNFVVBfRElTTUlTUzogXCJtb3VzZXVwLmRpc21pc3NcIiArIEVWRU5UX0tFWSxcbiAgICAgIE1PVVNFRE9XTl9ESVNNSVNTOiBcIm1vdXNlZG93bi5kaXNtaXNzXCIgKyBFVkVOVF9LRVksXG4gICAgICBDTElDS19EQVRBX0FQSTogXCJjbGlja1wiICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZXG4gICAgfTtcbiAgICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgICAgU0NST0xMQkFSX01FQVNVUkVSOiAnbW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUnLFxuICAgICAgQkFDS0RST1A6ICdtb2RhbC1iYWNrZHJvcCcsXG4gICAgICBPUEVOOiAnbW9kYWwtb3BlbicsXG4gICAgICBGQURFOiAnZmFkZScsXG4gICAgICBTSE9XOiAnc2hvdydcbiAgICB9O1xuICAgIHZhciBTZWxlY3RvciA9IHtcbiAgICAgIERJQUxPRzogJy5tb2RhbC1kaWFsb2cnLFxuICAgICAgREFUQV9UT0dHTEU6ICdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXScsXG4gICAgICBEQVRBX0RJU01JU1M6ICdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nLFxuICAgICAgRklYRURfQ09OVEVOVDogJy5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3AnLFxuICAgICAgU1RJQ0tZX0NPTlRFTlQ6ICcuc3RpY2t5LXRvcCcsXG4gICAgICBOQVZCQVJfVE9HR0xFUjogJy5uYXZiYXItdG9nZ2xlcidcbiAgICAgIC8qKlxuICAgICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgKiBDbGFzcyBEZWZpbml0aW9uXG4gICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAqL1xuXG4gICAgfTtcblxuICAgIHZhciBNb2RhbCA9XG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIE1vZGFsKGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2RpYWxvZyA9ICQkJDEoZWxlbWVudCkuZmluZChTZWxlY3Rvci5ESUFMT0cpWzBdO1xuICAgICAgICB0aGlzLl9iYWNrZHJvcCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zY3JvbGxiYXJXaWR0aCA9IDA7XG4gICAgICB9IC8vIEdldHRlcnNcblxuXG4gICAgICB2YXIgX3Byb3RvID0gTW9kYWwucHJvdG90eXBlO1xuXG4gICAgICAvLyBQdWJsaWNcbiAgICAgIF9wcm90by50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUocmVsYXRlZFRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLnNob3cgPSBmdW5jdGlvbiBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJCQkMSh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSkpIHtcbiAgICAgICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3dFdmVudCA9ICQkJDEuRXZlbnQoRXZlbnQuU0hPVywge1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXRcbiAgICAgICAgfSk7XG4gICAgICAgICQkJDEodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzaG93RXZlbnQpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc1Nob3duIHx8IHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX2NoZWNrU2Nyb2xsYmFyKCk7XG5cbiAgICAgICAgdGhpcy5fc2V0U2Nyb2xsYmFyKCk7XG5cbiAgICAgICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XG5cbiAgICAgICAgJCQkMShkb2N1bWVudC5ib2R5KS5hZGRDbGFzcyhDbGFzc05hbWUuT1BFTik7XG5cbiAgICAgICAgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKTtcblxuICAgICAgICB0aGlzLl9zZXRSZXNpemVFdmVudCgpO1xuXG4gICAgICAgICQkJDEodGhpcy5fZWxlbWVudCkub24oRXZlbnQuQ0xJQ0tfRElTTUlTUywgU2VsZWN0b3IuREFUQV9ESVNNSVNTLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuaGlkZShldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAkJCQxKHRoaXMuX2RpYWxvZykub24oRXZlbnQuTU9VU0VET1dOX0RJU01JU1MsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkJCQxKF90aGlzLl9lbGVtZW50KS5vbmUoRXZlbnQuTU9VU0VVUF9ESVNNSVNTLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICgkJCQxKGV2ZW50LnRhcmdldCkuaXMoX3RoaXMuX2VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fc2hvd0JhY2tkcm9wKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5oaWRlID0gZnVuY3Rpb24gaGlkZShldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCAhdGhpcy5faXNTaG93bikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoaWRlRXZlbnQgPSAkJCQxLkV2ZW50KEV2ZW50LkhJREUpO1xuICAgICAgICAkJCQxKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KTtcblxuICAgICAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9ICQkJDEodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpO1xuXG4gICAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldEVzY2FwZUV2ZW50KCk7XG5cbiAgICAgICAgdGhpcy5fc2V0UmVzaXplRXZlbnQoKTtcblxuICAgICAgICAkJCQxKGRvY3VtZW50KS5vZmYoRXZlbnQuRk9DVVNJTik7XG4gICAgICAgICQkJDEodGhpcy5fZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuICAgICAgICAkJCQxKHRoaXMuX2VsZW1lbnQpLm9mZihFdmVudC5DTElDS19ESVNNSVNTKTtcbiAgICAgICAgJCQkMSh0aGlzLl9kaWFsb2cpLm9mZihFdmVudC5NT1VTRURPV05fRElTTUlTUyk7XG5cbiAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgICAkJCQxKHRoaXMuX2VsZW1lbnQpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuX2hpZGVNb2RhbChldmVudCk7XG4gICAgICAgICAgfSkuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9oaWRlTW9kYWwoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3Byb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAkJCQxLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuICAgICAgICAkJCQxKHdpbmRvdywgZG9jdW1lbnQsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2JhY2tkcm9wKS5vZmYoRVZFTlRfS0VZKTtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RpYWxvZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2JhY2tkcm9wID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNTaG93biA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lzQm9keU92ZXJmbG93aW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Njcm9sbGJhcldpZHRoID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5oYW5kbGVVcGRhdGUgPSBmdW5jdGlvbiBoYW5kbGVVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xuICAgICAgfTsgLy8gUHJpdmF0ZVxuXG5cbiAgICAgIF9wcm90by5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgY29uZmlnID0gX29iamVjdFNwcmVhZCh7fSwgRGVmYXVsdCwgY29uZmlnKTtcbiAgICAgICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCBEZWZhdWx0VHlwZSk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uX3Nob3dFbGVtZW50ID0gZnVuY3Rpb24gX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSAkJCQxKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5GQURFKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSB8fCB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgbW92ZSBtb2RhbCdzIERPTSBwb3NpdGlvblxuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMDtcblxuICAgICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAgIFV0aWwucmVmbG93KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgJCQkMSh0aGlzLl9lbGVtZW50KS5hZGRDbGFzcyhDbGFzc05hbWUuU0hPVyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5mb2N1cykge1xuICAgICAgICAgIHRoaXMuX2VuZm9yY2VGb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3duRXZlbnQgPSAkJCQxLkV2ZW50KEV2ZW50LlNIT1dOLCB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdHJhbnNpdGlvbkNvbXBsZXRlID0gZnVuY3Rpb24gdHJhbnNpdGlvbkNvbXBsZXRlKCkge1xuICAgICAgICAgIGlmIChfdGhpczMuX2NvbmZpZy5mb2N1cykge1xuICAgICAgICAgICAgX3RoaXMzLl9lbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgICAgICAkJCQxKF90aGlzMy5fZWxlbWVudCkudHJpZ2dlcihzaG93bkV2ZW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICAgICQkJDEodGhpcy5fZGlhbG9nKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgdHJhbnNpdGlvbkNvbXBsZXRlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYW5zaXRpb25Db21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uX2VuZm9yY2VGb2N1cyA9IGZ1bmN0aW9uIF9lbmZvcmNlRm9jdXMoKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgICQkJDEoZG9jdW1lbnQpLm9mZihFdmVudC5GT0NVU0lOKSAvLyBHdWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcbiAgICAgICAgLm9uKEV2ZW50LkZPQ1VTSU4sIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGlmIChkb2N1bWVudCAhPT0gZXZlbnQudGFyZ2V0ICYmIF90aGlzNC5fZWxlbWVudCAhPT0gZXZlbnQudGFyZ2V0ICYmICQkJDEoX3RoaXM0Ll9lbGVtZW50KS5oYXMoZXZlbnQudGFyZ2V0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIF90aGlzNC5fZWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uX3NldEVzY2FwZUV2ZW50ID0gZnVuY3Rpb24gX3NldEVzY2FwZUV2ZW50KCkge1xuICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5faXNTaG93biAmJiB0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcbiAgICAgICAgICAkJCQxKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50LktFWURPV05fRElTTUlTUywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IEVTQ0FQRV9LRVlDT0RFKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgX3RoaXM1LmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTaG93bikge1xuICAgICAgICAgICQkJDEodGhpcy5fZWxlbWVudCkub2ZmKEV2ZW50LktFWURPV05fRElTTUlTUyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5fc2V0UmVzaXplRXZlbnQgPSBmdW5jdGlvbiBfc2V0UmVzaXplRXZlbnQoKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XG4gICAgICAgICAgJCQkMSh3aW5kb3cpLm9uKEV2ZW50LlJFU0laRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM2LmhhbmRsZVVwZGF0ZShldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJCQkMSh3aW5kb3cpLm9mZihFdmVudC5SRVNJWkUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uX2hpZGVNb2RhbCA9IGZ1bmN0aW9uIF9oaWRlTW9kYWwoKSB7XG4gICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcblxuICAgICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9zaG93QmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICQkJDEoZG9jdW1lbnQuYm9keSkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLk9QRU4pO1xuXG4gICAgICAgICAgX3RoaXM3Ll9yZXNldEFkanVzdG1lbnRzKCk7XG5cbiAgICAgICAgICBfdGhpczcuX3Jlc2V0U2Nyb2xsYmFyKCk7XG5cbiAgICAgICAgICAkJCQxKF90aGlzNy5fZWxlbWVudCkudHJpZ2dlcihFdmVudC5ISURERU4pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5fcmVtb3ZlQmFja2Ryb3AgPSBmdW5jdGlvbiBfcmVtb3ZlQmFja2Ryb3AoKSB7XG4gICAgICAgIGlmICh0aGlzLl9iYWNrZHJvcCkge1xuICAgICAgICAgICQkJDEodGhpcy5fYmFja2Ryb3ApLnJlbW92ZSgpO1xuICAgICAgICAgIHRoaXMuX2JhY2tkcm9wID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9zaG93QmFja2Ryb3AgPSBmdW5jdGlvbiBfc2hvd0JhY2tkcm9wKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICAgIHZhciBhbmltYXRlID0gJCQkMSh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSkgPyBDbGFzc05hbWUuRkFERSA6ICcnO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc1Nob3duICYmIHRoaXMuX2NvbmZpZy5iYWNrZHJvcCkge1xuICAgICAgICAgIHRoaXMuX2JhY2tkcm9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdGhpcy5fYmFja2Ryb3AuY2xhc3NOYW1lID0gQ2xhc3NOYW1lLkJBQ0tEUk9QO1xuXG4gICAgICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgICAgICQkJDEodGhpcy5fYmFja2Ryb3ApLmFkZENsYXNzKGFuaW1hdGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICQkJDEodGhpcy5fYmFja2Ryb3ApLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xuICAgICAgICAgICQkJDEodGhpcy5fZWxlbWVudCkub24oRXZlbnQuQ0xJQ0tfRElTTUlTUywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXM4Ll9pZ25vcmVCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgICAgICAgIF90aGlzOC5faWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoX3RoaXM4Ll9jb25maWcuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICAgIF90aGlzOC5fZWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXM4LmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgICBVdGlsLnJlZmxvdyh0aGlzLl9iYWNrZHJvcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgJCQkMSh0aGlzLl9iYWNrZHJvcCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpO1xuXG4gICAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghYW5pbWF0ZSkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2JhY2tkcm9wKTtcbiAgICAgICAgICAkJCQxKHRoaXMuX2JhY2tkcm9wKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY2FsbGJhY2spLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGJhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTaG93biAmJiB0aGlzLl9iYWNrZHJvcCkge1xuICAgICAgICAgICQkJDEodGhpcy5fYmFja2Ryb3ApLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5TSE9XKTtcblxuICAgICAgICAgIHZhciBjYWxsYmFja1JlbW92ZSA9IGZ1bmN0aW9uIGNhbGxiYWNrUmVtb3ZlKCkge1xuICAgICAgICAgICAgX3RoaXM4Ll9yZW1vdmVCYWNrZHJvcCgpO1xuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCQkJDEodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XG4gICAgICAgICAgICB2YXIgX2JhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9iYWNrZHJvcCk7XG5cbiAgICAgICAgICAgICQkJDEodGhpcy5fYmFja2Ryb3ApLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjYWxsYmFja1JlbW92ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoX2JhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2tSZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9OyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyB0aGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xuICAgICAgLy8gdG9kbyAoZmF0KTogdGhlc2Ugc2hvdWxkIHByb2JhYmx5IGJlIHJlZmFjdG9yZWQgb3V0IG9mIG1vZGFsLmpzXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgX3Byb3RvLl9hZGp1c3REaWFsb2cgPSBmdW5jdGlvbiBfYWRqdXN0RGlhbG9nKCkge1xuICAgICAgICB2YXIgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXG4gICAgICAgIGlmICghdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgJiYgaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IHRoaXMuX3Njcm9sbGJhcldpZHRoICsgXCJweFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IHRoaXMuX3Njcm9sbGJhcldpZHRoICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uX3Jlc2V0QWRqdXN0bWVudHMgPSBmdW5jdGlvbiBfcmVzZXRBZGp1c3RtZW50cygpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9ICcnO1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9jaGVja1Njcm9sbGJhciA9IGZ1bmN0aW9uIF9jaGVja1Njcm9sbGJhcigpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyA9IHJlY3QubGVmdCArIHJlY3QucmlnaHQgPCB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgdGhpcy5fc2Nyb2xsYmFyV2lkdGggPSB0aGlzLl9nZXRTY3JvbGxiYXJXaWR0aCgpO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9zZXRTY3JvbGxiYXIgPSBmdW5jdGlvbiBfc2V0U2Nyb2xsYmFyKCkge1xuICAgICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcpIHtcbiAgICAgICAgICAvLyBOb3RlOiBET01Ob2RlLnN0eWxlLnBhZGRpbmdSaWdodCByZXR1cm5zIHRoZSBhY3R1YWwgdmFsdWUgb3IgJycgaWYgbm90IHNldFxuICAgICAgICAgIC8vICAgd2hpbGUgJChET01Ob2RlKS5jc3MoJ3BhZGRpbmctcmlnaHQnKSByZXR1cm5zIHRoZSBjYWxjdWxhdGVkIHZhbHVlIG9yIDAgaWYgbm90IHNldFxuICAgICAgICAgIC8vIEFkanVzdCBmaXhlZCBjb250ZW50IHBhZGRpbmdcbiAgICAgICAgICAkJCQxKFNlbGVjdG9yLkZJWEVEX0NPTlRFTlQpLmVhY2goZnVuY3Rpb24gKGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgYWN0dWFsUGFkZGluZyA9ICQkJDEoZWxlbWVudClbMF0uc3R5bGUucGFkZGluZ1JpZ2h0O1xuICAgICAgICAgICAgdmFyIGNhbGN1bGF0ZWRQYWRkaW5nID0gJCQkMShlbGVtZW50KS5jc3MoJ3BhZGRpbmctcmlnaHQnKTtcbiAgICAgICAgICAgICQkJDEoZWxlbWVudCkuZGF0YSgncGFkZGluZy1yaWdodCcsIGFjdHVhbFBhZGRpbmcpLmNzcygncGFkZGluZy1yaWdodCcsIHBhcnNlRmxvYXQoY2FsY3VsYXRlZFBhZGRpbmcpICsgX3RoaXM5Ll9zY3JvbGxiYXJXaWR0aCArIFwicHhcIik7XG4gICAgICAgICAgfSk7IC8vIEFkanVzdCBzdGlja3kgY29udGVudCBtYXJnaW5cblxuICAgICAgICAgICQkJDEoU2VsZWN0b3IuU1RJQ0tZX0NPTlRFTlQpLmVhY2goZnVuY3Rpb24gKGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgYWN0dWFsTWFyZ2luID0gJCQkMShlbGVtZW50KVswXS5zdHlsZS5tYXJnaW5SaWdodDtcbiAgICAgICAgICAgIHZhciBjYWxjdWxhdGVkTWFyZ2luID0gJCQkMShlbGVtZW50KS5jc3MoJ21hcmdpbi1yaWdodCcpO1xuICAgICAgICAgICAgJCQkMShlbGVtZW50KS5kYXRhKCdtYXJnaW4tcmlnaHQnLCBhY3R1YWxNYXJnaW4pLmNzcygnbWFyZ2luLXJpZ2h0JywgcGFyc2VGbG9hdChjYWxjdWxhdGVkTWFyZ2luKSAtIF90aGlzOS5fc2Nyb2xsYmFyV2lkdGggKyBcInB4XCIpO1xuICAgICAgICAgIH0pOyAvLyBBZGp1c3QgbmF2YmFyLXRvZ2dsZXIgbWFyZ2luXG5cbiAgICAgICAgICAkJCQxKFNlbGVjdG9yLk5BVkJBUl9UT0dHTEVSKS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGFjdHVhbE1hcmdpbiA9ICQkJDEoZWxlbWVudClbMF0uc3R5bGUubWFyZ2luUmlnaHQ7XG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlZE1hcmdpbiA9ICQkJDEoZWxlbWVudCkuY3NzKCdtYXJnaW4tcmlnaHQnKTtcbiAgICAgICAgICAgICQkJDEoZWxlbWVudCkuZGF0YSgnbWFyZ2luLXJpZ2h0JywgYWN0dWFsTWFyZ2luKS5jc3MoJ21hcmdpbi1yaWdodCcsIHBhcnNlRmxvYXQoY2FsY3VsYXRlZE1hcmdpbikgKyBfdGhpczkuX3Njcm9sbGJhcldpZHRoICsgXCJweFwiKTtcbiAgICAgICAgICB9KTsgLy8gQWRqdXN0IGJvZHkgcGFkZGluZ1xuXG4gICAgICAgICAgdmFyIGFjdHVhbFBhZGRpbmcgPSBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodDtcbiAgICAgICAgICB2YXIgY2FsY3VsYXRlZFBhZGRpbmcgPSAkJCQxKGRvY3VtZW50LmJvZHkpLmNzcygncGFkZGluZy1yaWdodCcpO1xuICAgICAgICAgICQkJDEoZG9jdW1lbnQuYm9keSkuZGF0YSgncGFkZGluZy1yaWdodCcsIGFjdHVhbFBhZGRpbmcpLmNzcygncGFkZGluZy1yaWdodCcsIHBhcnNlRmxvYXQoY2FsY3VsYXRlZFBhZGRpbmcpICsgdGhpcy5fc2Nyb2xsYmFyV2lkdGggKyBcInB4XCIpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uX3Jlc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gX3Jlc2V0U2Nyb2xsYmFyKCkge1xuICAgICAgICAvLyBSZXN0b3JlIGZpeGVkIGNvbnRlbnQgcGFkZGluZ1xuICAgICAgICAkJCQxKFNlbGVjdG9yLkZJWEVEX0NPTlRFTlQpLmVhY2goZnVuY3Rpb24gKGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgICAgdmFyIHBhZGRpbmcgPSAkJCQxKGVsZW1lbnQpLmRhdGEoJ3BhZGRpbmctcmlnaHQnKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgcGFkZGluZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICQkJDEoZWxlbWVudCkuY3NzKCdwYWRkaW5nLXJpZ2h0JywgcGFkZGluZykucmVtb3ZlRGF0YSgncGFkZGluZy1yaWdodCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIFJlc3RvcmUgc3RpY2t5IGNvbnRlbnQgYW5kIG5hdmJhci10b2dnbGVyIG1hcmdpblxuXG4gICAgICAgICQkJDEoU2VsZWN0b3IuU1RJQ0tZX0NPTlRFTlQgKyBcIiwgXCIgKyBTZWxlY3Rvci5OQVZCQVJfVE9HR0xFUikuZWFjaChmdW5jdGlvbiAoaW5kZXgsIGVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgbWFyZ2luID0gJCQkMShlbGVtZW50KS5kYXRhKCdtYXJnaW4tcmlnaHQnKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgbWFyZ2luICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgJCQkMShlbGVtZW50KS5jc3MoJ21hcmdpbi1yaWdodCcsIG1hcmdpbikucmVtb3ZlRGF0YSgnbWFyZ2luLXJpZ2h0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy8gUmVzdG9yZSBib2R5IHBhZGRpbmdcblxuICAgICAgICB2YXIgcGFkZGluZyA9ICQkJDEoZG9jdW1lbnQuYm9keSkuZGF0YSgncGFkZGluZy1yaWdodCcpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcGFkZGluZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAkJCQxKGRvY3VtZW50LmJvZHkpLmNzcygncGFkZGluZy1yaWdodCcsIHBhZGRpbmcpLnJlbW92ZURhdGEoJ3BhZGRpbmctcmlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9nZXRTY3JvbGxiYXJXaWR0aCA9IGZ1bmN0aW9uIF9nZXRTY3JvbGxiYXJXaWR0aCgpIHtcbiAgICAgICAgLy8gdGh4IGQud2Fsc2hcbiAgICAgICAgdmFyIHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gQ2xhc3NOYW1lLlNDUk9MTEJBUl9NRUFTVVJFUjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpO1xuICAgICAgICB2YXIgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGg7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbGJhcldpZHRoO1xuICAgICAgfTsgLy8gU3RhdGljXG5cblxuICAgICAgTW9kYWwuX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnLCByZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBkYXRhID0gJCQkMSh0aGlzKS5kYXRhKERBVEFfS0VZKTtcblxuICAgICAgICAgIHZhciBfY29uZmlnID0gX29iamVjdFNwcmVhZCh7fSwgRGVmYXVsdCwgJCQkMSh0aGlzKS5kYXRhKCksIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KTtcblxuICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgZGF0YSA9IG5ldyBNb2RhbCh0aGlzLCBfY29uZmlnKTtcbiAgICAgICAgICAgICQkJDEodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIG1ldGhvZCBuYW1lZCBcXFwiXCIgKyBjb25maWcgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGFbY29uZmlnXShyZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF9jb25maWcuc2hvdykge1xuICAgICAgICAgICAgZGF0YS5zaG93KHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBfY3JlYXRlQ2xhc3MoTW9kYWwsIG51bGwsIFt7XG4gICAgICAgIGtleTogXCJWRVJTSU9OXCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJEZWZhdWx0XCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBNb2RhbDtcbiAgICB9KCk7XG4gICAgLyoqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuXG4gICAgJCQkMShkb2N1bWVudCkub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkRBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgdmFyIHRhcmdldDtcbiAgICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKTtcblxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIHRhcmdldCA9ICQkJDEoc2VsZWN0b3IpWzBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29uZmlnID0gJCQkMSh0YXJnZXQpLmRhdGEoREFUQV9LRVkpID8gJ3RvZ2dsZScgOiBfb2JqZWN0U3ByZWFkKHt9LCAkJCQxKHRhcmdldCkuZGF0YSgpLCAkJCQxKHRoaXMpLmRhdGEoKSk7XG5cbiAgICAgIGlmICh0aGlzLnRhZ05hbWUgPT09ICdBJyB8fCB0aGlzLnRhZ05hbWUgPT09ICdBUkVBJykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgJHRhcmdldCA9ICQkJDEodGFyZ2V0KS5vbmUoRXZlbnQuU0hPVywgZnVuY3Rpb24gKHNob3dFdmVudCkge1xuICAgICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgLy8gT25seSByZWdpc3RlciBmb2N1cyByZXN0b3JlciBpZiBtb2RhbCB3aWxsIGFjdHVhbGx5IGdldCBzaG93blxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgICR0YXJnZXQub25lKEV2ZW50LkhJRERFTiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICgkJCQxKF90aGlzMTApLmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgICBfdGhpczEwLmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJCQkMSh0YXJnZXQpLCBjb25maWcsIHRoaXMpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIGpRdWVyeVxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG4gICAgJCQkMS5mbltOQU1FXSA9IE1vZGFsLl9qUXVlcnlJbnRlcmZhY2U7XG4gICAgJCQkMS5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IE1vZGFsO1xuXG4gICAgJCQkMS5mbltOQU1FXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgJCQkMS5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVDtcbiAgICAgIHJldHVybiBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gTW9kYWw7XG4gIH0oJCk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCAodjQuMS4xKTogdG9vbHRpcC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgVG9vbHRpcCA9IGZ1bmN0aW9uICgkJCQxKSB7XG4gICAgLyoqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogQ29uc3RhbnRzXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG4gICAgdmFyIE5BTUUgPSAndG9vbHRpcCc7XG4gICAgdmFyIFZFUlNJT04gPSAnNC4xLjEnO1xuICAgIHZhciBEQVRBX0tFWSA9ICdicy50b29sdGlwJztcbiAgICB2YXIgRVZFTlRfS0VZID0gXCIuXCIgKyBEQVRBX0tFWTtcbiAgICB2YXIgSlFVRVJZX05PX0NPTkZMSUNUID0gJCQkMS5mbltOQU1FXTtcbiAgICB2YXIgQ0xBU1NfUFJFRklYID0gJ2JzLXRvb2x0aXAnO1xuICAgIHZhciBCU0NMU19QUkVGSVhfUkVHRVggPSBuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBDTEFTU19QUkVGSVggKyBcIlxcXFxTK1wiLCAnZycpO1xuICAgIHZhciBEZWZhdWx0VHlwZSA9IHtcbiAgICAgIGFuaW1hdGlvbjogJ2Jvb2xlYW4nLFxuICAgICAgdGVtcGxhdGU6ICdzdHJpbmcnLFxuICAgICAgdGl0bGU6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJyxcbiAgICAgIHRyaWdnZXI6ICdzdHJpbmcnLFxuICAgICAgZGVsYXk6ICcobnVtYmVyfG9iamVjdCknLFxuICAgICAgaHRtbDogJ2Jvb2xlYW4nLFxuICAgICAgc2VsZWN0b3I6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgICAgIHBsYWNlbWVudDogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgICAgIG9mZnNldDogJyhudW1iZXJ8c3RyaW5nKScsXG4gICAgICBjb250YWluZXI6ICcoc3RyaW5nfGVsZW1lbnR8Ym9vbGVhbiknLFxuICAgICAgZmFsbGJhY2tQbGFjZW1lbnQ6ICcoc3RyaW5nfGFycmF5KScsXG4gICAgICBib3VuZGFyeTogJyhzdHJpbmd8ZWxlbWVudCknXG4gICAgfTtcbiAgICB2YXIgQXR0YWNobWVudE1hcCA9IHtcbiAgICAgIEFVVE86ICdhdXRvJyxcbiAgICAgIFRPUDogJ3RvcCcsXG4gICAgICBSSUdIVDogJ3JpZ2h0JyxcbiAgICAgIEJPVFRPTTogJ2JvdHRvbScsXG4gICAgICBMRUZUOiAnbGVmdCdcbiAgICB9O1xuICAgIHZhciBEZWZhdWx0ID0ge1xuICAgICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwidG9vbHRpcFwiIHJvbGU9XCJ0b29sdGlwXCI+JyArICc8ZGl2IGNsYXNzPVwiYXJyb3dcIj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCI+PC9kaXY+PC9kaXY+JyxcbiAgICAgIHRyaWdnZXI6ICdob3ZlciBmb2N1cycsXG4gICAgICB0aXRsZTogJycsXG4gICAgICBkZWxheTogMCxcbiAgICAgIGh0bWw6IGZhbHNlLFxuICAgICAgc2VsZWN0b3I6IGZhbHNlLFxuICAgICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIGNvbnRhaW5lcjogZmFsc2UsXG4gICAgICBmYWxsYmFja1BsYWNlbWVudDogJ2ZsaXAnLFxuICAgICAgYm91bmRhcnk6ICdzY3JvbGxQYXJlbnQnXG4gICAgfTtcbiAgICB2YXIgSG92ZXJTdGF0ZSA9IHtcbiAgICAgIFNIT1c6ICdzaG93JyxcbiAgICAgIE9VVDogJ291dCdcbiAgICB9O1xuICAgIHZhciBFdmVudCA9IHtcbiAgICAgIEhJREU6IFwiaGlkZVwiICsgRVZFTlRfS0VZLFxuICAgICAgSElEREVOOiBcImhpZGRlblwiICsgRVZFTlRfS0VZLFxuICAgICAgU0hPVzogXCJzaG93XCIgKyBFVkVOVF9LRVksXG4gICAgICBTSE9XTjogXCJzaG93blwiICsgRVZFTlRfS0VZLFxuICAgICAgSU5TRVJURUQ6IFwiaW5zZXJ0ZWRcIiArIEVWRU5UX0tFWSxcbiAgICAgIENMSUNLOiBcImNsaWNrXCIgKyBFVkVOVF9LRVksXG4gICAgICBGT0NVU0lOOiBcImZvY3VzaW5cIiArIEVWRU5UX0tFWSxcbiAgICAgIEZPQ1VTT1VUOiBcImZvY3Vzb3V0XCIgKyBFVkVOVF9LRVksXG4gICAgICBNT1VTRUVOVEVSOiBcIm1vdXNlZW50ZXJcIiArIEVWRU5UX0tFWSxcbiAgICAgIE1PVVNFTEVBVkU6IFwibW91c2VsZWF2ZVwiICsgRVZFTlRfS0VZXG4gICAgfTtcbiAgICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgICAgRkFERTogJ2ZhZGUnLFxuICAgICAgU0hPVzogJ3Nob3cnXG4gICAgfTtcbiAgICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgICBUT09MVElQOiAnLnRvb2x0aXAnLFxuICAgICAgVE9PTFRJUF9JTk5FUjogJy50b29sdGlwLWlubmVyJyxcbiAgICAgIEFSUk9XOiAnLmFycm93J1xuICAgIH07XG4gICAgdmFyIFRyaWdnZXIgPSB7XG4gICAgICBIT1ZFUjogJ2hvdmVyJyxcbiAgICAgIEZPQ1VTOiAnZm9jdXMnLFxuICAgICAgQ0xJQ0s6ICdjbGljaycsXG4gICAgICBNQU5VQUw6ICdtYW51YWwnXG4gICAgICAvKipcbiAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgKi9cblxuICAgIH07XG5cbiAgICB2YXIgVG9vbHRpcCA9XG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRvb2x0aXAoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBmb3IgUG9wcGVyIGRlcGVuZGVuY3lcbiAgICAgICAgICogUG9wcGVyIC0gaHR0cHM6Ly9wb3BwZXIuanMub3JnXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXAgdG9vbHRpcHMgcmVxdWlyZSBQb3BwZXIuanMgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZyknKTtcbiAgICAgICAgfSAvLyBwcml2YXRlXG5cblxuICAgICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gMDtcbiAgICAgICAgdGhpcy5faG92ZXJTdGF0ZSA9ICcnO1xuICAgICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0ge307XG4gICAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7IC8vIFByb3RlY3RlZFxuXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgICAgIHRoaXMudGlwID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgICAgIH0gLy8gR2V0dGVyc1xuXG5cbiAgICAgIHZhciBfcHJvdG8gPSBUb29sdGlwLnByb3RvdHlwZTtcblxuICAgICAgLy8gUHVibGljXG4gICAgICBfcHJvdG8uZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by50b2dnbGVFbmFibGVkID0gZnVuY3Rpb24gdG9nZ2xlRW5hYmxlZCgpIHtcbiAgICAgICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZDtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgZGF0YUtleSA9IHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVk7XG4gICAgICAgICAgdmFyIGNvbnRleHQgPSAkJCQxKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSk7XG5cbiAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihldmVudC5jdXJyZW50VGFyZ2V0LCB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKTtcbiAgICAgICAgICAgICQkJDEoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5LCBjb250ZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyLmNsaWNrID0gIWNvbnRleHQuX2FjdGl2ZVRyaWdnZXIuY2xpY2s7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICAgICAgICBjb250ZXh0Ll9lbnRlcihudWxsLCBjb250ZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5fbGVhdmUobnVsbCwgY29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgkJCQxKHRoaXMuZ2V0VGlwRWxlbWVudCgpKS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVykpIHtcbiAgICAgICAgICAgIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fZW50ZXIobnVsbCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgICAkJCQxLnJlbW92ZURhdGEodGhpcy5lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKTtcbiAgICAgICAgJCQkMSh0aGlzLmVsZW1lbnQpLm9mZih0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSk7XG4gICAgICAgICQkJDEodGhpcy5lbGVtZW50KS5jbG9zZXN0KCcubW9kYWwnKS5vZmYoJ2hpZGUuYnMubW9kYWwnKTtcblxuICAgICAgICBpZiAodGhpcy50aXApIHtcbiAgICAgICAgICAkJCQxKHRoaXMudGlwKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9ob3ZlclN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuX3BvcHBlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMudGlwID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICBpZiAoJCQkMSh0aGlzLmVsZW1lbnQpLmNzcygnZGlzcGxheScpID09PSAnbm9uZScpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSB1c2Ugc2hvdyBvbiB2aXNpYmxlIGVsZW1lbnRzJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvd0V2ZW50ID0gJCQkMS5FdmVudCh0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1cpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgICAgICAkJCQxKHRoaXMuZWxlbWVudCkudHJpZ2dlcihzaG93RXZlbnQpO1xuICAgICAgICAgIHZhciBpc0luVGhlRG9tID0gJCQkMS5jb250YWlucyh0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuZWxlbWVudCk7XG5cbiAgICAgICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8ICFpc0luVGhlRG9tKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xuICAgICAgICAgIHZhciB0aXBJZCA9IFV0aWwuZ2V0VUlEKHRoaXMuY29uc3RydWN0b3IuTkFNRSk7XG4gICAgICAgICAgdGlwLnNldEF0dHJpYnV0ZSgnaWQnLCB0aXBJZCk7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIHRpcElkKTtcbiAgICAgICAgICB0aGlzLnNldENvbnRlbnQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICQkJDEodGlwKS5hZGRDbGFzcyhDbGFzc05hbWUuRkFERSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLmNvbmZpZy5wbGFjZW1lbnQgPT09ICdmdW5jdGlvbicgPyB0aGlzLmNvbmZpZy5wbGFjZW1lbnQuY2FsbCh0aGlzLCB0aXAsIHRoaXMuZWxlbWVudCkgOiB0aGlzLmNvbmZpZy5wbGFjZW1lbnQ7XG5cbiAgICAgICAgICB2YXIgYXR0YWNobWVudCA9IHRoaXMuX2dldEF0dGFjaG1lbnQocGxhY2VtZW50KTtcblxuICAgICAgICAgIHRoaXMuYWRkQXR0YWNobWVudENsYXNzKGF0dGFjaG1lbnQpO1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbmZpZy5jb250YWluZXIgPT09IGZhbHNlID8gZG9jdW1lbnQuYm9keSA6ICQkJDEodGhpcy5jb25maWcuY29udGFpbmVyKTtcbiAgICAgICAgICAkJCQxKHRpcCkuZGF0YSh0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKTtcblxuICAgICAgICAgIGlmICghJCQkMS5jb250YWlucyh0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMudGlwKSkge1xuICAgICAgICAgICAgJCQkMSh0aXApLmFwcGVuZFRvKGNvbnRhaW5lcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgJCQkMSh0aGlzLmVsZW1lbnQpLnRyaWdnZXIodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5JTlNFUlRFRCk7XG4gICAgICAgICAgdGhpcy5fcG9wcGVyID0gbmV3IFBvcHBlcih0aGlzLmVsZW1lbnQsIHRpcCwge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBhdHRhY2htZW50LFxuICAgICAgICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5jb25maWcub2Zmc2V0XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZsaXA6IHtcbiAgICAgICAgICAgICAgICBiZWhhdmlvcjogdGhpcy5jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYXJyb3c6IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBTZWxlY3Rvci5BUlJPV1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAgICAgICAgICAgICBib3VuZGFyaWVzRWxlbWVudDogdGhpcy5jb25maWcuYm91bmRhcnlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ3JlYXRlOiBmdW5jdGlvbiBvbkNyZWF0ZShkYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhLm9yaWdpbmFsUGxhY2VtZW50ICE9PSBkYXRhLnBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UoZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoZGF0YSkge1xuICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgICQkJDEodGlwKS5hZGRDbGFzcyhDbGFzc05hbWUuU0hPVyk7IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcbiAgICAgICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xuICAgICAgICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXG4gICAgICAgICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXG5cbiAgICAgICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAkJCQxKGRvY3VtZW50LmJvZHkpLmNoaWxkcmVuKCkub24oJ21vdXNlb3ZlcicsIG51bGwsICQkJDEubm9vcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgICBfdGhpcy5fZml4VHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJldkhvdmVyU3RhdGUgPSBfdGhpcy5faG92ZXJTdGF0ZTtcbiAgICAgICAgICAgIF90aGlzLl9ob3ZlclN0YXRlID0gbnVsbDtcbiAgICAgICAgICAgICQkJDEoX3RoaXMuZWxlbWVudCkudHJpZ2dlcihfdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XTik7XG5cbiAgICAgICAgICAgIGlmIChwcmV2SG92ZXJTdGF0ZSA9PT0gSG92ZXJTdGF0ZS5PVVQpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX2xlYXZlKG51bGwsIF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCQkJDEodGhpcy50aXApLmhhc0NsYXNzKENsYXNzTmFtZS5GQURFKSkge1xuICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy50aXApO1xuICAgICAgICAgICAgJCQkMSh0aGlzLnRpcCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiBoaWRlKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKTtcbiAgICAgICAgdmFyIGhpZGVFdmVudCA9ICQkJDEuRXZlbnQodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURFKTtcblxuICAgICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLl9ob3ZlclN0YXRlICE9PSBIb3ZlclN0YXRlLlNIT1cgJiYgdGlwLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRpcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRpcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMyLl9jbGVhblRpcENsYXNzKCk7XG5cbiAgICAgICAgICBfdGhpczIuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcblxuICAgICAgICAgICQkJDEoX3RoaXMyLmVsZW1lbnQpLnRyaWdnZXIoX3RoaXMyLmNvbnN0cnVjdG9yLkV2ZW50LkhJRERFTik7XG5cbiAgICAgICAgICBpZiAoX3RoaXMyLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzMi5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgICQkJDEodGhpcy5lbGVtZW50KS50cmlnZ2VyKGhpZGVFdmVudCk7XG5cbiAgICAgICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgICQkJDEodGlwKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVyk7IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXG4gICAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XG5cbiAgICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgICQkJDEoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vZmYoJ21vdXNlb3ZlcicsIG51bGwsICQkJDEubm9vcCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RyaWdnZXIuQ0xJQ0tdID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVHJpZ2dlci5GT0NVU10gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUcmlnZ2VyLkhPVkVSXSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICgkJCQxKHRoaXMudGlwKS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSkpIHtcbiAgICAgICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aXApO1xuICAgICAgICAgICQkJDEodGlwKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2hvdmVyU3RhdGUgPSAnJztcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9wb3BwZXIuc2NoZWR1bGVVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfTsgLy8gUHJvdGVjdGVkXG5cblxuICAgICAgX3Byb3RvLmlzV2l0aENvbnRlbnQgPSBmdW5jdGlvbiBpc1dpdGhDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmdldFRpdGxlKCkpO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLmFkZEF0dGFjaG1lbnRDbGFzcyA9IGZ1bmN0aW9uIGFkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KSB7XG4gICAgICAgICQkJDEodGhpcy5nZXRUaXBFbGVtZW50KCkpLmFkZENsYXNzKENMQVNTX1BSRUZJWCArIFwiLVwiICsgYXR0YWNobWVudCk7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uZ2V0VGlwRWxlbWVudCA9IGZ1bmN0aW9uIGdldFRpcEVsZW1lbnQoKSB7XG4gICAgICAgIHRoaXMudGlwID0gdGhpcy50aXAgfHwgJCQkMSh0aGlzLmNvbmZpZy50ZW1wbGF0ZSlbMF07XG4gICAgICAgIHJldHVybiB0aGlzLnRpcDtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5zZXRDb250ZW50ID0gZnVuY3Rpb24gc2V0Q29udGVudCgpIHtcbiAgICAgICAgdmFyICR0aXAgPSAkJCQxKHRoaXMuZ2V0VGlwRWxlbWVudCgpKTtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50Q29udGVudCgkdGlwLmZpbmQoU2VsZWN0b3IuVE9PTFRJUF9JTk5FUiksIHRoaXMuZ2V0VGl0bGUoKSk7XG4gICAgICAgICR0aXAucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkZBREUgKyBcIiBcIiArIENsYXNzTmFtZS5TSE9XKTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5zZXRFbGVtZW50Q29udGVudCA9IGZ1bmN0aW9uIHNldEVsZW1lbnRDb250ZW50KCRlbGVtZW50LCBjb250ZW50KSB7XG4gICAgICAgIHZhciBodG1sID0gdGhpcy5jb25maWcuaHRtbDtcblxuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdvYmplY3QnICYmIChjb250ZW50Lm5vZGVUeXBlIHx8IGNvbnRlbnQuanF1ZXJ5KSkge1xuICAgICAgICAgIC8vIENvbnRlbnQgaXMgYSBET00gbm9kZSBvciBhIGpRdWVyeVxuICAgICAgICAgIGlmIChodG1sKSB7XG4gICAgICAgICAgICBpZiAoISQkJDEoY29udGVudCkucGFyZW50KCkuaXMoJGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICRlbGVtZW50LmVtcHR5KCkuYXBwZW5kKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkZWxlbWVudC50ZXh0KCQkJDEoY29udGVudCkudGV4dCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGVsZW1lbnRbaHRtbCA/ICdodG1sJyA6ICd0ZXh0J10oY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5nZXRUaXRsZSA9IGZ1bmN0aW9uIGdldFRpdGxlKCkge1xuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJyk7XG5cbiAgICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICAgIHRpdGxlID0gdHlwZW9mIHRoaXMuY29uZmlnLnRpdGxlID09PSAnZnVuY3Rpb24nID8gdGhpcy5jb25maWcudGl0bGUuY2FsbCh0aGlzLmVsZW1lbnQpIDogdGhpcy5jb25maWcudGl0bGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGl0bGU7XG4gICAgICB9OyAvLyBQcml2YXRlXG5cblxuICAgICAgX3Byb3RvLl9nZXRBdHRhY2htZW50ID0gZnVuY3Rpb24gX2dldEF0dGFjaG1lbnQocGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiBBdHRhY2htZW50TWFwW3BsYWNlbWVudC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5fc2V0TGlzdGVuZXJzID0gZnVuY3Rpb24gX3NldExpc3RlbmVycygpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHRyaWdnZXJzID0gdGhpcy5jb25maWcudHJpZ2dlci5zcGxpdCgnICcpO1xuICAgICAgICB0cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0cmlnZ2VyKSB7XG4gICAgICAgICAgaWYgKHRyaWdnZXIgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgICQkJDEoX3RoaXMzLmVsZW1lbnQpLm9uKF90aGlzMy5jb25zdHJ1Y3Rvci5FdmVudC5DTElDSywgX3RoaXMzLmNvbmZpZy5zZWxlY3RvciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczMudG9nZ2xlKGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHJpZ2dlciAhPT0gVHJpZ2dlci5NQU5VQUwpIHtcbiAgICAgICAgICAgIHZhciBldmVudEluID0gdHJpZ2dlciA9PT0gVHJpZ2dlci5IT1ZFUiA/IF90aGlzMy5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUVOVEVSIDogX3RoaXMzLmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTSU47XG4gICAgICAgICAgICB2YXIgZXZlbnRPdXQgPSB0cmlnZ2VyID09PSBUcmlnZ2VyLkhPVkVSID8gX3RoaXMzLmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFTEVBVkUgOiBfdGhpczMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNPVVQ7XG4gICAgICAgICAgICAkJCQxKF90aGlzMy5lbGVtZW50KS5vbihldmVudEluLCBfdGhpczMuY29uZmlnLnNlbGVjdG9yLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fZW50ZXIoZXZlbnQpO1xuICAgICAgICAgICAgfSkub24oZXZlbnRPdXQsIF90aGlzMy5jb25maWcuc2VsZWN0b3IsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLl9sZWF2ZShldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkJCQxKF90aGlzMy5lbGVtZW50KS5jbG9zZXN0KCcubW9kYWwnKS5vbignaGlkZS5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuaGlkZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcuc2VsZWN0b3IpIHtcbiAgICAgICAgICB0aGlzLmNvbmZpZyA9IF9vYmplY3RTcHJlYWQoe30sIHRoaXMuY29uZmlnLCB7XG4gICAgICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2ZpeFRpdGxlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5fZml4VGl0bGUgPSBmdW5jdGlvbiBfZml4VGl0bGUoKSB7XG4gICAgICAgIHZhciB0aXRsZVR5cGUgPSB0eXBlb2YgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpO1xuXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpIHx8IHRpdGxlVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJywgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKSB8fCAnJyk7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5fZW50ZXIgPSBmdW5jdGlvbiBfZW50ZXIoZXZlbnQsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGRhdGFLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZO1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCAkJCQxKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSk7XG5cbiAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgY29udGV4dCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGV2ZW50LmN1cnJlbnRUYXJnZXQsIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKCkpO1xuICAgICAgICAgICQkJDEoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5LCBjb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nID8gVHJpZ2dlci5GT0NVUyA6IFRyaWdnZXIuSE9WRVJdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkJCQxKGNvbnRleHQuZ2V0VGlwRWxlbWVudCgpKS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVykgfHwgY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSG92ZXJTdGF0ZS5TSE9XKSB7XG4gICAgICAgICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhvdmVyU3RhdGUuU0hPVztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclRpbWVvdXQoY29udGV4dC5fdGltZW91dCk7XG4gICAgICAgIGNvbnRleHQuX2hvdmVyU3RhdGUgPSBIb3ZlclN0YXRlLlNIT1c7XG5cbiAgICAgICAgaWYgKCFjb250ZXh0LmNvbmZpZy5kZWxheSB8fCAhY29udGV4dC5jb25maWcuZGVsYXkuc2hvdykge1xuICAgICAgICAgIGNvbnRleHQuc2hvdygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSG92ZXJTdGF0ZS5TSE9XKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNob3coKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGNvbnRleHQuY29uZmlnLmRlbGF5LnNob3cpO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9sZWF2ZSA9IGZ1bmN0aW9uIF9sZWF2ZShldmVudCwgY29udGV4dCkge1xuICAgICAgICB2YXIgZGF0YUtleSA9IHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVk7XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8ICQkJDEoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5KTtcblxuICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICBjb250ZXh0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZXZlbnQuY3VycmVudFRhcmdldCwgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSk7XG4gICAgICAgICAgJCQkMShldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXksIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNvdXQnID8gVHJpZ2dlci5GT0NVUyA6IFRyaWdnZXIuSE9WRVJdID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuX3RpbWVvdXQpO1xuICAgICAgICBjb250ZXh0Ll9ob3ZlclN0YXRlID0gSG92ZXJTdGF0ZS5PVVQ7XG5cbiAgICAgICAgaWYgKCFjb250ZXh0LmNvbmZpZy5kZWxheSB8fCAhY29udGV4dC5jb25maWcuZGVsYXkuaGlkZSkge1xuICAgICAgICAgIGNvbnRleHQuaGlkZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSG92ZXJTdGF0ZS5PVVQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgY29udGV4dC5jb25maWcuZGVsYXkuaGlkZSk7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uX2lzV2l0aEFjdGl2ZVRyaWdnZXIgPSBmdW5jdGlvbiBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcbiAgICAgICAgZm9yICh2YXIgdHJpZ2dlciBpbiB0aGlzLl9hY3RpdmVUcmlnZ2VyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRyaWdnZXJbdHJpZ2dlcl0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgY29uZmlnID0gX29iamVjdFNwcmVhZCh7fSwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LCAkJCQxKHRoaXMuZWxlbWVudCkuZGF0YSgpLCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY29uZmlnLmRlbGF5ID0ge1xuICAgICAgICAgICAgc2hvdzogY29uZmlnLmRlbGF5LFxuICAgICAgICAgICAgaGlkZTogY29uZmlnLmRlbGF5XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnLnRpdGxlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGNvbmZpZy50aXRsZSA9IGNvbmZpZy50aXRsZS50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcuY29udGVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBjb25maWcuY29udGVudCA9IGNvbmZpZy5jb250ZW50LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9nZXREZWxlZ2F0ZUNvbmZpZyA9IGZ1bmN0aW9uIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZykge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNvbmZpZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtrZXldICE9PSB0aGlzLmNvbmZpZ1trZXldKSB7XG4gICAgICAgICAgICAgIGNvbmZpZ1trZXldID0gdGhpcy5jb25maWdba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9jbGVhblRpcENsYXNzID0gZnVuY3Rpb24gX2NsZWFuVGlwQ2xhc3MoKSB7XG4gICAgICAgIHZhciAkdGlwID0gJCQkMSh0aGlzLmdldFRpcEVsZW1lbnQoKSk7XG4gICAgICAgIHZhciB0YWJDbGFzcyA9ICR0aXAuYXR0cignY2xhc3MnKS5tYXRjaChCU0NMU19QUkVGSVhfUkVHRVgpO1xuXG4gICAgICAgIGlmICh0YWJDbGFzcyAhPT0gbnVsbCAmJiB0YWJDbGFzcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgJHRpcC5yZW1vdmVDbGFzcyh0YWJDbGFzcy5qb2luKCcnKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlID0gZnVuY3Rpb24gX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShkYXRhKSB7XG4gICAgICAgIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKTtcblxuICAgICAgICB0aGlzLmFkZEF0dGFjaG1lbnRDbGFzcyh0aGlzLl9nZXRBdHRhY2htZW50KGRhdGEucGxhY2VtZW50KSk7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uX2ZpeFRyYW5zaXRpb24gPSBmdW5jdGlvbiBfZml4VHJhbnNpdGlvbigpIHtcbiAgICAgICAgdmFyIHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xuICAgICAgICB2YXIgaW5pdENvbmZpZ0FuaW1hdGlvbiA9IHRoaXMuY29uZmlnLmFuaW1hdGlvbjtcblxuICAgICAgICBpZiAodGlwLmdldEF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnKSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgICQkJDEodGlwKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuRkFERSk7XG4gICAgICAgIHRoaXMuY29uZmlnLmFuaW1hdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIHRoaXMuY29uZmlnLmFuaW1hdGlvbiA9IGluaXRDb25maWdBbmltYXRpb247XG4gICAgICB9OyAvLyBTdGF0aWNcblxuXG4gICAgICBUb29sdGlwLl9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9ICQkJDEodGhpcykuZGF0YShEQVRBX0tFWSk7XG5cbiAgICAgICAgICB2YXIgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZztcblxuICAgICAgICAgIGlmICghZGF0YSAmJiAvZGlzcG9zZXxoaWRlLy50ZXN0KGNvbmZpZykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgVG9vbHRpcCh0aGlzLCBfY29uZmlnKTtcbiAgICAgICAgICAgICQkJDEodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIG1ldGhvZCBuYW1lZCBcXFwiXCIgKyBjb25maWcgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBfY3JlYXRlQ2xhc3MoVG9vbHRpcCwgbnVsbCwgW3tcbiAgICAgICAga2V5OiBcIlZFUlNJT05cIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcIkRlZmF1bHRcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIERlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcIk5BTUVcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIE5BTUU7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcIkRBVEFfS0VZXCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBEQVRBX0tFWTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiRXZlbnRcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIEV2ZW50O1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJFVkVOVF9LRVlcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIEVWRU5UX0tFWTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiRGVmYXVsdFR5cGVcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIERlZmF1bHRUeXBlO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBUb29sdGlwO1xuICAgIH0oKTtcbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBqUXVlcnlcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuXG4gICAgJCQkMS5mbltOQU1FXSA9IFRvb2x0aXAuX2pRdWVyeUludGVyZmFjZTtcbiAgICAkJCQxLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gVG9vbHRpcDtcblxuICAgICQkJDEuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICQkJDEuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XG4gICAgICByZXR1cm4gVG9vbHRpcC5falF1ZXJ5SW50ZXJmYWNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gVG9vbHRpcDtcbiAgfSgkLCBQb3BwZXIpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgKHY0LjEuMSk6IHBvcG92ZXIuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIFBvcG92ZXIgPSBmdW5jdGlvbiAoJCQkMSkge1xuICAgIC8qKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIENvbnN0YW50c1xuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuICAgIHZhciBOQU1FID0gJ3BvcG92ZXInO1xuICAgIHZhciBWRVJTSU9OID0gJzQuMS4xJztcbiAgICB2YXIgREFUQV9LRVkgPSAnYnMucG9wb3Zlcic7XG4gICAgdmFyIEVWRU5UX0tFWSA9IFwiLlwiICsgREFUQV9LRVk7XG4gICAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQkJDEuZm5bTkFNRV07XG4gICAgdmFyIENMQVNTX1BSRUZJWCA9ICdicy1wb3BvdmVyJztcbiAgICB2YXIgQlNDTFNfUFJFRklYX1JFR0VYID0gbmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgQ0xBU1NfUFJFRklYICsgXCJcXFxcUytcIiwgJ2cnKTtcblxuICAgIHZhciBEZWZhdWx0ID0gX29iamVjdFNwcmVhZCh7fSwgVG9vbHRpcC5EZWZhdWx0LCB7XG4gICAgICBwbGFjZW1lbnQ6ICdyaWdodCcsXG4gICAgICB0cmlnZ2VyOiAnY2xpY2snLFxuICAgICAgY29udGVudDogJycsXG4gICAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJwb3BvdmVyXCIgcm9sZT1cInRvb2x0aXBcIj4nICsgJzxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PicgKyAnPGgzIGNsYXNzPVwicG9wb3Zlci1oZWFkZXJcIj48L2gzPicgKyAnPGRpdiBjbGFzcz1cInBvcG92ZXItYm9keVwiPjwvZGl2PjwvZGl2PidcbiAgICB9KTtcblxuICAgIHZhciBEZWZhdWx0VHlwZSA9IF9vYmplY3RTcHJlYWQoe30sIFRvb2x0aXAuRGVmYXVsdFR5cGUsIHtcbiAgICAgIGNvbnRlbnQ6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJ1xuICAgIH0pO1xuXG4gICAgdmFyIENsYXNzTmFtZSA9IHtcbiAgICAgIEZBREU6ICdmYWRlJyxcbiAgICAgIFNIT1c6ICdzaG93J1xuICAgIH07XG4gICAgdmFyIFNlbGVjdG9yID0ge1xuICAgICAgVElUTEU6ICcucG9wb3Zlci1oZWFkZXInLFxuICAgICAgQ09OVEVOVDogJy5wb3BvdmVyLWJvZHknXG4gICAgfTtcbiAgICB2YXIgRXZlbnQgPSB7XG4gICAgICBISURFOiBcImhpZGVcIiArIEVWRU5UX0tFWSxcbiAgICAgIEhJRERFTjogXCJoaWRkZW5cIiArIEVWRU5UX0tFWSxcbiAgICAgIFNIT1c6IFwic2hvd1wiICsgRVZFTlRfS0VZLFxuICAgICAgU0hPV046IFwic2hvd25cIiArIEVWRU5UX0tFWSxcbiAgICAgIElOU0VSVEVEOiBcImluc2VydGVkXCIgKyBFVkVOVF9LRVksXG4gICAgICBDTElDSzogXCJjbGlja1wiICsgRVZFTlRfS0VZLFxuICAgICAgRk9DVVNJTjogXCJmb2N1c2luXCIgKyBFVkVOVF9LRVksXG4gICAgICBGT0NVU09VVDogXCJmb2N1c291dFwiICsgRVZFTlRfS0VZLFxuICAgICAgTU9VU0VFTlRFUjogXCJtb3VzZWVudGVyXCIgKyBFVkVOVF9LRVksXG4gICAgICBNT1VTRUxFQVZFOiBcIm1vdXNlbGVhdmVcIiArIEVWRU5UX0tFWVxuICAgICAgLyoqXG4gICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAqIENsYXNzIERlZmluaXRpb25cbiAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICovXG5cbiAgICB9O1xuXG4gICAgdmFyIFBvcG92ZXIgPVxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBmdW5jdGlvbiAoX1Rvb2x0aXApIHtcbiAgICAgIF9pbmhlcml0c0xvb3NlKFBvcG92ZXIsIF9Ub29sdGlwKTtcblxuICAgICAgZnVuY3Rpb24gUG9wb3ZlcigpIHtcbiAgICAgICAgcmV0dXJuIF9Ub29sdGlwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIF9wcm90byA9IFBvcG92ZXIucHJvdG90eXBlO1xuXG4gICAgICAvLyBPdmVycmlkZXNcbiAgICAgIF9wcm90by5pc1dpdGhDb250ZW50ID0gZnVuY3Rpb24gaXNXaXRoQ29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KCk7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uYWRkQXR0YWNobWVudENsYXNzID0gZnVuY3Rpb24gYWRkQXR0YWNobWVudENsYXNzKGF0dGFjaG1lbnQpIHtcbiAgICAgICAgJCQkMSh0aGlzLmdldFRpcEVsZW1lbnQoKSkuYWRkQ2xhc3MoQ0xBU1NfUFJFRklYICsgXCItXCIgKyBhdHRhY2htZW50KTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5nZXRUaXBFbGVtZW50ID0gZnVuY3Rpb24gZ2V0VGlwRWxlbWVudCgpIHtcbiAgICAgICAgdGhpcy50aXAgPSB0aGlzLnRpcCB8fCAkJCQxKHRoaXMuY29uZmlnLnRlbXBsYXRlKVswXTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlwO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLnNldENvbnRlbnQgPSBmdW5jdGlvbiBzZXRDb250ZW50KCkge1xuICAgICAgICB2YXIgJHRpcCA9ICQkJDEodGhpcy5nZXRUaXBFbGVtZW50KCkpOyAvLyBXZSB1c2UgYXBwZW5kIGZvciBodG1sIG9iamVjdHMgdG8gbWFpbnRhaW4ganMgZXZlbnRzXG5cbiAgICAgICAgdGhpcy5zZXRFbGVtZW50Q29udGVudCgkdGlwLmZpbmQoU2VsZWN0b3IuVElUTEUpLCB0aGlzLmdldFRpdGxlKCkpO1xuXG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5fZ2V0Q29udGVudCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmNhbGwodGhpcy5lbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0RWxlbWVudENvbnRlbnQoJHRpcC5maW5kKFNlbGVjdG9yLkNPTlRFTlQpLCBjb250ZW50KTtcbiAgICAgICAgJHRpcC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuRkFERSArIFwiIFwiICsgQ2xhc3NOYW1lLlNIT1cpO1xuICAgICAgfTsgLy8gUHJpdmF0ZVxuXG5cbiAgICAgIF9wcm90by5fZ2V0Q29udGVudCA9IGZ1bmN0aW9uIF9nZXRDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1jb250ZW50JykgfHwgdGhpcy5jb25maWcuY29udGVudDtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5fY2xlYW5UaXBDbGFzcyA9IGZ1bmN0aW9uIF9jbGVhblRpcENsYXNzKCkge1xuICAgICAgICB2YXIgJHRpcCA9ICQkJDEodGhpcy5nZXRUaXBFbGVtZW50KCkpO1xuICAgICAgICB2YXIgdGFiQ2xhc3MgPSAkdGlwLmF0dHIoJ2NsYXNzJykubWF0Y2goQlNDTFNfUFJFRklYX1JFR0VYKTtcblxuICAgICAgICBpZiAodGFiQ2xhc3MgIT09IG51bGwgJiYgdGFiQ2xhc3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICR0aXAucmVtb3ZlQ2xhc3ModGFiQ2xhc3Muam9pbignJykpO1xuICAgICAgICB9XG4gICAgICB9OyAvLyBTdGF0aWNcblxuXG4gICAgICBQb3BvdmVyLl9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9ICQkJDEodGhpcykuZGF0YShEQVRBX0tFWSk7XG5cbiAgICAgICAgICB2YXIgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDogbnVsbDtcblxuICAgICAgICAgIGlmICghZGF0YSAmJiAvZGVzdHJveXxoaWRlLy50ZXN0KGNvbmZpZykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgUG9wb3Zlcih0aGlzLCBfY29uZmlnKTtcbiAgICAgICAgICAgICQkJDEodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIG1ldGhvZCBuYW1lZCBcXFwiXCIgKyBjb25maWcgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBfY3JlYXRlQ2xhc3MoUG9wb3ZlciwgbnVsbCwgW3tcbiAgICAgICAga2V5OiBcIlZFUlNJT05cIixcbiAgICAgICAgLy8gR2V0dGVyc1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiRGVmYXVsdFwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gRGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiTkFNRVwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gTkFNRTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiREFUQV9LRVlcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIERBVEFfS0VZO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJFdmVudFwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcIkVWRU5UX0tFWVwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gRVZFTlRfS0VZO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJEZWZhdWx0VHlwZVwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gRGVmYXVsdFR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIFBvcG92ZXI7XG4gICAgfShUb29sdGlwKTtcbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBqUXVlcnlcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuXG4gICAgJCQkMS5mbltOQU1FXSA9IFBvcG92ZXIuX2pRdWVyeUludGVyZmFjZTtcbiAgICAkJCQxLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gUG9wb3ZlcjtcblxuICAgICQkJDEuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICQkJDEuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XG4gICAgICByZXR1cm4gUG9wb3Zlci5falF1ZXJ5SW50ZXJmYWNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gUG9wb3ZlcjtcbiAgfSgkKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwICh2NC4xLjEpOiBzY3JvbGxzcHkuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIFNjcm9sbFNweSA9IGZ1bmN0aW9uICgkJCQxKSB7XG4gICAgLyoqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogQ29uc3RhbnRzXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG4gICAgdmFyIE5BTUUgPSAnc2Nyb2xsc3B5JztcbiAgICB2YXIgVkVSU0lPTiA9ICc0LjEuMSc7XG4gICAgdmFyIERBVEFfS0VZID0gJ2JzLnNjcm9sbHNweSc7XG4gICAgdmFyIEVWRU5UX0tFWSA9IFwiLlwiICsgREFUQV9LRVk7XG4gICAgdmFyIERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknO1xuICAgIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkJCQxLmZuW05BTUVdO1xuICAgIHZhciBEZWZhdWx0ID0ge1xuICAgICAgb2Zmc2V0OiAxMCxcbiAgICAgIG1ldGhvZDogJ2F1dG8nLFxuICAgICAgdGFyZ2V0OiAnJ1xuICAgIH07XG4gICAgdmFyIERlZmF1bHRUeXBlID0ge1xuICAgICAgb2Zmc2V0OiAnbnVtYmVyJyxcbiAgICAgIG1ldGhvZDogJ3N0cmluZycsXG4gICAgICB0YXJnZXQ6ICcoc3RyaW5nfGVsZW1lbnQpJ1xuICAgIH07XG4gICAgdmFyIEV2ZW50ID0ge1xuICAgICAgQUNUSVZBVEU6IFwiYWN0aXZhdGVcIiArIEVWRU5UX0tFWSxcbiAgICAgIFNDUk9MTDogXCJzY3JvbGxcIiArIEVWRU5UX0tFWSxcbiAgICAgIExPQURfREFUQV9BUEk6IFwibG9hZFwiICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZXG4gICAgfTtcbiAgICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgICAgRFJPUERPV05fSVRFTTogJ2Ryb3Bkb3duLWl0ZW0nLFxuICAgICAgRFJPUERPV05fTUVOVTogJ2Ryb3Bkb3duLW1lbnUnLFxuICAgICAgQUNUSVZFOiAnYWN0aXZlJ1xuICAgIH07XG4gICAgdmFyIFNlbGVjdG9yID0ge1xuICAgICAgREFUQV9TUFk6ICdbZGF0YS1zcHk9XCJzY3JvbGxcIl0nLFxuICAgICAgQUNUSVZFOiAnLmFjdGl2ZScsXG4gICAgICBOQVZfTElTVF9HUk9VUDogJy5uYXYsIC5saXN0LWdyb3VwJyxcbiAgICAgIE5BVl9MSU5LUzogJy5uYXYtbGluaycsXG4gICAgICBOQVZfSVRFTVM6ICcubmF2LWl0ZW0nLFxuICAgICAgTElTVF9JVEVNUzogJy5saXN0LWdyb3VwLWl0ZW0nLFxuICAgICAgRFJPUERPV046ICcuZHJvcGRvd24nLFxuICAgICAgRFJPUERPV05fSVRFTVM6ICcuZHJvcGRvd24taXRlbScsXG4gICAgICBEUk9QRE9XTl9UT0dHTEU6ICcuZHJvcGRvd24tdG9nZ2xlJ1xuICAgIH07XG4gICAgdmFyIE9mZnNldE1ldGhvZCA9IHtcbiAgICAgIE9GRlNFVDogJ29mZnNldCcsXG4gICAgICBQT1NJVElPTjogJ3Bvc2l0aW9uJ1xuICAgICAgLyoqXG4gICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAqIENsYXNzIERlZmluaXRpb25cbiAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICovXG5cbiAgICB9O1xuXG4gICAgdmFyIFNjcm9sbFNweSA9XG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFNjcm9sbFNweShlbGVtZW50LCBjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudCA9IGVsZW1lbnQudGFnTmFtZSA9PT0gJ0JPRFknID8gd2luZG93IDogZWxlbWVudDtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gdGhpcy5fY29uZmlnLnRhcmdldCArIFwiIFwiICsgU2VsZWN0b3IuTkFWX0xJTktTICsgXCIsXCIgKyAodGhpcy5fY29uZmlnLnRhcmdldCArIFwiIFwiICsgU2VsZWN0b3IuTElTVF9JVEVNUyArIFwiLFwiKSArICh0aGlzLl9jb25maWcudGFyZ2V0ICsgXCIgXCIgKyBTZWxlY3Rvci5EUk9QRE9XTl9JVEVNUyk7XG4gICAgICAgIHRoaXMuX29mZnNldHMgPSBbXTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9zY3JvbGxIZWlnaHQgPSAwO1xuICAgICAgICAkJCQxKHRoaXMuX3Njcm9sbEVsZW1lbnQpLm9uKEV2ZW50LlNDUk9MTCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9wcm9jZXNzKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuXG4gICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcbiAgICAgIH0gLy8gR2V0dGVyc1xuXG5cbiAgICAgIHZhciBfcHJvdG8gPSBTY3JvbGxTcHkucHJvdG90eXBlO1xuXG4gICAgICAvLyBQdWJsaWNcbiAgICAgIF9wcm90by5yZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGF1dG9NZXRob2QgPSB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB0aGlzLl9zY3JvbGxFbGVtZW50LndpbmRvdyA/IE9mZnNldE1ldGhvZC5PRkZTRVQgOiBPZmZzZXRNZXRob2QuUE9TSVRJT047XG4gICAgICAgIHZhciBvZmZzZXRNZXRob2QgPSB0aGlzLl9jb25maWcubWV0aG9kID09PSAnYXV0bycgPyBhdXRvTWV0aG9kIDogdGhpcy5fY29uZmlnLm1ldGhvZDtcbiAgICAgICAgdmFyIG9mZnNldEJhc2UgPSBvZmZzZXRNZXRob2QgPT09IE9mZnNldE1ldGhvZC5QT1NJVElPTiA/IHRoaXMuX2dldFNjcm9sbFRvcCgpIDogMDtcbiAgICAgICAgdGhpcy5fb2Zmc2V0cyA9IFtdO1xuICAgICAgICB0aGlzLl90YXJnZXRzID0gW107XG4gICAgICAgIHRoaXMuX3Njcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpO1xuICAgICAgICB2YXIgdGFyZ2V0cyA9ICQkJDEubWFrZUFycmF5KCQkJDEodGhpcy5fc2VsZWN0b3IpKTtcbiAgICAgICAgdGFyZ2V0cy5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0O1xuICAgICAgICAgIHZhciB0YXJnZXRTZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGlmICh0YXJnZXRTZWxlY3Rvcikge1xuICAgICAgICAgICAgdGFyZ2V0ID0gJCQkMSh0YXJnZXRTZWxlY3RvcilbMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldEJDUiA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgaWYgKHRhcmdldEJDUi53aWR0aCB8fCB0YXJnZXRCQ1IuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgIC8vIFRPRE8gKGZhdCk6IHJlbW92ZSBza2V0Y2ggcmVsaWFuY2Ugb24galF1ZXJ5IHBvc2l0aW9uL29mZnNldFxuICAgICAgICAgICAgICByZXR1cm4gWyQkJDEodGFyZ2V0KVtvZmZzZXRNZXRob2RdKCkudG9wICsgb2Zmc2V0QmFzZSwgdGFyZ2V0U2VsZWN0b3JdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIF90aGlzMi5fb2Zmc2V0cy5wdXNoKGl0ZW1bMF0pO1xuXG4gICAgICAgICAgX3RoaXMyLl90YXJnZXRzLnB1c2goaXRlbVsxXSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAkJCQxLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuICAgICAgICAkJCQxKHRoaXMuX3Njcm9sbEVsZW1lbnQpLm9mZihFVkVOVF9LRVkpO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb2Zmc2V0cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RhcmdldHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9zY3JvbGxIZWlnaHQgPSBudWxsO1xuICAgICAgfTsgLy8gUHJpdmF0ZVxuXG5cbiAgICAgIF9wcm90by5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgY29uZmlnID0gX29iamVjdFNwcmVhZCh7fSwgRGVmYXVsdCwgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnLnRhcmdldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgaWQgPSAkJCQxKGNvbmZpZy50YXJnZXQpLmF0dHIoJ2lkJyk7XG5cbiAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICBpZCA9IFV0aWwuZ2V0VUlEKE5BTUUpO1xuICAgICAgICAgICAgJCQkMShjb25maWcudGFyZ2V0KS5hdHRyKCdpZCcsIGlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25maWcudGFyZ2V0ID0gXCIjXCIgKyBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgRGVmYXVsdFR5cGUpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9nZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiBfZ2V0U2Nyb2xsVG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID8gdGhpcy5fc2Nyb2xsRWxlbWVudC5wYWdlWU9mZnNldCA6IHRoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9nZXRTY3JvbGxIZWlnaHQgPSBmdW5jdGlvbiBfZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxIZWlnaHQgfHwgTWF0aC5tYXgoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQpO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9nZXRPZmZzZXRIZWlnaHQgPSBmdW5jdGlvbiBfZ2V0T2Zmc2V0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID8gd2luZG93LmlubmVySGVpZ2h0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uX3Byb2Nlc3MgPSBmdW5jdGlvbiBfcHJvY2VzcygpIHtcbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuX2dldFNjcm9sbFRvcCgpICsgdGhpcy5fY29uZmlnLm9mZnNldDtcblxuICAgICAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gdGhpcy5fZ2V0U2Nyb2xsSGVpZ2h0KCk7XG5cbiAgICAgICAgdmFyIG1heFNjcm9sbCA9IHRoaXMuX2NvbmZpZy5vZmZzZXQgKyBzY3JvbGxIZWlnaHQgLSB0aGlzLl9nZXRPZmZzZXRIZWlnaHQoKTtcblxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsSGVpZ2h0ICE9PSBzY3JvbGxIZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY3JvbGxUb3AgPj0gbWF4U2Nyb2xsKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldHNbdGhpcy5fdGFyZ2V0cy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ICYmIHNjcm9sbFRvcCA8IHRoaXMuX29mZnNldHNbMF0gJiYgdGhpcy5fb2Zmc2V0c1swXSA+IDApIHtcbiAgICAgICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsO1xuXG4gICAgICAgICAgdGhpcy5fY2xlYXIoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vZmZzZXRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIHZhciBpc0FjdGl2ZVRhcmdldCA9IHRoaXMuX2FjdGl2ZVRhcmdldCAhPT0gdGhpcy5fdGFyZ2V0c1tpXSAmJiBzY3JvbGxUb3AgPj0gdGhpcy5fb2Zmc2V0c1tpXSAmJiAodHlwZW9mIHRoaXMuX29mZnNldHNbaSArIDFdID09PSAndW5kZWZpbmVkJyB8fCBzY3JvbGxUb3AgPCB0aGlzLl9vZmZzZXRzW2kgKyAxXSk7XG5cbiAgICAgICAgICBpZiAoaXNBY3RpdmVUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlKHRoaXMuX3RhcmdldHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3Byb3RvLl9hY3RpdmF0ZSA9IGZ1bmN0aW9uIF9hY3RpdmF0ZSh0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgICAgIHRoaXMuX2NsZWFyKCk7XG5cbiAgICAgICAgdmFyIHF1ZXJpZXMgPSB0aGlzLl9zZWxlY3Rvci5zcGxpdCgnLCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyb3ctYm9keS1zdHlsZVxuXG5cbiAgICAgICAgcXVlcmllcyA9IHF1ZXJpZXMubWFwKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgIHJldHVybiBzZWxlY3RvciArIFwiW2RhdGEtdGFyZ2V0PVxcXCJcIiArIHRhcmdldCArIFwiXFxcIl0sXCIgKyAoc2VsZWN0b3IgKyBcIltocmVmPVxcXCJcIiArIHRhcmdldCArIFwiXFxcIl1cIik7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgJGxpbmsgPSAkJCQxKHF1ZXJpZXMuam9pbignLCcpKTtcblxuICAgICAgICBpZiAoJGxpbmsuaGFzQ2xhc3MoQ2xhc3NOYW1lLkRST1BET1dOX0lURU0pKSB7XG4gICAgICAgICAgJGxpbmsuY2xvc2VzdChTZWxlY3Rvci5EUk9QRE9XTikuZmluZChTZWxlY3Rvci5EUk9QRE9XTl9UT0dHTEUpLmFkZENsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgICAgICRsaW5rLmFkZENsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNldCB0cmlnZ2VyZWQgbGluayBhcyBhY3RpdmVcbiAgICAgICAgICAkbGluay5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTsgLy8gU2V0IHRyaWdnZXJlZCBsaW5rcyBwYXJlbnRzIGFzIGFjdGl2ZVxuICAgICAgICAgIC8vIFdpdGggYm90aCA8dWw+IGFuZCA8bmF2PiBtYXJrdXAgYSBwYXJlbnQgaXMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYW55IG5hdiBhbmNlc3RvclxuXG4gICAgICAgICAgJGxpbmsucGFyZW50cyhTZWxlY3Rvci5OQVZfTElTVF9HUk9VUCkucHJldihTZWxlY3Rvci5OQVZfTElOS1MgKyBcIiwgXCIgKyBTZWxlY3Rvci5MSVNUX0lURU1TKS5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTsgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSB3aGVuIC5uYXYtbGluayBpcyBpbnNpZGUgLm5hdi1pdGVtXG5cbiAgICAgICAgICAkbGluay5wYXJlbnRzKFNlbGVjdG9yLk5BVl9MSVNUX0dST1VQKS5wcmV2KFNlbGVjdG9yLk5BVl9JVEVNUykuY2hpbGRyZW4oU2VsZWN0b3IuTkFWX0xJTktTKS5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgICAgfVxuXG4gICAgICAgICQkJDEodGhpcy5fc2Nyb2xsRWxlbWVudCkudHJpZ2dlcihFdmVudC5BQ1RJVkFURSwge1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRhcmdldFxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIF9wcm90by5fY2xlYXIgPSBmdW5jdGlvbiBfY2xlYXIoKSB7XG4gICAgICAgICQkJDEodGhpcy5fc2VsZWN0b3IpLmZpbHRlcihTZWxlY3Rvci5BQ1RJVkUpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgfTsgLy8gU3RhdGljXG5cblxuICAgICAgU2Nyb2xsU3B5Ll9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9ICQkJDEodGhpcykuZGF0YShEQVRBX0tFWSk7XG5cbiAgICAgICAgICB2YXIgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZztcblxuICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgZGF0YSA9IG5ldyBTY3JvbGxTcHkodGhpcywgX2NvbmZpZyk7XG4gICAgICAgICAgICAkJCQxKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyBtZXRob2QgbmFtZWQgXFxcIlwiICsgY29uZmlnICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgX2NyZWF0ZUNsYXNzKFNjcm9sbFNweSwgbnVsbCwgW3tcbiAgICAgICAga2V5OiBcIlZFUlNJT05cIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcIkRlZmF1bHRcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIERlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIFNjcm9sbFNweTtcbiAgICB9KCk7XG4gICAgLyoqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuXG4gICAgJCQkMSh3aW5kb3cpLm9uKEV2ZW50LkxPQURfREFUQV9BUEksIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzY3JvbGxTcHlzID0gJCQkMS5tYWtlQXJyYXkoJCQkMShTZWxlY3Rvci5EQVRBX1NQWSkpO1xuXG4gICAgICBmb3IgKHZhciBpID0gc2Nyb2xsU3B5cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgdmFyICRzcHkgPSAkJCQxKHNjcm9sbFNweXNbaV0pO1xuXG4gICAgICAgIFNjcm9sbFNweS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJHNweSwgJHNweS5kYXRhKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIGpRdWVyeVxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG4gICAgJCQkMS5mbltOQU1FXSA9IFNjcm9sbFNweS5falF1ZXJ5SW50ZXJmYWNlO1xuICAgICQkJDEuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBTY3JvbGxTcHk7XG5cbiAgICAkJCQxLmZuW05BTUVdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAkJCQxLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgICAgcmV0dXJuIFNjcm9sbFNweS5falF1ZXJ5SW50ZXJmYWNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2Nyb2xsU3B5O1xuICB9KCQpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgKHY0LjEuMSk6IHRhYi5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgVGFiID0gZnVuY3Rpb24gKCQkJDEpIHtcbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBDb25zdGFudHNcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cbiAgICB2YXIgTkFNRSA9ICd0YWInO1xuICAgIHZhciBWRVJTSU9OID0gJzQuMS4xJztcbiAgICB2YXIgREFUQV9LRVkgPSAnYnMudGFiJztcbiAgICB2YXIgRVZFTlRfS0VZID0gXCIuXCIgKyBEQVRBX0tFWTtcbiAgICB2YXIgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XG4gICAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQkJDEuZm5bTkFNRV07XG4gICAgdmFyIEV2ZW50ID0ge1xuICAgICAgSElERTogXCJoaWRlXCIgKyBFVkVOVF9LRVksXG4gICAgICBISURERU46IFwiaGlkZGVuXCIgKyBFVkVOVF9LRVksXG4gICAgICBTSE9XOiBcInNob3dcIiArIEVWRU5UX0tFWSxcbiAgICAgIFNIT1dOOiBcInNob3duXCIgKyBFVkVOVF9LRVksXG4gICAgICBDTElDS19EQVRBX0FQSTogXCJjbGlja1wiICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZXG4gICAgfTtcbiAgICB2YXIgQ2xhc3NOYW1lID0ge1xuICAgICAgRFJPUERPV05fTUVOVTogJ2Ryb3Bkb3duLW1lbnUnLFxuICAgICAgQUNUSVZFOiAnYWN0aXZlJyxcbiAgICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgICAgRkFERTogJ2ZhZGUnLFxuICAgICAgU0hPVzogJ3Nob3cnXG4gICAgfTtcbiAgICB2YXIgU2VsZWN0b3IgPSB7XG4gICAgICBEUk9QRE9XTjogJy5kcm9wZG93bicsXG4gICAgICBOQVZfTElTVF9HUk9VUDogJy5uYXYsIC5saXN0LWdyb3VwJyxcbiAgICAgIEFDVElWRTogJy5hY3RpdmUnLFxuICAgICAgQUNUSVZFX1VMOiAnPiBsaSA+IC5hY3RpdmUnLFxuICAgICAgREFUQV9UT0dHTEU6ICdbZGF0YS10b2dnbGU9XCJ0YWJcIl0sIFtkYXRhLXRvZ2dsZT1cInBpbGxcIl0sIFtkYXRhLXRvZ2dsZT1cImxpc3RcIl0nLFxuICAgICAgRFJPUERPV05fVE9HR0xFOiAnLmRyb3Bkb3duLXRvZ2dsZScsXG4gICAgICBEUk9QRE9XTl9BQ1RJVkVfQ0hJTEQ6ICc+IC5kcm9wZG93bi1tZW51IC5hY3RpdmUnXG4gICAgICAvKipcbiAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgKi9cblxuICAgIH07XG5cbiAgICB2YXIgVGFiID1cbiAgICAvKiNfX1BVUkVfXyovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGFiKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB9IC8vIEdldHRlcnNcblxuXG4gICAgICB2YXIgX3Byb3RvID0gVGFiLnByb3RvdHlwZTtcblxuICAgICAgLy8gUHVibGljXG4gICAgICBfcHJvdG8uc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSAmJiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmICQkJDEodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSkgfHwgJCQkMSh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRElTQUJMRUQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRhcmdldDtcbiAgICAgICAgdmFyIHByZXZpb3VzO1xuICAgICAgICB2YXIgbGlzdEVsZW1lbnQgPSAkJCQxKHRoaXMuX2VsZW1lbnQpLmNsb3Nlc3QoU2VsZWN0b3IuTkFWX0xJU1RfR1JPVVApWzBdO1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKGxpc3RFbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGl0ZW1TZWxlY3RvciA9IGxpc3RFbGVtZW50Lm5vZGVOYW1lID09PSAnVUwnID8gU2VsZWN0b3IuQUNUSVZFX1VMIDogU2VsZWN0b3IuQUNUSVZFO1xuICAgICAgICAgIHByZXZpb3VzID0gJCQkMS5tYWtlQXJyYXkoJCQkMShsaXN0RWxlbWVudCkuZmluZChpdGVtU2VsZWN0b3IpKTtcbiAgICAgICAgICBwcmV2aW91cyA9IHByZXZpb3VzW3ByZXZpb3VzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhpZGVFdmVudCA9ICQkJDEuRXZlbnQoRXZlbnQuSElERSwge1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzaG93RXZlbnQgPSAkJCQxLkV2ZW50KEV2ZW50LlNIT1csIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBwcmV2aW91c1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgICAkJCQxKHByZXZpb3VzKS50cmlnZ2VyKGhpZGVFdmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAkJCQxKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2hvd0V2ZW50KTtcblxuICAgICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgIHRhcmdldCA9ICQkJDEoc2VsZWN0b3IpWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYWN0aXZhdGUodGhpcy5fZWxlbWVudCwgbGlzdEVsZW1lbnQpO1xuXG4gICAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICAgIHZhciBoaWRkZW5FdmVudCA9ICQkJDEuRXZlbnQoRXZlbnQuSElEREVOLCB7XG4gICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBfdGhpcy5fZWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzaG93bkV2ZW50ID0gJCQkMS5FdmVudChFdmVudC5TSE9XTiwge1xuICAgICAgICAgICAgcmVsYXRlZFRhcmdldDogcHJldmlvdXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAkJCQxKHByZXZpb3VzKS50cmlnZ2VyKGhpZGRlbkV2ZW50KTtcbiAgICAgICAgICAkJCQxKF90aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNob3duRXZlbnQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICB0aGlzLl9hY3RpdmF0ZSh0YXJnZXQsIHRhcmdldC5wYXJlbnROb2RlLCBjb21wbGV0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3Byb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAkJCQxLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICAgIH07IC8vIFByaXZhdGVcblxuXG4gICAgICBfcHJvdG8uX2FjdGl2YXRlID0gZnVuY3Rpb24gX2FjdGl2YXRlKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnRzO1xuXG4gICAgICAgIGlmIChjb250YWluZXIubm9kZU5hbWUgPT09ICdVTCcpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50cyA9ICQkJDEoY29udGFpbmVyKS5maW5kKFNlbGVjdG9yLkFDVElWRV9VTCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudHMgPSAkJCQxKGNvbnRhaW5lcikuY2hpbGRyZW4oU2VsZWN0b3IuQUNUSVZFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3RpdmUgPSBhY3RpdmVFbGVtZW50c1swXTtcbiAgICAgICAgdmFyIGlzVHJhbnNpdGlvbmluZyA9IGNhbGxiYWNrICYmIGFjdGl2ZSAmJiAkJCQxKGFjdGl2ZSkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpO1xuXG4gICAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX3RyYW5zaXRpb25Db21wbGV0ZShlbGVtZW50LCBhY3RpdmUsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoYWN0aXZlICYmIGlzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGFjdGl2ZSk7XG4gICAgICAgICAgJCQkMShhY3RpdmUpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8uX3RyYW5zaXRpb25Db21wbGV0ZSA9IGZ1bmN0aW9uIF90cmFuc2l0aW9uQ29tcGxldGUoZWxlbWVudCwgYWN0aXZlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICAgJCQkMShhY3RpdmUpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5TSE9XICsgXCIgXCIgKyBDbGFzc05hbWUuQUNUSVZFKTtcbiAgICAgICAgICB2YXIgZHJvcGRvd25DaGlsZCA9ICQkJDEoYWN0aXZlLnBhcmVudE5vZGUpLmZpbmQoU2VsZWN0b3IuRFJPUERPV05fQUNUSVZFX0NISUxEKVswXTtcblxuICAgICAgICAgIGlmIChkcm9wZG93bkNoaWxkKSB7XG4gICAgICAgICAgICAkJCQxKGRyb3Bkb3duQ2hpbGQpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5BQ1RJVkUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhY3RpdmUuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICd0YWInKSB7XG4gICAgICAgICAgICBhY3RpdmUuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICQkJDEoZWxlbWVudCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG5cbiAgICAgICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICd0YWInKSB7XG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFV0aWwucmVmbG93KGVsZW1lbnQpO1xuICAgICAgICAkJCQxKGVsZW1lbnQpLmFkZENsYXNzKENsYXNzTmFtZS5TSE9XKTtcblxuICAgICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICYmICQkJDEoZWxlbWVudC5wYXJlbnROb2RlKS5oYXNDbGFzcyhDbGFzc05hbWUuRFJPUERPV05fTUVOVSkpIHtcbiAgICAgICAgICB2YXIgZHJvcGRvd25FbGVtZW50ID0gJCQkMShlbGVtZW50KS5jbG9zZXN0KFNlbGVjdG9yLkRST1BET1dOKVswXTtcblxuICAgICAgICAgIGlmIChkcm9wZG93bkVsZW1lbnQpIHtcbiAgICAgICAgICAgICQkJDEoZHJvcGRvd25FbGVtZW50KS5maW5kKFNlbGVjdG9yLkRST1BET1dOX1RPR0dMRSkuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH07IC8vIFN0YXRpY1xuXG5cbiAgICAgIFRhYi5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyICR0aGlzID0gJCQkMSh0aGlzKTtcbiAgICAgICAgICB2YXIgZGF0YSA9ICR0aGlzLmRhdGEoREFUQV9LRVkpO1xuXG4gICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBkYXRhID0gbmV3IFRhYih0aGlzKTtcbiAgICAgICAgICAgICR0aGlzLmRhdGEoREFUQV9LRVksIGRhdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyBtZXRob2QgbmFtZWQgXFxcIlwiICsgY29uZmlnICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgX2NyZWF0ZUNsYXNzKFRhYiwgbnVsbCwgW3tcbiAgICAgICAga2V5OiBcIlZFUlNJT05cIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIFRhYjtcbiAgICB9KCk7XG4gICAgLyoqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuXG4gICAgJCQkMShkb2N1bWVudCkub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkRBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIFRhYi5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJCQkMSh0aGlzKSwgJ3Nob3cnKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBqUXVlcnlcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuICAgICQkJDEuZm5bTkFNRV0gPSBUYWIuX2pRdWVyeUludGVyZmFjZTtcbiAgICAkJCQxLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gVGFiO1xuXG4gICAgJCQkMS5mbltOQU1FXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgJCQkMS5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVDtcbiAgICAgIHJldHVybiBUYWIuX2pRdWVyeUludGVyZmFjZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRhYjtcbiAgfSgkKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwICh2NC4xLjEpOiBpbmRleC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAoZnVuY3Rpb24gKCQkJDEpIHtcbiAgICBpZiAodHlwZW9mICQkJDEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgalF1ZXJ5LiBqUXVlcnkgbXVzdCBiZSBpbmNsdWRlZCBiZWZvcmUgQm9vdHN0cmFwXFwncyBKYXZhU2NyaXB0LicpO1xuICAgIH1cblxuICAgIHZhciB2ZXJzaW9uID0gJCQkMS5mbi5qcXVlcnkuc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpO1xuICAgIHZhciBtaW5NYWpvciA9IDE7XG4gICAgdmFyIGx0TWFqb3IgPSAyO1xuICAgIHZhciBtaW5NaW5vciA9IDk7XG4gICAgdmFyIG1pblBhdGNoID0gMTtcbiAgICB2YXIgbWF4TWFqb3IgPSA0O1xuXG4gICAgaWYgKHZlcnNpb25bMF0gPCBsdE1ham9yICYmIHZlcnNpb25bMV0gPCBtaW5NaW5vciB8fCB2ZXJzaW9uWzBdID09PSBtaW5NYWpvciAmJiB2ZXJzaW9uWzFdID09PSBtaW5NaW5vciAmJiB2ZXJzaW9uWzJdIDwgbWluUGF0Y2ggfHwgdmVyc2lvblswXSA+PSBtYXhNYWpvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb290c3RyYXBcXCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgYXQgbGVhc3QgalF1ZXJ5IHYxLjkuMSBidXQgbGVzcyB0aGFuIHY0LjAuMCcpO1xuICAgIH1cbiAgfSkoJCk7XG5cbiAgZXhwb3J0cy5VdGlsID0gVXRpbDtcbiAgZXhwb3J0cy5BbGVydCA9IEFsZXJ0O1xuICBleHBvcnRzLkJ1dHRvbiA9IEJ1dHRvbjtcbiAgZXhwb3J0cy5DYXJvdXNlbCA9IENhcm91c2VsO1xuICBleHBvcnRzLkNvbGxhcHNlID0gQ29sbGFwc2U7XG4gIGV4cG9ydHMuRHJvcGRvd24gPSBEcm9wZG93bjtcbiAgZXhwb3J0cy5Nb2RhbCA9IE1vZGFsO1xuICBleHBvcnRzLlBvcG92ZXIgPSBQb3BvdmVyO1xuICBleHBvcnRzLlNjcm9sbHNweSA9IFNjcm9sbFNweTtcbiAgZXhwb3J0cy5UYWIgPSBUYWI7XG4gIGV4cG9ydHMuVG9vbHRpcCA9IFRvb2x0aXA7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb3RzdHJhcC5qcy5tYXBcbiIsIi8qIEBsaWNlbnNlIEMzLmpzIHYwLjQuMjMgfCAoYykgQzMgVGVhbSBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHwgaHR0cDovL2MzanMub3JnLyAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsLmMzID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIENMQVNTID0ge1xuICAgICAgICB0YXJnZXQ6ICdjMy10YXJnZXQnLFxuICAgICAgICBjaGFydDogJ2MzLWNoYXJ0JyxcbiAgICAgICAgY2hhcnRMaW5lOiAnYzMtY2hhcnQtbGluZScsXG4gICAgICAgIGNoYXJ0TGluZXM6ICdjMy1jaGFydC1saW5lcycsXG4gICAgICAgIGNoYXJ0QmFyOiAnYzMtY2hhcnQtYmFyJyxcbiAgICAgICAgY2hhcnRCYXJzOiAnYzMtY2hhcnQtYmFycycsXG4gICAgICAgIGNoYXJ0VGV4dDogJ2MzLWNoYXJ0LXRleHQnLFxuICAgICAgICBjaGFydFRleHRzOiAnYzMtY2hhcnQtdGV4dHMnLFxuICAgICAgICBjaGFydEFyYzogJ2MzLWNoYXJ0LWFyYycsXG4gICAgICAgIGNoYXJ0QXJjczogJ2MzLWNoYXJ0LWFyY3MnLFxuICAgICAgICBjaGFydEFyY3NUaXRsZTogJ2MzLWNoYXJ0LWFyY3MtdGl0bGUnLFxuICAgICAgICBjaGFydEFyY3NCYWNrZ3JvdW5kOiAnYzMtY2hhcnQtYXJjcy1iYWNrZ3JvdW5kJyxcbiAgICAgICAgY2hhcnRBcmNzR2F1Z2VVbml0OiAnYzMtY2hhcnQtYXJjcy1nYXVnZS11bml0JyxcbiAgICAgICAgY2hhcnRBcmNzR2F1Z2VNYXg6ICdjMy1jaGFydC1hcmNzLWdhdWdlLW1heCcsXG4gICAgICAgIGNoYXJ0QXJjc0dhdWdlTWluOiAnYzMtY2hhcnQtYXJjcy1nYXVnZS1taW4nLFxuICAgICAgICBzZWxlY3RlZENpcmNsZTogJ2MzLXNlbGVjdGVkLWNpcmNsZScsXG4gICAgICAgIHNlbGVjdGVkQ2lyY2xlczogJ2MzLXNlbGVjdGVkLWNpcmNsZXMnLFxuICAgICAgICBldmVudFJlY3Q6ICdjMy1ldmVudC1yZWN0JyxcbiAgICAgICAgZXZlbnRSZWN0czogJ2MzLWV2ZW50LXJlY3RzJyxcbiAgICAgICAgZXZlbnRSZWN0c1NpbmdsZTogJ2MzLWV2ZW50LXJlY3RzLXNpbmdsZScsXG4gICAgICAgIGV2ZW50UmVjdHNNdWx0aXBsZTogJ2MzLWV2ZW50LXJlY3RzLW11bHRpcGxlJyxcbiAgICAgICAgem9vbVJlY3Q6ICdjMy16b29tLXJlY3QnLFxuICAgICAgICBicnVzaDogJ2MzLWJydXNoJyxcbiAgICAgICAgZm9jdXNlZDogJ2MzLWZvY3VzZWQnLFxuICAgICAgICBkZWZvY3VzZWQ6ICdjMy1kZWZvY3VzZWQnLFxuICAgICAgICByZWdpb246ICdjMy1yZWdpb24nLFxuICAgICAgICByZWdpb25zOiAnYzMtcmVnaW9ucycsXG4gICAgICAgIHRpdGxlOiAnYzMtdGl0bGUnLFxuICAgICAgICB0b29sdGlwQ29udGFpbmVyOiAnYzMtdG9vbHRpcC1jb250YWluZXInLFxuICAgICAgICB0b29sdGlwOiAnYzMtdG9vbHRpcCcsXG4gICAgICAgIHRvb2x0aXBOYW1lOiAnYzMtdG9vbHRpcC1uYW1lJyxcbiAgICAgICAgc2hhcGU6ICdjMy1zaGFwZScsXG4gICAgICAgIHNoYXBlczogJ2MzLXNoYXBlcycsXG4gICAgICAgIGxpbmU6ICdjMy1saW5lJyxcbiAgICAgICAgbGluZXM6ICdjMy1saW5lcycsXG4gICAgICAgIGJhcjogJ2MzLWJhcicsXG4gICAgICAgIGJhcnM6ICdjMy1iYXJzJyxcbiAgICAgICAgY2lyY2xlOiAnYzMtY2lyY2xlJyxcbiAgICAgICAgY2lyY2xlczogJ2MzLWNpcmNsZXMnLFxuICAgICAgICBhcmM6ICdjMy1hcmMnLFxuICAgICAgICBhcmNMYWJlbExpbmU6ICdjMy1hcmMtbGFiZWwtbGluZScsXG4gICAgICAgIGFyY3M6ICdjMy1hcmNzJyxcbiAgICAgICAgYXJlYTogJ2MzLWFyZWEnLFxuICAgICAgICBhcmVhczogJ2MzLWFyZWFzJyxcbiAgICAgICAgZW1wdHk6ICdjMy1lbXB0eScsXG4gICAgICAgIHRleHQ6ICdjMy10ZXh0JyxcbiAgICAgICAgdGV4dHM6ICdjMy10ZXh0cycsXG4gICAgICAgIGdhdWdlVmFsdWU6ICdjMy1nYXVnZS12YWx1ZScsXG4gICAgICAgIGdyaWQ6ICdjMy1ncmlkJyxcbiAgICAgICAgZ3JpZExpbmVzOiAnYzMtZ3JpZC1saW5lcycsXG4gICAgICAgIHhncmlkOiAnYzMteGdyaWQnLFxuICAgICAgICB4Z3JpZHM6ICdjMy14Z3JpZHMnLFxuICAgICAgICB4Z3JpZExpbmU6ICdjMy14Z3JpZC1saW5lJyxcbiAgICAgICAgeGdyaWRMaW5lczogJ2MzLXhncmlkLWxpbmVzJyxcbiAgICAgICAgeGdyaWRGb2N1czogJ2MzLXhncmlkLWZvY3VzJyxcbiAgICAgICAgeWdyaWQ6ICdjMy15Z3JpZCcsXG4gICAgICAgIHlncmlkczogJ2MzLXlncmlkcycsXG4gICAgICAgIHlncmlkTGluZTogJ2MzLXlncmlkLWxpbmUnLFxuICAgICAgICB5Z3JpZExpbmVzOiAnYzMteWdyaWQtbGluZXMnLFxuICAgICAgICBheGlzOiAnYzMtYXhpcycsXG4gICAgICAgIGF4aXNYOiAnYzMtYXhpcy14JyxcbiAgICAgICAgYXhpc1hMYWJlbDogJ2MzLWF4aXMteC1sYWJlbCcsXG4gICAgICAgIGF4aXNZOiAnYzMtYXhpcy15JyxcbiAgICAgICAgYXhpc1lMYWJlbDogJ2MzLWF4aXMteS1sYWJlbCcsXG4gICAgICAgIGF4aXNZMjogJ2MzLWF4aXMteTInLFxuICAgICAgICBheGlzWTJMYWJlbDogJ2MzLWF4aXMteTItbGFiZWwnLFxuICAgICAgICBsZWdlbmRCYWNrZ3JvdW5kOiAnYzMtbGVnZW5kLWJhY2tncm91bmQnLFxuICAgICAgICBsZWdlbmRJdGVtOiAnYzMtbGVnZW5kLWl0ZW0nLFxuICAgICAgICBsZWdlbmRJdGVtRXZlbnQ6ICdjMy1sZWdlbmQtaXRlbS1ldmVudCcsXG4gICAgICAgIGxlZ2VuZEl0ZW1UaWxlOiAnYzMtbGVnZW5kLWl0ZW0tdGlsZScsXG4gICAgICAgIGxlZ2VuZEl0ZW1IaWRkZW46ICdjMy1sZWdlbmQtaXRlbS1oaWRkZW4nLFxuICAgICAgICBsZWdlbmRJdGVtRm9jdXNlZDogJ2MzLWxlZ2VuZC1pdGVtLWZvY3VzZWQnLFxuICAgICAgICBkcmFnYXJlYTogJ2MzLWRyYWdhcmVhJyxcbiAgICAgICAgRVhQQU5ERUQ6ICdfZXhwYW5kZWRfJyxcbiAgICAgICAgU0VMRUNURUQ6ICdfc2VsZWN0ZWRfJyxcbiAgICAgICAgSU5DTFVERUQ6ICdfaW5jbHVkZWRfJ1xuICAgIH07XG5cbiAgICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG5cbiAgICB2YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG4gICAgfTtcblxuICAgIHZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgICAgIGlmICghc2VsZikge1xuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xuICAgIH07XG5cbiAgICB2YXIgaXNWYWx1ZSA9IGZ1bmN0aW9uIGlzVmFsdWUodikge1xuICAgICAgICByZXR1cm4gdiB8fCB2ID09PSAwO1xuICAgIH07XG4gICAgdmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKG8pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvID09PSAnZnVuY3Rpb24nO1xuICAgIH07XG4gICAgdmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KG8pIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkobyk7XG4gICAgfTtcbiAgICB2YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyhvKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ3N0cmluZyc7XG4gICAgfTtcbiAgICB2YXIgaXNVbmRlZmluZWQgPSBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfTtcbiAgICB2YXIgaXNEZWZpbmVkID0gZnVuY3Rpb24gaXNEZWZpbmVkKHYpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2ICE9PSAndW5kZWZpbmVkJztcbiAgICB9O1xuICAgIHZhciBjZWlsMTAgPSBmdW5jdGlvbiBjZWlsMTAodikge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHYgLyAxMCkgKiAxMDtcbiAgICB9O1xuICAgIHZhciBhc0hhbGZQaXhlbCA9IGZ1bmN0aW9uIGFzSGFsZlBpeGVsKG4pIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChuKSArIDAuNTtcbiAgICB9O1xuICAgIHZhciBkaWZmRG9tYWluID0gZnVuY3Rpb24gZGlmZkRvbWFpbihkKSB7XG4gICAgICAgIHJldHVybiBkWzFdIC0gZFswXTtcbiAgICB9O1xuICAgIHZhciBpc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eShvKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ3VuZGVmaW5lZCcgfHwgbyA9PT0gbnVsbCB8fCBpc1N0cmluZyhvKSAmJiBvLmxlbmd0aCA9PT0gMCB8fCAodHlwZW9mIG8gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG8pKSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMobykubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgdmFyIG5vdEVtcHR5ID0gZnVuY3Rpb24gbm90RW1wdHkobykge1xuICAgICAgICByZXR1cm4gIWMzX2NoYXJ0X2ludGVybmFsX2ZuLmlzRW1wdHkobyk7XG4gICAgfTtcbiAgICB2YXIgZ2V0T3B0aW9uID0gZnVuY3Rpb24gZ2V0T3B0aW9uKG9wdGlvbnMsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc0RlZmluZWQob3B0aW9uc1trZXldKSA/IG9wdGlvbnNba2V5XSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9O1xuICAgIHZhciBoYXNWYWx1ZSA9IGZ1bmN0aW9uIGhhc1ZhbHVlKGRpY3QsIHZhbHVlKSB7XG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBPYmplY3Qua2V5cyhkaWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChkaWN0W2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH07XG4gICAgdmFyIHNhbml0aXNlID0gZnVuY3Rpb24gc2FuaXRpc2Uoc3RyKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpIDogc3RyO1xuICAgIH07XG4gICAgdmFyIGdldFBhdGhCb3ggPSBmdW5jdGlvbiBnZXRQYXRoQm94KHBhdGgpIHtcbiAgICAgICAgdmFyIGJveCA9IHBhdGguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBpdGVtcyA9IFtwYXRoLnBhdGhTZWdMaXN0LmdldEl0ZW0oMCksIHBhdGgucGF0aFNlZ0xpc3QuZ2V0SXRlbSgxKV0sXG4gICAgICAgICAgICBtaW5YID0gaXRlbXNbMF0ueCxcbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihpdGVtc1swXS55LCBpdGVtc1sxXS55KTtcbiAgICAgICAgcmV0dXJuIHsgeDogbWluWCwgeTogbWluWSwgd2lkdGg6IGJveC53aWR0aCwgaGVpZ2h0OiBib3guaGVpZ2h0IH07XG4gICAgfTtcblxuICAgIHZhciBjM19heGlzX2ZuO1xuICAgIHZhciBjM19heGlzX2ludGVybmFsX2ZuO1xuXG4gICAgZnVuY3Rpb24gQXhpc0ludGVybmFsKGNvbXBvbmVudCwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBpbnRlcm5hbCA9IHRoaXM7XG4gICAgICAgIGludGVybmFsLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgaW50ZXJuYWwucGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgICAgIGludGVybmFsLmQzID0gY29tcG9uZW50LmQzO1xuICAgICAgICBpbnRlcm5hbC5zY2FsZSA9IGludGVybmFsLmQzLnNjYWxlLmxpbmVhcigpO1xuICAgICAgICBpbnRlcm5hbC5yYW5nZTtcbiAgICAgICAgaW50ZXJuYWwub3JpZW50ID0gXCJib3R0b21cIjtcbiAgICAgICAgaW50ZXJuYWwuaW5uZXJUaWNrU2l6ZSA9IDY7XG4gICAgICAgIGludGVybmFsLm91dGVyVGlja1NpemUgPSB0aGlzLnBhcmFtcy53aXRoT3V0ZXJUaWNrID8gNiA6IDA7XG4gICAgICAgIGludGVybmFsLnRpY2tQYWRkaW5nID0gMztcbiAgICAgICAgaW50ZXJuYWwudGlja1ZhbHVlcyA9IG51bGw7XG4gICAgICAgIGludGVybmFsLnRpY2tGb3JtYXQ7XG4gICAgICAgIGludGVybmFsLnRpY2tBcmd1bWVudHM7XG5cbiAgICAgICAgaW50ZXJuYWwudGlja09mZnNldCA9IDA7XG4gICAgICAgIGludGVybmFsLnRpY2tDdWxsaW5nID0gdHJ1ZTtcbiAgICAgICAgaW50ZXJuYWwudGlja0NlbnRlcmVkO1xuICAgICAgICBpbnRlcm5hbC50aWNrVGV4dENoYXJTaXplO1xuICAgICAgICBpbnRlcm5hbC50aWNrVGV4dFJvdGF0ZSA9IGludGVybmFsLnBhcmFtcy50aWNrVGV4dFJvdGF0ZTtcbiAgICAgICAgaW50ZXJuYWwudGlja0xlbmd0aDtcblxuICAgICAgICBpbnRlcm5hbC5heGlzID0gaW50ZXJuYWwuZ2VuZXJhdGVBeGlzKCk7XG4gICAgfVxuICAgIGMzX2F4aXNfaW50ZXJuYWxfZm4gPSBBeGlzSW50ZXJuYWwucHJvdG90eXBlO1xuXG4gICAgYzNfYXhpc19pbnRlcm5hbF9mbi5heGlzWCA9IGZ1bmN0aW9uIChzZWxlY3Rpb24sIHgsIHRpY2tPZmZzZXQpIHtcbiAgICAgICAgc2VsZWN0aW9uLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIE1hdGguY2VpbCh4KGQpICsgdGlja09mZnNldCkgKyBcIiwgMClcIjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjM19heGlzX2ludGVybmFsX2ZuLmF4aXNZID0gZnVuY3Rpb24gKHNlbGVjdGlvbiwgeSkge1xuICAgICAgICBzZWxlY3Rpb24uYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKDAsXCIgKyBNYXRoLmNlaWwoeShkKSkgKyBcIilcIjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjM19heGlzX2ludGVybmFsX2ZuLnNjYWxlRXh0ZW50ID0gZnVuY3Rpb24gKGRvbWFpbikge1xuICAgICAgICB2YXIgc3RhcnQgPSBkb21haW5bMF0sXG4gICAgICAgICAgICBzdG9wID0gZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0IDwgc3RvcCA/IFtzdGFydCwgc3RvcF0gOiBbc3RvcCwgc3RhcnRdO1xuICAgIH07XG4gICAgYzNfYXhpc19pbnRlcm5hbF9mbi5nZW5lcmF0ZVRpY2tzID0gZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICAgIHZhciBpbnRlcm5hbCA9IHRoaXM7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgZG9tYWluLFxuICAgICAgICAgICAgdGlja3MgPSBbXTtcbiAgICAgICAgaWYgKHNjYWxlLnRpY2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGUudGlja3MuYXBwbHkoc2NhbGUsIGludGVybmFsLnRpY2tBcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpO1xuICAgICAgICBmb3IgKGkgPSBNYXRoLmNlaWwoZG9tYWluWzBdKTsgaSA8IGRvbWFpblsxXTsgaSsrKSB7XG4gICAgICAgICAgICB0aWNrcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aWNrcy5sZW5ndGggPiAwICYmIHRpY2tzWzBdID4gMCkge1xuICAgICAgICAgICAgdGlja3MudW5zaGlmdCh0aWNrc1swXSAtICh0aWNrc1sxXSAtIHRpY2tzWzBdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpY2tzO1xuICAgIH07XG4gICAgYzNfYXhpc19pbnRlcm5hbF9mbi5jb3B5U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnRlcm5hbCA9IHRoaXM7XG4gICAgICAgIHZhciBuZXdTY2FsZSA9IGludGVybmFsLnNjYWxlLmNvcHkoKSxcbiAgICAgICAgICAgIGRvbWFpbjtcbiAgICAgICAgaWYgKGludGVybmFsLnBhcmFtcy5pc0NhdGVnb3J5KSB7XG4gICAgICAgICAgICBkb21haW4gPSBpbnRlcm5hbC5zY2FsZS5kb21haW4oKTtcbiAgICAgICAgICAgIG5ld1NjYWxlLmRvbWFpbihbZG9tYWluWzBdLCBkb21haW5bMV0gLSAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1NjYWxlO1xuICAgIH07XG4gICAgYzNfYXhpc19pbnRlcm5hbF9mbi50ZXh0Rm9ybWF0dGVkID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIGludGVybmFsID0gdGhpcyxcbiAgICAgICAgICAgIGZvcm1hdHRlZCA9IGludGVybmFsLnRpY2tGb3JtYXQgPyBpbnRlcm5hbC50aWNrRm9ybWF0KHYpIDogdjtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmb3JtYXR0ZWQgIT09ICd1bmRlZmluZWQnID8gZm9ybWF0dGVkIDogJyc7XG4gICAgfTtcbiAgICBjM19heGlzX2ludGVybmFsX2ZuLnVwZGF0ZVJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW50ZXJuYWwgPSB0aGlzO1xuICAgICAgICBpbnRlcm5hbC5yYW5nZSA9IGludGVybmFsLnNjYWxlLnJhbmdlRXh0ZW50ID8gaW50ZXJuYWwuc2NhbGUucmFuZ2VFeHRlbnQoKSA6IGludGVybmFsLnNjYWxlRXh0ZW50KGludGVybmFsLnNjYWxlLnJhbmdlKCkpO1xuICAgICAgICByZXR1cm4gaW50ZXJuYWwucmFuZ2U7XG4gICAgfTtcbiAgICBjM19heGlzX2ludGVybmFsX2ZuLnVwZGF0ZVRpY2tUZXh0Q2hhclNpemUgPSBmdW5jdGlvbiAodGljaykge1xuICAgICAgICB2YXIgaW50ZXJuYWwgPSB0aGlzO1xuICAgICAgICBpZiAoaW50ZXJuYWwudGlja1RleHRDaGFyU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsLnRpY2tUZXh0Q2hhclNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSB7XG4gICAgICAgICAgICBoOiAxMS41LFxuICAgICAgICAgICAgdzogNS41XG4gICAgICAgIH07XG4gICAgICAgIHRpY2suc2VsZWN0KCd0ZXh0JykudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsLnRleHRGb3JtYXR0ZWQoZCk7XG4gICAgICAgIH0pLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBib3ggPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgIHRleHQgPSBpbnRlcm5hbC50ZXh0Rm9ybWF0dGVkKGQpLFxuICAgICAgICAgICAgICAgIGggPSBib3guaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHcgPSB0ZXh0ID8gYm94LndpZHRoIC8gdGV4dC5sZW5ndGggOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaCAmJiB3KSB7XG4gICAgICAgICAgICAgICAgc2l6ZS5oID0gaDtcbiAgICAgICAgICAgICAgICBzaXplLncgPSB3O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS50ZXh0KCcnKTtcbiAgICAgICAgaW50ZXJuYWwudGlja1RleHRDaGFyU2l6ZSA9IHNpemU7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH07XG4gICAgYzNfYXhpc19pbnRlcm5hbF9mbi50cmFuc2l0aW9uaXNlID0gZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMud2l0aG91dFRyYW5zaXRpb24gPyBzZWxlY3Rpb24gOiB0aGlzLmQzLnRyYW5zaXRpb24oc2VsZWN0aW9uKTtcbiAgICB9O1xuICAgIGMzX2F4aXNfaW50ZXJuYWxfZm4uaXNWZXJ0aWNhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZW50ID09PSAnbGVmdCcgfHwgdGhpcy5vcmllbnQgPT09ICdyaWdodCc7XG4gICAgfTtcbiAgICBjM19heGlzX2ludGVybmFsX2ZuLnRzcGFuRGF0YSA9IGZ1bmN0aW9uIChkLCBpLCB0aWNrcywgc2NhbGUpIHtcbiAgICAgICAgdmFyIGludGVybmFsID0gdGhpcztcbiAgICAgICAgdmFyIHNwbGl0dGVkID0gaW50ZXJuYWwucGFyYW1zLnRpY2tNdWx0aWxpbmUgPyBpbnRlcm5hbC5zcGxpdFRpY2tUZXh0KGQsIHRpY2tzLCBzY2FsZSkgOiBbXS5jb25jYXQoaW50ZXJuYWwudGV4dEZvcm1hdHRlZChkKSk7XG5cbiAgICAgICAgaWYgKGludGVybmFsLnBhcmFtcy50aWNrTXVsdGlsaW5lICYmIGludGVybmFsLnBhcmFtcy50aWNrTXVsdGlsaW5lTWF4ID4gMCkge1xuICAgICAgICAgICAgc3BsaXR0ZWQgPSBpbnRlcm5hbC5lbGxpcHNpZnkoc3BsaXR0ZWQsIGludGVybmFsLnBhcmFtcy50aWNrTXVsdGlsaW5lTWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzcGxpdHRlZC5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGluZGV4OiBpLCBzcGxpdHRlZDogcywgbGVuZ3RoOiBzcGxpdHRlZC5sZW5ndGggfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjM19heGlzX2ludGVybmFsX2ZuLnNwbGl0VGlja1RleHQgPSBmdW5jdGlvbiAoZCwgdGlja3MsIHNjYWxlKSB7XG4gICAgICAgIHZhciBpbnRlcm5hbCA9IHRoaXMsXG4gICAgICAgICAgICB0aWNrVGV4dCA9IGludGVybmFsLnRleHRGb3JtYXR0ZWQoZCksXG4gICAgICAgICAgICBtYXhXaWR0aCA9IGludGVybmFsLnBhcmFtcy50aWNrV2lkdGgsXG4gICAgICAgICAgICBzdWJ0ZXh0LFxuICAgICAgICAgICAgc3BhY2VJbmRleCxcbiAgICAgICAgICAgIHRleHRXaWR0aCxcbiAgICAgICAgICAgIHNwbGl0dGVkID0gW107XG5cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aWNrVGV4dCkgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRpY2tUZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXhXaWR0aCB8fCBtYXhXaWR0aCA8PSAwKSB7XG4gICAgICAgICAgICBtYXhXaWR0aCA9IGludGVybmFsLmlzVmVydGljYWwoKSA/IDk1IDogaW50ZXJuYWwucGFyYW1zLmlzQ2F0ZWdvcnkgPyBNYXRoLmNlaWwoc2NhbGUodGlja3NbMV0pIC0gc2NhbGUodGlja3NbMF0pKSAtIDEyIDogMTEwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3BsaXQoc3BsaXR0ZWQsIHRleHQpIHtcbiAgICAgICAgICAgIHNwYWNlSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQXQoaSkgPT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICBzcGFjZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VidGV4dCA9IHRleHQuc3Vic3RyKDAsIGkgKyAxKTtcbiAgICAgICAgICAgICAgICB0ZXh0V2lkdGggPSBpbnRlcm5hbC50aWNrVGV4dENoYXJTaXplLncgKiBzdWJ0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBpZiB0ZXh0IHdpZHRoIGdldHMgb3ZlciB0aWNrIHdpZHRoLCBzcGxpdCBieSBzcGFjZSBpbmRleCBvciBjcnJlbnQgaW5kZXhcbiAgICAgICAgICAgICAgICBpZiAobWF4V2lkdGggPCB0ZXh0V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwbGl0KHNwbGl0dGVkLmNvbmNhdCh0ZXh0LnN1YnN0cigwLCBzcGFjZUluZGV4ID8gc3BhY2VJbmRleCA6IGkpKSwgdGV4dC5zbGljZShzcGFjZUluZGV4ID8gc3BhY2VJbmRleCArIDEgOiBpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNwbGl0dGVkLmNvbmNhdCh0ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzcGxpdChzcGxpdHRlZCwgdGlja1RleHQgKyBcIlwiKTtcbiAgICB9O1xuICAgIGMzX2F4aXNfaW50ZXJuYWxfZm4uZWxsaXBzaWZ5ID0gZnVuY3Rpb24gKHNwbGl0dGVkLCBtYXgpIHtcbiAgICAgICAgaWYgKHNwbGl0dGVkLmxlbmd0aCA8PSBtYXgpIHtcbiAgICAgICAgICAgIHJldHVybiBzcGxpdHRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGxpcHNpZmllZCA9IHNwbGl0dGVkLnNsaWNlKDAsIG1heCk7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSAzO1xuICAgICAgICBmb3IgKHZhciBpID0gbWF4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGUgPSBlbGxpcHNpZmllZFtpXS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGVsbGlwc2lmaWVkW2ldID0gZWxsaXBzaWZpZWRbaV0uc3Vic3RyKDAsIGF2YWlsYWJsZSAtIHJlbWFpbmluZykucGFkRW5kKGF2YWlsYWJsZSwgJy4nKTtcblxuICAgICAgICAgICAgcmVtYWluaW5nIC09IGF2YWlsYWJsZTtcblxuICAgICAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxsaXBzaWZpZWQ7XG4gICAgfTtcbiAgICBjM19heGlzX2ludGVybmFsX2ZuLnVwZGF0ZVRpY2tMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnRlcm5hbCA9IHRoaXM7XG4gICAgICAgIGludGVybmFsLnRpY2tMZW5ndGggPSBNYXRoLm1heChpbnRlcm5hbC5pbm5lclRpY2tTaXplLCAwKSArIGludGVybmFsLnRpY2tQYWRkaW5nO1xuICAgIH07XG4gICAgYzNfYXhpc19pbnRlcm5hbF9mbi5saW5lWTIgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgaW50ZXJuYWwgPSB0aGlzLFxuICAgICAgICAgICAgdGlja1Bvc2l0aW9uID0gaW50ZXJuYWwuc2NhbGUoZCkgKyAoaW50ZXJuYWwudGlja0NlbnRlcmVkID8gMCA6IGludGVybmFsLnRpY2tPZmZzZXQpO1xuICAgICAgICByZXR1cm4gaW50ZXJuYWwucmFuZ2VbMF0gPCB0aWNrUG9zaXRpb24gJiYgdGlja1Bvc2l0aW9uIDwgaW50ZXJuYWwucmFuZ2VbMV0gPyBpbnRlcm5hbC5pbm5lclRpY2tTaXplIDogMDtcbiAgICB9O1xuICAgIGMzX2F4aXNfaW50ZXJuYWxfZm4udGV4dFkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnRlcm5hbCA9IHRoaXMsXG4gICAgICAgICAgICByb3RhdGUgPSBpbnRlcm5hbC50aWNrVGV4dFJvdGF0ZTtcbiAgICAgICAgcmV0dXJuIHJvdGF0ZSA/IDExLjUgLSAyLjUgKiAocm90YXRlIC8gMTUpICogKHJvdGF0ZSA+IDAgPyAxIDogLTEpIDogaW50ZXJuYWwudGlja0xlbmd0aDtcbiAgICB9O1xuICAgIGMzX2F4aXNfaW50ZXJuYWxfZm4udGV4dFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGludGVybmFsID0gdGhpcyxcbiAgICAgICAgICAgIHJvdGF0ZSA9IGludGVybmFsLnRpY2tUZXh0Um90YXRlO1xuICAgICAgICByZXR1cm4gcm90YXRlID8gXCJyb3RhdGUoXCIgKyByb3RhdGUgKyBcIilcIiA6IFwiXCI7XG4gICAgfTtcbiAgICBjM19heGlzX2ludGVybmFsX2ZuLnRleHRUZXh0QW5jaG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW50ZXJuYWwgPSB0aGlzLFxuICAgICAgICAgICAgcm90YXRlID0gaW50ZXJuYWwudGlja1RleHRSb3RhdGU7XG4gICAgICAgIHJldHVybiByb3RhdGUgPyByb3RhdGUgPiAwID8gXCJzdGFydFwiIDogXCJlbmRcIiA6IFwibWlkZGxlXCI7XG4gICAgfTtcbiAgICBjM19heGlzX2ludGVybmFsX2ZuLnRzcGFuRHggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnRlcm5hbCA9IHRoaXMsXG4gICAgICAgICAgICByb3RhdGUgPSBpbnRlcm5hbC50aWNrVGV4dFJvdGF0ZTtcbiAgICAgICAgcmV0dXJuIHJvdGF0ZSA/IDggKiBNYXRoLnNpbihNYXRoLlBJICogKHJvdGF0ZSAvIDE4MCkpIDogMDtcbiAgICB9O1xuICAgIGMzX2F4aXNfaW50ZXJuYWxfZm4udHNwYW5EeSA9IGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHZhciBpbnRlcm5hbCA9IHRoaXMsXG4gICAgICAgICAgICBkeSA9IGludGVybmFsLnRpY2tUZXh0Q2hhclNpemUuaDtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbC5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgICAgICAgICAgICBkeSA9IC0oKGQubGVuZ3RoIC0gMSkgKiAoaW50ZXJuYWwudGlja1RleHRDaGFyU2l6ZS5oIC8gMikgLSAzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHkgPSBcIi43MWVtXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR5O1xuICAgIH07XG5cbiAgICBjM19heGlzX2ludGVybmFsX2ZuLmdlbmVyYXRlQXhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGludGVybmFsID0gdGhpcyxcbiAgICAgICAgICAgIGQzID0gaW50ZXJuYWwuZDMsXG4gICAgICAgICAgICBwYXJhbXMgPSBpbnRlcm5hbC5wYXJhbXM7XG4gICAgICAgIGZ1bmN0aW9uIGF4aXMoZykge1xuICAgICAgICAgICAgZy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZyA9IGF4aXMuZyA9IGQzLnNlbGVjdCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciBzY2FsZTAgPSB0aGlzLl9fY2hhcnRfXyB8fCBpbnRlcm5hbC5zY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUxID0gdGhpcy5fX2NoYXJ0X18gPSBpbnRlcm5hbC5jb3B5U2NhbGUoKTtcblxuICAgICAgICAgICAgICAgIHZhciB0aWNrcyA9IGludGVybmFsLnRpY2tWYWx1ZXMgPyBpbnRlcm5hbC50aWNrVmFsdWVzIDogaW50ZXJuYWwuZ2VuZXJhdGVUaWNrcyhzY2FsZTEpLFxuICAgICAgICAgICAgICAgICAgICB0aWNrID0gZy5zZWxlY3RBbGwoXCIudGlja1wiKS5kYXRhKHRpY2tzLCBzY2FsZTEpLFxuICAgICAgICAgICAgICAgICAgICB0aWNrRW50ZXIgPSB0aWNrLmVudGVyKCkuaW5zZXJ0KFwiZ1wiLCBcIi5kb21haW5cIikuYXR0cihcImNsYXNzXCIsIFwidGlja1wiKS5zdHlsZShcIm9wYWNpdHlcIiwgMWUtNiksXG5cbiAgICAgICAgICAgICAgICAvLyBNRU1POiBObyBleGl0IHRyYW5zaXRpb24uIFRoZSByZWFzb24gaXMgdGhpcyB0cmFuc2l0aW9uIGFmZmVjdHMgbWF4IHRpY2sgd2lkdGggY2FsY3VsYXRpb24gYmVjYXVzZSBvbGQgdGljayB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSB0aWNrcy5cbiAgICAgICAgICAgICAgICB0aWNrRXhpdCA9IHRpY2suZXhpdCgpLnJlbW92ZSgpLFxuICAgICAgICAgICAgICAgICAgICB0aWNrVXBkYXRlID0gaW50ZXJuYWwudHJhbnNpdGlvbmlzZSh0aWNrKS5zdHlsZShcIm9wYWNpdHlcIiwgMSksXG4gICAgICAgICAgICAgICAgICAgIHRpY2tUcmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgICAgIHRpY2tYLFxuICAgICAgICAgICAgICAgICAgICB0aWNrWTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuaXNDYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbC50aWNrT2Zmc2V0ID0gTWF0aC5jZWlsKChzY2FsZTEoMSkgLSBzY2FsZTEoMCkpIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRpY2tYID0gaW50ZXJuYWwudGlja0NlbnRlcmVkID8gMCA6IGludGVybmFsLnRpY2tPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHRpY2tZID0gaW50ZXJuYWwudGlja0NlbnRlcmVkID8gaW50ZXJuYWwudGlja09mZnNldCA6IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWwudGlja09mZnNldCA9IHRpY2tYID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aWNrRW50ZXIuYXBwZW5kKFwibGluZVwiKTtcbiAgICAgICAgICAgICAgICB0aWNrRW50ZXIuYXBwZW5kKFwidGV4dFwiKTtcblxuICAgICAgICAgICAgICAgIGludGVybmFsLnVwZGF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWwudXBkYXRlVGlja0xlbmd0aCgpO1xuICAgICAgICAgICAgICAgIGludGVybmFsLnVwZGF0ZVRpY2tUZXh0Q2hhclNpemUoZy5zZWxlY3QoJy50aWNrJykpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVVcGRhdGUgPSB0aWNrVXBkYXRlLnNlbGVjdChcImxpbmVcIiksXG4gICAgICAgICAgICAgICAgICAgIHRleHRVcGRhdGUgPSB0aWNrVXBkYXRlLnNlbGVjdChcInRleHRcIiksXG4gICAgICAgICAgICAgICAgICAgIHRzcGFuVXBkYXRlID0gdGljay5zZWxlY3QoXCJ0ZXh0XCIpLnNlbGVjdEFsbCgndHNwYW4nKS5kYXRhKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbC50c3BhbkRhdGEoZCwgaSwgdGlja3MsIHNjYWxlMSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0c3BhblVwZGF0ZS5lbnRlcigpLmFwcGVuZCgndHNwYW4nKTtcbiAgICAgICAgICAgICAgICB0c3BhblVwZGF0ZS5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdHNwYW5VcGRhdGUudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5zcGxpdHRlZDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gZy5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLmRhdGEoWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aFVwZGF0ZSA9IChwYXRoLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJkb21haW5cIiksIGludGVybmFsLnRyYW5zaXRpb25pc2UocGF0aCkpO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZWFjaCBhdHRyIHNob3VsZCBiZSBvbmUgZnVuY3Rpb24gYW5kIGNoYW5nZSBpdHMgYmVoYXZpb3IgYnkgaW50ZXJuYWwub3JpZW50LCBwcm9iYWJseVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaW50ZXJuYWwub3JpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWNrVHJhbnNmb3JtID0gaW50ZXJuYWwuYXhpc1g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVVwZGF0ZS5hdHRyKFwieDFcIiwgdGlja1gpLmF0dHIoXCJ4MlwiLCB0aWNrWCkuYXR0cihcInkyXCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbC5saW5lWTIoZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFVwZGF0ZS5hdHRyKFwieFwiLCAwKS5hdHRyKFwieVwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWwudGV4dFkoZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWwudGV4dFRyYW5zZm9ybShkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5zdHlsZShcInRleHQtYW5jaG9yXCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbC50ZXh0VGV4dEFuY2hvcihkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0c3BhblVwZGF0ZS5hdHRyKCd4JywgMCkuYXR0cihcImR5XCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbC50c3BhbkR5KGQsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmF0dHIoJ2R4JywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFsLnRzcGFuRHgoZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFVwZGF0ZS5hdHRyKFwiZFwiLCBcIk1cIiArIGludGVybmFsLnJhbmdlWzBdICsgXCIsXCIgKyBpbnRlcm5hbC5vdXRlclRpY2tTaXplICsgXCJWMEhcIiArIGludGVybmFsLnJhbmdlWzFdICsgXCJWXCIgKyBpbnRlcm5hbC5vdXRlclRpY2tTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHJvdGF0ZWQgdGljayB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlja1RyYW5zZm9ybSA9IGludGVybmFsLmF4aXNYO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVVcGRhdGUuYXR0cihcIngxXCIsIHRpY2tYKS5hdHRyKFwieDJcIiwgdGlja1gpLmF0dHIoXCJ5MlwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTEgKiBpbnRlcm5hbC5saW5lWTIoZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFVwZGF0ZS5hdHRyKFwieFwiLCAwKS5hdHRyKFwieVwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTEgKiBpbnRlcm5hbC50ZXh0WShkLCBpKSAtIChwYXJhbXMuaXNDYXRlZ29yeSA/IDIgOiBpbnRlcm5hbC50aWNrTGVuZ3RoIC0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWwudGV4dFRyYW5zZm9ybShkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5zdHlsZShcInRleHQtYW5jaG9yXCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbC50ZXh0VGV4dEFuY2hvcihkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0c3BhblVwZGF0ZS5hdHRyKCd4JywgMCkuYXR0cihcImR5XCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbC50c3BhbkR5KGQsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmF0dHIoJ2R4JywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFsLnRzcGFuRHgoZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFVwZGF0ZS5hdHRyKFwiZFwiLCBcIk1cIiArIGludGVybmFsLnJhbmdlWzBdICsgXCIsXCIgKyAtaW50ZXJuYWwub3V0ZXJUaWNrU2l6ZSArIFwiVjBIXCIgKyBpbnRlcm5hbC5yYW5nZVsxXSArIFwiVlwiICsgLWludGVybmFsLm91dGVyVGlja1NpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tUcmFuc2Zvcm0gPSBpbnRlcm5hbC5heGlzWTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lVXBkYXRlLmF0dHIoXCJ4MlwiLCAtaW50ZXJuYWwuaW5uZXJUaWNrU2l6ZSkuYXR0cihcInkxXCIsIHRpY2tZKS5hdHRyKFwieTJcIiwgdGlja1kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRVcGRhdGUuYXR0cihcInhcIiwgLWludGVybmFsLnRpY2tMZW5ndGgpLmF0dHIoXCJ5XCIsIGludGVybmFsLnRpY2tPZmZzZXQpLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHNwYW5VcGRhdGUuYXR0cigneCcsIC1pbnRlcm5hbC50aWNrTGVuZ3RoKS5hdHRyKFwiZHlcIiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFsLnRzcGFuRHkoZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFVwZGF0ZS5hdHRyKFwiZFwiLCBcIk1cIiArIC1pbnRlcm5hbC5vdXRlclRpY2tTaXplICsgXCIsXCIgKyBpbnRlcm5hbC5yYW5nZVswXSArIFwiSDBWXCIgKyBpbnRlcm5hbC5yYW5nZVsxXSArIFwiSFwiICsgLWludGVybmFsLm91dGVyVGlja1NpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWNrVHJhbnNmb3JtID0gaW50ZXJuYWwuYXhpc1k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVVwZGF0ZS5hdHRyKFwieDJcIiwgaW50ZXJuYWwuaW5uZXJUaWNrU2l6ZSkuYXR0cihcInkxXCIsIHRpY2tZKS5hdHRyKFwieTJcIiwgdGlja1kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRVcGRhdGUuYXR0cihcInhcIiwgaW50ZXJuYWwudGlja0xlbmd0aCkuYXR0cihcInlcIiwgaW50ZXJuYWwudGlja09mZnNldCkuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcInN0YXJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRzcGFuVXBkYXRlLmF0dHIoJ3gnLCBpbnRlcm5hbC50aWNrTGVuZ3RoKS5hdHRyKFwiZHlcIiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFsLnRzcGFuRHkoZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFVwZGF0ZS5hdHRyKFwiZFwiLCBcIk1cIiArIGludGVybmFsLm91dGVyVGlja1NpemUgKyBcIixcIiArIGludGVybmFsLnJhbmdlWzBdICsgXCJIMFZcIiArIGludGVybmFsLnJhbmdlWzFdICsgXCJIXCIgKyBpbnRlcm5hbC5vdXRlclRpY2tTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjYWxlMS5yYW5nZUJhbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBzY2FsZTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBkeCA9IHgucmFuZ2VCYW5kKCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBzY2FsZTAgPSBzY2FsZTEgPSBmdW5jdGlvbiBzY2FsZTEoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoZCkgKyBkeDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNjYWxlMC5yYW5nZUJhbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUwID0gc2NhbGUxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2tFeGl0LmNhbGwodGlja1RyYW5zZm9ybSwgc2NhbGUxLCBpbnRlcm5hbC50aWNrT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGlja0VudGVyLmNhbGwodGlja1RyYW5zZm9ybSwgc2NhbGUwLCBpbnRlcm5hbC50aWNrT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aWNrVXBkYXRlLmNhbGwodGlja1RyYW5zZm9ybSwgc2NhbGUxLCBpbnRlcm5hbC50aWNrT2Zmc2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGF4aXMuc2NhbGUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFsLnNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50ZXJuYWwuc2NhbGUgPSB4O1xuICAgICAgICAgICAgcmV0dXJuIGF4aXM7XG4gICAgICAgIH07XG4gICAgICAgIGF4aXMub3JpZW50ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbC5vcmllbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnRlcm5hbC5vcmllbnQgPSB4IGluIHsgdG9wOiAxLCByaWdodDogMSwgYm90dG9tOiAxLCBsZWZ0OiAxIH0gPyB4ICsgXCJcIiA6IFwiYm90dG9tXCI7XG4gICAgICAgICAgICByZXR1cm4gYXhpcztcbiAgICAgICAgfTtcbiAgICAgICAgYXhpcy50aWNrRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFsLnRpY2tGb3JtYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnRlcm5hbC50aWNrRm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICAgICAgcmV0dXJuIGF4aXM7XG4gICAgICAgIH07XG4gICAgICAgIGF4aXMudGlja0NlbnRlcmVkID0gZnVuY3Rpb24gKGlzQ2VudGVyZWQpIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbC50aWNrQ2VudGVyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnRlcm5hbC50aWNrQ2VudGVyZWQgPSBpc0NlbnRlcmVkO1xuICAgICAgICAgICAgcmV0dXJuIGF4aXM7XG4gICAgICAgIH07XG4gICAgICAgIGF4aXMudGlja09mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbC50aWNrT2Zmc2V0O1xuICAgICAgICB9O1xuICAgICAgICBheGlzLnRpY2tJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCwgbGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5pc0NhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSBpbnRlcm5hbC50aWNrT2Zmc2V0ICogMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gYXhpcy5nLnNlbGVjdCgncGF0aC5kb21haW4nKS5ub2RlKCkuZ2V0VG90YWxMZW5ndGgoKSAtIGludGVybmFsLm91dGVyVGlja1NpemUgKiAyO1xuICAgICAgICAgICAgICAgIGludGVydmFsID0gbGVuZ3RoIC8gYXhpcy5nLnNlbGVjdEFsbCgnbGluZScpLnNpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnRlcnZhbCA9PT0gSW5maW5pdHkgPyAwIDogaW50ZXJ2YWw7XG4gICAgICAgIH07XG4gICAgICAgIGF4aXMudGlja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWwudGlja0FyZ3VtZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludGVybmFsLnRpY2tBcmd1bWVudHMgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICByZXR1cm4gYXhpcztcbiAgICAgICAgfTtcbiAgICAgICAgYXhpcy50aWNrQ3VsbGluZyA9IGZ1bmN0aW9uIChjdWxsaW5nKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWwudGlja0N1bGxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnRlcm5hbC50aWNrQ3VsbGluZyA9IGN1bGxpbmc7XG4gICAgICAgICAgICByZXR1cm4gYXhpcztcbiAgICAgICAgfTtcbiAgICAgICAgYXhpcy50aWNrVmFsdWVzID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGludGVybmFsLnRpY2tWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4KGludGVybmFsLnNjYWxlLmRvbWFpbigpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFsLnRpY2tWYWx1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGludGVybmFsLnRpY2tWYWx1ZXMgPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF4aXM7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG5cbiAgICB2YXIgQXhpcyA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgICAgIGluaGVyaXRzKEF4aXMsIF9Db21wb25lbnQpO1xuXG4gICAgICAgIGZ1bmN0aW9uIEF4aXMob3duZXIpIHtcbiAgICAgICAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEF4aXMpO1xuXG4gICAgICAgICAgICB2YXIgZm4gPSB7XG4gICAgICAgICAgICAgICAgZm46IGMzX2F4aXNfZm4sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgZm46IGMzX2F4aXNfaW50ZXJuYWxfZm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChBeGlzLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQXhpcykpLmNhbGwodGhpcywgb3duZXIsICdheGlzJywgZm4pKTtcblxuICAgICAgICAgICAgX3RoaXMuZDMgPSBvd25lci5kMztcbiAgICAgICAgICAgIF90aGlzLmludGVybmFsID0gQXhpc0ludGVybmFsO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEF4aXM7XG4gICAgfShDb21wb25lbnQpO1xuXG4gICAgYzNfYXhpc19mbiA9IEF4aXMucHJvdG90eXBlO1xuXG4gICAgYzNfYXhpc19mbi5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5vd25lcixcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIG1haW4gPSAkJC5tYWluO1xuICAgICAgICAkJC5heGVzLnggPSBtYWluLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIENMQVNTLmF4aXMgKyAnICcgKyBDTEFTUy5heGlzWCkuYXR0cihcImNsaXAtcGF0aFwiLCBjb25maWcuYXhpc194X2lubmVyID8gXCJcIiA6ICQkLmNsaXBQYXRoRm9yWEF4aXMpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKCd4JykpLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBjb25maWcuYXhpc194X3Nob3cgPyAndmlzaWJsZScgOiAnaGlkZGVuJyk7XG4gICAgICAgICQkLmF4ZXMueC5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5heGlzWExhYmVsKS5hdHRyKFwidHJhbnNmb3JtXCIsIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcInJvdGF0ZSgtOTApXCIgOiBcIlwiKS5zdHlsZShcInRleHQtYW5jaG9yXCIsIHRoaXMudGV4dEFuY2hvckZvclhBeGlzTGFiZWwuYmluZCh0aGlzKSk7XG4gICAgICAgICQkLmF4ZXMueSA9IG1haW4uYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuYXhpcyArICcgJyArIENMQVNTLmF4aXNZKS5hdHRyKFwiY2xpcC1wYXRoXCIsIGNvbmZpZy5heGlzX3lfaW5uZXIgPyBcIlwiIDogJCQuY2xpcFBhdGhGb3JZQXhpcykuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoJ3knKSkuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZy5heGlzX3lfc2hvdyA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nKTtcbiAgICAgICAgJCQuYXhlcy55LmFwcGVuZChcInRleHRcIikuYXR0cihcImNsYXNzXCIsIENMQVNTLmF4aXNZTGFiZWwpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/IFwiXCIgOiBcInJvdGF0ZSgtOTApXCIpLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgdGhpcy50ZXh0QW5jaG9yRm9yWUF4aXNMYWJlbC5iaW5kKHRoaXMpKTtcblxuICAgICAgICAkJC5heGVzLnkyID0gbWFpbi5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5heGlzICsgJyAnICsgQ0xBU1MuYXhpc1kyKVxuICAgICAgICAvLyBjbGlwLXBhdGg/XG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZSgneTInKSkuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZy5heGlzX3kyX3Nob3cgPyAndmlzaWJsZScgOiAnaGlkZGVuJyk7XG4gICAgICAgICQkLmF4ZXMueTIuYXBwZW5kKFwidGV4dFwiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuYXhpc1kyTGFiZWwpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/IFwiXCIgOiBcInJvdGF0ZSgtOTApXCIpLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgdGhpcy50ZXh0QW5jaG9yRm9yWTJBeGlzTGFiZWwuYmluZCh0aGlzKSk7XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLmdldFhBeGlzID0gZnVuY3Rpb24gZ2V0WEF4aXMoc2NhbGUsIG9yaWVudCwgdGlja0Zvcm1hdCwgdGlja1ZhbHVlcywgd2l0aE91dGVyVGljaywgd2l0aG91dFRyYW5zaXRpb24sIHdpdGhvdXRSb3RhdGVUaWNrVGV4dCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLm93bmVyLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgYXhpc1BhcmFtcyA9IHtcbiAgICAgICAgICAgIGlzQ2F0ZWdvcnk6ICQkLmlzQ2F0ZWdvcml6ZWQoKSxcbiAgICAgICAgICAgIHdpdGhPdXRlclRpY2s6IHdpdGhPdXRlclRpY2ssXG4gICAgICAgICAgICB0aWNrTXVsdGlsaW5lOiBjb25maWcuYXhpc194X3RpY2tfbXVsdGlsaW5lLFxuICAgICAgICAgICAgdGlja011bHRpbGluZU1heDogY29uZmlnLmF4aXNfeF90aWNrX211bHRpbGluZSA/IE51bWJlcihjb25maWcuYXhpc194X3RpY2tfbXVsdGlsaW5lTWF4KSA6IDAsXG4gICAgICAgICAgICB0aWNrV2lkdGg6IGNvbmZpZy5heGlzX3hfdGlja193aWR0aCxcbiAgICAgICAgICAgIHRpY2tUZXh0Um90YXRlOiB3aXRob3V0Um90YXRlVGlja1RleHQgPyAwIDogY29uZmlnLmF4aXNfeF90aWNrX3JvdGF0ZSxcbiAgICAgICAgICAgIHdpdGhvdXRUcmFuc2l0aW9uOiB3aXRob3V0VHJhbnNpdGlvblxuICAgICAgICB9LFxuICAgICAgICAgICAgYXhpcyA9IG5ldyB0aGlzLmludGVybmFsKHRoaXMsIGF4aXNQYXJhbXMpLmF4aXMuc2NhbGUoc2NhbGUpLm9yaWVudChvcmllbnQpO1xuXG4gICAgICAgIGlmICgkJC5pc1RpbWVTZXJpZXMoKSAmJiB0aWNrVmFsdWVzICYmIHR5cGVvZiB0aWNrVmFsdWVzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRpY2tWYWx1ZXMgPSB0aWNrVmFsdWVzLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiAkJC5wYXJzZURhdGUodik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aWNrXG4gICAgICAgIGF4aXMudGlja0Zvcm1hdCh0aWNrRm9ybWF0KS50aWNrVmFsdWVzKHRpY2tWYWx1ZXMpO1xuICAgICAgICBpZiAoJCQuaXNDYXRlZ29yaXplZCgpKSB7XG4gICAgICAgICAgICBheGlzLnRpY2tDZW50ZXJlZChjb25maWcuYXhpc194X3RpY2tfY2VudGVyZWQpO1xuICAgICAgICAgICAgaWYgKGlzRW1wdHkoY29uZmlnLmF4aXNfeF90aWNrX2N1bGxpbmcpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmF4aXNfeF90aWNrX2N1bGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYzNfYXhpc19mbi51cGRhdGVYQXhpc1RpY2tWYWx1ZXMgPSBmdW5jdGlvbiB1cGRhdGVYQXhpc1RpY2tWYWx1ZXModGFyZ2V0cywgYXhpcykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLm93bmVyLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgdGlja1ZhbHVlcztcbiAgICAgICAgaWYgKGNvbmZpZy5heGlzX3hfdGlja19maXQgfHwgY29uZmlnLmF4aXNfeF90aWNrX2NvdW50KSB7XG4gICAgICAgICAgICB0aWNrVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVRpY2tWYWx1ZXMoJCQubWFwVGFyZ2V0c1RvVW5pcXVlWHModGFyZ2V0cyksIGNvbmZpZy5heGlzX3hfdGlja19jb3VudCwgJCQuaXNUaW1lU2VyaWVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzKSB7XG4gICAgICAgICAgICBheGlzLnRpY2tWYWx1ZXModGlja1ZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkJC54QXhpcy50aWNrVmFsdWVzKHRpY2tWYWx1ZXMpO1xuICAgICAgICAgICAgJCQuc3ViWEF4aXMudGlja1ZhbHVlcyh0aWNrVmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlja1ZhbHVlcztcbiAgICB9O1xuICAgIGMzX2F4aXNfZm4uZ2V0WUF4aXMgPSBmdW5jdGlvbiBnZXRZQXhpcyhzY2FsZSwgb3JpZW50LCB0aWNrRm9ybWF0LCB0aWNrVmFsdWVzLCB3aXRoT3V0ZXJUaWNrLCB3aXRob3V0VHJhbnNpdGlvbiwgd2l0aG91dFJvdGF0ZVRpY2tUZXh0KSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMub3duZXIsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBheGlzUGFyYW1zID0ge1xuICAgICAgICAgICAgd2l0aE91dGVyVGljazogd2l0aE91dGVyVGljayxcbiAgICAgICAgICAgIHdpdGhvdXRUcmFuc2l0aW9uOiB3aXRob3V0VHJhbnNpdGlvbixcbiAgICAgICAgICAgIHRpY2tUZXh0Um90YXRlOiB3aXRob3V0Um90YXRlVGlja1RleHQgPyAwIDogY29uZmlnLmF4aXNfeV90aWNrX3JvdGF0ZVxuICAgICAgICB9LFxuICAgICAgICAgICAgYXhpcyA9IG5ldyB0aGlzLmludGVybmFsKHRoaXMsIGF4aXNQYXJhbXMpLmF4aXMuc2NhbGUoc2NhbGUpLm9yaWVudChvcmllbnQpLnRpY2tGb3JtYXQodGlja0Zvcm1hdCk7XG4gICAgICAgIGlmICgkJC5pc1RpbWVTZXJpZXNZKCkpIHtcbiAgICAgICAgICAgIGF4aXMudGlja3MoJCQuZDMudGltZVtjb25maWcuYXhpc195X3RpY2tfdGltZV92YWx1ZV0sIGNvbmZpZy5heGlzX3lfdGlja190aW1lX2ludGVydmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF4aXMudGlja1ZhbHVlcyh0aWNrVmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGMzX2F4aXNfZm4uZ2V0SWQgPSBmdW5jdGlvbiBnZXRJZChpZCkge1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5vd25lci5jb25maWc7XG4gICAgICAgIHJldHVybiBpZCBpbiBjb25maWcuZGF0YV9heGVzID8gY29uZmlnLmRhdGFfYXhlc1tpZF0gOiAneSc7XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLmdldFhBeGlzVGlja0Zvcm1hdCA9IGZ1bmN0aW9uIGdldFhBeGlzVGlja0Zvcm1hdCgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5vd25lcixcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIGZvcm1hdCA9ICQkLmlzVGltZVNlcmllcygpID8gJCQuZGVmYXVsdEF4aXNUaW1lRm9ybWF0IDogJCQuaXNDYXRlZ29yaXplZCgpID8gJCQuY2F0ZWdvcnlOYW1lIDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2IDwgMCA/IHYudG9GaXhlZCgwKSA6IHY7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjb25maWcuYXhpc194X3RpY2tfZm9ybWF0KSB7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjb25maWcuYXhpc194X3RpY2tfZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5heGlzX3hfdGlja19mb3JtYXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCQkLmlzVGltZVNlcmllcygpKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZnVuY3Rpb24gZm9ybWF0KGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGUgPyAkJC5heGlzVGltZUZvcm1hdChjb25maWcuYXhpc194X3RpY2tfZm9ybWF0KShkYXRlKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQuY2FsbCgkJCwgdik7XG4gICAgICAgIH0gOiBmb3JtYXQ7XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLmdldFRpY2tWYWx1ZXMgPSBmdW5jdGlvbiBnZXRUaWNrVmFsdWVzKHRpY2tWYWx1ZXMsIGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIHRpY2tWYWx1ZXMgPyB0aWNrVmFsdWVzIDogYXhpcyA/IGF4aXMudGlja1ZhbHVlcygpIDogdW5kZWZpbmVkO1xuICAgIH07XG4gICAgYzNfYXhpc19mbi5nZXRYQXhpc1RpY2tWYWx1ZXMgPSBmdW5jdGlvbiBnZXRYQXhpc1RpY2tWYWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRpY2tWYWx1ZXModGhpcy5vd25lci5jb25maWcuYXhpc194X3RpY2tfdmFsdWVzLCB0aGlzLm93bmVyLnhBeGlzKTtcbiAgICB9O1xuICAgIGMzX2F4aXNfZm4uZ2V0WUF4aXNUaWNrVmFsdWVzID0gZnVuY3Rpb24gZ2V0WUF4aXNUaWNrVmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUaWNrVmFsdWVzKHRoaXMub3duZXIuY29uZmlnLmF4aXNfeV90aWNrX3ZhbHVlcywgdGhpcy5vd25lci55QXhpcyk7XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLmdldFkyQXhpc1RpY2tWYWx1ZXMgPSBmdW5jdGlvbiBnZXRZMkF4aXNUaWNrVmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUaWNrVmFsdWVzKHRoaXMub3duZXIuY29uZmlnLmF4aXNfeTJfdGlja192YWx1ZXMsIHRoaXMub3duZXIueTJBeGlzKTtcbiAgICB9O1xuICAgIGMzX2F4aXNfZm4uZ2V0TGFiZWxPcHRpb25CeUF4aXNJZCA9IGZ1bmN0aW9uIGdldExhYmVsT3B0aW9uQnlBeGlzSWQoYXhpc0lkKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMub3duZXIsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBvcHRpb247XG4gICAgICAgIGlmIChheGlzSWQgPT09ICd5Jykge1xuICAgICAgICAgICAgb3B0aW9uID0gY29uZmlnLmF4aXNfeV9sYWJlbDtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzSWQgPT09ICd5MicpIHtcbiAgICAgICAgICAgIG9wdGlvbiA9IGNvbmZpZy5heGlzX3kyX2xhYmVsO1xuICAgICAgICB9IGVsc2UgaWYgKGF4aXNJZCA9PT0gJ3gnKSB7XG4gICAgICAgICAgICBvcHRpb24gPSBjb25maWcuYXhpc194X2xhYmVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb247XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLmdldExhYmVsVGV4dCA9IGZ1bmN0aW9uIGdldExhYmVsVGV4dChheGlzSWQpIHtcbiAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMuZ2V0TGFiZWxPcHRpb25CeUF4aXNJZChheGlzSWQpO1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcob3B0aW9uKSA/IG9wdGlvbiA6IG9wdGlvbiA/IG9wdGlvbi50ZXh0IDogbnVsbDtcbiAgICB9O1xuICAgIGMzX2F4aXNfZm4uc2V0TGFiZWxUZXh0ID0gZnVuY3Rpb24gc2V0TGFiZWxUZXh0KGF4aXNJZCwgdGV4dCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLm93bmVyLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgb3B0aW9uID0gdGhpcy5nZXRMYWJlbE9wdGlvbkJ5QXhpc0lkKGF4aXNJZCk7XG4gICAgICAgIGlmIChpc1N0cmluZyhvcHRpb24pKSB7XG4gICAgICAgICAgICBpZiAoYXhpc0lkID09PSAneScpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuYXhpc195X2xhYmVsID0gdGV4dDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXhpc0lkID09PSAneTInKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmF4aXNfeTJfbGFiZWwgPSB0ZXh0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChheGlzSWQgPT09ICd4Jykge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5heGlzX3hfbGFiZWwgPSB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbikge1xuICAgICAgICAgICAgb3B0aW9uLnRleHQgPSB0ZXh0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLmdldExhYmVsUG9zaXRpb24gPSBmdW5jdGlvbiBnZXRMYWJlbFBvc2l0aW9uKGF4aXNJZCwgZGVmYXVsdFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBvcHRpb24gPSB0aGlzLmdldExhYmVsT3B0aW9uQnlBeGlzSWQoYXhpc0lkKSxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gb3B0aW9uICYmICh0eXBlb2Ygb3B0aW9uID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvcHRpb24pKSA9PT0gJ29iamVjdCcgJiYgb3B0aW9uLnBvc2l0aW9uID8gb3B0aW9uLnBvc2l0aW9uIDogZGVmYXVsdFBvc2l0aW9uO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNJbm5lcjogcG9zaXRpb24uaW5kZXhPZignaW5uZXInKSA+PSAwLFxuICAgICAgICAgICAgaXNPdXRlcjogcG9zaXRpb24uaW5kZXhPZignb3V0ZXInKSA+PSAwLFxuICAgICAgICAgICAgaXNMZWZ0OiBwb3NpdGlvbi5pbmRleE9mKCdsZWZ0JykgPj0gMCxcbiAgICAgICAgICAgIGlzQ2VudGVyOiBwb3NpdGlvbi5pbmRleE9mKCdjZW50ZXInKSA+PSAwLFxuICAgICAgICAgICAgaXNSaWdodDogcG9zaXRpb24uaW5kZXhPZigncmlnaHQnKSA+PSAwLFxuICAgICAgICAgICAgaXNUb3A6IHBvc2l0aW9uLmluZGV4T2YoJ3RvcCcpID49IDAsXG4gICAgICAgICAgICBpc01pZGRsZTogcG9zaXRpb24uaW5kZXhPZignbWlkZGxlJykgPj0gMCxcbiAgICAgICAgICAgIGlzQm90dG9tOiBwb3NpdGlvbi5pbmRleE9mKCdib3R0b20nKSA+PSAwXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLmdldFhBeGlzTGFiZWxQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldFhBeGlzTGFiZWxQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGFiZWxQb3NpdGlvbigneCcsIHRoaXMub3duZXIuY29uZmlnLmF4aXNfcm90YXRlZCA/ICdpbm5lci10b3AnIDogJ2lubmVyLXJpZ2h0Jyk7XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLmdldFlBeGlzTGFiZWxQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldFlBeGlzTGFiZWxQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGFiZWxQb3NpdGlvbigneScsIHRoaXMub3duZXIuY29uZmlnLmF4aXNfcm90YXRlZCA/ICdpbm5lci1yaWdodCcgOiAnaW5uZXItdG9wJyk7XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLmdldFkyQXhpc0xhYmVsUG9zaXRpb24gPSBmdW5jdGlvbiBnZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYWJlbFBvc2l0aW9uKCd5MicsIHRoaXMub3duZXIuY29uZmlnLmF4aXNfcm90YXRlZCA/ICdpbm5lci1yaWdodCcgOiAnaW5uZXItdG9wJyk7XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLmdldExhYmVsUG9zaXRpb25CeUlkID0gZnVuY3Rpb24gZ2V0TGFiZWxQb3NpdGlvbkJ5SWQoaWQpIHtcbiAgICAgICAgcmV0dXJuIGlkID09PSAneTInID8gdGhpcy5nZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkgOiBpZCA9PT0gJ3knID8gdGhpcy5nZXRZQXhpc0xhYmVsUG9zaXRpb24oKSA6IHRoaXMuZ2V0WEF4aXNMYWJlbFBvc2l0aW9uKCk7XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLnRleHRGb3JYQXhpc0xhYmVsID0gZnVuY3Rpb24gdGV4dEZvclhBeGlzTGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExhYmVsVGV4dCgneCcpO1xuICAgIH07XG4gICAgYzNfYXhpc19mbi50ZXh0Rm9yWUF4aXNMYWJlbCA9IGZ1bmN0aW9uIHRleHRGb3JZQXhpc0xhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYWJlbFRleHQoJ3knKTtcbiAgICB9O1xuICAgIGMzX2F4aXNfZm4udGV4dEZvclkyQXhpc0xhYmVsID0gZnVuY3Rpb24gdGV4dEZvclkyQXhpc0xhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYWJlbFRleHQoJ3kyJyk7XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLnhGb3JBeGlzTGFiZWwgPSBmdW5jdGlvbiB4Rm9yQXhpc0xhYmVsKGZvckhvcml6b250YWwsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMub3duZXI7XG4gICAgICAgIGlmIChmb3JIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb24uaXNMZWZ0ID8gMCA6IHBvc2l0aW9uLmlzQ2VudGVyID8gJCQud2lkdGggLyAyIDogJCQud2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb24uaXNCb3R0b20gPyAtJCQuaGVpZ2h0IDogcG9zaXRpb24uaXNNaWRkbGUgPyAtJCQuaGVpZ2h0IC8gMiA6IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGMzX2F4aXNfZm4uZHhGb3JBeGlzTGFiZWwgPSBmdW5jdGlvbiBkeEZvckF4aXNMYWJlbChmb3JIb3Jpem9udGFsLCBwb3NpdGlvbikge1xuICAgICAgICBpZiAoZm9ySG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uLmlzTGVmdCA/IFwiMC41ZW1cIiA6IHBvc2l0aW9uLmlzUmlnaHQgPyBcIi0wLjVlbVwiIDogXCIwXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb24uaXNUb3AgPyBcIi0wLjVlbVwiIDogcG9zaXRpb24uaXNCb3R0b20gPyBcIjAuNWVtXCIgOiBcIjBcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgYzNfYXhpc19mbi50ZXh0QW5jaG9yRm9yQXhpc0xhYmVsID0gZnVuY3Rpb24gdGV4dEFuY2hvckZvckF4aXNMYWJlbChmb3JIb3Jpem9udGFsLCBwb3NpdGlvbikge1xuICAgICAgICBpZiAoZm9ySG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uLmlzTGVmdCA/ICdzdGFydCcgOiBwb3NpdGlvbi5pc0NlbnRlciA/ICdtaWRkbGUnIDogJ2VuZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb24uaXNCb3R0b20gPyAnc3RhcnQnIDogcG9zaXRpb24uaXNNaWRkbGUgPyAnbWlkZGxlJyA6ICdlbmQnO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLnhGb3JYQXhpc0xhYmVsID0gZnVuY3Rpb24geEZvclhBeGlzTGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnhGb3JBeGlzTGFiZWwoIXRoaXMub3duZXIuY29uZmlnLmF4aXNfcm90YXRlZCwgdGhpcy5nZXRYQXhpc0xhYmVsUG9zaXRpb24oKSk7XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLnhGb3JZQXhpc0xhYmVsID0gZnVuY3Rpb24geEZvcllBeGlzTGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnhGb3JBeGlzTGFiZWwodGhpcy5vd25lci5jb25maWcuYXhpc19yb3RhdGVkLCB0aGlzLmdldFlBeGlzTGFiZWxQb3NpdGlvbigpKTtcbiAgICB9O1xuICAgIGMzX2F4aXNfZm4ueEZvclkyQXhpc0xhYmVsID0gZnVuY3Rpb24geEZvclkyQXhpc0xhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy54Rm9yQXhpc0xhYmVsKHRoaXMub3duZXIuY29uZmlnLmF4aXNfcm90YXRlZCwgdGhpcy5nZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkpO1xuICAgIH07XG4gICAgYzNfYXhpc19mbi5keEZvclhBeGlzTGFiZWwgPSBmdW5jdGlvbiBkeEZvclhBeGlzTGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmR4Rm9yQXhpc0xhYmVsKCF0aGlzLm93bmVyLmNvbmZpZy5heGlzX3JvdGF0ZWQsIHRoaXMuZ2V0WEF4aXNMYWJlbFBvc2l0aW9uKCkpO1xuICAgIH07XG4gICAgYzNfYXhpc19mbi5keEZvcllBeGlzTGFiZWwgPSBmdW5jdGlvbiBkeEZvcllBeGlzTGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmR4Rm9yQXhpc0xhYmVsKHRoaXMub3duZXIuY29uZmlnLmF4aXNfcm90YXRlZCwgdGhpcy5nZXRZQXhpc0xhYmVsUG9zaXRpb24oKSk7XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLmR4Rm9yWTJBeGlzTGFiZWwgPSBmdW5jdGlvbiBkeEZvclkyQXhpc0xhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5keEZvckF4aXNMYWJlbCh0aGlzLm93bmVyLmNvbmZpZy5heGlzX3JvdGF0ZWQsIHRoaXMuZ2V0WTJBeGlzTGFiZWxQb3NpdGlvbigpKTtcbiAgICB9O1xuICAgIGMzX2F4aXNfZm4uZHlGb3JYQXhpc0xhYmVsID0gZnVuY3Rpb24gZHlGb3JYQXhpc0xhYmVsKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLm93bmVyLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFhBeGlzTGFiZWxQb3NpdGlvbigpO1xuICAgICAgICBpZiAoY29uZmlnLmF4aXNfcm90YXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uLmlzSW5uZXIgPyBcIjEuMmVtXCIgOiAtMjUgLSAoJCQuY29uZmlnLmF4aXNfeF9pbm5lciA/IDAgOiB0aGlzLmdldE1heFRpY2tXaWR0aCgneCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbi5pc0lubmVyID8gXCItMC41ZW1cIiA6IGNvbmZpZy5heGlzX3hfaGVpZ2h0ID8gY29uZmlnLmF4aXNfeF9oZWlnaHQgLSAxMCA6IFwiM2VtXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGMzX2F4aXNfZm4uZHlGb3JZQXhpc0xhYmVsID0gZnVuY3Rpb24gZHlGb3JZQXhpc0xhYmVsKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLm93bmVyLFxuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFlBeGlzTGFiZWxQb3NpdGlvbigpO1xuICAgICAgICBpZiAoJCQuY29uZmlnLmF4aXNfcm90YXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uLmlzSW5uZXIgPyBcIi0wLjVlbVwiIDogXCIzZW1cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbi5pc0lubmVyID8gXCIxLjJlbVwiIDogLTEwIC0gKCQkLmNvbmZpZy5heGlzX3lfaW5uZXIgPyAwIDogdGhpcy5nZXRNYXhUaWNrV2lkdGgoJ3knKSArIDEwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgYzNfYXhpc19mbi5keUZvclkyQXhpc0xhYmVsID0gZnVuY3Rpb24gZHlGb3JZMkF4aXNMYWJlbCgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5vd25lcixcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCk7XG4gICAgICAgIGlmICgkJC5jb25maWcuYXhpc19yb3RhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb24uaXNJbm5lciA/IFwiMS4yZW1cIiA6IFwiLTIuMmVtXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb24uaXNJbm5lciA/IFwiLTAuNWVtXCIgOiAxNSArICgkJC5jb25maWcuYXhpc195Ml9pbm5lciA/IDAgOiB0aGlzLmdldE1heFRpY2tXaWR0aCgneTInKSArIDE1KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgYzNfYXhpc19mbi50ZXh0QW5jaG9yRm9yWEF4aXNMYWJlbCA9IGZ1bmN0aW9uIHRleHRBbmNob3JGb3JYQXhpc0xhYmVsKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLm93bmVyO1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0QW5jaG9yRm9yQXhpc0xhYmVsKCEkJC5jb25maWcuYXhpc19yb3RhdGVkLCB0aGlzLmdldFhBeGlzTGFiZWxQb3NpdGlvbigpKTtcbiAgICB9O1xuICAgIGMzX2F4aXNfZm4udGV4dEFuY2hvckZvcllBeGlzTGFiZWwgPSBmdW5jdGlvbiB0ZXh0QW5jaG9yRm9yWUF4aXNMYWJlbCgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5vd25lcjtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dEFuY2hvckZvckF4aXNMYWJlbCgkJC5jb25maWcuYXhpc19yb3RhdGVkLCB0aGlzLmdldFlBeGlzTGFiZWxQb3NpdGlvbigpKTtcbiAgICB9O1xuICAgIGMzX2F4aXNfZm4udGV4dEFuY2hvckZvclkyQXhpc0xhYmVsID0gZnVuY3Rpb24gdGV4dEFuY2hvckZvclkyQXhpc0xhYmVsKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLm93bmVyO1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0QW5jaG9yRm9yQXhpc0xhYmVsKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQsIHRoaXMuZ2V0WTJBeGlzTGFiZWxQb3NpdGlvbigpKTtcbiAgICB9O1xuICAgIGMzX2F4aXNfZm4uZ2V0TWF4VGlja1dpZHRoID0gZnVuY3Rpb24gZ2V0TWF4VGlja1dpZHRoKGlkLCB3aXRob3V0UmVjb21wdXRlKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMub3duZXIsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBtYXhXaWR0aCA9IDAsXG4gICAgICAgICAgICB0YXJnZXRzVG9TaG93LFxuICAgICAgICAgICAgc2NhbGUsXG4gICAgICAgICAgICBheGlzLFxuICAgICAgICAgICAgZHVtbXksXG4gICAgICAgICAgICBzdmc7XG4gICAgICAgIGlmICh3aXRob3V0UmVjb21wdXRlICYmICQkLmN1cnJlbnRNYXhUaWNrV2lkdGhzW2lkXSkge1xuICAgICAgICAgICAgcmV0dXJuICQkLmN1cnJlbnRNYXhUaWNrV2lkdGhzW2lkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJCQuc3ZnKSB7XG4gICAgICAgICAgICB0YXJnZXRzVG9TaG93ID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpO1xuICAgICAgICAgICAgaWYgKGlkID09PSAneScpIHtcbiAgICAgICAgICAgICAgICBzY2FsZSA9ICQkLnkuY29weSgpLmRvbWFpbigkJC5nZXRZRG9tYWluKHRhcmdldHNUb1Nob3csICd5JykpO1xuICAgICAgICAgICAgICAgIGF4aXMgPSB0aGlzLmdldFlBeGlzKHNjYWxlLCAkJC55T3JpZW50LCBjb25maWcuYXhpc195X3RpY2tfZm9ybWF0LCAkJC55QXhpc1RpY2tWYWx1ZXMsIGZhbHNlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICd5MicpIHtcbiAgICAgICAgICAgICAgICBzY2FsZSA9ICQkLnkyLmNvcHkoKS5kb21haW4oJCQuZ2V0WURvbWFpbih0YXJnZXRzVG9TaG93LCAneTInKSk7XG4gICAgICAgICAgICAgICAgYXhpcyA9IHRoaXMuZ2V0WUF4aXMoc2NhbGUsICQkLnkyT3JpZW50LCBjb25maWcuYXhpc195Ml90aWNrX2Zvcm1hdCwgJCQueTJBeGlzVGlja1ZhbHVlcywgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2FsZSA9ICQkLnguY29weSgpLmRvbWFpbigkJC5nZXRYRG9tYWluKHRhcmdldHNUb1Nob3cpKTtcbiAgICAgICAgICAgICAgICBheGlzID0gdGhpcy5nZXRYQXhpcyhzY2FsZSwgJCQueE9yaWVudCwgJCQueEF4aXNUaWNrRm9ybWF0LCAkJC54QXhpc1RpY2tWYWx1ZXMsIGZhbHNlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVhBeGlzVGlja1ZhbHVlcyh0YXJnZXRzVG9TaG93LCBheGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGR1bW15ID0gJCQuZDMuc2VsZWN0KCdib2R5JykuYXBwZW5kKCdkaXYnKS5jbGFzc2VkKCdjMycsIHRydWUpO1xuICAgICAgICAgICAgc3ZnID0gZHVtbXkuYXBwZW5kKFwic3ZnXCIpLnN0eWxlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpLnN0eWxlKCdwb3NpdGlvbicsICdmaXhlZCcpLnN0eWxlKCd0b3AnLCAwKS5zdHlsZSgnbGVmdCcsIDApLCBzdmcuYXBwZW5kKCdnJykuY2FsbChheGlzKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkJC5kMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKCd0ZXh0JykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3ggPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF4V2lkdGggPCBib3gud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFdpZHRoID0gYm94LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZHVtbXkucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAkJC5jdXJyZW50TWF4VGlja1dpZHRoc1tpZF0gPSBtYXhXaWR0aCA8PSAwID8gJCQuY3VycmVudE1heFRpY2tXaWR0aHNbaWRdIDogbWF4V2lkdGg7XG4gICAgICAgIHJldHVybiAkJC5jdXJyZW50TWF4VGlja1dpZHRoc1tpZF07XG4gICAgfTtcblxuICAgIGMzX2F4aXNfZm4udXBkYXRlTGFiZWxzID0gZnVuY3Rpb24gdXBkYXRlTGFiZWxzKHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMub3duZXI7XG4gICAgICAgIHZhciBheGlzWExhYmVsID0gJCQubWFpbi5zZWxlY3QoJy4nICsgQ0xBU1MuYXhpc1ggKyAnIC4nICsgQ0xBU1MuYXhpc1hMYWJlbCksXG4gICAgICAgICAgICBheGlzWUxhYmVsID0gJCQubWFpbi5zZWxlY3QoJy4nICsgQ0xBU1MuYXhpc1kgKyAnIC4nICsgQ0xBU1MuYXhpc1lMYWJlbCksXG4gICAgICAgICAgICBheGlzWTJMYWJlbCA9ICQkLm1haW4uc2VsZWN0KCcuJyArIENMQVNTLmF4aXNZMiArICcgLicgKyBDTEFTUy5heGlzWTJMYWJlbCk7XG4gICAgICAgICh3aXRoVHJhbnNpdGlvbiA/IGF4aXNYTGFiZWwudHJhbnNpdGlvbigpIDogYXhpc1hMYWJlbCkuYXR0cihcInhcIiwgdGhpcy54Rm9yWEF4aXNMYWJlbC5iaW5kKHRoaXMpKS5hdHRyKFwiZHhcIiwgdGhpcy5keEZvclhBeGlzTGFiZWwuYmluZCh0aGlzKSkuYXR0cihcImR5XCIsIHRoaXMuZHlGb3JYQXhpc0xhYmVsLmJpbmQodGhpcykpLnRleHQodGhpcy50ZXh0Rm9yWEF4aXNMYWJlbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgKHdpdGhUcmFuc2l0aW9uID8gYXhpc1lMYWJlbC50cmFuc2l0aW9uKCkgOiBheGlzWUxhYmVsKS5hdHRyKFwieFwiLCB0aGlzLnhGb3JZQXhpc0xhYmVsLmJpbmQodGhpcykpLmF0dHIoXCJkeFwiLCB0aGlzLmR4Rm9yWUF4aXNMYWJlbC5iaW5kKHRoaXMpKS5hdHRyKFwiZHlcIiwgdGhpcy5keUZvcllBeGlzTGFiZWwuYmluZCh0aGlzKSkudGV4dCh0aGlzLnRleHRGb3JZQXhpc0xhYmVsLmJpbmQodGhpcykpO1xuICAgICAgICAod2l0aFRyYW5zaXRpb24gPyBheGlzWTJMYWJlbC50cmFuc2l0aW9uKCkgOiBheGlzWTJMYWJlbCkuYXR0cihcInhcIiwgdGhpcy54Rm9yWTJBeGlzTGFiZWwuYmluZCh0aGlzKSkuYXR0cihcImR4XCIsIHRoaXMuZHhGb3JZMkF4aXNMYWJlbC5iaW5kKHRoaXMpKS5hdHRyKFwiZHlcIiwgdGhpcy5keUZvclkyQXhpc0xhYmVsLmJpbmQodGhpcykpLnRleHQodGhpcy50ZXh0Rm9yWTJBeGlzTGFiZWwuYmluZCh0aGlzKSk7XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLmdldFBhZGRpbmcgPSBmdW5jdGlvbiBnZXRQYWRkaW5nKHBhZGRpbmcsIGtleSwgZGVmYXVsdFZhbHVlLCBkb21haW5MZW5ndGgpIHtcbiAgICAgICAgdmFyIHAgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcicgPyBwYWRkaW5nIDogcGFkZGluZ1trZXldO1xuICAgICAgICBpZiAoIWlzVmFsdWUocCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRpbmcudW5pdCA9PT0gJ3JhdGlvJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhZGRpbmdba2V5XSAqIGRvbWFpbkxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhc3N1bWUgcGFkZGluZyBpcyBwaXhlbHMgaWYgdW5pdCBpcyBub3Qgc3BlY2lmaWVkXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRQaXhlbHNUb0F4aXNQYWRkaW5nKHAsIGRvbWFpbkxlbmd0aCk7XG4gICAgfTtcbiAgICBjM19heGlzX2ZuLmNvbnZlcnRQaXhlbHNUb0F4aXNQYWRkaW5nID0gZnVuY3Rpb24gY29udmVydFBpeGVsc1RvQXhpc1BhZGRpbmcocGl4ZWxzLCBkb21haW5MZW5ndGgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5vd25lcixcbiAgICAgICAgICAgIGxlbmd0aCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQgPyAkJC53aWR0aCA6ICQkLmhlaWdodDtcbiAgICAgICAgcmV0dXJuIGRvbWFpbkxlbmd0aCAqIChwaXhlbHMgLyBsZW5ndGgpO1xuICAgIH07XG4gICAgYzNfYXhpc19mbi5nZW5lcmF0ZVRpY2tWYWx1ZXMgPSBmdW5jdGlvbiBnZW5lcmF0ZVRpY2tWYWx1ZXModmFsdWVzLCB0aWNrQ291bnQsIGZvclRpbWVTZXJpZXMpIHtcbiAgICAgICAgdmFyIHRpY2tWYWx1ZXMgPSB2YWx1ZXMsXG4gICAgICAgICAgICB0YXJnZXRDb3VudCxcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgY291bnQsXG4gICAgICAgICAgICBpbnRlcnZhbCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICB0aWNrVmFsdWU7XG4gICAgICAgIGlmICh0aWNrQ291bnQpIHtcbiAgICAgICAgICAgIHRhcmdldENvdW50ID0gaXNGdW5jdGlvbih0aWNrQ291bnQpID8gdGlja0NvdW50KCkgOiB0aWNrQ291bnQ7XG4gICAgICAgICAgICAvLyBjb21wdXRlIHRpY2tzIGFjY29yZGluZyB0byB0aWNrQ291bnRcbiAgICAgICAgICAgIGlmICh0YXJnZXRDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRpY2tWYWx1ZXMgPSBbdmFsdWVzWzBdXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0Q291bnQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICB0aWNrVmFsdWVzID0gW3ZhbHVlc1swXSwgdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldENvdW50ID4gMikge1xuICAgICAgICAgICAgICAgIGNvdW50ID0gdGFyZ2V0Q291bnQgLSAyO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdmFsdWVzWzBdO1xuICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSAoZW5kIC0gc3RhcnQpIC8gKGNvdW50ICsgMSk7XG4gICAgICAgICAgICAgICAgLy8gcmUtY29uc3RydWN0IHVuaXF1ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICB0aWNrVmFsdWVzID0gW3N0YXJ0XTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aWNrVmFsdWUgPSArc3RhcnQgKyBpbnRlcnZhbCAqIChpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRpY2tWYWx1ZXMucHVzaChmb3JUaW1lU2VyaWVzID8gbmV3IERhdGUodGlja1ZhbHVlKSA6IHRpY2tWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpY2tWYWx1ZXMucHVzaChlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZm9yVGltZVNlcmllcykge1xuICAgICAgICAgICAgdGlja1ZhbHVlcyA9IHRpY2tWYWx1ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aWNrVmFsdWVzO1xuICAgIH07XG4gICAgYzNfYXhpc19mbi5nZW5lcmF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24gZ2VuZXJhdGVUcmFuc2l0aW9ucyhkdXJhdGlvbikge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLm93bmVyLFxuICAgICAgICAgICAgYXhlcyA9ICQkLmF4ZXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBheGlzWDogZHVyYXRpb24gPyBheGVzLngudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKSA6IGF4ZXMueCxcbiAgICAgICAgICAgIGF4aXNZOiBkdXJhdGlvbiA/IGF4ZXMueS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pIDogYXhlcy55LFxuICAgICAgICAgICAgYXhpc1kyOiBkdXJhdGlvbiA/IGF4ZXMueTIudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKSA6IGF4ZXMueTIsXG4gICAgICAgICAgICBheGlzU3ViWDogZHVyYXRpb24gPyBheGVzLnN1YngudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKSA6IGF4ZXMuc3VieFxuICAgICAgICB9O1xuICAgIH07XG4gICAgYzNfYXhpc19mbi5yZWRyYXcgPSBmdW5jdGlvbiByZWRyYXcodHJhbnNpdGlvbnMsIGlzSGlkZGVuKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMub3duZXI7XG4gICAgICAgICQkLmF4ZXMueC5zdHlsZShcIm9wYWNpdHlcIiwgaXNIaWRkZW4gPyAwIDogMSk7XG4gICAgICAgICQkLmF4ZXMueS5zdHlsZShcIm9wYWNpdHlcIiwgaXNIaWRkZW4gPyAwIDogMSk7XG4gICAgICAgICQkLmF4ZXMueTIuc3R5bGUoXCJvcGFjaXR5XCIsIGlzSGlkZGVuID8gMCA6IDEpO1xuICAgICAgICAkJC5heGVzLnN1Ynguc3R5bGUoXCJvcGFjaXR5XCIsIGlzSGlkZGVuID8gMCA6IDEpO1xuICAgICAgICB0cmFuc2l0aW9ucy5heGlzWC5jYWxsKCQkLnhBeGlzKTtcbiAgICAgICAgdHJhbnNpdGlvbnMuYXhpc1kuY2FsbCgkJC55QXhpcyk7XG4gICAgICAgIHRyYW5zaXRpb25zLmF4aXNZMi5jYWxsKCQkLnkyQXhpcyk7XG4gICAgICAgIHRyYW5zaXRpb25zLmF4aXNTdWJYLmNhbGwoJCQuc3ViWEF4aXMpO1xuICAgIH07XG5cbiAgICB2YXIgYzMgPSB7IHZlcnNpb246IFwiMC40LjIzXCIgfTtcblxuICAgIHZhciBjM19jaGFydF9mbjtcbiAgICB2YXIgYzNfY2hhcnRfaW50ZXJuYWxfZm47XG5cbiAgICBmdW5jdGlvbiBDb21wb25lbnQob3duZXIsIGNvbXBvbmVudEtleSwgZm4pIHtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICBjMy5jaGFydC5pbnRlcm5hbFtjb21wb25lbnRLZXldID0gZm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ2hhcnQoY29uZmlnKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWwgPSBuZXcgQ2hhcnRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgJCQubG9hZENvbmZpZyhjb25maWcpO1xuXG4gICAgICAgICQkLmJlZm9yZUluaXQoY29uZmlnKTtcbiAgICAgICAgJCQuaW5pdCgpO1xuICAgICAgICAkJC5hZnRlckluaXQoY29uZmlnKTtcblxuICAgICAgICAvLyBiaW5kIFwidGhpc1wiIHRvIG5lc3RlZCBBUElcbiAgICAgICAgKGZ1bmN0aW9uIGJpbmRUaGlzKGZuLCB0YXJnZXQsIGFyZ1RoaXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGZuKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IGZuW2tleV0uYmluZChhcmdUaGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoZm5ba2V5XSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBiaW5kVGhpcyhmbltrZXldLCB0YXJnZXRba2V5XSwgYXJnVGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKGMzX2NoYXJ0X2ZuLCB0aGlzLCB0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDaGFydEludGVybmFsKGFwaSkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICAkJC5kMyA9IHdpbmRvdy5kMyA/IHdpbmRvdy5kMyA6IHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJyA/IHJlcXVpcmUoXCJkM1wiKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgJCQuYXBpID0gYXBpO1xuICAgICAgICAkJC5jb25maWcgPSAkJC5nZXREZWZhdWx0Q29uZmlnKCk7XG4gICAgICAgICQkLmRhdGEgPSB7fTtcbiAgICAgICAgJCQuY2FjaGUgPSB7fTtcbiAgICAgICAgJCQuYXhlcyA9IHt9O1xuICAgIH1cblxuICAgIGMzLmdlbmVyYXRlID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IENoYXJ0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIGMzLmNoYXJ0ID0ge1xuICAgICAgICBmbjogQ2hhcnQucHJvdG90eXBlLFxuICAgICAgICBpbnRlcm5hbDoge1xuICAgICAgICAgICAgZm46IENoYXJ0SW50ZXJuYWwucHJvdG90eXBlXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ZuID0gYzMuY2hhcnQuZm47XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4gPSBjMy5jaGFydC5pbnRlcm5hbC5mbjtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmJlZm9yZUluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNhbiBkbyBzb21ldGhpbmdcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmFmdGVySW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY2FuIGRvIHNvbWV0aGluZ1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcblxuICAgICAgICAkJC5pbml0UGFyYW1zKCk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5kYXRhX3VybCkge1xuICAgICAgICAgICAgJCQuY29udmVydFVybFRvRGF0YShjb25maWcuZGF0YV91cmwsIGNvbmZpZy5kYXRhX21pbWVUeXBlLCBjb25maWcuZGF0YV9oZWFkZXJzLCBjb25maWcuZGF0YV9rZXlzLCAkJC5pbml0V2l0aERhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5kYXRhX2pzb24pIHtcbiAgICAgICAgICAgICQkLmluaXRXaXRoRGF0YSgkJC5jb252ZXJ0SnNvblRvRGF0YShjb25maWcuZGF0YV9qc29uLCBjb25maWcuZGF0YV9rZXlzKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmRhdGFfcm93cykge1xuICAgICAgICAgICAgJCQuaW5pdFdpdGhEYXRhKCQkLmNvbnZlcnRSb3dzVG9EYXRhKGNvbmZpZy5kYXRhX3Jvd3MpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcuZGF0YV9jb2x1bW5zKSB7XG4gICAgICAgICAgICAkJC5pbml0V2l0aERhdGEoJCQuY29udmVydENvbHVtbnNUb0RhdGEoY29uZmlnLmRhdGFfY29sdW1ucykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ3VybCBvciBqc29uIG9yIHJvd3Mgb3IgY29sdW1ucyBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5pbml0UGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgZDMgPSAkJC5kMyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcblxuICAgICAgICAvLyBNRU1POiBjbGlwSWQgbmVlZHMgdG8gYmUgdW5pcXVlIGJlY2F1c2UgaXQgY29uZmxpY3RzIHdoZW4gbXVsdGlwbGUgY2hhcnRzIGV4aXN0XG4gICAgICAgICQkLmNsaXBJZCA9IFwiYzMtXCIgKyArbmV3IERhdGUoKSArICctY2xpcCcsICQkLmNsaXBJZEZvclhBeGlzID0gJCQuY2xpcElkICsgJy14YXhpcycsICQkLmNsaXBJZEZvcllBeGlzID0gJCQuY2xpcElkICsgJy15YXhpcycsICQkLmNsaXBJZEZvckdyaWQgPSAkJC5jbGlwSWQgKyAnLWdyaWQnLCAkJC5jbGlwSWRGb3JTdWJjaGFydCA9ICQkLmNsaXBJZCArICctc3ViY2hhcnQnLCAkJC5jbGlwUGF0aCA9ICQkLmdldENsaXBQYXRoKCQkLmNsaXBJZCksICQkLmNsaXBQYXRoRm9yWEF4aXMgPSAkJC5nZXRDbGlwUGF0aCgkJC5jbGlwSWRGb3JYQXhpcyksICQkLmNsaXBQYXRoRm9yWUF4aXMgPSAkJC5nZXRDbGlwUGF0aCgkJC5jbGlwSWRGb3JZQXhpcyk7XG4gICAgICAgICQkLmNsaXBQYXRoRm9yR3JpZCA9ICQkLmdldENsaXBQYXRoKCQkLmNsaXBJZEZvckdyaWQpLCAkJC5jbGlwUGF0aEZvclN1YmNoYXJ0ID0gJCQuZ2V0Q2xpcFBhdGgoJCQuY2xpcElkRm9yU3ViY2hhcnQpLCAkJC5kcmFnU3RhcnQgPSBudWxsO1xuICAgICAgICAkJC5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAkJC5mbG93aW5nID0gZmFsc2U7XG4gICAgICAgICQkLmNhbmNlbENsaWNrID0gZmFsc2U7XG4gICAgICAgICQkLm1vdXNlb3ZlciA9IGZhbHNlO1xuICAgICAgICAkJC50cmFuc2l0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgJCQuY29sb3IgPSAkJC5nZW5lcmF0ZUNvbG9yKCk7XG4gICAgICAgICQkLmxldmVsQ29sb3IgPSAkJC5nZW5lcmF0ZUxldmVsQ29sb3IoKTtcblxuICAgICAgICAkJC5kYXRhVGltZUZvcm1hdCA9IGNvbmZpZy5kYXRhX3hMb2NhbHRpbWUgPyBkMy50aW1lLmZvcm1hdCA6IGQzLnRpbWUuZm9ybWF0LnV0YztcbiAgICAgICAgJCQuYXhpc1RpbWVGb3JtYXQgPSBjb25maWcuYXhpc194X2xvY2FsdGltZSA/IGQzLnRpbWUuZm9ybWF0IDogZDMudGltZS5mb3JtYXQudXRjO1xuICAgICAgICAkJC5kZWZhdWx0QXhpc1RpbWVGb3JtYXQgPSAkJC5heGlzVGltZUZvcm1hdC5tdWx0aShbW1wiLiVMXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgfV0sIFtcIjolU1wiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQuZ2V0U2Vjb25kcygpO1xuICAgICAgICB9XSwgW1wiJUk6JU1cIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgfV0sIFtcIiVJICVwXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5nZXRIb3VycygpO1xuICAgICAgICB9XSwgW1wiJS1tLyUtZFwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQuZ2V0RGF5KCkgJiYgZC5nZXREYXRlKCkgIT09IDE7XG4gICAgICAgIH1dLCBbXCIlLW0vJS1kXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5nZXREYXRlKCkgIT09IDE7XG4gICAgICAgIH1dLCBbXCIlLW0vJS1kXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5nZXRNb250aCgpO1xuICAgICAgICB9XSwgW1wiJVkvJS1tLyUtZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfV1dKTtcblxuICAgICAgICAkJC5oaWRkZW5UYXJnZXRJZHMgPSBbXTtcbiAgICAgICAgJCQuaGlkZGVuTGVnZW5kSWRzID0gW107XG4gICAgICAgICQkLmZvY3VzZWRUYXJnZXRJZHMgPSBbXTtcbiAgICAgICAgJCQuZGVmb2N1c2VkVGFyZ2V0SWRzID0gW107XG5cbiAgICAgICAgJCQueE9yaWVudCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBjb25maWcuYXhpc194X2lubmVyID8gXCJyaWdodFwiIDogXCJsZWZ0XCIgOiBjb25maWcuYXhpc194X2lubmVyID8gXCJ0b3BcIiA6IFwiYm90dG9tXCI7XG4gICAgICAgICQkLnlPcmllbnQgPSBjb25maWcuYXhpc19yb3RhdGVkID8gY29uZmlnLmF4aXNfeV9pbm5lciA/IFwidG9wXCIgOiBcImJvdHRvbVwiIDogY29uZmlnLmF4aXNfeV9pbm5lciA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuICAgICAgICAkJC55Mk9yaWVudCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBjb25maWcuYXhpc195Ml9pbm5lciA/IFwiYm90dG9tXCIgOiBcInRvcFwiIDogY29uZmlnLmF4aXNfeTJfaW5uZXIgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICAgICAgJCQuc3ViWE9yaWVudCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcImxlZnRcIiA6IFwiYm90dG9tXCI7XG5cbiAgICAgICAgJCQuaXNMZWdlbmRSaWdodCA9IGNvbmZpZy5sZWdlbmRfcG9zaXRpb24gPT09ICdyaWdodCc7XG4gICAgICAgICQkLmlzTGVnZW5kSW5zZXQgPSBjb25maWcubGVnZW5kX3Bvc2l0aW9uID09PSAnaW5zZXQnO1xuICAgICAgICAkJC5pc0xlZ2VuZFRvcCA9IGNvbmZpZy5sZWdlbmRfaW5zZXRfYW5jaG9yID09PSAndG9wLWxlZnQnIHx8IGNvbmZpZy5sZWdlbmRfaW5zZXRfYW5jaG9yID09PSAndG9wLXJpZ2h0JztcbiAgICAgICAgJCQuaXNMZWdlbmRMZWZ0ID0gY29uZmlnLmxlZ2VuZF9pbnNldF9hbmNob3IgPT09ICd0b3AtbGVmdCcgfHwgY29uZmlnLmxlZ2VuZF9pbnNldF9hbmNob3IgPT09ICdib3R0b20tbGVmdCc7XG4gICAgICAgICQkLmxlZ2VuZFN0ZXAgPSAwO1xuICAgICAgICAkJC5sZWdlbmRJdGVtV2lkdGggPSAwO1xuICAgICAgICAkJC5sZWdlbmRJdGVtSGVpZ2h0ID0gMDtcblxuICAgICAgICAkJC5jdXJyZW50TWF4VGlja1dpZHRocyA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgeTI6IDBcbiAgICAgICAgfTtcblxuICAgICAgICAkJC5yb3RhdGVkX3BhZGRpbmdfbGVmdCA9IDMwO1xuICAgICAgICAkJC5yb3RhdGVkX3BhZGRpbmdfcmlnaHQgPSBjb25maWcuYXhpc19yb3RhdGVkICYmICFjb25maWcuYXhpc194X3Nob3cgPyAwIDogMzA7XG4gICAgICAgICQkLnJvdGF0ZWRfcGFkZGluZ190b3AgPSA1O1xuXG4gICAgICAgICQkLndpdGhvdXRGYWRlSW4gPSB7fTtcblxuICAgICAgICAkJC5pbnRlcnZhbEZvck9ic2VydmVJbnNlcnRlZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAkJC5heGVzLnN1YnggPSBkMy5zZWxlY3RBbGwoW10pOyAvLyBuZWVkcyB3aGVuIGV4Y2x1ZGluZyBzdWJjaGFydC5qc1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5pbml0Q2hhcnRFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdEJhcikge1xuICAgICAgICAgICAgdGhpcy5pbml0QmFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5pdExpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdExpbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbml0QXJjKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRBcmMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbml0R2F1Z2UpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdEdhdWdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5pdFRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdFRleHQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5pbml0V2l0aERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgZDMgPSAkJC5kMyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAgICAgdmFyIGRlZnMsXG4gICAgICAgICAgICBtYWluLFxuICAgICAgICAgICAgYmluZGluZyA9IHRydWU7XG5cbiAgICAgICAgJCQuYXhpcyA9IG5ldyBBeGlzKCQkKTtcblxuICAgICAgICBpZiAoJCQuaW5pdFBpZSkge1xuICAgICAgICAgICAgJCQuaW5pdFBpZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkJC5pbml0QnJ1c2gpIHtcbiAgICAgICAgICAgICQkLmluaXRCcnVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkJC5pbml0Wm9vbSkge1xuICAgICAgICAgICAgJCQuaW5pdFpvb20oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY29uZmlnLmJpbmR0bykge1xuICAgICAgICAgICAgJCQuc2VsZWN0Q2hhcnQgPSBkMy5zZWxlY3RBbGwoW10pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25maWcuYmluZHRvLm5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICQkLnNlbGVjdENoYXJ0ID0gY29uZmlnLmJpbmR0bztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQkLnNlbGVjdENoYXJ0ID0gZDMuc2VsZWN0KGNvbmZpZy5iaW5kdG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkJC5zZWxlY3RDaGFydC5lbXB0eSgpKSB7XG4gICAgICAgICAgICAkJC5zZWxlY3RDaGFydCA9IGQzLnNlbGVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSkuc3R5bGUoJ29wYWNpdHknLCAwKTtcbiAgICAgICAgICAgICQkLm9ic2VydmVJbnNlcnRlZCgkJC5zZWxlY3RDaGFydCk7XG4gICAgICAgICAgICBiaW5kaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgJCQuc2VsZWN0Q2hhcnQuaHRtbChcIlwiKS5jbGFzc2VkKFwiYzNcIiwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gSW5pdCBkYXRhIGFzIHRhcmdldHNcbiAgICAgICAgJCQuZGF0YS54cyA9IHt9O1xuICAgICAgICAkJC5kYXRhLnRhcmdldHMgPSAkJC5jb252ZXJ0RGF0YVRvVGFyZ2V0cyhkYXRhKTtcblxuICAgICAgICBpZiAoY29uZmlnLmRhdGFfZmlsdGVyKSB7XG4gICAgICAgICAgICAkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuZmlsdGVyKGNvbmZpZy5kYXRhX2ZpbHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGFyZ2V0cyB0byBoaWRlIGlmIG5lZWRlZFxuICAgICAgICBpZiAoY29uZmlnLmRhdGFfaGlkZSkge1xuICAgICAgICAgICAgJCQuYWRkSGlkZGVuVGFyZ2V0SWRzKGNvbmZpZy5kYXRhX2hpZGUgPT09IHRydWUgPyAkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpIDogY29uZmlnLmRhdGFfaGlkZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5sZWdlbmRfaGlkZSkge1xuICAgICAgICAgICAgJCQuYWRkSGlkZGVuTGVnZW5kSWRzKGNvbmZpZy5sZWdlbmRfaGlkZSA9PT0gdHJ1ZSA/ICQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cykgOiBjb25maWcubGVnZW5kX2hpZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdCBzaXplcyBhbmQgc2NhbGVzXG4gICAgICAgICQkLnVwZGF0ZVNpemVzKCk7XG4gICAgICAgICQkLnVwZGF0ZVNjYWxlcygpO1xuXG4gICAgICAgIC8vIFNldCBkb21haW5zIGZvciBlYWNoIHNjYWxlXG4gICAgICAgICQkLnguZG9tYWluKGQzLmV4dGVudCgkJC5nZXRYRG9tYWluKCQkLmRhdGEudGFyZ2V0cykpKTtcbiAgICAgICAgJCQueS5kb21haW4oJCQuZ2V0WURvbWFpbigkJC5kYXRhLnRhcmdldHMsICd5JykpO1xuICAgICAgICAkJC55Mi5kb21haW4oJCQuZ2V0WURvbWFpbigkJC5kYXRhLnRhcmdldHMsICd5MicpKTtcbiAgICAgICAgJCQuc3ViWC5kb21haW4oJCQueC5kb21haW4oKSk7XG4gICAgICAgICQkLnN1YlkuZG9tYWluKCQkLnkuZG9tYWluKCkpO1xuICAgICAgICAkJC5zdWJZMi5kb21haW4oJCQueTIuZG9tYWluKCkpO1xuXG4gICAgICAgIC8vIFNhdmUgb3JpZ2luYWwgeCBkb21haW4gZm9yIHpvb20gdXBkYXRlXG4gICAgICAgICQkLm9yZ1hEb21haW4gPSAkJC54LmRvbWFpbigpO1xuXG4gICAgICAgIC8vIFNldCBpbml0aWFsaXplZCBzY2FsZXMgdG8gYnJ1c2ggYW5kIHpvb21cbiAgICAgICAgaWYgKCQkLmJydXNoKSB7XG4gICAgICAgICAgICAkJC5icnVzaC5zY2FsZSgkJC5zdWJYKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnpvb21fZW5hYmxlZCkge1xuICAgICAgICAgICAgJCQuem9vbS5zY2FsZSgkJC54KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qLS0gQmFzaWMgRWxlbWVudHMgLS0qL1xuXG4gICAgICAgIC8vIERlZmluZSBzdmdzXG4gICAgICAgICQkLnN2ZyA9ICQkLnNlbGVjdENoYXJ0LmFwcGVuZChcInN2Z1wiKS5zdHlsZShcIm92ZXJmbG93XCIsIFwiaGlkZGVuXCIpLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5vbm1vdXNlb3Zlci5jYWxsKCQkKTtcbiAgICAgICAgfSkub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLm9ubW91c2VvdXQuY2FsbCgkJCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICgkJC5jb25maWcuc3ZnX2NsYXNzbmFtZSkge1xuICAgICAgICAgICAgJCQuc3ZnLmF0dHIoJ2NsYXNzJywgJCQuY29uZmlnLnN2Z19jbGFzc25hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGRlZnNcbiAgICAgICAgZGVmcyA9ICQkLnN2Zy5hcHBlbmQoXCJkZWZzXCIpO1xuICAgICAgICAkJC5jbGlwQ2hhcnQgPSAkJC5hcHBlbmRDbGlwKGRlZnMsICQkLmNsaXBJZCk7XG4gICAgICAgICQkLmNsaXBYQXhpcyA9ICQkLmFwcGVuZENsaXAoZGVmcywgJCQuY2xpcElkRm9yWEF4aXMpO1xuICAgICAgICAkJC5jbGlwWUF4aXMgPSAkJC5hcHBlbmRDbGlwKGRlZnMsICQkLmNsaXBJZEZvcllBeGlzKTtcbiAgICAgICAgJCQuY2xpcEdyaWQgPSAkJC5hcHBlbmRDbGlwKGRlZnMsICQkLmNsaXBJZEZvckdyaWQpO1xuICAgICAgICAkJC5jbGlwU3ViY2hhcnQgPSAkJC5hcHBlbmRDbGlwKGRlZnMsICQkLmNsaXBJZEZvclN1YmNoYXJ0KTtcbiAgICAgICAgJCQudXBkYXRlU3ZnU2l6ZSgpO1xuXG4gICAgICAgIC8vIERlZmluZSByZWdpb25zXG4gICAgICAgIG1haW4gPSAkJC5tYWluID0gJCQuc3ZnLmFwcGVuZChcImdcIikuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoJ21haW4nKSk7XG5cbiAgICAgICAgaWYgKCQkLmluaXRTdWJjaGFydCkge1xuICAgICAgICAgICAgJCQuaW5pdFN1YmNoYXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCQkLmluaXRUb29sdGlwKSB7XG4gICAgICAgICAgICAkJC5pbml0VG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkJC5pbml0TGVnZW5kKSB7XG4gICAgICAgICAgICAkJC5pbml0TGVnZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCQkLmluaXRUaXRsZSkge1xuICAgICAgICAgICAgJCQuaW5pdFRpdGxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKi0tIE1haW4gUmVnaW9uIC0tKi9cblxuICAgICAgICAvLyB0ZXh0IHdoZW4gZW1wdHlcbiAgICAgICAgbWFpbi5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy50ZXh0ICsgJyAnICsgQ0xBU1MuZW1wdHkpLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSAvLyBob3Jpem9udGFsIGNlbnRlcmluZyBvZiB0ZXh0IGF0IHggcG9zaXRpb24gaW4gYWxsIGJyb3dzZXJzLlxuICAgICAgICAuYXR0cihcImRvbWluYW50LWJhc2VsaW5lXCIsIFwibWlkZGxlXCIpOyAvLyB2ZXJ0aWNhbCBjZW50ZXJpbmcgb2YgdGV4dCBhdCB5IHBvc2l0aW9uIGluIGFsbCBicm93c2VycywgZXhjZXB0IElFLlxuXG4gICAgICAgIC8vIFJlZ2lvbnNcbiAgICAgICAgJCQuaW5pdFJlZ2lvbigpO1xuXG4gICAgICAgIC8vIEdyaWRzXG4gICAgICAgICQkLmluaXRHcmlkKCk7XG5cbiAgICAgICAgLy8gRGVmaW5lIGcgZm9yIGNoYXJ0IGFyZWFcbiAgICAgICAgbWFpbi5hcHBlbmQoJ2cnKS5hdHRyKFwiY2xpcC1wYXRoXCIsICQkLmNsaXBQYXRoKS5hdHRyKCdjbGFzcycsIENMQVNTLmNoYXJ0KTtcblxuICAgICAgICAvLyBHcmlkIGxpbmVzXG4gICAgICAgIGlmIChjb25maWcuZ3JpZF9saW5lc19mcm9udCkge1xuICAgICAgICAgICAgJCQuaW5pdEdyaWRMaW5lcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ292ZXIgd2hvbGUgd2l0aCByZWN0cyBmb3IgZXZlbnRzXG4gICAgICAgICQkLmluaXRFdmVudFJlY3QoKTtcblxuICAgICAgICAvLyBEZWZpbmUgZyBmb3IgY2hhcnRcbiAgICAgICAgJCQuaW5pdENoYXJ0RWxlbWVudHMoKTtcblxuICAgICAgICAvLyBpZiB6b29tIHByaXZpbGVnZWQsIGluc2VydCByZWN0IHRvIGZvcmVmcm9udFxuICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIG5lZWRlZD9cbiAgICAgICAgbWFpbi5pbnNlcnQoJ3JlY3QnLCBjb25maWcuem9vbV9wcml2aWxlZ2VkID8gbnVsbCA6ICdnLicgKyBDTEFTUy5yZWdpb25zKS5hdHRyKCdjbGFzcycsIENMQVNTLnpvb21SZWN0KS5hdHRyKCd3aWR0aCcsICQkLndpZHRoKS5hdHRyKCdoZWlnaHQnLCAkJC5oZWlnaHQpLnN0eWxlKCdvcGFjaXR5JywgMCkub24oXCJkYmxjbGljay56b29tXCIsIG51bGwpO1xuXG4gICAgICAgIC8vIFNldCBkZWZhdWx0IGV4dGVudCBpZiBkZWZpbmVkXG4gICAgICAgIGlmIChjb25maWcuYXhpc194X2V4dGVudCkge1xuICAgICAgICAgICAgJCQuYnJ1c2guZXh0ZW50KCQkLmdldERlZmF1bHRFeHRlbnQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgQXhpc1xuICAgICAgICAkJC5heGlzLmluaXQoKTtcblxuICAgICAgICAvLyBTZXQgdGFyZ2V0c1xuICAgICAgICAkJC51cGRhdGVUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cyk7XG5cbiAgICAgICAgLy8gRHJhdyB3aXRoIHRhcmdldHNcbiAgICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICQkLnVwZGF0ZURpbWVuc2lvbigpO1xuICAgICAgICAgICAgJCQuY29uZmlnLm9uaW5pdC5jYWxsKCQkKTtcbiAgICAgICAgICAgICQkLnJlZHJhdyh7XG4gICAgICAgICAgICAgICAgd2l0aFRyYW5zaXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdpdGhUcmFuc2Zvcm06IHRydWUsXG4gICAgICAgICAgICAgICAgd2l0aFVwZGF0ZVhEb21haW46IHRydWUsXG4gICAgICAgICAgICAgICAgd2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXG4gICAgICAgICAgICAgICAgd2l0aFRyYW5zaXRpb25Gb3JBeGlzOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCaW5kIHJlc2l6ZSBldmVudFxuICAgICAgICAkJC5iaW5kUmVzaXplKCk7XG5cbiAgICAgICAgLy8gZXhwb3J0IGVsZW1lbnQgb2YgdGhlIGNoYXJ0XG4gICAgICAgICQkLmFwaS5lbGVtZW50ID0gJCQuc2VsZWN0Q2hhcnQubm9kZSgpO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5zbW9vdGhMaW5lcyA9IGZ1bmN0aW9uIChlbCwgdHlwZSkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2dyaWQnKSB7XG4gICAgICAgICAgICBlbC5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZyA9ICQkLmQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBnLmF0dHIoJ3gxJyksXG4gICAgICAgICAgICAgICAgICAgIHgyID0gZy5hdHRyKCd4MicpLFxuICAgICAgICAgICAgICAgICAgICB5MSA9IGcuYXR0cigneTEnKSxcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBnLmF0dHIoJ3kyJyk7XG4gICAgICAgICAgICAgICAgZy5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgJ3gxJzogTWF0aC5jZWlsKHgxKSxcbiAgICAgICAgICAgICAgICAgICAgJ3gyJzogTWF0aC5jZWlsKHgyKSxcbiAgICAgICAgICAgICAgICAgICAgJ3kxJzogTWF0aC5jZWlsKHkxKSxcbiAgICAgICAgICAgICAgICAgICAgJ3kyJzogTWF0aC5jZWlsKHkyKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udXBkYXRlU2l6ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgICAgIHZhciBsZWdlbmRIZWlnaHQgPSAkJC5sZWdlbmQgPyAkJC5nZXRMZWdlbmRIZWlnaHQoKSA6IDAsXG4gICAgICAgICAgICBsZWdlbmRXaWR0aCA9ICQkLmxlZ2VuZCA/ICQkLmdldExlZ2VuZFdpZHRoKCkgOiAwLFxuICAgICAgICAgICAgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tID0gJCQuaXNMZWdlbmRSaWdodCB8fCAkJC5pc0xlZ2VuZEluc2V0ID8gMCA6IGxlZ2VuZEhlaWdodCxcbiAgICAgICAgICAgIGhhc0FyYyA9ICQkLmhhc0FyY1R5cGUoKSxcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0ID0gY29uZmlnLmF4aXNfcm90YXRlZCB8fCBoYXNBcmMgPyAwIDogJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoJ3gnKSxcbiAgICAgICAgICAgIHN1YmNoYXJ0SGVpZ2h0ID0gY29uZmlnLnN1YmNoYXJ0X3Nob3cgJiYgIWhhc0FyYyA/IGNvbmZpZy5zdWJjaGFydF9zaXplX2hlaWdodCArIHhBeGlzSGVpZ2h0IDogMDtcblxuICAgICAgICAkJC5jdXJyZW50V2lkdGggPSAkJC5nZXRDdXJyZW50V2lkdGgoKTtcbiAgICAgICAgJCQuY3VycmVudEhlaWdodCA9ICQkLmdldEN1cnJlbnRIZWlnaHQoKTtcblxuICAgICAgICAvLyBmb3IgbWFpblxuICAgICAgICAkJC5tYXJnaW4gPSBjb25maWcuYXhpc19yb3RhdGVkID8ge1xuICAgICAgICAgICAgdG9wOiAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodCgneTInKSArICQkLmdldEN1cnJlbnRQYWRkaW5nVG9wKCksXG4gICAgICAgICAgICByaWdodDogaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQoKSxcbiAgICAgICAgICAgIGJvdHRvbTogJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoJ3knKSArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSArICQkLmdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCksXG4gICAgICAgICAgICBsZWZ0OiBzdWJjaGFydEhlaWdodCArIChoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KCkpXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICB0b3A6IDQgKyAkJC5nZXRDdXJyZW50UGFkZGluZ1RvcCgpLCAvLyBmb3IgdG9wIHRpY2sgdGV4dFxuICAgICAgICAgICAgcmlnaHQ6IGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCksXG4gICAgICAgICAgICBib3R0b206IHhBeGlzSGVpZ2h0ICsgc3ViY2hhcnRIZWlnaHQgKyBsZWdlbmRIZWlnaHRGb3JCb3R0b20gKyAkJC5nZXRDdXJyZW50UGFkZGluZ0JvdHRvbSgpLFxuICAgICAgICAgICAgbGVmdDogaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCgpXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZm9yIHN1YmNoYXJ0XG4gICAgICAgICQkLm1hcmdpbjIgPSBjb25maWcuYXhpc19yb3RhdGVkID8ge1xuICAgICAgICAgICAgdG9wOiAkJC5tYXJnaW4udG9wLFxuICAgICAgICAgICAgcmlnaHQ6IE5hTixcbiAgICAgICAgICAgIGJvdHRvbTogMjAgKyBsZWdlbmRIZWlnaHRGb3JCb3R0b20sXG4gICAgICAgICAgICBsZWZ0OiAkJC5yb3RhdGVkX3BhZGRpbmdfbGVmdFxuICAgICAgICB9IDoge1xuICAgICAgICAgICAgdG9wOiAkJC5jdXJyZW50SGVpZ2h0IC0gc3ViY2hhcnRIZWlnaHQgLSBsZWdlbmRIZWlnaHRGb3JCb3R0b20sXG4gICAgICAgICAgICByaWdodDogTmFOLFxuICAgICAgICAgICAgYm90dG9tOiB4QXhpc0hlaWdodCArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQ6ICQkLm1hcmdpbi5sZWZ0XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZm9yIGxlZ2VuZFxuICAgICAgICAkJC5tYXJnaW4zID0ge1xuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgcmlnaHQ6IE5hTixcbiAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCQkLnVwZGF0ZVNpemVGb3JMZWdlbmQpIHtcbiAgICAgICAgICAgICQkLnVwZGF0ZVNpemVGb3JMZWdlbmQobGVnZW5kSGVpZ2h0LCBsZWdlbmRXaWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAkJC53aWR0aCA9ICQkLmN1cnJlbnRXaWR0aCAtICQkLm1hcmdpbi5sZWZ0IC0gJCQubWFyZ2luLnJpZ2h0O1xuICAgICAgICAkJC5oZWlnaHQgPSAkJC5jdXJyZW50SGVpZ2h0IC0gJCQubWFyZ2luLnRvcCAtICQkLm1hcmdpbi5ib3R0b207XG4gICAgICAgIGlmICgkJC53aWR0aCA8IDApIHtcbiAgICAgICAgICAgICQkLndpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJCQuaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgJCQuaGVpZ2h0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgICQkLndpZHRoMiA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAkJC5tYXJnaW4ubGVmdCAtICQkLnJvdGF0ZWRfcGFkZGluZ19sZWZ0IC0gJCQucm90YXRlZF9wYWRkaW5nX3JpZ2h0IDogJCQud2lkdGg7XG4gICAgICAgICQkLmhlaWdodDIgPSBjb25maWcuYXhpc19yb3RhdGVkID8gJCQuaGVpZ2h0IDogJCQuY3VycmVudEhlaWdodCAtICQkLm1hcmdpbjIudG9wIC0gJCQubWFyZ2luMi5ib3R0b207XG4gICAgICAgIGlmICgkJC53aWR0aDIgPCAwKSB7XG4gICAgICAgICAgICAkJC53aWR0aDIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkJC5oZWlnaHQyIDwgMCkge1xuICAgICAgICAgICAgJCQuaGVpZ2h0MiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3IgYXJjXG4gICAgICAgICQkLmFyY1dpZHRoID0gJCQud2lkdGggLSAoJCQuaXNMZWdlbmRSaWdodCA/IGxlZ2VuZFdpZHRoICsgMTAgOiAwKTtcbiAgICAgICAgJCQuYXJjSGVpZ2h0ID0gJCQuaGVpZ2h0IC0gKCQkLmlzTGVnZW5kUmlnaHQgPyAwIDogMTApO1xuICAgICAgICBpZiAoJCQuaGFzVHlwZSgnZ2F1Z2UnKSAmJiAhY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUpIHtcbiAgICAgICAgICAgICQkLmFyY0hlaWdodCArPSAkJC5oZWlnaHQgLSAkJC5nZXRHYXVnZUxhYmVsSGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCQkLnVwZGF0ZVJhZGl1cykge1xuICAgICAgICAgICAgJCQudXBkYXRlUmFkaXVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJCQuaXNMZWdlbmRSaWdodCAmJiBoYXNBcmMpIHtcbiAgICAgICAgICAgICQkLm1hcmdpbjMubGVmdCA9ICQkLmFyY1dpZHRoIC8gMiArICQkLnJhZGl1c0V4cGFuZGVkICogMS4xO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnVwZGF0ZVRhcmdldHMgPSBmdW5jdGlvbiAodGFyZ2V0cykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuXG4gICAgICAgIC8qLS0gTWFpbiAtLSovXG5cbiAgICAgICAgLy8tLSBUZXh0IC0tLy9cbiAgICAgICAgJCQudXBkYXRlVGFyZ2V0c0ZvclRleHQodGFyZ2V0cyk7XG5cbiAgICAgICAgLy8tLSBCYXIgLS0vL1xuICAgICAgICAkJC51cGRhdGVUYXJnZXRzRm9yQmFyKHRhcmdldHMpO1xuXG4gICAgICAgIC8vLS0gTGluZSAtLS8vXG4gICAgICAgICQkLnVwZGF0ZVRhcmdldHNGb3JMaW5lKHRhcmdldHMpO1xuXG4gICAgICAgIC8vLS0gQXJjIC0tLy9cbiAgICAgICAgaWYgKCQkLmhhc0FyY1R5cGUoKSAmJiAkJC51cGRhdGVUYXJnZXRzRm9yQXJjKSB7XG4gICAgICAgICAgICAkJC51cGRhdGVUYXJnZXRzRm9yQXJjKHRhcmdldHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyotLSBTdWIgLS0qL1xuXG4gICAgICAgIGlmICgkJC51cGRhdGVUYXJnZXRzRm9yU3ViY2hhcnQpIHtcbiAgICAgICAgICAgICQkLnVwZGF0ZVRhcmdldHNGb3JTdWJjaGFydCh0YXJnZXRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZhZGUtaW4gZWFjaCBjaGFydFxuICAgICAgICAkJC5zaG93VGFyZ2V0cygpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uc2hvd1RhcmdldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgICQkLnN2Zy5zZWxlY3RBbGwoJy4nICsgQ0xBU1MudGFyZ2V0KS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAkJC5pc1RhcmdldFRvU2hvdyhkLmlkKTtcbiAgICAgICAgfSkudHJhbnNpdGlvbigpLmR1cmF0aW9uKCQkLmNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKS5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnJlZHJhdyA9IGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2l0aW9ucykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgbWFpbiA9ICQkLm1haW4sXG4gICAgICAgICAgICBkMyA9ICQkLmQzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICAgICB2YXIgYXJlYUluZGljZXMgPSAkJC5nZXRTaGFwZUluZGljZXMoJCQuaXNBcmVhVHlwZSksXG4gICAgICAgICAgICBiYXJJbmRpY2VzID0gJCQuZ2V0U2hhcGVJbmRpY2VzKCQkLmlzQmFyVHlwZSksXG4gICAgICAgICAgICBsaW5lSW5kaWNlcyA9ICQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0xpbmVUeXBlKTtcbiAgICAgICAgdmFyIHdpdGhZLCB3aXRoU3ViY2hhcnQsIHdpdGhUcmFuc2l0aW9uLCB3aXRoVHJhbnNpdGlvbkZvckV4aXQsIHdpdGhUcmFuc2l0aW9uRm9yQXhpcywgd2l0aFRyYW5zZm9ybSwgd2l0aFVwZGF0ZVhEb21haW4sIHdpdGhVcGRhdGVPcmdYRG9tYWluLCB3aXRoVHJpbVhEb21haW4sIHdpdGhMZWdlbmQsIHdpdGhFdmVudFJlY3QsIHdpdGhEaW1lbnNpb24sIHdpdGhVcGRhdGVYQXhpcztcbiAgICAgICAgdmFyIGhpZGVBeGlzID0gJCQuaGFzQXJjVHlwZSgpO1xuICAgICAgICB2YXIgZHJhd0FyZWEsIGRyYXdCYXIsIGRyYXdMaW5lLCB4Rm9yVGV4dCwgeUZvclRleHQ7XG4gICAgICAgIHZhciBkdXJhdGlvbiwgZHVyYXRpb25Gb3JFeGl0LCBkdXJhdGlvbkZvckF4aXM7XG4gICAgICAgIHZhciB3YWl0Rm9yRHJhdywgZmxvdztcbiAgICAgICAgdmFyIHRhcmdldHNUb1Nob3cgPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cyksXG4gICAgICAgICAgICB0aWNrVmFsdWVzLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGludGVydmFsRm9yQ3VsbGluZyxcbiAgICAgICAgICAgIHhEb21haW5Gb3Jab29tO1xuICAgICAgICB2YXIgeHYgPSAkJC54di5iaW5kKCQkKSxcbiAgICAgICAgICAgIGN4LFxuICAgICAgICAgICAgY3k7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHdpdGhZID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFlcIiwgdHJ1ZSk7XG4gICAgICAgIHdpdGhTdWJjaGFydCA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhTdWJjaGFydFwiLCB0cnVlKTtcbiAgICAgICAgd2l0aFRyYW5zaXRpb24gPSBnZXRPcHRpb24ob3B0aW9ucywgXCJ3aXRoVHJhbnNpdGlvblwiLCB0cnVlKTtcbiAgICAgICAgd2l0aFRyYW5zZm9ybSA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2Zvcm1cIiwgZmFsc2UpO1xuICAgICAgICB3aXRoVXBkYXRlWERvbWFpbiA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhVcGRhdGVYRG9tYWluXCIsIGZhbHNlKTtcbiAgICAgICAgd2l0aFVwZGF0ZU9yZ1hEb21haW4gPSBnZXRPcHRpb24ob3B0aW9ucywgXCJ3aXRoVXBkYXRlT3JnWERvbWFpblwiLCBmYWxzZSk7XG4gICAgICAgIHdpdGhUcmltWERvbWFpbiA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmltWERvbWFpblwiLCB0cnVlKTtcbiAgICAgICAgd2l0aFVwZGF0ZVhBeGlzID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFVwZGF0ZVhBeGlzXCIsIHdpdGhVcGRhdGVYRG9tYWluKTtcbiAgICAgICAgd2l0aExlZ2VuZCA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhMZWdlbmRcIiwgZmFsc2UpO1xuICAgICAgICB3aXRoRXZlbnRSZWN0ID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aEV2ZW50UmVjdFwiLCB0cnVlKTtcbiAgICAgICAgd2l0aERpbWVuc2lvbiA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhEaW1lbnNpb25cIiwgdHJ1ZSk7XG4gICAgICAgIHdpdGhUcmFuc2l0aW9uRm9yRXhpdCA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2l0aW9uRm9yRXhpdFwiLCB3aXRoVHJhbnNpdGlvbik7XG4gICAgICAgIHdpdGhUcmFuc2l0aW9uRm9yQXhpcyA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2l0aW9uRm9yQXhpc1wiLCB3aXRoVHJhbnNpdGlvbik7XG5cbiAgICAgICAgZHVyYXRpb24gPSB3aXRoVHJhbnNpdGlvbiA/IGNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uIDogMDtcbiAgICAgICAgZHVyYXRpb25Gb3JFeGl0ID0gd2l0aFRyYW5zaXRpb25Gb3JFeGl0ID8gZHVyYXRpb24gOiAwO1xuICAgICAgICBkdXJhdGlvbkZvckF4aXMgPSB3aXRoVHJhbnNpdGlvbkZvckF4aXMgPyBkdXJhdGlvbiA6IDA7XG5cbiAgICAgICAgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucyB8fCAkJC5heGlzLmdlbmVyYXRlVHJhbnNpdGlvbnMoZHVyYXRpb25Gb3JBeGlzKTtcblxuICAgICAgICAvLyB1cGRhdGUgbGVnZW5kIGFuZCB0cmFuc2Zvcm0gZWFjaCBnXG4gICAgICAgIGlmICh3aXRoTGVnZW5kICYmIGNvbmZpZy5sZWdlbmRfc2hvdykge1xuICAgICAgICAgICAgJCQudXBkYXRlTGVnZW5kKCQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyksIG9wdGlvbnMsIHRyYW5zaXRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmICh3aXRoRGltZW5zaW9uKSB7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIHVwZGF0ZSBkaW1lbnNpb24gKGUuZy4gYXhpcy55LnRpY2sudmFsdWVzKSBiZWNhdXNlIHkgdGljayB2YWx1ZXMgc2hvdWxkIGNoYW5nZVxuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byB1cGRhdGUgYXhpcyBpbiBpdCBiZWNhdXNlIHRoZXkgd2lsbCBiZSB1cGRhdGVkIGluIHJlZHJhdygpXG4gICAgICAgICAgICAkJC51cGRhdGVEaW1lbnNpb24odHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNRU1POiBuZWVkZWQgZm9yIGdyaWRzIGNhbGN1bGF0aW9uXG4gICAgICAgIGlmICgkJC5pc0NhdGVnb3JpemVkKCkgJiYgdGFyZ2V0c1RvU2hvdy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICQkLnguZG9tYWluKFswLCAkJC5heGVzLnguc2VsZWN0QWxsKCcudGljaycpLnNpemUoKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldHNUb1Nob3cubGVuZ3RoKSB7XG4gICAgICAgICAgICAkJC51cGRhdGVYRG9tYWluKHRhcmdldHNUb1Nob3csIHdpdGhVcGRhdGVYRG9tYWluLCB3aXRoVXBkYXRlT3JnWERvbWFpbiwgd2l0aFRyaW1YRG9tYWluKTtcbiAgICAgICAgICAgIGlmICghY29uZmlnLmF4aXNfeF90aWNrX3ZhbHVlcykge1xuICAgICAgICAgICAgICAgIHRpY2tWYWx1ZXMgPSAkJC5heGlzLnVwZGF0ZVhBeGlzVGlja1ZhbHVlcyh0YXJnZXRzVG9TaG93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQkLnhBeGlzLnRpY2tWYWx1ZXMoW10pO1xuICAgICAgICAgICAgJCQuc3ViWEF4aXMudGlja1ZhbHVlcyhbXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLnpvb21fcmVzY2FsZSAmJiAhb3B0aW9ucy5mbG93KSB7XG4gICAgICAgICAgICB4RG9tYWluRm9yWm9vbSA9ICQkLngub3JnRG9tYWluKCk7XG4gICAgICAgIH1cblxuICAgICAgICAkJC55LmRvbWFpbigkJC5nZXRZRG9tYWluKHRhcmdldHNUb1Nob3csICd5JywgeERvbWFpbkZvclpvb20pKTtcbiAgICAgICAgJCQueTIuZG9tYWluKCQkLmdldFlEb21haW4odGFyZ2V0c1RvU2hvdywgJ3kyJywgeERvbWFpbkZvclpvb20pKTtcblxuICAgICAgICBpZiAoIWNvbmZpZy5heGlzX3lfdGlja192YWx1ZXMgJiYgY29uZmlnLmF4aXNfeV90aWNrX2NvdW50KSB7XG4gICAgICAgICAgICAkJC55QXhpcy50aWNrVmFsdWVzKCQkLmF4aXMuZ2VuZXJhdGVUaWNrVmFsdWVzKCQkLnkuZG9tYWluKCksIGNvbmZpZy5heGlzX3lfdGlja19jb3VudCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29uZmlnLmF4aXNfeTJfdGlja192YWx1ZXMgJiYgY29uZmlnLmF4aXNfeTJfdGlja19jb3VudCkge1xuICAgICAgICAgICAgJCQueTJBeGlzLnRpY2tWYWx1ZXMoJCQuYXhpcy5nZW5lcmF0ZVRpY2tWYWx1ZXMoJCQueTIuZG9tYWluKCksIGNvbmZpZy5heGlzX3kyX3RpY2tfY291bnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGF4ZXNcbiAgICAgICAgJCQuYXhpcy5yZWRyYXcodHJhbnNpdGlvbnMsIGhpZGVBeGlzKTtcblxuICAgICAgICAvLyBVcGRhdGUgYXhpcyBsYWJlbFxuICAgICAgICAkJC5heGlzLnVwZGF0ZUxhYmVscyh3aXRoVHJhbnNpdGlvbik7XG5cbiAgICAgICAgLy8gc2hvdy9oaWRlIGlmIG1hbnVhbCBjdWxsaW5nIG5lZWRlZFxuICAgICAgICBpZiAoKHdpdGhVcGRhdGVYRG9tYWluIHx8IHdpdGhVcGRhdGVYQXhpcykgJiYgdGFyZ2V0c1RvU2hvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuYXhpc194X3RpY2tfY3VsbGluZyAmJiB0aWNrVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IHRpY2tWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpY2tWYWx1ZXMubGVuZ3RoIC8gaSA8IGNvbmZpZy5heGlzX3hfdGlja19jdWxsaW5nX21heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxGb3JDdWxsaW5nID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQkLnN2Zy5zZWxlY3RBbGwoJy4nICsgQ0xBU1MuYXhpc1ggKyAnIC50aWNrIHRleHQnKS5lYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRpY2tWYWx1ZXMuaW5kZXhPZihlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnZGlzcGxheScsIGluZGV4ICUgaW50ZXJ2YWxGb3JDdWxsaW5nID8gJ25vbmUnIDogJ2Jsb2NrJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJCQuc3ZnLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5heGlzWCArICcgLnRpY2sgdGV4dCcpLnN0eWxlKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXR1cCBkcmF3ZXIgLSBNRU1POiB0aGVzZSBtdXN0IGJlIGNhbGxlZCBhZnRlciBheGlzIHVwZGF0ZWRcbiAgICAgICAgZHJhd0FyZWEgPSAkJC5nZW5lcmF0ZURyYXdBcmVhID8gJCQuZ2VuZXJhdGVEcmF3QXJlYShhcmVhSW5kaWNlcywgZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBkcmF3QmFyID0gJCQuZ2VuZXJhdGVEcmF3QmFyID8gJCQuZ2VuZXJhdGVEcmF3QmFyKGJhckluZGljZXMpIDogdW5kZWZpbmVkO1xuICAgICAgICBkcmF3TGluZSA9ICQkLmdlbmVyYXRlRHJhd0xpbmUgPyAkJC5nZW5lcmF0ZURyYXdMaW5lKGxpbmVJbmRpY2VzLCBmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHhGb3JUZXh0ID0gJCQuZ2VuZXJhdGVYWUZvclRleHQoYXJlYUluZGljZXMsIGJhckluZGljZXMsIGxpbmVJbmRpY2VzLCB0cnVlKTtcbiAgICAgICAgeUZvclRleHQgPSAkJC5nZW5lcmF0ZVhZRm9yVGV4dChhcmVhSW5kaWNlcywgYmFySW5kaWNlcywgbGluZUluZGljZXMsIGZhbHNlKTtcblxuICAgICAgICAvLyBVcGRhdGUgc3ViIGRvbWFpblxuICAgICAgICBpZiAod2l0aFkpIHtcbiAgICAgICAgICAgICQkLnN1YlkuZG9tYWluKCQkLmdldFlEb21haW4odGFyZ2V0c1RvU2hvdywgJ3knKSk7XG4gICAgICAgICAgICAkJC5zdWJZMi5kb21haW4oJCQuZ2V0WURvbWFpbih0YXJnZXRzVG9TaG93LCAneTInKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB4Z3JpZCBmb2N1c1xuICAgICAgICAkJC51cGRhdGVYZ3JpZEZvY3VzKCk7XG5cbiAgICAgICAgLy8gRGF0YSBlbXB0eSBsYWJlbCBwb3NpdGlvbmluZyBhbmQgdGV4dC5cbiAgICAgICAgbWFpbi5zZWxlY3QoXCJ0ZXh0LlwiICsgQ0xBU1MudGV4dCArICcuJyArIENMQVNTLmVtcHR5KS5hdHRyKFwieFwiLCAkJC53aWR0aCAvIDIpLmF0dHIoXCJ5XCIsICQkLmhlaWdodCAvIDIpLnRleHQoY29uZmlnLmRhdGFfZW1wdHlfbGFiZWxfdGV4dCkudHJhbnNpdGlvbigpLnN0eWxlKCdvcGFjaXR5JywgdGFyZ2V0c1RvU2hvdy5sZW5ndGggPyAwIDogMSk7XG5cbiAgICAgICAgLy8gZ3JpZFxuICAgICAgICAkJC51cGRhdGVHcmlkKGR1cmF0aW9uKTtcblxuICAgICAgICAvLyByZWN0IGZvciByZWdpb25zXG4gICAgICAgICQkLnVwZGF0ZVJlZ2lvbihkdXJhdGlvbik7XG5cbiAgICAgICAgLy8gYmFyc1xuICAgICAgICAkJC51cGRhdGVCYXIoZHVyYXRpb25Gb3JFeGl0KTtcblxuICAgICAgICAvLyBsaW5lcywgYXJlYXMgYW5kIGNyaWNsZXNcbiAgICAgICAgJCQudXBkYXRlTGluZShkdXJhdGlvbkZvckV4aXQpO1xuICAgICAgICAkJC51cGRhdGVBcmVhKGR1cmF0aW9uRm9yRXhpdCk7XG4gICAgICAgICQkLnVwZGF0ZUNpcmNsZSgpO1xuXG4gICAgICAgIC8vIHRleHRcbiAgICAgICAgaWYgKCQkLmhhc0RhdGFMYWJlbCgpKSB7XG4gICAgICAgICAgICAkJC51cGRhdGVUZXh0KGR1cmF0aW9uRm9yRXhpdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aXRsZVxuICAgICAgICBpZiAoJCQucmVkcmF3VGl0bGUpIHtcbiAgICAgICAgICAgICQkLnJlZHJhd1RpdGxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcmNcbiAgICAgICAgaWYgKCQkLnJlZHJhd0FyYykge1xuICAgICAgICAgICAgJCQucmVkcmF3QXJjKGR1cmF0aW9uLCBkdXJhdGlvbkZvckV4aXQsIHdpdGhUcmFuc2Zvcm0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3ViY2hhcnRcbiAgICAgICAgaWYgKCQkLnJlZHJhd1N1YmNoYXJ0KSB7XG4gICAgICAgICAgICAkJC5yZWRyYXdTdWJjaGFydCh3aXRoU3ViY2hhcnQsIHRyYW5zaXRpb25zLCBkdXJhdGlvbiwgZHVyYXRpb25Gb3JFeGl0LCBhcmVhSW5kaWNlcywgYmFySW5kaWNlcywgbGluZUluZGljZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2lyY2xlcyBmb3Igc2VsZWN0XG4gICAgICAgIG1haW4uc2VsZWN0QWxsKCcuJyArIENMQVNTLnNlbGVjdGVkQ2lyY2xlcykuZmlsdGVyKCQkLmlzQmFyVHlwZS5iaW5kKCQkKSkuc2VsZWN0QWxsKCdjaXJjbGUnKS5yZW1vdmUoKTtcblxuICAgICAgICAvLyBldmVudCByZWN0cyB3aWxsIHJlZHJhd24gd2hlbiBmbG93IGNhbGxlZFxuICAgICAgICBpZiAoY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQgJiYgIW9wdGlvbnMuZmxvdyAmJiB3aXRoRXZlbnRSZWN0KSB7XG4gICAgICAgICAgICAkJC5yZWRyYXdFdmVudFJlY3QoKTtcbiAgICAgICAgICAgIGlmICgkJC51cGRhdGVab29tKSB7XG4gICAgICAgICAgICAgICAgJCQudXBkYXRlWm9vbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIGNpcmNsZVkgYmFzZWQgb24gdXBkYXRlZCBwYXJhbWV0ZXJzXG4gICAgICAgICQkLnVwZGF0ZUNpcmNsZVkoKTtcblxuICAgICAgICAvLyBnZW5lcmF0ZSBjaXJjbGUgeC95IGZ1bmN0aW9ucyBkZXBlbmRpbmcgb24gdXBkYXRlZCBwYXJhbXNcbiAgICAgICAgY3ggPSAoJCQuY29uZmlnLmF4aXNfcm90YXRlZCA/ICQkLmNpcmNsZVkgOiAkJC5jaXJjbGVYKS5iaW5kKCQkKTtcbiAgICAgICAgY3kgPSAoJCQuY29uZmlnLmF4aXNfcm90YXRlZCA/ICQkLmNpcmNsZVggOiAkJC5jaXJjbGVZKS5iaW5kKCQkKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5mbG93KSB7XG4gICAgICAgICAgICBmbG93ID0gJCQuZ2VuZXJhdGVGbG93KHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzOiB0YXJnZXRzVG9TaG93LFxuICAgICAgICAgICAgICAgIGZsb3c6IG9wdGlvbnMuZmxvdyxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5mbG93LmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIGRyYXdCYXI6IGRyYXdCYXIsXG4gICAgICAgICAgICAgICAgZHJhd0xpbmU6IGRyYXdMaW5lLFxuICAgICAgICAgICAgICAgIGRyYXdBcmVhOiBkcmF3QXJlYSxcbiAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgIHh2OiB4dixcbiAgICAgICAgICAgICAgICB4Rm9yVGV4dDogeEZvclRleHQsXG4gICAgICAgICAgICAgICAgeUZvclRleHQ6IHlGb3JUZXh0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoZHVyYXRpb24gfHwgZmxvdykgJiYgJCQuaXNUYWJWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdXNlIHRyYW5zaXRpb24gaWYgdGFiIHZpc2libGUuIFNlZSAjOTM4LlxuICAgICAgICAgICAgLy8gdHJhbnNpdGlvbiBzaG91bGQgYmUgZGVyaXZlZCBmcm9tIG9uZSB0cmFuc2l0aW9uXG4gICAgICAgICAgICBkMy50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uc1RvV2FpdCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVkcmF3IGFuZCBnYXRoZXIgdHJhbnNpdGlvbnNcbiAgICAgICAgICAgICAgICBbJCQucmVkcmF3QmFyKGRyYXdCYXIsIHRydWUpLCAkJC5yZWRyYXdMaW5lKGRyYXdMaW5lLCB0cnVlKSwgJCQucmVkcmF3QXJlYShkcmF3QXJlYSwgdHJ1ZSksICQkLnJlZHJhd0NpcmNsZShjeCwgY3ksIHRydWUpLCAkJC5yZWRyYXdUZXh0KHhGb3JUZXh0LCB5Rm9yVGV4dCwgb3B0aW9ucy5mbG93LCB0cnVlKSwgJCQucmVkcmF3UmVnaW9uKHRydWUpLCAkJC5yZWRyYXdHcmlkKHRydWUpXS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFuc2l0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uc1RvV2FpdC5wdXNoKHRyYW5zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIGVuZCBvZiB0cmFuc2l0aW9ucyB0byBjYWxsIGZsb3cgYW5kIG9ucmVuZGVyZWQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB3YWl0Rm9yRHJhdyA9ICQkLmdlbmVyYXRlV2FpdCgpO1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zVG9XYWl0LmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FpdEZvckRyYXcuYWRkKHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkuY2FsbCh3YWl0Rm9yRHJhdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChmbG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZsb3coKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5vbnJlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5vbnJlbmRlcmVkLmNhbGwoJCQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJCQucmVkcmF3QmFyKGRyYXdCYXIpO1xuICAgICAgICAgICAgJCQucmVkcmF3TGluZShkcmF3TGluZSk7XG4gICAgICAgICAgICAkJC5yZWRyYXdBcmVhKGRyYXdBcmVhKTtcbiAgICAgICAgICAgICQkLnJlZHJhd0NpcmNsZShjeCwgY3kpO1xuICAgICAgICAgICAgJCQucmVkcmF3VGV4dCh4Rm9yVGV4dCwgeUZvclRleHQsIG9wdGlvbnMuZmxvdyk7XG4gICAgICAgICAgICAkJC5yZWRyYXdSZWdpb24oKTtcbiAgICAgICAgICAgICQkLnJlZHJhd0dyaWQoKTtcbiAgICAgICAgICAgIGlmIChjb25maWcub25yZW5kZXJlZCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5vbnJlbmRlcmVkLmNhbGwoJCQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIGZhZGVpbiBjb25kaXRpb25cbiAgICAgICAgJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgJCQud2l0aG91dEZhZGVJbltpZF0gPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udXBkYXRlQW5kUmVkcmF3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIHRyYW5zaXRpb25zO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgLy8gc2FtZSB3aXRoIHJlZHJhd1xuICAgICAgICBvcHRpb25zLndpdGhUcmFuc2l0aW9uID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFRyYW5zaXRpb25cIiwgdHJ1ZSk7XG4gICAgICAgIG9wdGlvbnMud2l0aFRyYW5zZm9ybSA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2Zvcm1cIiwgZmFsc2UpO1xuICAgICAgICBvcHRpb25zLndpdGhMZWdlbmQgPSBnZXRPcHRpb24ob3B0aW9ucywgXCJ3aXRoTGVnZW5kXCIsIGZhbHNlKTtcbiAgICAgICAgLy8gTk9UIHNhbWUgd2l0aCByZWRyYXdcbiAgICAgICAgb3B0aW9ucy53aXRoVXBkYXRlWERvbWFpbiA9IHRydWU7XG4gICAgICAgIG9wdGlvbnMud2l0aFVwZGF0ZU9yZ1hEb21haW4gPSB0cnVlO1xuICAgICAgICBvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yRXhpdCA9IGZhbHNlO1xuICAgICAgICBvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm1cIiwgb3B0aW9ucy53aXRoVHJhbnNpdGlvbik7XG4gICAgICAgIC8vIE1FTU86IHRoaXMgbmVlZHMgdG8gYmUgY2FsbGVkIGJlZm9yZSB1cGRhdGVMZWdlbmQgYW5kIGl0IG1lYW5zIHRoaXMgQUxXQVlTIG5lZWRzIHRvIGJlIGNhbGxlZClcbiAgICAgICAgJCQudXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgLy8gTUVNTzogY2FsbGVkIGluIHVwZGF0ZUxlZ2VuZCBpbiByZWRyYXcgaWYgd2l0aExlZ2VuZFxuICAgICAgICBpZiAoIShvcHRpb25zLndpdGhMZWdlbmQgJiYgY29uZmlnLmxlZ2VuZF9zaG93KSkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbnMgPSAkJC5heGlzLmdlbmVyYXRlVHJhbnNpdGlvbnMob3B0aW9ucy53aXRoVHJhbnNpdGlvbkZvckF4aXMgPyBjb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbiA6IDApO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHNjYWxlc1xuICAgICAgICAgICAgJCQudXBkYXRlU2NhbGVzKCk7XG4gICAgICAgICAgICAkJC51cGRhdGVTdmdTaXplKCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgZyBwb3NpdGlvbnNcbiAgICAgICAgICAgICQkLnRyYW5zZm9ybUFsbChvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtLCB0cmFuc2l0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRHJhdyB3aXRoIG5ldyBzaXplcyAmIHNjYWxlc1xuICAgICAgICAkJC5yZWRyYXcob3B0aW9ucywgdHJhbnNpdGlvbnMpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ucmVkcmF3V2l0aG91dFJlc2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVkcmF3KHtcbiAgICAgICAgICAgIHdpdGhZOiBmYWxzZSxcbiAgICAgICAgICAgIHdpdGhTdWJjaGFydDogZmFsc2UsXG4gICAgICAgICAgICB3aXRoRXZlbnRSZWN0OiBmYWxzZSxcbiAgICAgICAgICAgIHdpdGhUcmFuc2l0aW9uRm9yQXhpczogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmlzVGltZVNlcmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmF4aXNfeF90eXBlID09PSAndGltZXNlcmllcyc7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5pc0NhdGVnb3JpemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuYXhpc194X3R5cGUuaW5kZXhPZignY2F0ZWdvcicpID49IDA7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5pc0N1c3RvbVggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgICAgIHJldHVybiAhJCQuaXNUaW1lU2VyaWVzKCkgJiYgKGNvbmZpZy5kYXRhX3ggfHwgbm90RW1wdHkoY29uZmlnLmRhdGFfeHMpKTtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaXNUaW1lU2VyaWVzWSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmF4aXNfeV90eXBlID09PSAndGltZXNlcmllcyc7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldFRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5O1xuICAgICAgICBpZiAodGFyZ2V0ID09PSAnbWFpbicpIHtcbiAgICAgICAgICAgIHggPSBhc0hhbGZQaXhlbCgkJC5tYXJnaW4ubGVmdCk7XG4gICAgICAgICAgICB5ID0gYXNIYWxmUGl4ZWwoJCQubWFyZ2luLnRvcCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ID09PSAnY29udGV4dCcpIHtcbiAgICAgICAgICAgIHggPSBhc0hhbGZQaXhlbCgkJC5tYXJnaW4yLmxlZnQpO1xuICAgICAgICAgICAgeSA9IGFzSGFsZlBpeGVsKCQkLm1hcmdpbjIudG9wKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgPT09ICdsZWdlbmQnKSB7XG4gICAgICAgICAgICB4ID0gJCQubWFyZ2luMy5sZWZ0O1xuICAgICAgICAgICAgeSA9ICQkLm1hcmdpbjMudG9wO1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCA9PT0gJ3gnKSB7XG4gICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgIHkgPSBjb25maWcuYXhpc19yb3RhdGVkID8gMCA6ICQkLmhlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgPT09ICd5Jykge1xuICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICB5ID0gY29uZmlnLmF4aXNfcm90YXRlZCA/ICQkLmhlaWdodCA6IDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ID09PSAneTInKSB7XG4gICAgICAgICAgICB4ID0gY29uZmlnLmF4aXNfcm90YXRlZCA/IDAgOiAkJC53aWR0aDtcbiAgICAgICAgICAgIHkgPSBjb25maWcuYXhpc19yb3RhdGVkID8gMSA6IDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ID09PSAnc3VieCcpIHtcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgeSA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAwIDogJCQuaGVpZ2h0MjtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgPT09ICdhcmMnKSB7XG4gICAgICAgICAgICB4ID0gJCQuYXJjV2lkdGggLyAyO1xuICAgICAgICAgICAgeSA9ICQkLmFyY0hlaWdodCAvIDIgLSAoJCQuaGFzVHlwZSgnZ2F1Z2UnKSA/IDYgOiAwKTsgLy8gdG8gcHJldmVudCB3cm9uZyBkaXNwbGF5IG9mIG1pbiBhbmQgbWF4IGxhYmVsXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgeCArIFwiLFwiICsgeSArIFwiKVwiO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaW5pdGlhbE9wYWNpdHkgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC52YWx1ZSAhPT0gbnVsbCAmJiB0aGlzLndpdGhvdXRGYWRlSW5bZC5pZF0gPyAxIDogMDtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmluaXRpYWxPcGFjaXR5Rm9yQ2lyY2xlID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQudmFsdWUgIT09IG51bGwgJiYgdGhpcy53aXRob3V0RmFkZUluW2QuaWRdID8gdGhpcy5vcGFjaXR5Rm9yQ2lyY2xlKGQpIDogMDtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLm9wYWNpdHlGb3JDaXJjbGUgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgaXNQb2ludFNob3VsZEJlU2hvd24gPSBpc0Z1bmN0aW9uKHRoaXMuY29uZmlnLnBvaW50X3Nob3cpID8gdGhpcy5jb25maWcucG9pbnRfc2hvdyhkKSA6IHRoaXMuY29uZmlnLnBvaW50X3Nob3c7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gaXNQb2ludFNob3VsZEJlU2hvd24gPyAxIDogMDtcbiAgICAgICAgcmV0dXJuIGlzVmFsdWUoZC52YWx1ZSkgPyB0aGlzLmlzU2NhdHRlclR5cGUoZCkgPyAwLjUgOiBvcGFjaXR5IDogMDtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLm9wYWNpdHlGb3JUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNEYXRhTGFiZWwoKSA/IDEgOiAwO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ueHggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZCA/IHRoaXMueChkLngpIDogbnVsbDtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnh2ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIHZhbHVlID0gZC52YWx1ZTtcbiAgICAgICAgaWYgKCQkLmlzVGltZVNlcmllcygpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICQkLnBhcnNlRGF0ZShkLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmICgkJC5pc0NhdGVnb3JpemVkKCkgJiYgdHlwZW9mIGQudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICQkLmNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5pbmRleE9mKGQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoJCQueCh2YWx1ZSkpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ueXYgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgeVNjYWxlID0gZC5heGlzICYmIGQuYXhpcyA9PT0gJ3kyJyA/ICQkLnkyIDogJCQueTtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh5U2NhbGUoZC52YWx1ZSkpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uc3VieHggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZCA/IHRoaXMuc3ViWChkLngpIDogbnVsbDtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udHJhbnNmb3JtTWFpbiA9IGZ1bmN0aW9uICh3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIHhBeGlzLFxuICAgICAgICAgICAgeUF4aXMsXG4gICAgICAgICAgICB5MkF4aXM7XG4gICAgICAgIGlmICh0cmFuc2l0aW9ucyAmJiB0cmFuc2l0aW9ucy5heGlzWCkge1xuICAgICAgICAgICAgeEF4aXMgPSB0cmFuc2l0aW9ucy5heGlzWDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhBeGlzID0gJCQubWFpbi5zZWxlY3QoJy4nICsgQ0xBU1MuYXhpc1gpO1xuICAgICAgICAgICAgaWYgKHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgeEF4aXMgPSB4QXhpcy50cmFuc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zaXRpb25zICYmIHRyYW5zaXRpb25zLmF4aXNZKSB7XG4gICAgICAgICAgICB5QXhpcyA9IHRyYW5zaXRpb25zLmF4aXNZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeUF4aXMgPSAkJC5tYWluLnNlbGVjdCgnLicgKyBDTEFTUy5heGlzWSk7XG4gICAgICAgICAgICBpZiAod2l0aFRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB5QXhpcyA9IHlBeGlzLnRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1kyKSB7XG4gICAgICAgICAgICB5MkF4aXMgPSB0cmFuc2l0aW9ucy5heGlzWTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5MkF4aXMgPSAkJC5tYWluLnNlbGVjdCgnLicgKyBDTEFTUy5heGlzWTIpO1xuICAgICAgICAgICAgaWYgKHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgeTJBeGlzID0geTJBeGlzLnRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAod2l0aFRyYW5zaXRpb24gPyAkJC5tYWluLnRyYW5zaXRpb24oKSA6ICQkLm1haW4pLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKCdtYWluJykpO1xuICAgICAgICB4QXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZSgneCcpKTtcbiAgICAgICAgeUF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoJ3knKSk7XG4gICAgICAgIHkyQXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZSgneTInKSk7XG4gICAgICAgICQkLm1haW4uc2VsZWN0KCcuJyArIENMQVNTLmNoYXJ0QXJjcykuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoJ2FyYycpKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnRyYW5zZm9ybUFsbCA9IGZ1bmN0aW9uICh3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgJCQudHJhbnNmb3JtTWFpbih3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpO1xuICAgICAgICBpZiAoJCQuY29uZmlnLnN1YmNoYXJ0X3Nob3cpIHtcbiAgICAgICAgICAgICQkLnRyYW5zZm9ybUNvbnRleHQod2l0aFRyYW5zaXRpb24sIHRyYW5zaXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJCQubGVnZW5kKSB7XG4gICAgICAgICAgICAkJC50cmFuc2Zvcm1MZWdlbmQod2l0aFRyYW5zaXRpb24pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnVwZGF0ZVN2Z1NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBicnVzaCA9ICQkLnN2Zy5zZWxlY3QoXCIuYzMtYnJ1c2ggLmJhY2tncm91bmRcIik7XG4gICAgICAgICQkLnN2Zy5hdHRyKCd3aWR0aCcsICQkLmN1cnJlbnRXaWR0aCkuYXR0cignaGVpZ2h0JywgJCQuY3VycmVudEhlaWdodCk7XG4gICAgICAgICQkLnN2Zy5zZWxlY3RBbGwoWycjJyArICQkLmNsaXBJZCwgJyMnICsgJCQuY2xpcElkRm9yR3JpZF0pLnNlbGVjdCgncmVjdCcpLmF0dHIoJ3dpZHRoJywgJCQud2lkdGgpLmF0dHIoJ2hlaWdodCcsICQkLmhlaWdodCk7XG4gICAgICAgICQkLnN2Zy5zZWxlY3QoJyMnICsgJCQuY2xpcElkRm9yWEF4aXMpLnNlbGVjdCgncmVjdCcpLmF0dHIoJ3gnLCAkJC5nZXRYQXhpc0NsaXBYLmJpbmQoJCQpKS5hdHRyKCd5JywgJCQuZ2V0WEF4aXNDbGlwWS5iaW5kKCQkKSkuYXR0cignd2lkdGgnLCAkJC5nZXRYQXhpc0NsaXBXaWR0aC5iaW5kKCQkKSkuYXR0cignaGVpZ2h0JywgJCQuZ2V0WEF4aXNDbGlwSGVpZ2h0LmJpbmQoJCQpKTtcbiAgICAgICAgJCQuc3ZnLnNlbGVjdCgnIycgKyAkJC5jbGlwSWRGb3JZQXhpcykuc2VsZWN0KCdyZWN0JykuYXR0cigneCcsICQkLmdldFlBeGlzQ2xpcFguYmluZCgkJCkpLmF0dHIoJ3knLCAkJC5nZXRZQXhpc0NsaXBZLmJpbmQoJCQpKS5hdHRyKCd3aWR0aCcsICQkLmdldFlBeGlzQ2xpcFdpZHRoLmJpbmQoJCQpKS5hdHRyKCdoZWlnaHQnLCAkJC5nZXRZQXhpc0NsaXBIZWlnaHQuYmluZCgkJCkpO1xuICAgICAgICAkJC5zdmcuc2VsZWN0KCcjJyArICQkLmNsaXBJZEZvclN1YmNoYXJ0KS5zZWxlY3QoJ3JlY3QnKS5hdHRyKCd3aWR0aCcsICQkLndpZHRoKS5hdHRyKCdoZWlnaHQnLCBicnVzaC5zaXplKCkgPyBicnVzaC5hdHRyKCdoZWlnaHQnKSA6IDApO1xuICAgICAgICAkJC5zdmcuc2VsZWN0KCcuJyArIENMQVNTLnpvb21SZWN0KS5hdHRyKCd3aWR0aCcsICQkLndpZHRoKS5hdHRyKCdoZWlnaHQnLCAkJC5oZWlnaHQpO1xuICAgICAgICAvLyBNRU1POiBwYXJlbnQgZGl2J3MgaGVpZ2h0IHdpbGwgYmUgYmlnZ2VyIHRoYW4gc3ZnIHdoZW4gPCFET0NUWVBFIGh0bWw+XG4gICAgICAgICQkLnNlbGVjdENoYXJ0LnN0eWxlKCdtYXgtaGVpZ2h0JywgJCQuY3VycmVudEhlaWdodCArIFwicHhcIik7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnVwZGF0ZURpbWVuc2lvbiA9IGZ1bmN0aW9uICh3aXRob3V0QXhpcykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICBpZiAoIXdpdGhvdXRBeGlzKSB7XG4gICAgICAgICAgICBpZiAoJCQuY29uZmlnLmF4aXNfcm90YXRlZCkge1xuICAgICAgICAgICAgICAgICQkLmF4ZXMueC5jYWxsKCQkLnhBeGlzKTtcbiAgICAgICAgICAgICAgICAkJC5heGVzLnN1YnguY2FsbCgkJC5zdWJYQXhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQkLmF4ZXMueS5jYWxsKCQkLnlBeGlzKTtcbiAgICAgICAgICAgICAgICAkJC5heGVzLnkyLmNhbGwoJCQueTJBeGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAkJC51cGRhdGVTaXplcygpO1xuICAgICAgICAkJC51cGRhdGVTY2FsZXMoKTtcbiAgICAgICAgJCQudXBkYXRlU3ZnU2l6ZSgpO1xuICAgICAgICAkJC50cmFuc2Zvcm1BbGwoZmFsc2UpO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5vYnNlcnZlSW5zZXJ0ZWQgPSBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBvYnNlcnZlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgd2luZG93LmNvbnNvbGUuZXJyb3IoXCJNdXRhdGlvbk9ic2VydmVyIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgIG11dGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hpbGRMaXN0JyAmJiBtdXRhdGlvbi5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHdhaXQgZm9yIGNvbXBsZXRpb24gb2YgbG9hZCBiZWNhdXNlIHNpemUgY2FsY3VsYXRpb24gcmVxdWlyZXMgdGhlIGFjdHVhbCBzaXplcyBkZXRlcm1pbmVkIGFmdGVyIHRoYXQgY29tcGxldGlvblxuICAgICAgICAgICAgICAgICAgICAkJC5pbnRlcnZhbEZvck9ic2VydmVJbnNlcnRlZCA9IHdpbmRvdy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJlbnROb2RlIHdpbGwgTk9UIGJlIG51bGwgd2hlbiBjb21wbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24ubm9kZSgpLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCgkJC5pbnRlcnZhbEZvck9ic2VydmVJbnNlcnRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCQudXBkYXRlRGltZW5zaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQkLmJydXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQkLmJydXNoLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkJC5jb25maWcub25pbml0LmNhbGwoJCQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQkLnJlZHJhdyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhUcmFuc2Zvcm06IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aFRyYW5zaXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhMZWdlbmQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24udHJhbnNpdGlvbigpLnN0eWxlKCdvcGFjaXR5JywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoc2VsZWN0aW9uLm5vZGUoKSwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmJpbmRSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG5cbiAgICAgICAgJCQucmVzaXplRnVuY3Rpb24gPSAkJC5nZW5lcmF0ZVJlc2l6ZSgpOyAvLyBuZWVkIHRvIGNhbGwgLnJlbW92ZVxuXG4gICAgICAgICQkLnJlc2l6ZUZ1bmN0aW9uLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25maWcub25yZXNpemUuY2FsbCgkJCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29uZmlnLnJlc2l6ZV9hdXRvKSB7XG4gICAgICAgICAgICAkJC5yZXNpemVGdW5jdGlvbi5hZGQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICgkJC5yZXNpemVUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCgkJC5yZXNpemVUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJCQucmVzaXplVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlICQkLnJlc2l6ZVRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgICAgICQkLmFwaS5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAkJC5yZXNpemVGdW5jdGlvbi5hZGQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uZmlnLm9ucmVzaXplZC5jYWxsKCQkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJCQucmVzaXplSWZFbGVtZW50RGlzcGxheWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gaWYgZWxlbWVudCBub3QgZGlzcGxheWVkIHNraXAgaXRcbiAgICAgICAgICAgIGlmICgkJC5hcGkgPT0gbnVsbCB8fCAhJCQuYXBpLmVsZW1lbnQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkJC5yZXNpemVGdW5jdGlvbigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh3aW5kb3cuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hdHRhY2hFdmVudCgnb25yZXNpemUnLCAkJC5yZXNpemVJZkVsZW1lbnREaXNwbGF5ZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgJCQucmVzaXplSWZFbGVtZW50RGlzcGxheWVkLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byB0aGlzLCBpZiB0aGlzIGlzIGEgdmVyeSBvbGQgYnJvd3NlclxuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSB3aW5kb3cub25yZXNpemU7XG4gICAgICAgICAgICBpZiAoIXdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSB3cmFwcGVyIHRoYXQgd2lsbCBjYWxsIGFsbCBjaGFydHNcbiAgICAgICAgICAgICAgICB3cmFwcGVyID0gJCQuZ2VuZXJhdGVSZXNpemUoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXdyYXBwZXIuYWRkIHx8ICF3cmFwcGVyLnJlbW92ZSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIGFscmVhZHkgYSBoYW5kbGVyIHJlZ2lzdGVyZWQsIG1ha2Ugc3VyZSB3ZSBjYWxsIGl0IHRvb1xuICAgICAgICAgICAgICAgIHdyYXBwZXIgPSAkJC5nZW5lcmF0ZVJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgIHdyYXBwZXIuYWRkKHdpbmRvdy5vbnJlc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgdGhpcyBncmFwaCB0byB0aGUgd3JhcHBlciwgd2Ugd2lsbCBiZSByZW1vdmVkIGlmIHRoZSB1c2VyIGNhbGxzIGRlc3Ryb3lcbiAgICAgICAgICAgIHdyYXBwZXIuYWRkKCQkLnJlc2l6ZUZ1bmN0aW9uKTtcbiAgICAgICAgICAgIHdpbmRvdy5vbnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBlbGVtZW50IG5vdCBkaXNwbGF5ZWQgc2tpcCBpdFxuICAgICAgICAgICAgICAgIGlmICghJCQuYXBpLmVsZW1lbnQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3cmFwcGVyKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdlbmVyYXRlUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzaXplRnVuY3Rpb25zID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxSZXNpemVGdW5jdGlvbnMoKSB7XG4gICAgICAgICAgICByZXNpemVGdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgIGYoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxSZXNpemVGdW5jdGlvbnMuYWRkID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHJlc2l6ZUZ1bmN0aW9ucy5wdXNoKGYpO1xuICAgICAgICB9O1xuICAgICAgICBjYWxsUmVzaXplRnVuY3Rpb25zLnJlbW92ZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2l6ZUZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChyZXNpemVGdW5jdGlvbnNbaV0gPT09IGYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplRnVuY3Rpb25zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2FsbFJlc2l6ZUZ1bmN0aW9ucztcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZW5kYWxsID0gZnVuY3Rpb24gKHRyYW5zaXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgdHJhbnNpdGlvbi5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICsrbjtcbiAgICAgICAgfSkuZWFjaChcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISAtLW4pIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdlbmVyYXRlV2FpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25zVG9XYWl0ID0gW10sXG4gICAgICAgICAgICBmID0gZnVuY3Rpb24gZih0cmFuc2l0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkb25lID0gMDtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uc1RvV2FpdC5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LmVtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdC50cmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChkb25lID09PSB0cmFuc2l0aW9uc1RvV2FpdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgfTtcbiAgICAgICAgZi5hZGQgPSBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICAgICAgICAgICAgdHJhbnNpdGlvbnNUb1dhaXQucHVzaCh0cmFuc2l0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnBhcnNlRGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBwYXJzZWREYXRlO1xuICAgICAgICBpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHBhcnNlZERhdGUgPSBkYXRlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGFyc2VkRGF0ZSA9ICQkLmRhdGFUaW1lRm9ybWF0KCQkLmNvbmZpZy5kYXRhX3hGb3JtYXQpLnBhcnNlKGRhdGUpO1xuICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgZGF0ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGF0ZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKCtkYXRlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGRhdGUpKSB7XG4gICAgICAgICAgICBwYXJzZWREYXRlID0gbmV3IERhdGUoK2RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyc2VkRGF0ZSB8fCBpc05hTigrcGFyc2VkRGF0ZSkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHggJ1wiICsgZGF0ZSArIFwiJyB0byBEYXRlIG9iamVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkRGF0ZTtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaXNUYWJWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGlkZGVuO1xuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50LmhpZGRlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy8gT3BlcmEgMTIuMTAgYW5kIEZpcmVmb3ggMTggYW5kIGxhdGVyIHN1cHBvcnRcbiAgICAgICAgICAgIGhpZGRlbiA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Lm1vekhpZGRlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaGlkZGVuID0gXCJtb3pIaWRkZW5cIjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQubXNIaWRkZW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGhpZGRlbiA9IFwibXNIaWRkZW5cIjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQud2Via2l0SGlkZGVuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBoaWRkZW4gPSBcIndlYmtpdEhpZGRlblwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50W2hpZGRlbl0gPyBmYWxzZSA6IHRydWU7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmlzVmFsdWUgPSBpc1ZhbHVlO1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5pc0RlZmluZWQgPSBpc0RlZmluZWQ7XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uY2VpbDEwID0gY2VpbDEwO1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmFzSGFsZlBpeGVsID0gYXNIYWxmUGl4ZWw7XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZGlmZkRvbWFpbiA9IGRpZmZEb21haW47XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ubm90RW1wdHkgPSBub3RFbXB0eTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5ub3RFbXB0eSA9IG5vdEVtcHR5O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldE9wdGlvbiA9IGdldE9wdGlvbjtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5oYXNWYWx1ZSA9IGhhc1ZhbHVlO1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnNhbml0aXNlID0gc2FuaXRpc2U7XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0UGF0aEJveCA9IGdldFBhdGhCb3g7XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uQ0xBU1MgPSBDTEFTUztcblxuICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblxuICAgIC8vIFBoYW50b21KUyBkb2Vzbid0IGhhdmUgc3VwcG9ydCBmb3IgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsIHdoaWNoIGhhcyBjYXVzZWQgY29uZnVzaW9uLiBVc2VcbiAgICAvLyB0aGlzIHBvbHlmaWxsIHRvIGF2b2lkIHRoZSBjb25mdXNpb24uXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCNQb2x5ZmlsbFxuXG4gICAgaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChvVGhpcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1XG4gICAgICAgICAgICAgICAgLy8gaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICAgICAgZlRvQmluZCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZk5PUCA9IGZ1bmN0aW9uIGZOT1AoKSB7fSxcbiAgICAgICAgICAgICAgICBmQm91bmQgPSBmdW5jdGlvbiBmQm91bmQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1AgPyB0aGlzIDogb1RoaXMsIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgICAgICAgICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBmQm91bmQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gU1ZHUGF0aFNlZyBBUEkgcG9seWZpbGxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcHJvZ2Vycy9wYXRoc2VnXG4gICAgLy9cbiAgICAvLyBUaGlzIGlzIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgdGhlIFNWR1BhdGhTZWcgYW5kIFNWR1BhdGhTZWdMaXN0IEFQSXMgdGhhdCB3ZXJlIHJlbW92ZWQgZnJvbVxuICAgIC8vIFNWRzIgKGh0dHBzOi8vbGlzdHMudzMub3JnL0FyY2hpdmVzL1B1YmxpYy93d3ctc3ZnLzIwMTVKdW4vMDA0NC5odG1sKSwgaW5jbHVkaW5nIHRoZSBsYXRlc3Qgc3BlY1xuICAgIC8vIGNoYW5nZXMgd2hpY2ggd2VyZSBpbXBsZW1lbnRlZCBpbiBGaXJlZm94IDQzIGFuZCBDaHJvbWUgNDYuXG5cbiAgICAoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIGlmICghKFwiU1ZHUGF0aFNlZ1wiIGluIHdpbmRvdykpIHtcbiAgICAgICAgICAgIC8vIFNwZWM6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL3NpbmdsZS1wYWdlLmh0bWwjcGF0aHMtSW50ZXJmYWNlU1ZHUGF0aFNlZ1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWcgPSBmdW5jdGlvbiAodHlwZSwgdHlwZUFzTGV0dGVyLCBvd25pbmdQYXRoU2VnTGlzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aFNlZ1R5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aFNlZ1R5cGVBc0xldHRlciA9IHR5cGVBc0xldHRlcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9vd25pbmdQYXRoU2VnTGlzdCA9IG93bmluZ1BhdGhTZWdMaXN0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWcucHJvdG90eXBlLmNsYXNzbmFtZSA9IFwiU1ZHUGF0aFNlZ1wiO1xuXG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX1VOS05PV04gPSAwO1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19DTE9TRVBBVEggPSAxO1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19NT1ZFVE9fQUJTID0gMjtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfTU9WRVRPX1JFTCA9IDM7XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0xJTkVUT19BQlMgPSA0O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19MSU5FVE9fUkVMID0gNTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfQ1VSVkVUT19DVUJJQ19BQlMgPSA2O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX0NVQklDX1JFTCA9IDc7XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0NVUlZFVE9fUVVBRFJBVElDX0FCUyA9IDg7XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0NVUlZFVE9fUVVBRFJBVElDX1JFTCA9IDk7XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0FSQ19BQlMgPSAxMDtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfQVJDX1JFTCA9IDExO1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19MSU5FVE9fSE9SSVpPTlRBTF9BQlMgPSAxMjtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfTElORVRPX0hPUklaT05UQUxfUkVMID0gMTM7XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0xJTkVUT19WRVJUSUNBTF9BQlMgPSAxNDtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfTElORVRPX1ZFUlRJQ0FMX1JFTCA9IDE1O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX0NVQklDX1NNT09USF9BQlMgPSAxNjtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfQ1VSVkVUT19DVUJJQ19TTU9PVEhfUkVMID0gMTc7XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0NVUlZFVE9fUVVBRFJBVElDX1NNT09USF9BQlMgPSAxODtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfQ1VSVkVUT19RVUFEUkFUSUNfU01PT1RIX1JFTCA9IDE5O1xuXG4gICAgICAgICAgICAvLyBOb3RpZnkgb3duaW5nIFBhdGhTZWdMaXN0IG9uIGFueSBjaGFuZ2VzIHNvIHRoZXkgY2FuIGJlIHN5bmNocm9uaXplZCBiYWNrIHRvIHRoZSBwYXRoIGVsZW1lbnQuXG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZy5wcm90b3R5cGUuX3NlZ21lbnRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vd25pbmdQYXRoU2VnTGlzdCkgdGhpcy5fb3duaW5nUGF0aFNlZ0xpc3Quc2VnbWVudENoYW5nZWQodGhpcyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0Nsb3NlUGF0aCA9IGZ1bmN0aW9uIChvd25pbmdQYXRoU2VnTGlzdCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnLmNhbGwodGhpcywgd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19DTE9TRVBBVEgsIFwielwiLCBvd25pbmdQYXRoU2VnTGlzdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDbG9zZVBhdGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh3aW5kb3cuU1ZHUGF0aFNlZy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDbG9zZVBhdGgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltvYmplY3QgU1ZHUGF0aFNlZ0Nsb3NlUGF0aF1cIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0Nsb3NlUGF0aC5wcm90b3R5cGUuX2FzUGF0aFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoU2VnVHlwZUFzTGV0dGVyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnQ2xvc2VQYXRoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnQ2xvc2VQYXRoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ01vdmV0b0FicyA9IGZ1bmN0aW9uIChvd25pbmdQYXRoU2VnTGlzdCwgeCwgeSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnLmNhbGwodGhpcywgd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19NT1ZFVE9fQUJTLCBcIk1cIiwgb3duaW5nUGF0aFNlZ0xpc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTW92ZXRvQWJzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUod2luZG93LlNWR1BhdGhTZWcucHJvdG90eXBlKTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTW92ZXRvQWJzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IFNWR1BhdGhTZWdNb3ZldG9BYnNdXCI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdNb3ZldG9BYnMucHJvdG90eXBlLl9hc1BhdGhTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aFNlZ1R5cGVBc0xldHRlciArIFwiIFwiICsgdGhpcy5feCArIFwiIFwiICsgdGhpcy5feTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ01vdmV0b0Ficy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ01vdmV0b0Ficyh1bmRlZmluZWQsIHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ01vdmV0b0Ficy5wcm90b3R5cGUsIFwieFwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldCh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ01vdmV0b0Ficy5wcm90b3R5cGUsIFwieVwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feTtcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldCh5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdNb3ZldG9SZWwgPSBmdW5jdGlvbiAob3duaW5nUGF0aFNlZ0xpc3QsIHgsIHkpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZy5jYWxsKHRoaXMsIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfTU9WRVRPX1JFTCwgXCJtXCIsIG93bmluZ1BhdGhTZWdMaXN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ01vdmV0b1JlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHdpbmRvdy5TVkdQYXRoU2VnLnByb3RvdHlwZSk7XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ01vdmV0b1JlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBTVkdQYXRoU2VnTW92ZXRvUmVsXVwiO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTW92ZXRvUmVsLnByb3RvdHlwZS5fYXNQYXRoU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGhTZWdUeXBlQXNMZXR0ZXIgKyBcIiBcIiArIHRoaXMuX3ggKyBcIiBcIiArIHRoaXMuX3k7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdNb3ZldG9SZWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdNb3ZldG9SZWwodW5kZWZpbmVkLCB0aGlzLl94LCB0aGlzLl95KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdNb3ZldG9SZWwucHJvdG90eXBlLCBcInhcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94ID0geDt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdNb3ZldG9SZWwucHJvdG90eXBlLCBcInlcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl95ID0geTt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvQWJzID0gZnVuY3Rpb24gKG93bmluZ1BhdGhTZWdMaXN0LCB4LCB5KSB7XG4gICAgICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWcuY2FsbCh0aGlzLCB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0xJTkVUT19BQlMsIFwiTFwiLCBvd25pbmdQYXRoU2VnTGlzdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9BYnMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh3aW5kb3cuU1ZHUGF0aFNlZy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9BYnMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltvYmplY3QgU1ZHUGF0aFNlZ0xpbmV0b0Fic11cIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0xpbmV0b0Ficy5wcm90b3R5cGUuX2FzUGF0aFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoU2VnVHlwZUFzTGV0dGVyICsgXCIgXCIgKyB0aGlzLl94ICsgXCIgXCIgKyB0aGlzLl95O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvQWJzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvQWJzKHVuZGVmaW5lZCwgdGhpcy5feCwgdGhpcy5feSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvQWJzLnByb3RvdHlwZSwgXCJ4XCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feCA9IHg7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvQWJzLnByb3RvdHlwZSwgXCJ5XCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feSA9IHk7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0xpbmV0b1JlbCA9IGZ1bmN0aW9uIChvd25pbmdQYXRoU2VnTGlzdCwgeCwgeSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnLmNhbGwodGhpcywgd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19MSU5FVE9fUkVMLCBcImxcIiwgb3duaW5nUGF0aFNlZ0xpc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvUmVsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUod2luZG93LlNWR1BhdGhTZWcucHJvdG90eXBlKTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvUmVsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IFNWR1BhdGhTZWdMaW5ldG9SZWxdXCI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9SZWwucHJvdG90eXBlLl9hc1BhdGhTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aFNlZ1R5cGVBc0xldHRlciArIFwiIFwiICsgdGhpcy5feCArIFwiIFwiICsgdGhpcy5feTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0xpbmV0b1JlbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ0xpbmV0b1JlbCh1bmRlZmluZWQsIHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0xpbmV0b1JlbC5wcm90b3R5cGUsIFwieFwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldCh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0xpbmV0b1JlbC5wcm90b3R5cGUsIFwieVwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feTtcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldCh5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNBYnMgPSBmdW5jdGlvbiAob3duaW5nUGF0aFNlZ0xpc3QsIHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWcuY2FsbCh0aGlzLCB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0NVUlZFVE9fQ1VCSUNfQUJTLCBcIkNcIiwgb3duaW5nUGF0aFNlZ0xpc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuX3gxID0geDE7XG4gICAgICAgICAgICAgICAgdGhpcy5feTEgPSB5MTtcbiAgICAgICAgICAgICAgICB0aGlzLl94MiA9IHgyO1xuICAgICAgICAgICAgICAgIHRoaXMuX3kyID0geTI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNBYnMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh3aW5kb3cuU1ZHUGF0aFNlZy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNBYnMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltvYmplY3QgU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY0Fic11cIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY0Ficy5wcm90b3R5cGUuX2FzUGF0aFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoU2VnVHlwZUFzTGV0dGVyICsgXCIgXCIgKyB0aGlzLl94MSArIFwiIFwiICsgdGhpcy5feTEgKyBcIiBcIiArIHRoaXMuX3gyICsgXCIgXCIgKyB0aGlzLl95MiArIFwiIFwiICsgdGhpcy5feCArIFwiIFwiICsgdGhpcy5feTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY0Ficy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY0Ficyh1bmRlZmluZWQsIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3gxLCB0aGlzLl95MSwgdGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNBYnMucHJvdG90eXBlLCBcInhcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94ID0geDt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNBYnMucHJvdG90eXBlLCBcInlcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl95ID0geTt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNBYnMucHJvdG90eXBlLCBcIngxXCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl94MTtcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldCh4MSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94MSA9IHgxO3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY0Ficy5wcm90b3R5cGUsIFwieTFcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3kxO1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KHkxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3kxID0geTE7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b0N1YmljQWJzLnByb3RvdHlwZSwgXCJ4MlwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feDI7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feDIgPSB4Mjt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNBYnMucHJvdG90eXBlLCBcInkyXCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl95MjtcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldCh5Mikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl95MiA9IHkyO3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNSZWwgPSBmdW5jdGlvbiAob3duaW5nUGF0aFNlZ0xpc3QsIHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWcuY2FsbCh0aGlzLCB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0NVUlZFVE9fQ1VCSUNfUkVMLCBcImNcIiwgb3duaW5nUGF0aFNlZ0xpc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuX3gxID0geDE7XG4gICAgICAgICAgICAgICAgdGhpcy5feTEgPSB5MTtcbiAgICAgICAgICAgICAgICB0aGlzLl94MiA9IHgyO1xuICAgICAgICAgICAgICAgIHRoaXMuX3kyID0geTI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNSZWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh3aW5kb3cuU1ZHUGF0aFNlZy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNSZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltvYmplY3QgU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1JlbF1cIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1JlbC5wcm90b3R5cGUuX2FzUGF0aFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoU2VnVHlwZUFzTGV0dGVyICsgXCIgXCIgKyB0aGlzLl94MSArIFwiIFwiICsgdGhpcy5feTEgKyBcIiBcIiArIHRoaXMuX3gyICsgXCIgXCIgKyB0aGlzLl95MiArIFwiIFwiICsgdGhpcy5feCArIFwiIFwiICsgdGhpcy5feTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1JlbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1JlbCh1bmRlZmluZWQsIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3gxLCB0aGlzLl95MSwgdGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNSZWwucHJvdG90eXBlLCBcInhcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94ID0geDt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNSZWwucHJvdG90eXBlLCBcInlcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl95ID0geTt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNSZWwucHJvdG90eXBlLCBcIngxXCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl94MTtcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldCh4MSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94MSA9IHgxO3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1JlbC5wcm90b3R5cGUsIFwieTFcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3kxO1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KHkxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3kxID0geTE7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b0N1YmljUmVsLnByb3RvdHlwZSwgXCJ4MlwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feDI7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feDIgPSB4Mjt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNSZWwucHJvdG90eXBlLCBcInkyXCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl95MjtcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldCh5Mikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl95MiA9IHkyO3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljQWJzID0gZnVuY3Rpb24gKG93bmluZ1BhdGhTZWdMaXN0LCB4LCB5LCB4MSwgeTEpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZy5jYWxsKHRoaXMsIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfQ1VSVkVUT19RVUFEUkFUSUNfQUJTLCBcIlFcIiwgb3duaW5nUGF0aFNlZ0xpc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuX3gxID0geDE7XG4gICAgICAgICAgICAgICAgdGhpcy5feTEgPSB5MTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNBYnMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh3aW5kb3cuU1ZHUGF0aFNlZy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljQWJzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IFNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljQWJzXVwiO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY0Ficy5wcm90b3R5cGUuX2FzUGF0aFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoU2VnVHlwZUFzTGV0dGVyICsgXCIgXCIgKyB0aGlzLl94MSArIFwiIFwiICsgdGhpcy5feTEgKyBcIiBcIiArIHRoaXMuX3ggKyBcIiBcIiArIHRoaXMuX3k7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljQWJzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY0Ficyh1bmRlZmluZWQsIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3gxLCB0aGlzLl95MSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY0Ficy5wcm90b3R5cGUsIFwieFwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldCh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNBYnMucHJvdG90eXBlLCBcInlcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl95ID0geTt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljQWJzLnByb3RvdHlwZSwgXCJ4MVwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feDE7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feDEgPSB4MTt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljQWJzLnByb3RvdHlwZSwgXCJ5MVwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feTE7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feTEgPSB5MTt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1JlbCA9IGZ1bmN0aW9uIChvd25pbmdQYXRoU2VnTGlzdCwgeCwgeSwgeDEsIHkxKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWcuY2FsbCh0aGlzLCB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0NVUlZFVE9fUVVBRFJBVElDX1JFTCwgXCJxXCIsIG93bmluZ1BhdGhTZWdMaXN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgICAgICAgICB0aGlzLl94MSA9IHgxO1xuICAgICAgICAgICAgICAgIHRoaXMuX3kxID0geTE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljUmVsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUod2luZG93LlNWR1BhdGhTZWcucHJvdG90eXBlKTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1JlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1JlbF1cIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNSZWwucHJvdG90eXBlLl9hc1BhdGhTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aFNlZ1R5cGVBc0xldHRlciArIFwiIFwiICsgdGhpcy5feDEgKyBcIiBcIiArIHRoaXMuX3kxICsgXCIgXCIgKyB0aGlzLl94ICsgXCIgXCIgKyB0aGlzLl95O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1JlbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNSZWwodW5kZWZpbmVkLCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl94MSwgdGhpcy5feTEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNSZWwucHJvdG90eXBlLCBcInhcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94ID0geDt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljUmVsLnByb3RvdHlwZSwgXCJ5XCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feSA9IHk7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1JlbC5wcm90b3R5cGUsIFwieDFcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3gxO1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KHgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3gxID0geDE7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1JlbC5wcm90b3R5cGUsIFwieTFcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3kxO1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KHkxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3kxID0geTE7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0FyY0FicyA9IGZ1bmN0aW9uIChvd25pbmdQYXRoU2VnTGlzdCwgeCwgeSwgcjEsIHIyLCBhbmdsZSwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZy5jYWxsKHRoaXMsIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfQVJDX0FCUywgXCJBXCIsIG93bmluZ1BhdGhTZWdMaXN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yMSA9IHIxO1xuICAgICAgICAgICAgICAgIHRoaXMuX3IyID0gcjI7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXJnZUFyY0ZsYWcgPSBsYXJnZUFyY0ZsYWc7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3dlZXBGbGFnID0gc3dlZXBGbGFnO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnQXJjQWJzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUod2luZG93LlNWR1BhdGhTZWcucHJvdG90eXBlKTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnQXJjQWJzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IFNWR1BhdGhTZWdBcmNBYnNdXCI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdBcmNBYnMucHJvdG90eXBlLl9hc1BhdGhTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aFNlZ1R5cGVBc0xldHRlciArIFwiIFwiICsgdGhpcy5fcjEgKyBcIiBcIiArIHRoaXMuX3IyICsgXCIgXCIgKyB0aGlzLl9hbmdsZSArIFwiIFwiICsgKHRoaXMuX2xhcmdlQXJjRmxhZyA/IFwiMVwiIDogXCIwXCIpICsgXCIgXCIgKyAodGhpcy5fc3dlZXBGbGFnID8gXCIxXCIgOiBcIjBcIikgKyBcIiBcIiArIHRoaXMuX3ggKyBcIiBcIiArIHRoaXMuX3k7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdBcmNBYnMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdBcmNBYnModW5kZWZpbmVkLCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl9yMSwgdGhpcy5fcjIsIHRoaXMuX2FuZ2xlLCB0aGlzLl9sYXJnZUFyY0ZsYWcsIHRoaXMuX3N3ZWVwRmxhZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnQXJjQWJzLnByb3RvdHlwZSwgXCJ4XCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feCA9IHg7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnQXJjQWJzLnByb3RvdHlwZSwgXCJ5XCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feSA9IHk7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnQXJjQWJzLnByb3RvdHlwZSwgXCJyMVwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcjE7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQocjEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcjEgPSByMTt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdBcmNBYnMucHJvdG90eXBlLCBcInIyXCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yMjtcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChyMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yMiA9IHIyO3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0FyY0Ficy5wcm90b3R5cGUsIFwiYW5nbGVcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuZ2xlO1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KGFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuZ2xlID0gYW5nbGU7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnQXJjQWJzLnByb3RvdHlwZSwgXCJsYXJnZUFyY0ZsYWdcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhcmdlQXJjRmxhZztcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChsYXJnZUFyY0ZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFyZ2VBcmNGbGFnID0gbGFyZ2VBcmNGbGFnO3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0FyY0Ficy5wcm90b3R5cGUsIFwic3dlZXBGbGFnXCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zd2VlcEZsYWc7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoc3dlZXBGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N3ZWVwRmxhZyA9IHN3ZWVwRmxhZzt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnQXJjUmVsID0gZnVuY3Rpb24gKG93bmluZ1BhdGhTZWdMaXN0LCB4LCB5LCByMSwgcjIsIGFuZ2xlLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnLmNhbGwodGhpcywgd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19BUkNfUkVMLCBcImFcIiwgb3duaW5nUGF0aFNlZ0xpc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuX3IxID0gcjE7XG4gICAgICAgICAgICAgICAgdGhpcy5fcjIgPSByMjtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhcmdlQXJjRmxhZyA9IGxhcmdlQXJjRmxhZztcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2VlcEZsYWcgPSBzd2VlcEZsYWc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdBcmNSZWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh3aW5kb3cuU1ZHUGF0aFNlZy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdBcmNSZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltvYmplY3QgU1ZHUGF0aFNlZ0FyY1JlbF1cIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0FyY1JlbC5wcm90b3R5cGUuX2FzUGF0aFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoU2VnVHlwZUFzTGV0dGVyICsgXCIgXCIgKyB0aGlzLl9yMSArIFwiIFwiICsgdGhpcy5fcjIgKyBcIiBcIiArIHRoaXMuX2FuZ2xlICsgXCIgXCIgKyAodGhpcy5fbGFyZ2VBcmNGbGFnID8gXCIxXCIgOiBcIjBcIikgKyBcIiBcIiArICh0aGlzLl9zd2VlcEZsYWcgPyBcIjFcIiA6IFwiMFwiKSArIFwiIFwiICsgdGhpcy5feCArIFwiIFwiICsgdGhpcy5feTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0FyY1JlbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ0FyY1JlbCh1bmRlZmluZWQsIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3IxLCB0aGlzLl9yMiwgdGhpcy5fYW5nbGUsIHRoaXMuX2xhcmdlQXJjRmxhZywgdGhpcy5fc3dlZXBGbGFnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdBcmNSZWwucHJvdG90eXBlLCBcInhcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94ID0geDt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdBcmNSZWwucHJvdG90eXBlLCBcInlcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl95ID0geTt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdBcmNSZWwucHJvdG90eXBlLCBcInIxXCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yMTtcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChyMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yMSA9IHIxO3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0FyY1JlbC5wcm90b3R5cGUsIFwicjJcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3IyO1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KHIyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3IyID0gcjI7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnQXJjUmVsLnByb3RvdHlwZSwgXCJhbmdsZVwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5nbGU7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoYW5nbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5nbGUgPSBhbmdsZTt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdBcmNSZWwucHJvdG90eXBlLCBcImxhcmdlQXJjRmxhZ1wiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFyZ2VBcmNGbGFnO1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KGxhcmdlQXJjRmxhZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXJnZUFyY0ZsYWcgPSBsYXJnZUFyY0ZsYWc7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnQXJjUmVsLnByb3RvdHlwZSwgXCJzd2VlcEZsYWdcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N3ZWVwRmxhZztcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChzd2VlcEZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3dlZXBGbGFnID0gc3dlZXBGbGFnO3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsQWJzID0gZnVuY3Rpb24gKG93bmluZ1BhdGhTZWdMaXN0LCB4KSB7XG4gICAgICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWcuY2FsbCh0aGlzLCB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0xJTkVUT19IT1JJWk9OVEFMX0FCUywgXCJIXCIsIG93bmluZ1BhdGhTZWdMaXN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxBYnMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh3aW5kb3cuU1ZHUGF0aFNlZy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsQWJzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IFNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsQWJzXVwiO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvSG9yaXpvbnRhbEFicy5wcm90b3R5cGUuX2FzUGF0aFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoU2VnVHlwZUFzTGV0dGVyICsgXCIgXCIgKyB0aGlzLl94O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvSG9yaXpvbnRhbEFicy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxBYnModW5kZWZpbmVkLCB0aGlzLl94KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsQWJzLnByb3RvdHlwZSwgXCJ4XCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feCA9IHg7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxSZWwgPSBmdW5jdGlvbiAob3duaW5nUGF0aFNlZ0xpc3QsIHgpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZy5jYWxsKHRoaXMsIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfTElORVRPX0hPUklaT05UQUxfUkVMLCBcImhcIiwgb3duaW5nUGF0aFNlZ0xpc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvSG9yaXpvbnRhbFJlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHdpbmRvdy5TVkdQYXRoU2VnLnByb3RvdHlwZSk7XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxSZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltvYmplY3QgU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxSZWxdXCI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsUmVsLnByb3RvdHlwZS5fYXNQYXRoU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGhTZWdUeXBlQXNMZXR0ZXIgKyBcIiBcIiArIHRoaXMuX3g7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsUmVsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvSG9yaXpvbnRhbFJlbCh1bmRlZmluZWQsIHRoaXMuX3gpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxSZWwucHJvdG90eXBlLCBcInhcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94ID0geDt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvVmVydGljYWxBYnMgPSBmdW5jdGlvbiAob3duaW5nUGF0aFNlZ0xpc3QsIHkpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZy5jYWxsKHRoaXMsIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfTElORVRPX1ZFUlRJQ0FMX0FCUywgXCJWXCIsIG93bmluZ1BhdGhTZWdMaXN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsQWJzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUod2luZG93LlNWR1BhdGhTZWcucHJvdG90eXBlKTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvVmVydGljYWxBYnMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltvYmplY3QgU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsQWJzXVwiO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvVmVydGljYWxBYnMucHJvdG90eXBlLl9hc1BhdGhTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aFNlZ1R5cGVBc0xldHRlciArIFwiIFwiICsgdGhpcy5feTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsQWJzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvVmVydGljYWxBYnModW5kZWZpbmVkLCB0aGlzLl95KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbEFicy5wcm90b3R5cGUsIFwieVwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feTtcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldCh5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbFJlbCA9IGZ1bmN0aW9uIChvd25pbmdQYXRoU2VnTGlzdCwgeSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnLmNhbGwodGhpcywgd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19MSU5FVE9fVkVSVElDQUxfUkVMLCBcInZcIiwgb3duaW5nUGF0aFNlZ0xpc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvVmVydGljYWxSZWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh3aW5kb3cuU1ZHUGF0aFNlZy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbFJlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBTVkdQYXRoU2VnTGluZXRvVmVydGljYWxSZWxdXCI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbFJlbC5wcm90b3R5cGUuX2FzUGF0aFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoU2VnVHlwZUFzTGV0dGVyICsgXCIgXCIgKyB0aGlzLl95O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvVmVydGljYWxSZWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbFJlbCh1bmRlZmluZWQsIHRoaXMuX3kpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsUmVsLnByb3RvdHlwZSwgXCJ5XCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feSA9IHk7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aEFicyA9IGZ1bmN0aW9uIChvd25pbmdQYXRoU2VnTGlzdCwgeCwgeSwgeDIsIHkyKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWcuY2FsbCh0aGlzLCB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0NVUlZFVE9fQ1VCSUNfU01PT1RIX0FCUywgXCJTXCIsIG93bmluZ1BhdGhTZWdMaXN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgICAgICAgICB0aGlzLl94MiA9IHgyO1xuICAgICAgICAgICAgICAgIHRoaXMuX3kyID0geTI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhBYnMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh3aW5kb3cuU1ZHUGF0aFNlZy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhBYnMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltvYmplY3QgU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aEFic11cIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aEFicy5wcm90b3R5cGUuX2FzUGF0aFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoU2VnVHlwZUFzTGV0dGVyICsgXCIgXCIgKyB0aGlzLl94MiArIFwiIFwiICsgdGhpcy5feTIgKyBcIiBcIiArIHRoaXMuX3ggKyBcIiBcIiArIHRoaXMuX3k7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhBYnMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhBYnModW5kZWZpbmVkLCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl94MiwgdGhpcy5feTIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aEFicy5wcm90b3R5cGUsIFwieFwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldCh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aEFicy5wcm90b3R5cGUsIFwieVwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feTtcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldCh5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aEFicy5wcm90b3R5cGUsIFwieDJcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3gyO1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KHgyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3gyID0geDI7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoQWJzLnByb3RvdHlwZSwgXCJ5MlwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feTI7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeTIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feTIgPSB5Mjt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoUmVsID0gZnVuY3Rpb24gKG93bmluZ1BhdGhTZWdMaXN0LCB4LCB5LCB4MiwgeTIpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZy5jYWxsKHRoaXMsIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfQ1VSVkVUT19DVUJJQ19TTU9PVEhfUkVMLCBcInNcIiwgb3duaW5nUGF0aFNlZ0xpc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuX3gyID0geDI7XG4gICAgICAgICAgICAgICAgdGhpcy5feTIgPSB5MjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aFJlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHdpbmRvdy5TVkdQYXRoU2VnLnByb3RvdHlwZSk7XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aFJlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBTVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoUmVsXVwiO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoUmVsLnByb3RvdHlwZS5fYXNQYXRoU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGhTZWdUeXBlQXNMZXR0ZXIgKyBcIiBcIiArIHRoaXMuX3gyICsgXCIgXCIgKyB0aGlzLl95MiArIFwiIFwiICsgdGhpcy5feCArIFwiIFwiICsgdGhpcy5feTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aFJlbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aFJlbCh1bmRlZmluZWQsIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3gyLCB0aGlzLl95Mik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoUmVsLnByb3RvdHlwZSwgXCJ4XCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feCA9IHg7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoUmVsLnByb3RvdHlwZSwgXCJ5XCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feSA9IHk7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoUmVsLnByb3RvdHlwZSwgXCJ4MlwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feDI7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feDIgPSB4Mjt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhSZWwucHJvdG90eXBlLCBcInkyXCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl95MjtcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldCh5Mikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl95MiA9IHkyO3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoQWJzID0gZnVuY3Rpb24gKG93bmluZ1BhdGhTZWdMaXN0LCB4LCB5KSB7XG4gICAgICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWcuY2FsbCh0aGlzLCB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0NVUlZFVE9fUVVBRFJBVElDX1NNT09USF9BQlMsIFwiVFwiLCBvd25pbmdQYXRoU2VnTGlzdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoQWJzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUod2luZG93LlNWR1BhdGhTZWcucHJvdG90eXBlKTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aEFicy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aEFic11cIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGhBYnMucHJvdG90eXBlLl9hc1BhdGhTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aFNlZ1R5cGVBc0xldHRlciArIFwiIFwiICsgdGhpcy5feCArIFwiIFwiICsgdGhpcy5feTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGhBYnMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoQWJzKHVuZGVmaW5lZCwgdGhpcy5feCwgdGhpcy5feSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aEFicy5wcm90b3R5cGUsIFwieFwiLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldCh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O3RoaXMuX3NlZ21lbnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGhBYnMucHJvdG90eXBlLCBcInlcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl95ID0geTt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aFJlbCA9IGZ1bmN0aW9uIChvd25pbmdQYXRoU2VnTGlzdCwgeCwgeSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnLmNhbGwodGhpcywgd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX1FVQURSQVRJQ19TTU9PVEhfUkVMLCBcInRcIiwgb3duaW5nUGF0aFNlZ0xpc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aFJlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHdpbmRvdy5TVkdQYXRoU2VnLnByb3RvdHlwZSk7XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGhSZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltvYmplY3QgU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGhSZWxdXCI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoUmVsLnByb3RvdHlwZS5fYXNQYXRoU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGhTZWdUeXBlQXNMZXR0ZXIgKyBcIiBcIiArIHRoaXMuX3ggKyBcIiBcIiArIHRoaXMuX3k7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoUmVsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aFJlbCh1bmRlZmluZWQsIHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGhSZWwucHJvdG90eXBlLCBcInhcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoeCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94ID0geDt0aGlzLl9zZWdtZW50Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoUmVsLnByb3RvdHlwZSwgXCJ5XCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgICAgICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feSA9IHk7dGhpcy5fc2VnbWVudENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9LCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICAvLyBBZGQgY3JlYXRlU1ZHUGF0aFNlZyogZnVuY3Rpb25zIHRvIHdpbmRvdy5TVkdQYXRoRWxlbWVudC5cbiAgICAgICAgICAgIC8vIFNwZWM6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL3NpbmdsZS1wYWdlLmh0bWwjcGF0aHMtSW50ZXJmYWNld2luZG93LlNWR1BhdGhFbGVtZW50LlxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTVkdQYXRoU2VnQ2xvc2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdDbG9zZVBhdGgodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNWR1BhdGhTZWdNb3ZldG9BYnMgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdNb3ZldG9BYnModW5kZWZpbmVkLCB4LCB5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNWR1BhdGhTZWdNb3ZldG9SZWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdNb3ZldG9SZWwodW5kZWZpbmVkLCB4LCB5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9BYnMgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9BYnModW5kZWZpbmVkLCB4LCB5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9SZWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9SZWwodW5kZWZpbmVkLCB4LCB5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNBYnMgPSBmdW5jdGlvbiAoeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b0N1YmljQWJzKHVuZGVmaW5lZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1JlbCA9IGZ1bmN0aW9uICh4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNSZWwodW5kZWZpbmVkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY0FicyA9IGZ1bmN0aW9uICh4LCB5LCB4MSwgeTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY0Ficyh1bmRlZmluZWQsIHgsIHksIHgxLCB5MSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1JlbCA9IGZ1bmN0aW9uICh4LCB5LCB4MSwgeTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1JlbCh1bmRlZmluZWQsIHgsIHksIHgxLCB5MSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTVkdQYXRoU2VnQXJjQWJzID0gZnVuY3Rpb24gKHgsIHksIHIxLCByMiwgYW5nbGUsIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ0FyY0Ficyh1bmRlZmluZWQsIHgsIHksIHIxLCByMiwgYW5nbGUsIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNWR1BhdGhTZWdBcmNSZWwgPSBmdW5jdGlvbiAoeCwgeSwgcjEsIHIyLCBhbmdsZSwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnQXJjUmVsKHVuZGVmaW5lZCwgeCwgeSwgcjEsIHIyLCBhbmdsZSwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxBYnMgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsQWJzKHVuZGVmaW5lZCwgeCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTVkdQYXRoU2VnTGluZXRvSG9yaXpvbnRhbFJlbCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxSZWwodW5kZWZpbmVkLCB4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbEFicyA9IGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsQWJzKHVuZGVmaW5lZCwgeSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTVkdQYXRoU2VnTGluZXRvVmVydGljYWxSZWwgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbFJlbCh1bmRlZmluZWQsIHkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aEFicyA9IGZ1bmN0aW9uICh4LCB5LCB4MiwgeTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoQWJzKHVuZGVmaW5lZCwgeCwgeSwgeDIsIHkyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhSZWwgPSBmdW5jdGlvbiAoeCwgeSwgeDIsIHkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aFJlbCh1bmRlZmluZWQsIHgsIHksIHgyLCB5Mik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aEFicyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGhBYnModW5kZWZpbmVkLCB4LCB5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoUmVsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aFJlbCh1bmRlZmluZWQsIHgsIHkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCEoXCJnZXRQYXRoU2VnQXRMZW5ndGhcIiBpbiB3aW5kb3cuU1ZHUGF0aEVsZW1lbnQucHJvdG90eXBlKSkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBnZXRQYXRoU2VnQXRMZW5ndGggdG8gU1ZHUGF0aEVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gU3BlYzogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzExL3NpbmdsZS1wYWdlLmh0bWwjcGF0aHMtX19zdmdfX1NWR1BhdGhFbGVtZW50X19nZXRQYXRoU2VnQXRMZW5ndGhcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHBvbHlmaWxsIHJlcXVpcmVzIFNWR1BhdGhFbGVtZW50LmdldFRvdGFsTGVuZ3RoIHRvIGltcGxlbWVudCB0aGUgZGlzdGFuY2UtYWxvbmctYS1wYXRoIGFsZ29yaXRobS5cbiAgICAgICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aEVsZW1lbnQucHJvdG90eXBlLmdldFBhdGhTZWdBdExlbmd0aCA9IGZ1bmN0aW9uIChkaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPT09IHVuZGVmaW5lZCB8fCAhaXNGaW5pdGUoZGlzdGFuY2UpKSB0aHJvdyBcIkludmFsaWQgYXJndW1lbnRzLlwiO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZWFzdXJlbWVudEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInBhdGhcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lYXN1cmVtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkXCIsIHRoaXMuZ2V0QXR0cmlidXRlKFwiZFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0UGF0aFNlZ21lbnQgPSBtZWFzdXJlbWVudEVsZW1lbnQucGF0aFNlZ0xpc3QubnVtYmVyT2ZJdGVtcyAtIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBhdGggaXMgZW1wdHksIHJldHVybiAwLlxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFBhdGhTZWdtZW50IDw9IDApIHJldHVybiAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lYXN1cmVtZW50RWxlbWVudC5wYXRoU2VnTGlzdC5yZW1vdmVJdGVtKGxhc3RQYXRoU2VnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBtZWFzdXJlbWVudEVsZW1lbnQuZ2V0VG90YWxMZW5ndGgoKSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGF0aFNlZ21lbnQtLTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobGFzdFBhdGhTZWdtZW50ID4gMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYXN0UGF0aFNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKFwiU1ZHUGF0aFNlZ0xpc3RcIiBpbiB3aW5kb3cpKSB7XG4gICAgICAgICAgICAvLyBTcGVjOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9zaW5nbGUtcGFnZS5odG1sI3BhdGhzLUludGVyZmFjZVNWR1BhdGhTZWdMaXN0XG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0xpc3QgPSBmdW5jdGlvbiAocGF0aEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXRoRWxlbWVudCA9IHBhdGhFbGVtZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3QgPSB0aGlzLl9wYXJzZVBhdGgodGhpcy5fcGF0aEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZFwiKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgYSBNdXRhdGlvbk9ic2VydmVyIHRvIGNhdGNoIGNoYW5nZXMgdG8gdGhlIHBhdGgncyBcImRcIiBhdHRyaWJ1dGUuXG4gICAgICAgICAgICAgICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlckNvbmZpZyA9IHsgXCJhdHRyaWJ1dGVzXCI6IHRydWUsIFwiYXR0cmlidXRlRmlsdGVyXCI6IFtcImRcIl0gfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXRoRWxlbWVudE11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl91cGRhdGVMaXN0RnJvbVBhdGhNdXRhdGlvbnMuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF0aEVsZW1lbnRNdXRhdGlvbk9ic2VydmVyLm9ic2VydmUodGhpcy5fcGF0aEVsZW1lbnQsIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXJDb25maWcpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaXN0LnByb3RvdHlwZS5jbGFzc25hbWUgPSBcIlNWR1BhdGhTZWdMaXN0XCI7XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aFNlZ0xpc3QucHJvdG90eXBlLCBcIm51bWJlck9mSXRlbXNcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1BhdGhTeW5jaHJvbml6ZWRUb0xpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgcGF0aFNlZ0xpc3QgYWNjZXNzb3JzIHRvIHdpbmRvdy5TVkdQYXRoRWxlbWVudC5cbiAgICAgICAgICAgIC8vIFNwZWM6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL3NpbmdsZS1wYWdlLmh0bWwjcGF0aHMtSW50ZXJmYWNlU1ZHQW5pbWF0ZWRQYXRoRGF0YVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5TVkdQYXRoRWxlbWVudC5wcm90b3R5cGUsIFwicGF0aFNlZ0xpc3RcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3BhdGhTZWdMaXN0KSB0aGlzLl9wYXRoU2VnTGlzdCA9IG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ0xpc3QodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXRoU2VnTGlzdDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRklYTUU6IFRoZSBmb2xsb3dpbmcgYXJlIG5vdCBpbXBsZW1lbnRlZCBhbmQgc2ltcGx5IHJldHVybiB3aW5kb3cuU1ZHUGF0aEVsZW1lbnQucGF0aFNlZ0xpc3QuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNWR1BhdGhFbGVtZW50LnByb3RvdHlwZSwgXCJub3JtYWxpemVkUGF0aFNlZ0xpc3RcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aFNlZ0xpc3Q7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aEVsZW1lbnQucHJvdG90eXBlLCBcImFuaW1hdGVkUGF0aFNlZ0xpc3RcIiwgeyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aFNlZ0xpc3Q7XG4gICAgICAgICAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuU1ZHUGF0aEVsZW1lbnQucHJvdG90eXBlLCBcImFuaW1hdGVkTm9ybWFsaXplZFBhdGhTZWdMaXN0XCIsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGhTZWdMaXN0O1xuICAgICAgICAgICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfSk7XG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgYW55IHBlbmRpbmcgbXV0YXRpb25zIHRvIHRoZSBwYXRoIGVsZW1lbnQgYW5kIHVwZGF0ZSB0aGUgbGlzdCBhcyBuZWVkZWQuXG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSB0aGUgZmlyc3QgY2FsbCBvZiBhbGwgcHVibGljIGZ1bmN0aW9ucyBhbmQgaXMgbmVlZGVkIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIE11dGF0aW9uT2JzZXJ2ZXJzIGFyZSBub3Qgc3luY2hyb25vdXMgc28gd2UgY2FuIGhhdmUgcGVuZGluZyBhc3luY2hyb25vdXMgbXV0YXRpb25zLlxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaXN0LnByb3RvdHlwZS5fY2hlY2tQYXRoU3luY2hyb25pemVkVG9MaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxpc3RGcm9tUGF0aE11dGF0aW9ucyh0aGlzLl9wYXRoRWxlbWVudE11dGF0aW9uT2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0xpc3QucHJvdG90eXBlLl91cGRhdGVMaXN0RnJvbVBhdGhNdXRhdGlvbnMgPSBmdW5jdGlvbiAobXV0YXRpb25SZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXRoRWxlbWVudCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBoYXNQYXRoTXV0YXRpb25zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbXV0YXRpb25SZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT0gXCJkXCIpIGhhc1BhdGhNdXRhdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChoYXNQYXRoTXV0YXRpb25zKSB0aGlzLl9saXN0ID0gdGhpcy5fcGFyc2VQYXRoKHRoaXMuX3BhdGhFbGVtZW50LmdldEF0dHJpYnV0ZShcImRcIikpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gU2VyaWFsaXplIHRoZSBsaXN0IGFuZCB1cGRhdGUgdGhlIHBhdGgncyAnZCcgYXR0cmlidXRlLlxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaXN0LnByb3RvdHlwZS5fd3JpdGVMaXN0VG9QYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdGhFbGVtZW50TXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZFwiLCB3aW5kb3cuU1ZHUGF0aFNlZ0xpc3QuX3BhdGhTZWdBcnJheUFzU3RyaW5nKHRoaXMuX2xpc3QpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXRoRWxlbWVudE11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9wYXRoRWxlbWVudCwgdGhpcy5fbXV0YXRpb25PYnNlcnZlckNvbmZpZyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBXaGVuIGEgcGF0aCBzZWdtZW50IGNoYW5nZXMgdGhlIGxpc3QgbmVlZHMgdG8gYmUgc3luY2hyb25pemVkIGJhY2sgdG8gdGhlIHBhdGggZWxlbWVudC5cbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTGlzdC5wcm90b3R5cGUuc2VnbWVudENoYW5nZWQgPSBmdW5jdGlvbiAocGF0aFNlZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlTGlzdFRvUGF0aCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1BhdGhTeW5jaHJvbml6ZWRUb0xpc3QoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3QuZm9yRWFjaChmdW5jdGlvbiAocGF0aFNlZykge1xuICAgICAgICAgICAgICAgICAgICBwYXRoU2VnLl9vd25pbmdQYXRoU2VnTGlzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlTGlzdFRvUGF0aCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaXN0LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG5ld0l0ZW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1BhdGhTeW5jaHJvbml6ZWRUb0xpc3QoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3QgPSBbbmV3SXRlbV07XG4gICAgICAgICAgICAgICAgbmV3SXRlbS5fb3duaW5nUGF0aFNlZ0xpc3QgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlTGlzdFRvUGF0aCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdJdGVtO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaXN0LnByb3RvdHlwZS5fY2hlY2tWYWxpZEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGluZGV4KSB8fCBpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5udW1iZXJPZkl0ZW1zKSB0aHJvdyBcIklOREVYX1NJWkVfRVJSXCI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0xpc3QucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1BhdGhTeW5jaHJvbml6ZWRUb0xpc3QoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrVmFsaWRJbmRleChpbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RbaW5kZXhdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaXN0LnByb3RvdHlwZS5pbnNlcnRJdGVtQmVmb3JlID0gZnVuY3Rpb24gKG5ld0l0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXRoU3luY2hyb25pemVkVG9MaXN0KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTcGVjOiBJZiB0aGUgaW5kZXggaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIG51bWJlck9mSXRlbXMsIHRoZW4gdGhlIG5ldyBpdGVtIGlzIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gdGhpcy5udW1iZXJPZkl0ZW1zKSBpbmRleCA9IHRoaXMubnVtYmVyT2ZJdGVtcztcbiAgICAgICAgICAgICAgICBpZiAobmV3SXRlbS5fb3duaW5nUGF0aFNlZ0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU1ZHMiBzcGVjIHNheXMgdG8gbWFrZSBhIGNvcHkuXG4gICAgICAgICAgICAgICAgICAgIG5ld0l0ZW0gPSBuZXdJdGVtLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3Quc3BsaWNlKGluZGV4LCAwLCBuZXdJdGVtKTtcbiAgICAgICAgICAgICAgICBuZXdJdGVtLl9vd25pbmdQYXRoU2VnTGlzdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVMaXN0VG9QYXRoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0l0ZW07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB3aW5kb3cuU1ZHUGF0aFNlZ0xpc3QucHJvdG90eXBlLnJlcGxhY2VJdGVtID0gZnVuY3Rpb24gKG5ld0l0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXRoU3luY2hyb25pemVkVG9MaXN0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3SXRlbS5fb3duaW5nUGF0aFNlZ0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU1ZHMiBzcGVjIHNheXMgdG8gbWFrZSBhIGNvcHkuXG4gICAgICAgICAgICAgICAgICAgIG5ld0l0ZW0gPSBuZXdJdGVtLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrVmFsaWRJbmRleChpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdFtpbmRleF0gPSBuZXdJdGVtO1xuICAgICAgICAgICAgICAgIG5ld0l0ZW0uX293bmluZ1BhdGhTZWdMaXN0ID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZUxpc3RUb1BhdGgoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3SXRlbTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTGlzdC5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUGF0aFN5bmNocm9uaXplZFRvTGlzdCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tWYWxpZEluZGV4KGluZGV4KTtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2xpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZUxpc3RUb1BhdGgoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTGlzdC5wcm90b3R5cGUuYXBwZW5kSXRlbSA9IGZ1bmN0aW9uIChuZXdJdGVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXRoU3luY2hyb25pemVkVG9MaXN0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3SXRlbS5fb3duaW5nUGF0aFNlZ0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU1ZHMiBzcGVjIHNheXMgdG8gbWFrZSBhIGNvcHkuXG4gICAgICAgICAgICAgICAgICAgIG5ld0l0ZW0gPSBuZXdJdGVtLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3QucHVzaChuZXdJdGVtKTtcbiAgICAgICAgICAgICAgICBuZXdJdGVtLl9vd25pbmdQYXRoU2VnTGlzdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogT3B0aW1pemUgdGhpcyB0byBqdXN0IGFwcGVuZCB0byB0aGUgZXhpc3RpbmcgYXR0cmlidXRlLlxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlTGlzdFRvUGF0aCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdJdGVtO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd2luZG93LlNWR1BhdGhTZWdMaXN0Ll9wYXRoU2VnQXJyYXlBc1N0cmluZyA9IGZ1bmN0aW9uIChwYXRoU2VnQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gXCJcIjtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhdGhTZWdBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoU2VnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBwYXRoU2VnLl9hc1BhdGhTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBcIiBcIiArIHBhdGhTZWcuX2FzUGF0aFN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFRoaXMgY2xvc2VseSBmb2xsb3dzIFNWR1BhdGhQYXJzZXI6OnBhcnNlUGF0aCBmcm9tIFNvdXJjZS9jb3JlL3N2Zy9TVkdQYXRoUGFyc2VyLmNwcC5cbiAgICAgICAgICAgIHdpbmRvdy5TVkdQYXRoU2VnTGlzdC5wcm90b3R5cGUuX3BhcnNlUGF0aCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0cmluZyB8fCBzdHJpbmcubGVuZ3RoID09IDApIHJldHVybiBbXTtcblxuICAgICAgICAgICAgICAgIHZhciBvd25pbmdQYXRoU2VnTGlzdCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgQnVpbGRlciA9IGZ1bmN0aW9uIEJ1aWxkZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aFNlZ0xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kU2VnbWVudCA9IGZ1bmN0aW9uIChwYXRoU2VnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aFNlZ0xpc3QucHVzaChwYXRoU2VnKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIFNvdXJjZSA9IGZ1bmN0aW9uIFNvdXJjZShzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmRJbmRleCA9IHRoaXMuX3N0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzQ29tbWFuZCA9IHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfVU5LTk9XTjtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9za2lwT3B0aW9uYWxTcGFjZXMoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU291cmNlLnByb3RvdHlwZS5faXNDdXJyZW50U3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFyYWN0ZXIgPSB0aGlzLl9zdHJpbmdbdGhpcy5fY3VycmVudEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJhY3RlciA8PSBcIiBcIiAmJiAoY2hhcmFjdGVyID09IFwiIFwiIHx8IGNoYXJhY3RlciA9PSBcIlxcblwiIHx8IGNoYXJhY3RlciA9PSBcIlxcdFwiIHx8IGNoYXJhY3RlciA9PSBcIlxcclwiIHx8IGNoYXJhY3RlciA9PSBcIlxcZlwiKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU291cmNlLnByb3RvdHlwZS5fc2tpcE9wdGlvbmFsU3BhY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5fY3VycmVudEluZGV4IDwgdGhpcy5fZW5kSW5kZXggJiYgdGhpcy5faXNDdXJyZW50U3BhY2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1yZXR1cm4gdGhpcy5fY3VycmVudEluZGV4IDwgdGhpcy5fZW5kSW5kZXg7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNvdXJjZS5wcm90b3R5cGUuX3NraXBPcHRpb25hbFNwYWNlc09yRGVsaW1pdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEluZGV4IDwgdGhpcy5fZW5kSW5kZXggJiYgIXRoaXMuX2lzQ3VycmVudFNwYWNlKCkgJiYgdGhpcy5fc3RyaW5nLmNoYXJBdCh0aGlzLl9jdXJyZW50SW5kZXgpICE9IFwiLFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9za2lwT3B0aW9uYWxTcGFjZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRJbmRleCA8IHRoaXMuX2VuZEluZGV4ICYmIHRoaXMuX3N0cmluZy5jaGFyQXQodGhpcy5fY3VycmVudEluZGV4KSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NraXBPcHRpb25hbFNwYWNlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50SW5kZXggPCB0aGlzLl9lbmRJbmRleDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU291cmNlLnByb3RvdHlwZS5oYXNNb3JlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRJbmRleCA8IHRoaXMuX2VuZEluZGV4O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBTb3VyY2UucHJvdG90eXBlLnBlZWtTZWdtZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvb2thaGVhZCA9IHRoaXMuX3N0cmluZ1t0aGlzLl9jdXJyZW50SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGF0aFNlZ1R5cGVGcm9tQ2hhcihsb29rYWhlYWQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBTb3VyY2UucHJvdG90eXBlLl9wYXRoU2VnVHlwZUZyb21DaGFyID0gZnVuY3Rpb24gKGxvb2thaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfQ0xPU0VQQVRIO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19NT1ZFVE9fQUJTO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19NT1ZFVE9fUkVMO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19MSU5FVE9fQUJTO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19MSU5FVE9fUkVMO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX0NVQklDX0FCUztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfQ1VSVkVUT19DVUJJQ19SRUw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiUVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0NVUlZFVE9fUVVBRFJBVElDX0FCUztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfQ1VSVkVUT19RVUFEUkFUSUNfUkVMO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19BUkNfQUJTO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19BUkNfUkVMO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19MSU5FVE9fSE9SSVpPTlRBTF9BQlM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0xJTkVUT19IT1JJWk9OVEFMX1JFTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfTElORVRPX1ZFUlRJQ0FMX0FCUztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfTElORVRPX1ZFUlRJQ0FMX1JFTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfQ1VSVkVUT19DVUJJQ19TTU9PVEhfQUJTO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX0NVQklDX1NNT09USF9SRUw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0NVUlZFVE9fUVVBRFJBVElDX1NNT09USF9BQlM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0NVUlZFVE9fUVVBRFJBVElDX1NNT09USF9SRUw7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX1VOS05PV047XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU291cmNlLnByb3RvdHlwZS5fbmV4dENvbW1hbmRIZWxwZXIgPSBmdW5jdGlvbiAobG9va2FoZWFkLCBwcmV2aW91c0NvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHJlbWFpbmluZyBjb29yZGluYXRlcyBpbiB0aGUgY3VycmVudCBjb21tYW5kLlxuICAgICAgICAgICAgICAgICAgICBpZiAoKGxvb2thaGVhZCA9PSBcIitcIiB8fCBsb29rYWhlYWQgPT0gXCItXCIgfHwgbG9va2FoZWFkID09IFwiLlwiIHx8IGxvb2thaGVhZCA+PSBcIjBcIiAmJiBsb29rYWhlYWQgPD0gXCI5XCIpICYmIHByZXZpb3VzQ29tbWFuZCAhPSB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0NMT1NFUEFUSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzQ29tbWFuZCA9PSB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX01PVkVUT19BQlMpIHJldHVybiB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0xJTkVUT19BQlM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNDb21tYW5kID09IHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfTU9WRVRPX1JFTCkgcmV0dXJuIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfTElORVRPX1JFTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2aW91c0NvbW1hbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfVU5LTk9XTjtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgU291cmNlLnByb3RvdHlwZS5pbml0aWFsQ29tbWFuZElzTW92ZVRvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcGF0aCBpcyBlbXB0eSBpdCBpcyBzdGlsbCB2YWxpZCwgc28gcmV0dXJuIHRydWUuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNNb3JlRGF0YSgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSB0aGlzLnBlZWtTZWdtZW50VHlwZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXRoIG11c3Qgc3RhcnQgd2l0aCBtb3ZlVG8uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kID09IHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfTU9WRVRPX0FCUyB8fCBjb21tYW5kID09IHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfTU9WRVRPX1JFTDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBudW1iZXIgZnJvbSBhbiBTVkcgcGF0aC4gVGhpcyB2ZXJ5IGNsb3NlbHkgZm9sbG93cyBnZW5lcmljUGFyc2VOdW1iZXIoLi4uKSBmcm9tIFNvdXJjZS9jb3JlL3N2Zy9TVkdQYXJzZXJVdGlsaXRpZXMuY3BwLlxuICAgICAgICAgICAgICAgIC8vIFNwZWM6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL3NpbmdsZS1wYWdlLmh0bWwjcGF0aHMtUGF0aERhdGFCTkZcbiAgICAgICAgICAgICAgICBTb3VyY2UucHJvdG90eXBlLl9wYXJzZU51bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVnZXIgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhYyA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNpbWFsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ24gPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwc2lnbiA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSB0aGlzLl9jdXJyZW50SW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2tpcE9wdGlvbmFsU3BhY2VzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgc2lnbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRJbmRleCA8IHRoaXMuX2VuZEluZGV4ICYmIHRoaXMuX3N0cmluZy5jaGFyQXQodGhpcy5fY3VycmVudEluZGV4KSA9PSBcIitcIikgdGhpcy5fY3VycmVudEluZGV4Kys7ZWxzZSBpZiAodGhpcy5fY3VycmVudEluZGV4IDwgdGhpcy5fZW5kSW5kZXggJiYgdGhpcy5fc3RyaW5nLmNoYXJBdCh0aGlzLl9jdXJyZW50SW5kZXgpID09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50SW5kZXggPT0gdGhpcy5fZW5kSW5kZXggfHwgKHRoaXMuX3N0cmluZy5jaGFyQXQodGhpcy5fY3VycmVudEluZGV4KSA8IFwiMFwiIHx8IHRoaXMuX3N0cmluZy5jaGFyQXQodGhpcy5fY3VycmVudEluZGV4KSA+IFwiOVwiKSAmJiB0aGlzLl9zdHJpbmcuY2hhckF0KHRoaXMuX2N1cnJlbnRJbmRleCkgIT0gXCIuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgbnVtYmVyIG11c3QgYmUgb25lIG9mIFswLTkrLS5dLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIHRoZSBpbnRlZ2VyIHBhcnQsIGJ1aWxkIHJpZ2h0LXRvLWxlZnQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEludFBhcnRJbmRleCA9IHRoaXMuX2N1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnJlbnRJbmRleCA8IHRoaXMuX2VuZEluZGV4ICYmIHRoaXMuX3N0cmluZy5jaGFyQXQodGhpcy5fY3VycmVudEluZGV4KSA+PSBcIjBcIiAmJiB0aGlzLl9zdHJpbmcuY2hhckF0KHRoaXMuX2N1cnJlbnRJbmRleCkgPD0gXCI5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIEFkdmFuY2UgdG8gZmlyc3Qgbm9uLWRpZ2l0LlxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50SW5kZXggIT0gc3RhcnRJbnRQYXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FuSW50UGFydEluZGV4ID0gdGhpcy5fY3VycmVudEluZGV4IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzY2FuSW50UGFydEluZGV4ID49IHN0YXJ0SW50UGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZWdlciArPSBtdWx0aXBsaWVyICogKHRoaXMuX3N0cmluZy5jaGFyQXQoc2NhbkludFBhcnRJbmRleC0tKSAtIFwiMFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyICo9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgZGVjaW1hbHMuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50SW5kZXggPCB0aGlzLl9lbmRJbmRleCAmJiB0aGlzLl9zdHJpbmcuY2hhckF0KHRoaXMuX2N1cnJlbnRJbmRleCkgPT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCsrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBtdXN0IGJlIGEgbGVhc3Qgb25lIGRpZ2l0IGZvbGxvd2luZyB0aGUgLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRJbmRleCA+PSB0aGlzLl9lbmRJbmRleCB8fCB0aGlzLl9zdHJpbmcuY2hhckF0KHRoaXMuX2N1cnJlbnRJbmRleCkgPCBcIjBcIiB8fCB0aGlzLl9zdHJpbmcuY2hhckF0KHRoaXMuX2N1cnJlbnRJbmRleCkgPiBcIjlcIikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLl9jdXJyZW50SW5kZXggPCB0aGlzLl9lbmRJbmRleCAmJiB0aGlzLl9zdHJpbmcuY2hhckF0KHRoaXMuX2N1cnJlbnRJbmRleCkgPj0gXCIwXCIgJiYgdGhpcy5fc3RyaW5nLmNoYXJBdCh0aGlzLl9jdXJyZW50SW5kZXgpIDw9IFwiOVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhYyAqPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNpbWFsICs9ICh0aGlzLl9zdHJpbmcuY2hhckF0KHRoaXMuX2N1cnJlbnRJbmRleCkgLSBcIjBcIikgLyBmcmFjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgZXhwb25lbnQgcGFydC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRJbmRleCAhPSBzdGFydEluZGV4ICYmIHRoaXMuX2N1cnJlbnRJbmRleCArIDEgPCB0aGlzLl9lbmRJbmRleCAmJiAodGhpcy5fc3RyaW5nLmNoYXJBdCh0aGlzLl9jdXJyZW50SW5kZXgpID09IFwiZVwiIHx8IHRoaXMuX3N0cmluZy5jaGFyQXQodGhpcy5fY3VycmVudEluZGV4KSA9PSBcIkVcIikgJiYgdGhpcy5fc3RyaW5nLmNoYXJBdCh0aGlzLl9jdXJyZW50SW5kZXggKyAxKSAhPSBcInhcIiAmJiB0aGlzLl9zdHJpbmcuY2hhckF0KHRoaXMuX2N1cnJlbnRJbmRleCArIDEpICE9IFwibVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXgrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgc2lnbiBvZiB0aGUgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RyaW5nLmNoYXJBdCh0aGlzLl9jdXJyZW50SW5kZXgpID09IFwiK1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3N0cmluZy5jaGFyQXQodGhpcy5fY3VycmVudEluZGV4KSA9PSBcIi1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHNpZ24gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbXVzdCBiZSBhbiBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50SW5kZXggPj0gdGhpcy5fZW5kSW5kZXggfHwgdGhpcy5fc3RyaW5nLmNoYXJBdCh0aGlzLl9jdXJyZW50SW5kZXgpIDwgXCIwXCIgfHwgdGhpcy5fc3RyaW5nLmNoYXJBdCh0aGlzLl9jdXJyZW50SW5kZXgpID4gXCI5XCIpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLl9jdXJyZW50SW5kZXggPCB0aGlzLl9lbmRJbmRleCAmJiB0aGlzLl9zdHJpbmcuY2hhckF0KHRoaXMuX2N1cnJlbnRJbmRleCkgPj0gXCIwXCIgJiYgdGhpcy5fc3RyaW5nLmNoYXJBdCh0aGlzLl9jdXJyZW50SW5kZXgpIDw9IFwiOVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgKj0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgKz0gdGhpcy5fc3RyaW5nLmNoYXJBdCh0aGlzLl9jdXJyZW50SW5kZXgpIC0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtYmVyID0gaW50ZWdlciArIGRlY2ltYWw7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlciAqPSBzaWduO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCkgbnVtYmVyICo9IE1hdGgucG93KDEwLCBleHBzaWduICogZXhwb25lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID09IHRoaXMuX2N1cnJlbnRJbmRleCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9za2lwT3B0aW9uYWxTcGFjZXNPckRlbGltaXRlcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNvdXJjZS5wcm90b3R5cGUuX3BhcnNlQXJjRmxhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRJbmRleCA+PSB0aGlzLl9lbmRJbmRleCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZsYWdDaGFyID0gdGhpcy5fc3RyaW5nLmNoYXJBdCh0aGlzLl9jdXJyZW50SW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFnQ2hhciA9PSBcIjBcIikgZmxhZyA9IGZhbHNlO2Vsc2UgaWYgKGZsYWdDaGFyID09IFwiMVwiKSBmbGFnID0gdHJ1ZTtlbHNlIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2tpcE9wdGlvbmFsU3BhY2VzT3JEZWxpbWl0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsYWc7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIFNvdXJjZS5wcm90b3R5cGUucGFyc2VTZWdtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9va2FoZWFkID0gdGhpcy5fc3RyaW5nW3RoaXMuX2N1cnJlbnRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21tYW5kID0gdGhpcy5fcGF0aFNlZ1R5cGVGcm9tQ2hhcihsb29rYWhlYWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZCA9PSB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX1VOS05PV04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvc3NpYmx5IGFuIGltcGxpY2l0IGNvbW1hbmQuIE5vdCBhbGxvd2VkIGlmIHRoaXMgaXMgdGhlIGZpcnN0IGNvbW1hbmQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJldmlvdXNDb21tYW5kID09IHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfVU5LTk9XTikgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kID0gdGhpcy5fbmV4dENvbW1hbmRIZWxwZXIobG9va2FoZWFkLCB0aGlzLl9wcmV2aW91c0NvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQgPT0gd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19VTktOT1dOKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNDb21tYW5kID0gY29tbWFuZDtcblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19NT1ZFVE9fUkVMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdNb3ZldG9SZWwob3duaW5nUGF0aFNlZ0xpc3QsIHRoaXMuX3BhcnNlTnVtYmVyKCksIHRoaXMuX3BhcnNlTnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX01PVkVUT19BQlM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ01vdmV0b0Ficyhvd25pbmdQYXRoU2VnTGlzdCwgdGhpcy5fcGFyc2VOdW1iZXIoKSwgdGhpcy5fcGFyc2VOdW1iZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfTElORVRPX1JFTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvUmVsKG93bmluZ1BhdGhTZWdMaXN0LCB0aGlzLl9wYXJzZU51bWJlcigpLCB0aGlzLl9wYXJzZU51bWJlcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19MSU5FVE9fQUJTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9BYnMob3duaW5nUGF0aFNlZ0xpc3QsIHRoaXMuX3BhcnNlTnVtYmVyKCksIHRoaXMuX3BhcnNlTnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0xJTkVUT19IT1JJWk9OVEFMX1JFTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvSG9yaXpvbnRhbFJlbChvd25pbmdQYXRoU2VnTGlzdCwgdGhpcy5fcGFyc2VOdW1iZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfTElORVRPX0hPUklaT05UQUxfQUJTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsQWJzKG93bmluZ1BhdGhTZWdMaXN0LCB0aGlzLl9wYXJzZU51bWJlcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19MSU5FVE9fVkVSVElDQUxfUkVMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbFJlbChvd25pbmdQYXRoU2VnTGlzdCwgdGhpcy5fcGFyc2VOdW1iZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfTElORVRPX1ZFUlRJQ0FMX0FCUzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnTGluZXRvVmVydGljYWxBYnMob3duaW5nUGF0aFNlZ0xpc3QsIHRoaXMuX3BhcnNlTnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0NMT1NFUEFUSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9za2lwT3B0aW9uYWxTcGFjZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnQ2xvc2VQYXRoKG93bmluZ1BhdGhTZWdMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX0NVQklDX1JFTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0geyB4MTogdGhpcy5fcGFyc2VOdW1iZXIoKSwgeTE6IHRoaXMuX3BhcnNlTnVtYmVyKCksIHgyOiB0aGlzLl9wYXJzZU51bWJlcigpLCB5MjogdGhpcy5fcGFyc2VOdW1iZXIoKSwgeDogdGhpcy5fcGFyc2VOdW1iZXIoKSwgeTogdGhpcy5fcGFyc2VOdW1iZXIoKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNSZWwob3duaW5nUGF0aFNlZ0xpc3QsIHBvaW50cy54LCBwb2ludHMueSwgcG9pbnRzLngxLCBwb2ludHMueTEsIHBvaW50cy54MiwgcG9pbnRzLnkyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX0NVQklDX0FCUzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0geyB4MTogdGhpcy5fcGFyc2VOdW1iZXIoKSwgeTE6IHRoaXMuX3BhcnNlTnVtYmVyKCksIHgyOiB0aGlzLl9wYXJzZU51bWJlcigpLCB5MjogdGhpcy5fcGFyc2VOdW1iZXIoKSwgeDogdGhpcy5fcGFyc2VOdW1iZXIoKSwgeTogdGhpcy5fcGFyc2VOdW1iZXIoKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNBYnMob3duaW5nUGF0aFNlZ0xpc3QsIHBvaW50cy54LCBwb2ludHMueSwgcG9pbnRzLngxLCBwb2ludHMueTEsIHBvaW50cy54MiwgcG9pbnRzLnkyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX0NVQklDX1NNT09USF9SRUw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHsgeDI6IHRoaXMuX3BhcnNlTnVtYmVyKCksIHkyOiB0aGlzLl9wYXJzZU51bWJlcigpLCB4OiB0aGlzLl9wYXJzZU51bWJlcigpLCB5OiB0aGlzLl9wYXJzZU51bWJlcigpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aFJlbChvd25pbmdQYXRoU2VnTGlzdCwgcG9pbnRzLngsIHBvaW50cy55LCBwb2ludHMueDIsIHBvaW50cy55Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfQ1VSVkVUT19DVUJJQ19TTU9PVEhfQUJTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSB7IHgyOiB0aGlzLl9wYXJzZU51bWJlcigpLCB5MjogdGhpcy5fcGFyc2VOdW1iZXIoKSwgeDogdGhpcy5fcGFyc2VOdW1iZXIoKSwgeTogdGhpcy5fcGFyc2VOdW1iZXIoKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhBYnMob3duaW5nUGF0aFNlZ0xpc3QsIHBvaW50cy54LCBwb2ludHMueSwgcG9pbnRzLngyLCBwb2ludHMueTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB3aW5kb3cuU1ZHUGF0aFNlZy5QQVRIU0VHX0NVUlZFVE9fUVVBRFJBVElDX1JFTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0geyB4MTogdGhpcy5fcGFyc2VOdW1iZXIoKSwgeTE6IHRoaXMuX3BhcnNlTnVtYmVyKCksIHg6IHRoaXMuX3BhcnNlTnVtYmVyKCksIHk6IHRoaXMuX3BhcnNlTnVtYmVyKCkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5TVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1JlbChvd25pbmdQYXRoU2VnTGlzdCwgcG9pbnRzLngsIHBvaW50cy55LCBwb2ludHMueDEsIHBvaW50cy55MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfQ1VSVkVUT19RVUFEUkFUSUNfQUJTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSB7IHgxOiB0aGlzLl9wYXJzZU51bWJlcigpLCB5MTogdGhpcy5fcGFyc2VOdW1iZXIoKSwgeDogdGhpcy5fcGFyc2VOdW1iZXIoKSwgeTogdGhpcy5fcGFyc2VOdW1iZXIoKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljQWJzKG93bmluZ1BhdGhTZWdMaXN0LCBwb2ludHMueCwgcG9pbnRzLnksIHBvaW50cy54MSwgcG9pbnRzLnkxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX1FVQURSQVRJQ19TTU9PVEhfUkVMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoUmVsKG93bmluZ1BhdGhTZWdMaXN0LCB0aGlzLl9wYXJzZU51bWJlcigpLCB0aGlzLl9wYXJzZU51bWJlcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX1FVQURSQVRJQ19TTU9PVEhfQUJTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoQWJzKG93bmluZ1BhdGhTZWdMaXN0LCB0aGlzLl9wYXJzZU51bWJlcigpLCB0aGlzLl9wYXJzZU51bWJlcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugd2luZG93LlNWR1BhdGhTZWcuUEFUSFNFR19BUkNfUkVMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSB7IHgxOiB0aGlzLl9wYXJzZU51bWJlcigpLCB5MTogdGhpcy5fcGFyc2VOdW1iZXIoKSwgYXJjQW5nbGU6IHRoaXMuX3BhcnNlTnVtYmVyKCksIGFyY0xhcmdlOiB0aGlzLl9wYXJzZUFyY0ZsYWcoKSwgYXJjU3dlZXA6IHRoaXMuX3BhcnNlQXJjRmxhZygpLCB4OiB0aGlzLl9wYXJzZU51bWJlcigpLCB5OiB0aGlzLl9wYXJzZU51bWJlcigpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU1ZHUGF0aFNlZ0FyY1JlbChvd25pbmdQYXRoU2VnTGlzdCwgcG9pbnRzLngsIHBvaW50cy55LCBwb2ludHMueDEsIHBvaW50cy55MSwgcG9pbnRzLmFyY0FuZ2xlLCBwb2ludHMuYXJjTGFyZ2UsIHBvaW50cy5hcmNTd2VlcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHdpbmRvdy5TVkdQYXRoU2VnLlBBVEhTRUdfQVJDX0FCUzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0geyB4MTogdGhpcy5fcGFyc2VOdW1iZXIoKSwgeTE6IHRoaXMuX3BhcnNlTnVtYmVyKCksIGFyY0FuZ2xlOiB0aGlzLl9wYXJzZU51bWJlcigpLCBhcmNMYXJnZTogdGhpcy5fcGFyc2VBcmNGbGFnKCksIGFyY1N3ZWVwOiB0aGlzLl9wYXJzZUFyY0ZsYWcoKSwgeDogdGhpcy5fcGFyc2VOdW1iZXIoKSwgeTogdGhpcy5fcGFyc2VOdW1iZXIoKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlNWR1BhdGhTZWdBcmNBYnMob3duaW5nUGF0aFNlZ0xpc3QsIHBvaW50cy54LCBwb2ludHMueSwgcG9pbnRzLngxLCBwb2ludHMueTEsIHBvaW50cy5hcmNBbmdsZSwgcG9pbnRzLmFyY0xhcmdlLCBwb2ludHMuYXJjU3dlZXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIlVua25vd24gcGF0aCBzZWcgdHlwZS5cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG5ldyBTb3VyY2Uoc3RyaW5nKTtcblxuICAgICAgICAgICAgICAgIGlmICghc291cmNlLmluaXRpYWxDb21tYW5kSXNNb3ZlVG8oKSkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzb3VyY2UuaGFzTW9yZURhdGEoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aFNlZyA9IHNvdXJjZS5wYXJzZVNlZ21lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXRoU2VnKSByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZXIuYXBwZW5kU2VnbWVudChwYXRoU2VnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRlci5wYXRoU2VnTGlzdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KSgpO1xuXG4gICAgLy8gU3RyaW5nLnBhZEVuZCBwb2x5ZmlsbCBmb3IgSUUxMVxuICAgIC8vXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3V4aXR0ZW4vcG9seWZpbGwvYmxvYi9tYXN0ZXIvc3RyaW5nLnBvbHlmaWxsLmpzXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3BhZEVuZFxuICAgIGlmICghU3RyaW5nLnByb3RvdHlwZS5wYWRFbmQpIHtcbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS5wYWRFbmQgPSBmdW5jdGlvbiBwYWRFbmQodGFyZ2V0TGVuZ3RoLCBwYWRTdHJpbmcpIHtcbiAgICAgICAgICAgIHRhcmdldExlbmd0aCA9IHRhcmdldExlbmd0aCA+PiAwOyAvL2Zsb29yIGlmIG51bWJlciBvciBjb252ZXJ0IG5vbi1udW1iZXIgdG8gMDtcbiAgICAgICAgICAgIHBhZFN0cmluZyA9IFN0cmluZyh0eXBlb2YgcGFkU3RyaW5nICE9PSAndW5kZWZpbmVkJyA/IHBhZFN0cmluZyA6ICcgJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPiB0YXJnZXRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRMZW5ndGggPSB0YXJnZXRMZW5ndGggLSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0TGVuZ3RoID4gcGFkU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYWRTdHJpbmcgKz0gcGFkU3RyaW5nLnJlcGVhdCh0YXJnZXRMZW5ndGggLyBwYWRTdHJpbmcubGVuZ3RoKTsgLy9hcHBlbmQgdG8gb3JpZ2luYWwgdG8gZW5zdXJlIHdlIGFyZSBsb25nZXIgdGhhbiBuZWVkZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzKSArIHBhZFN0cmluZy5zbGljZSgwLCB0YXJnZXRMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbiAgICBjM19jaGFydF9mbi5heGlzID0gZnVuY3Rpb24gKCkge307XG4gICAgYzNfY2hhcnRfZm4uYXhpcy5sYWJlbHMgPSBmdW5jdGlvbiAobGFiZWxzKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWw7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhsYWJlbHMpLmZvckVhY2goZnVuY3Rpb24gKGF4aXNJZCkge1xuICAgICAgICAgICAgICAgICQkLmF4aXMuc2V0TGFiZWxUZXh0KGF4aXNJZCwgbGFiZWxzW2F4aXNJZF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkJC5heGlzLnVwZGF0ZUxhYmVscygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJldHVybiBzb21lIHZhbHVlcz9cbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ZuLmF4aXMubWF4ID0gZnVuY3Rpb24gKG1heCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgbWF4ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihtYXgpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZShtYXgueCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmF4aXNfeF9tYXggPSBtYXgueDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsdWUobWF4LnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5heGlzX3lfbWF4ID0gbWF4Lnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlKG1heC55MikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmF4aXNfeTJfbWF4ID0gbWF4LnkyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmF4aXNfeV9tYXggPSBjb25maWcuYXhpc195Ml9tYXggPSBtYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkJC5yZWRyYXcoeyB3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSwgd2l0aFVwZGF0ZVhEb21haW46IHRydWUgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IGNvbmZpZy5heGlzX3hfbWF4LFxuICAgICAgICAgICAgICAgIHk6IGNvbmZpZy5heGlzX3lfbWF4LFxuICAgICAgICAgICAgICAgIHkyOiBjb25maWcuYXhpc195Ml9tYXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ZuLmF4aXMubWluID0gZnVuY3Rpb24gKG1pbikge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgbWluID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihtaW4pKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZShtaW4ueCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmF4aXNfeF9taW4gPSBtaW4ueDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsdWUobWluLnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5heGlzX3lfbWluID0gbWluLnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlKG1pbi55MikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmF4aXNfeTJfbWluID0gbWluLnkyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmF4aXNfeV9taW4gPSBjb25maWcuYXhpc195Ml9taW4gPSBtaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkJC5yZWRyYXcoeyB3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSwgd2l0aFVwZGF0ZVhEb21haW46IHRydWUgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IGNvbmZpZy5heGlzX3hfbWluLFxuICAgICAgICAgICAgICAgIHk6IGNvbmZpZy5heGlzX3lfbWluLFxuICAgICAgICAgICAgICAgIHkyOiBjb25maWcuYXhpc195Ml9taW5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ZuLmF4aXMucmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmFuZ2UubWF4KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXhpcy5tYXgocmFuZ2UubWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmFuZ2UubWluKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXhpcy5taW4ocmFuZ2UubWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLmF4aXMubWF4KCksXG4gICAgICAgICAgICAgICAgbWluOiB0aGlzLmF4aXMubWluKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfZm4uY2F0ZWdvcnkgPSBmdW5jdGlvbiAoaSwgY2F0ZWdvcnkpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25maWcuYXhpc194X2NhdGVnb3JpZXNbaV0gPSBjYXRlZ29yeTtcbiAgICAgICAgICAgICQkLnJlZHJhdygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25maWcuYXhpc194X2NhdGVnb3JpZXNbaV07XG4gICAgfTtcbiAgICBjM19jaGFydF9mbi5jYXRlZ29yaWVzID0gZnVuY3Rpb24gKGNhdGVnb3JpZXMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcyA9IGNhdGVnb3JpZXM7XG4gICAgICAgICQkLnJlZHJhdygpO1xuICAgICAgICByZXR1cm4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9mbi5yZXNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICAgICBjb25maWcuc2l6ZV93aWR0aCA9IHNpemUgPyBzaXplLndpZHRoIDogbnVsbDtcbiAgICAgICAgY29uZmlnLnNpemVfaGVpZ2h0ID0gc2l6ZSA/IHNpemUuaGVpZ2h0IDogbnVsbDtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9mbi5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbDtcbiAgICAgICAgJCQudXBkYXRlQW5kUmVkcmF3KHsgd2l0aExlZ2VuZDogdHJ1ZSwgd2l0aFRyYW5zaXRpb246IGZhbHNlLCB3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybTogZmFsc2UgfSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ZuLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWw7XG5cbiAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwoJCQuaW50ZXJ2YWxGb3JPYnNlcnZlSW5zZXJ0ZWQpO1xuXG4gICAgICAgIGlmICgkJC5yZXNpemVUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoJCQucmVzaXplVGltZW91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2luZG93LmRldGFjaEV2ZW50KSB7XG4gICAgICAgICAgICB3aW5kb3cuZGV0YWNoRXZlbnQoJ29ucmVzaXplJywgJCQucmVzaXplSWZFbGVtZW50RGlzcGxheWVkKTtcbiAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICQkLnJlc2l6ZUlmRWxlbWVudERpc3BsYXllZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IHdpbmRvdy5vbnJlc2l6ZTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG5vIG9uZSBlbHNlIHJlbW92ZWQgb3VyIHdyYXBwZXIgYW5kIHJlbW92ZSBvdXIgcmVzaXplRnVuY3Rpb24gZnJvbSBpdFxuICAgICAgICAgICAgaWYgKHdyYXBwZXIgJiYgd3JhcHBlci5hZGQgJiYgd3JhcHBlci5yZW1vdmUpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLnJlbW92ZSgkJC5yZXNpemVGdW5jdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgdGhlIGlubmVyIHJlc2l6ZSBmdW5jdGlvbnNcbiAgICAgICAgJCQucmVzaXplRnVuY3Rpb24ucmVtb3ZlKCk7XG5cbiAgICAgICAgJCQuc2VsZWN0Q2hhcnQuY2xhc3NlZCgnYzMnLCBmYWxzZSkuaHRtbChcIlwiKTtcblxuICAgICAgICAvLyBNRU1POiB0aGlzIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Ygc29tZSBlbGVtZW50cyB3aWxsIG5vdCBiZSByZWxlYXNlZCwgdGhlbiBtZW1vcnkgbGVhayB3aWxsIGhhcHBlbi5cbiAgICAgICAgT2JqZWN0LmtleXMoJCQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgJCRba2V5XSA9IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBmaXhcbiAgICBjM19jaGFydF9mbi5jb2xvciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsO1xuICAgICAgICByZXR1cm4gJCQuY29sb3IoaWQpOyAvLyBtb3JlIHBhdHRlcm5zXG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ZuLmRhdGEgPSBmdW5jdGlvbiAodGFyZ2V0SWRzKSB7XG4gICAgICAgIHZhciB0YXJnZXRzID0gdGhpcy5pbnRlcm5hbC5kYXRhLnRhcmdldHM7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGFyZ2V0SWRzID09PSAndW5kZWZpbmVkJyA/IHRhcmdldHMgOiB0YXJnZXRzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdCh0YXJnZXRJZHMpLmluZGV4T2YodC5pZCkgPj0gMDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9mbi5kYXRhLnNob3duID0gZnVuY3Rpb24gKHRhcmdldElkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbC5maWx0ZXJUYXJnZXRzVG9TaG93KHRoaXMuZGF0YSh0YXJnZXRJZHMpKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ZuLmRhdGEudmFsdWVzID0gZnVuY3Rpb24gKHRhcmdldElkKSB7XG4gICAgICAgIHZhciB0YXJnZXRzLFxuICAgICAgICAgICAgdmFsdWVzID0gbnVsbDtcbiAgICAgICAgaWYgKHRhcmdldElkKSB7XG4gICAgICAgICAgICB0YXJnZXRzID0gdGhpcy5kYXRhKHRhcmdldElkKTtcbiAgICAgICAgICAgIHZhbHVlcyA9IHRhcmdldHNbMF0gPyB0YXJnZXRzWzBdLnZhbHVlcy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZTtcbiAgICAgICAgICAgIH0pIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgYzNfY2hhcnRfZm4uZGF0YS5uYW1lcyA9IGZ1bmN0aW9uIChuYW1lcykge1xuICAgICAgICB0aGlzLmludGVybmFsLmNsZWFyTGVnZW5kSXRlbVRleHRCb3hDYWNoZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbC51cGRhdGVEYXRhQXR0cmlidXRlcygnbmFtZXMnLCBuYW1lcyk7XG4gICAgfTtcbiAgICBjM19jaGFydF9mbi5kYXRhLmNvbG9ycyA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWwudXBkYXRlRGF0YUF0dHJpYnV0ZXMoJ2NvbG9ycycsIGNvbG9ycyk7XG4gICAgfTtcbiAgICBjM19jaGFydF9mbi5kYXRhLmF4ZXMgPSBmdW5jdGlvbiAoYXhlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbC51cGRhdGVEYXRhQXR0cmlidXRlcygnYXhlcycsIGF4ZXMpO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9mbi5mbG93ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgICAgIHRhcmdldHMsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgbm90Zm91bmRJZHMgPSBbXSxcbiAgICAgICAgICAgIG9yZ0RhdGFDb3VudCA9ICQkLmdldE1heERhdGFDb3VudCgpLFxuICAgICAgICAgICAgZGF0YUNvdW50LFxuICAgICAgICAgICAgZG9tYWluLFxuICAgICAgICAgICAgYmFzZVRhcmdldCxcbiAgICAgICAgICAgIGJhc2VWYWx1ZSxcbiAgICAgICAgICAgIGxlbmd0aCA9IDAsXG4gICAgICAgICAgICB0YWlsID0gMCxcbiAgICAgICAgICAgIGRpZmYsXG4gICAgICAgICAgICB0bztcblxuICAgICAgICBpZiAoYXJncy5qc29uKSB7XG4gICAgICAgICAgICBkYXRhID0gJCQuY29udmVydEpzb25Ub0RhdGEoYXJncy5qc29uLCBhcmdzLmtleXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3Mucm93cykge1xuICAgICAgICAgICAgZGF0YSA9ICQkLmNvbnZlcnRSb3dzVG9EYXRhKGFyZ3Mucm93cyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJncy5jb2x1bW5zKSB7XG4gICAgICAgICAgICBkYXRhID0gJCQuY29udmVydENvbHVtbnNUb0RhdGEoYXJncy5jb2x1bW5zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRzID0gJCQuY29udmVydERhdGFUb1RhcmdldHMoZGF0YSwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gVXBkYXRlL0FkZCBkYXRhXG4gICAgICAgICQkLmRhdGEudGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGo7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0LmlkID09PSB0YXJnZXRzW2ldLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodC52YWx1ZXNbdC52YWx1ZXMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhaWwgPSB0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXS5pbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gdGFyZ2V0c1tpXS52YWx1ZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0c1tpXS52YWx1ZXNbal0uaW5kZXggPSB0YWlsICsgajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJCQuaXNUaW1lU2VyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRzW2ldLnZhbHVlc1tqXS54ID0gdGFpbCArIGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdC52YWx1ZXMgPSB0LnZhbHVlcy5jb25jYXQodGFyZ2V0c1tpXS52YWx1ZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgbm90Zm91bmRJZHMucHVzaCh0LmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQXBwZW5kIG51bGwgZm9yIG5vdCBmb3VuZCB0YXJnZXRzXG4gICAgICAgICQkLmRhdGEudGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgaSwgajtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub3Rmb3VuZElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0LmlkID09PSBub3Rmb3VuZElkc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICB0YWlsID0gdC52YWx1ZXNbdC52YWx1ZXMubGVuZ3RoIC0gMV0uaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQudmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiB0YWlsICsgaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLmdldE90aGVyVGFyZ2V0WCh0YWlsICsgaikgOiB0YWlsICsgaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIG51bGwgdmFsdWVzIGZvciBuZXcgdGFyZ2V0XG4gICAgICAgIGlmICgkJC5kYXRhLnRhcmdldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9ICQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXNbMF0uaW5kZXg7IGkgPCB0YWlsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLmdldE90aGVyVGFyZ2V0WChpKSA6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdC52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICB2LmluZGV4ICs9IHRhaWw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghJCQuaXNUaW1lU2VyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYueCArPSB0YWlsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdC52YWx1ZXMgPSBtaXNzaW5nLmNvbmNhdCh0LnZhbHVlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuY29uY2F0KHRhcmdldHMpOyAvLyBhZGQgcmVtYWluZWRcblxuICAgICAgICAvLyBjaGVjayBkYXRhIGNvdW50IGJlY2F1c2UgYmVoYXZpb3IgbmVlZHMgdG8gY2hhbmdlIHdoZW4gaXQncyBvbmx5IG9uZVxuICAgICAgICBkYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcbiAgICAgICAgYmFzZVRhcmdldCA9ICQkLmRhdGEudGFyZ2V0c1swXTtcbiAgICAgICAgYmFzZVZhbHVlID0gYmFzZVRhcmdldC52YWx1ZXNbMF07XG5cbiAgICAgICAgLy8gVXBkYXRlIGxlbmd0aCB0byBmbG93IGlmIG5lZWRlZFxuICAgICAgICBpZiAoaXNEZWZpbmVkKGFyZ3MudG8pKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICAgICAgdG8gPSAkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLnBhcnNlRGF0ZShhcmdzLnRvKSA6IGFyZ3MudG87XG4gICAgICAgICAgICBiYXNlVGFyZ2V0LnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYueCA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmaW5lZChhcmdzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgb25seSBvbmUgZGF0YSwgdXBkYXRlIHRoZSBkb21haW4gdG8gZmxvdyBmcm9tIGxlZnQgZWRnZSBvZiB0aGUgY2hhcnRcbiAgICAgICAgaWYgKCFvcmdEYXRhQ291bnQpIHtcbiAgICAgICAgICAgIGlmICgkJC5pc1RpbWVTZXJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChiYXNlVGFyZ2V0LnZhbHVlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPSBiYXNlVGFyZ2V0LnZhbHVlc1tiYXNlVGFyZ2V0LnZhbHVlcy5sZW5ndGggLSAxXS54IC0gYmFzZVZhbHVlLng7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA9IGJhc2VWYWx1ZS54IC0gJCQuZ2V0WERvbWFpbigkJC5kYXRhLnRhcmdldHMpWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlmZiA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21haW4gPSBbYmFzZVZhbHVlLnggLSBkaWZmLCBiYXNlVmFsdWUueF07XG4gICAgICAgICAgICAkJC51cGRhdGVYRG9tYWluKG51bGwsIHRydWUsIHRydWUsIGZhbHNlLCBkb21haW4pO1xuICAgICAgICB9IGVsc2UgaWYgKG9yZ0RhdGFDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKCQkLmlzVGltZVNlcmllcygpKSB7XG4gICAgICAgICAgICAgICAgZGlmZiA9IChiYXNlVGFyZ2V0LnZhbHVlc1tiYXNlVGFyZ2V0LnZhbHVlcy5sZW5ndGggLSAxXS54IC0gYmFzZVZhbHVlLngpIC8gMjtcbiAgICAgICAgICAgICAgICBkb21haW4gPSBbbmV3IERhdGUoK2Jhc2VWYWx1ZS54IC0gZGlmZiksIG5ldyBEYXRlKCtiYXNlVmFsdWUueCArIGRpZmYpXTtcbiAgICAgICAgICAgICAgICAkJC51cGRhdGVYRG9tYWluKG51bGwsIHRydWUsIHRydWUsIGZhbHNlLCBkb21haW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRhcmdldHNcbiAgICAgICAgJCQudXBkYXRlVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpO1xuXG4gICAgICAgIC8vIFJlZHJhdyB3aXRoIG5ldyB0YXJnZXRzXG4gICAgICAgICQkLnJlZHJhdyh7XG4gICAgICAgICAgICBmbG93OiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGJhc2VWYWx1ZS5pbmRleCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogaXNWYWx1ZShhcmdzLmR1cmF0aW9uKSA/IGFyZ3MuZHVyYXRpb24gOiAkJC5jb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbixcbiAgICAgICAgICAgICAgICBkb25lOiBhcmdzLmRvbmUsXG4gICAgICAgICAgICAgICAgb3JnRGF0YUNvdW50OiBvcmdEYXRhQ291bnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3aXRoTGVnZW5kOiB0cnVlLFxuICAgICAgICAgICAgd2l0aFRyYW5zaXRpb246IG9yZ0RhdGFDb3VudCA+IDEsXG4gICAgICAgICAgICB3aXRoVHJpbVhEb21haW46IGZhbHNlLFxuICAgICAgICAgICAgd2l0aFVwZGF0ZVhBeGlzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZW5lcmF0ZUZsb3cgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgZDMgPSAkJC5kMztcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldHMgPSBhcmdzLnRhcmdldHMsXG4gICAgICAgICAgICAgICAgZmxvdyA9IGFyZ3MuZmxvdyxcbiAgICAgICAgICAgICAgICBkcmF3QmFyID0gYXJncy5kcmF3QmFyLFxuICAgICAgICAgICAgICAgIGRyYXdMaW5lID0gYXJncy5kcmF3TGluZSxcbiAgICAgICAgICAgICAgICBkcmF3QXJlYSA9IGFyZ3MuZHJhd0FyZWEsXG4gICAgICAgICAgICAgICAgY3ggPSBhcmdzLmN4LFxuICAgICAgICAgICAgICAgIGN5ID0gYXJncy5jeSxcbiAgICAgICAgICAgICAgICB4diA9IGFyZ3MueHYsXG4gICAgICAgICAgICAgICAgeEZvclRleHQgPSBhcmdzLnhGb3JUZXh0LFxuICAgICAgICAgICAgICAgIHlGb3JUZXh0ID0gYXJncy55Rm9yVGV4dCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IGFyZ3MuZHVyYXRpb247XG5cbiAgICAgICAgICAgIHZhciB0cmFuc2xhdGVYLFxuICAgICAgICAgICAgICAgIHNjYWxlWCA9IDEsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIGZsb3dJbmRleCA9IGZsb3cuaW5kZXgsXG4gICAgICAgICAgICAgICAgZmxvd0xlbmd0aCA9IGZsb3cubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGZsb3dTdGFydCA9ICQkLmdldFZhbHVlT25JbmRleCgkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzLCBmbG93SW5kZXgpLFxuICAgICAgICAgICAgICAgIGZsb3dFbmQgPSAkJC5nZXRWYWx1ZU9uSW5kZXgoJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlcywgZmxvd0luZGV4ICsgZmxvd0xlbmd0aCksXG4gICAgICAgICAgICAgICAgb3JnRG9tYWluID0gJCQueC5kb21haW4oKSxcbiAgICAgICAgICAgICAgICBkb21haW4sXG4gICAgICAgICAgICAgICAgZHVyYXRpb25Gb3JGbG93ID0gZmxvdy5kdXJhdGlvbiB8fCBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICBkb25lID0gZmxvdy5kb25lIHx8IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAgICAgICAgIHdhaXQgPSAkJC5nZW5lcmF0ZVdhaXQoKTtcblxuICAgICAgICAgICAgdmFyIHhncmlkID0gJCQueGdyaWQgfHwgZDMuc2VsZWN0QWxsKFtdKSxcbiAgICAgICAgICAgICAgICB4Z3JpZExpbmVzID0gJCQueGdyaWRMaW5lcyB8fCBkMy5zZWxlY3RBbGwoW10pLFxuICAgICAgICAgICAgICAgIG1haW5SZWdpb24gPSAkJC5tYWluUmVnaW9uIHx8IGQzLnNlbGVjdEFsbChbXSksXG4gICAgICAgICAgICAgICAgbWFpblRleHQgPSAkJC5tYWluVGV4dCB8fCBkMy5zZWxlY3RBbGwoW10pLFxuICAgICAgICAgICAgICAgIG1haW5CYXIgPSAkJC5tYWluQmFyIHx8IGQzLnNlbGVjdEFsbChbXSksXG4gICAgICAgICAgICAgICAgbWFpbkxpbmUgPSAkJC5tYWluTGluZSB8fCBkMy5zZWxlY3RBbGwoW10pLFxuICAgICAgICAgICAgICAgIG1haW5BcmVhID0gJCQubWFpbkFyZWEgfHwgZDMuc2VsZWN0QWxsKFtdKSxcbiAgICAgICAgICAgICAgICBtYWluQ2lyY2xlID0gJCQubWFpbkNpcmNsZSB8fCBkMy5zZWxlY3RBbGwoW10pO1xuXG4gICAgICAgICAgICAvLyBzZXQgZmxhZ1xuICAgICAgICAgICAgJCQuZmxvd2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBoZWFkIGRhdGEgYWZ0ZXIgcmVuZGVyZWRcbiAgICAgICAgICAgICQkLmRhdGEudGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgZC52YWx1ZXMuc3BsaWNlKDAsIGZsb3dMZW5ndGgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB4IGRvbWFpbiB0byBnZW5lcmF0ZSBheGlzIGVsZW1lbnRzIGZvciBmbG93XG4gICAgICAgICAgICBkb21haW4gPSAkJC51cGRhdGVYRG9tYWluKHRhcmdldHMsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGVsZW1lbnRzIHJlbGF0ZWQgdG8geCBzY2FsZVxuICAgICAgICAgICAgaWYgKCQkLnVwZGF0ZVhHcmlkKSB7XG4gICAgICAgICAgICAgICAgJCQudXBkYXRlWEdyaWQodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRyYW5zZm9ybSB0byBmbG93XG4gICAgICAgICAgICBpZiAoIWZsb3cub3JnRGF0YUNvdW50KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgZW1wdHlcbiAgICAgICAgICAgICAgICBpZiAoJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWCA9ICQkLngob3JnRG9tYWluWzBdKSAtICQkLngoZG9tYWluWzBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJCQuaXNUaW1lU2VyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb3dTdGFydCA9ICQkLmdldFZhbHVlT25JbmRleCgkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb3dFbmQgPSAkJC5nZXRWYWx1ZU9uSW5kZXgoJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlcywgJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVggPSAkJC54KGZsb3dTdGFydC54KSAtICQkLngoZmxvd0VuZC54KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVggPSBkaWZmRG9tYWluKGRvbWFpbikgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmbG93Lm9yZ0RhdGFDb3VudCA9PT0gMSB8fCAoZmxvd1N0YXJ0ICYmIGZsb3dTdGFydC54KSA9PT0gKGZsb3dFbmQgJiYgZmxvd0VuZC54KSkge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVggPSAkJC54KG9yZ0RvbWFpblswXSkgLSAkJC54KGRvbWFpblswXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgkJC5pc1RpbWVTZXJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVYID0gJCQueChvcmdEb21haW5bMF0pIC0gJCQueChkb21haW5bMF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVggPSAkJC54KGZsb3dTdGFydC54KSAtICQkLngoZmxvd0VuZC54KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY2FsZVggPSBkaWZmRG9tYWluKG9yZ0RvbWFpbikgLyBkaWZmRG9tYWluKGRvbWFpbik7XG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyB0cmFuc2xhdGVYICsgJywwKSBzY2FsZSgnICsgc2NhbGVYICsgJywxKSc7XG5cbiAgICAgICAgICAgICQkLmhpZGVYR3JpZEZvY3VzKCk7XG5cbiAgICAgICAgICAgIGQzLnRyYW5zaXRpb24oKS5lYXNlKCdsaW5lYXInKS5kdXJhdGlvbihkdXJhdGlvbkZvckZsb3cpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHdhaXQuYWRkKCQkLmF4ZXMueC50cmFuc2l0aW9uKCkuY2FsbCgkJC54QXhpcykpO1xuICAgICAgICAgICAgICAgIHdhaXQuYWRkKG1haW5CYXIudHJhbnNpdGlvbigpLmF0dHIoJ3RyYW5zZm9ybScsIHRyYW5zZm9ybSkpO1xuICAgICAgICAgICAgICAgIHdhaXQuYWRkKG1haW5MaW5lLnRyYW5zaXRpb24oKS5hdHRyKCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm0pKTtcbiAgICAgICAgICAgICAgICB3YWl0LmFkZChtYWluQXJlYS50cmFuc2l0aW9uKCkuYXR0cigndHJhbnNmb3JtJywgdHJhbnNmb3JtKSk7XG4gICAgICAgICAgICAgICAgd2FpdC5hZGQobWFpbkNpcmNsZS50cmFuc2l0aW9uKCkuYXR0cigndHJhbnNmb3JtJywgdHJhbnNmb3JtKSk7XG4gICAgICAgICAgICAgICAgd2FpdC5hZGQobWFpblRleHQudHJhbnNpdGlvbigpLmF0dHIoJ3RyYW5zZm9ybScsIHRyYW5zZm9ybSkpO1xuICAgICAgICAgICAgICAgIHdhaXQuYWRkKG1haW5SZWdpb24uZmlsdGVyKCQkLmlzUmVnaW9uT25YKS50cmFuc2l0aW9uKCkuYXR0cigndHJhbnNmb3JtJywgdHJhbnNmb3JtKSk7XG4gICAgICAgICAgICAgICAgd2FpdC5hZGQoeGdyaWQudHJhbnNpdGlvbigpLmF0dHIoJ3RyYW5zZm9ybScsIHRyYW5zZm9ybSkpO1xuICAgICAgICAgICAgICAgIHdhaXQuYWRkKHhncmlkTGluZXMudHJhbnNpdGlvbigpLmF0dHIoJ3RyYW5zZm9ybScsIHRyYW5zZm9ybSkpO1xuICAgICAgICAgICAgfSkuY2FsbCh3YWl0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlcyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0cyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBldmVudFJlY3RzID0gW107XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZmxvd2VkIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgaWYgKGZsb3dMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGZsb3dMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGVzLnB1c2goJy4nICsgQ0xBU1Muc2hhcGUgKyAnLScgKyAoZmxvd0luZGV4ICsgaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHMucHVzaCgnLicgKyBDTEFTUy50ZXh0ICsgJy0nICsgKGZsb3dJbmRleCArIGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50UmVjdHMucHVzaCgnLicgKyBDTEFTUy5ldmVudFJlY3QgKyAnLScgKyAoZmxvd0luZGV4ICsgaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICQkLnN2Zy5zZWxlY3RBbGwoJy4nICsgQ0xBU1Muc2hhcGVzKS5zZWxlY3RBbGwoc2hhcGVzKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgJCQuc3ZnLnNlbGVjdEFsbCgnLicgKyBDTEFTUy50ZXh0cykuc2VsZWN0QWxsKHRleHRzKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgJCQuc3ZnLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5ldmVudFJlY3RzKS5zZWxlY3RBbGwoZXZlbnRSZWN0cykucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICQkLnN2Zy5zZWxlY3QoJy4nICsgQ0xBU1MueGdyaWQpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGRyYXcgYWdhaW4gZm9yIHJlbW92aW5nIGZsb3dlZCBlbGVtZW50cyBhbmQgcmV2ZXJ0aW5nIGF0dHJcbiAgICAgICAgICAgICAgICB4Z3JpZC5hdHRyKCd0cmFuc2Zvcm0nLCBudWxsKS5hdHRyKCQkLnhncmlkQXR0cik7XG4gICAgICAgICAgICAgICAgeGdyaWRMaW5lcy5hdHRyKCd0cmFuc2Zvcm0nLCBudWxsKTtcbiAgICAgICAgICAgICAgICB4Z3JpZExpbmVzLnNlbGVjdCgnbGluZScpLmF0dHIoXCJ4MVwiLCBjb25maWcuYXhpc19yb3RhdGVkID8gMCA6IHh2KS5hdHRyKFwieDJcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/ICQkLndpZHRoIDogeHYpO1xuICAgICAgICAgICAgICAgIHhncmlkTGluZXMuc2VsZWN0KCd0ZXh0JykuYXR0cihcInhcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/ICQkLndpZHRoIDogMCkuYXR0cihcInlcIiwgeHYpO1xuICAgICAgICAgICAgICAgIG1haW5CYXIuYXR0cigndHJhbnNmb3JtJywgbnVsbCkuYXR0cihcImRcIiwgZHJhd0Jhcik7XG4gICAgICAgICAgICAgICAgbWFpbkxpbmUuYXR0cigndHJhbnNmb3JtJywgbnVsbCkuYXR0cihcImRcIiwgZHJhd0xpbmUpO1xuICAgICAgICAgICAgICAgIG1haW5BcmVhLmF0dHIoJ3RyYW5zZm9ybScsIG51bGwpLmF0dHIoXCJkXCIsIGRyYXdBcmVhKTtcbiAgICAgICAgICAgICAgICBtYWluQ2lyY2xlLmF0dHIoJ3RyYW5zZm9ybScsIG51bGwpLmF0dHIoXCJjeFwiLCBjeCkuYXR0cihcImN5XCIsIGN5KTtcbiAgICAgICAgICAgICAgICBtYWluVGV4dC5hdHRyKCd0cmFuc2Zvcm0nLCBudWxsKS5hdHRyKCd4JywgeEZvclRleHQpLmF0dHIoJ3knLCB5Rm9yVGV4dCkuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsICQkLm9wYWNpdHlGb3JUZXh0LmJpbmQoJCQpKTtcbiAgICAgICAgICAgICAgICBtYWluUmVnaW9uLmF0dHIoJ3RyYW5zZm9ybScsIG51bGwpO1xuICAgICAgICAgICAgICAgIG1haW5SZWdpb24uc2VsZWN0KCdyZWN0JykuZmlsdGVyKCQkLmlzUmVnaW9uT25YKS5hdHRyKFwieFwiLCAkJC5yZWdpb25YLmJpbmQoJCQpKS5hdHRyKFwid2lkdGhcIiwgJCQucmVnaW9uV2lkdGguYmluZCgkJCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICQkLnJlZHJhd0V2ZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrIGZvciBlbmQgb2YgZmxvd1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcblxuICAgICAgICAgICAgICAgICQkLmZsb3dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBjM19jaGFydF9mbi5mb2N1cyA9IGZ1bmN0aW9uICh0YXJnZXRJZHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgICAgIGNhbmRpZGF0ZXM7XG5cbiAgICAgICAgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKTtcbiAgICAgICAgY2FuZGlkYXRlcyA9ICQkLnN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKHRhcmdldElkcy5maWx0ZXIoJCQuaXNUYXJnZXRUb1Nob3csICQkKSkpLCB0aGlzLnJldmVydCgpO1xuICAgICAgICB0aGlzLmRlZm9jdXMoKTtcbiAgICAgICAgY2FuZGlkYXRlcy5jbGFzc2VkKENMQVNTLmZvY3VzZWQsIHRydWUpLmNsYXNzZWQoQ0xBU1MuZGVmb2N1c2VkLCBmYWxzZSk7XG4gICAgICAgIGlmICgkJC5oYXNBcmNUeXBlKCkpIHtcbiAgICAgICAgICAgICQkLmV4cGFuZEFyYyh0YXJnZXRJZHMpO1xuICAgICAgICB9XG4gICAgICAgICQkLnRvZ2dsZUZvY3VzTGVnZW5kKHRhcmdldElkcywgdHJ1ZSk7XG5cbiAgICAgICAgJCQuZm9jdXNlZFRhcmdldElkcyA9IHRhcmdldElkcztcbiAgICAgICAgJCQuZGVmb2N1c2VkVGFyZ2V0SWRzID0gJCQuZGVmb2N1c2VkVGFyZ2V0SWRzLmZpbHRlcihmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRJZHMuaW5kZXhPZihpZCkgPCAwO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfZm4uZGVmb2N1cyA9IGZ1bmN0aW9uICh0YXJnZXRJZHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgICAgIGNhbmRpZGF0ZXM7XG5cbiAgICAgICAgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKTtcbiAgICAgICAgY2FuZGlkYXRlcyA9ICQkLnN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKHRhcmdldElkcy5maWx0ZXIoJCQuaXNUYXJnZXRUb1Nob3csICQkKSkpLCBjYW5kaWRhdGVzLmNsYXNzZWQoQ0xBU1MuZm9jdXNlZCwgZmFsc2UpLmNsYXNzZWQoQ0xBU1MuZGVmb2N1c2VkLCB0cnVlKTtcbiAgICAgICAgaWYgKCQkLmhhc0FyY1R5cGUoKSkge1xuICAgICAgICAgICAgJCQudW5leHBhbmRBcmModGFyZ2V0SWRzKTtcbiAgICAgICAgfVxuICAgICAgICAkJC50b2dnbGVGb2N1c0xlZ2VuZCh0YXJnZXRJZHMsIGZhbHNlKTtcblxuICAgICAgICAkJC5mb2N1c2VkVGFyZ2V0SWRzID0gJCQuZm9jdXNlZFRhcmdldElkcy5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMDtcbiAgICAgICAgfSk7XG4gICAgICAgICQkLmRlZm9jdXNlZFRhcmdldElkcyA9IHRhcmdldElkcztcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfZm4ucmV2ZXJ0ID0gZnVuY3Rpb24gKHRhcmdldElkcykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICAgICAgY2FuZGlkYXRlcztcblxuICAgICAgICB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpO1xuICAgICAgICBjYW5kaWRhdGVzID0gJCQuc3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHModGFyZ2V0SWRzKSk7IC8vIHNob3VsZCBiZSBmb3IgYWxsIHRhcmdldHNcblxuICAgICAgICBjYW5kaWRhdGVzLmNsYXNzZWQoQ0xBU1MuZm9jdXNlZCwgZmFsc2UpLmNsYXNzZWQoQ0xBU1MuZGVmb2N1c2VkLCBmYWxzZSk7XG4gICAgICAgIGlmICgkJC5oYXNBcmNUeXBlKCkpIHtcbiAgICAgICAgICAgICQkLnVuZXhwYW5kQXJjKHRhcmdldElkcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCQkLmNvbmZpZy5sZWdlbmRfc2hvdykge1xuICAgICAgICAgICAgJCQuc2hvd0xlZ2VuZCh0YXJnZXRJZHMuZmlsdGVyKCQkLmlzTGVnZW5kVG9TaG93LmJpbmQoJCQpKSk7XG4gICAgICAgICAgICAkJC5sZWdlbmQuc2VsZWN0QWxsKCQkLnNlbGVjdG9yTGVnZW5kcyh0YXJnZXRJZHMpKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkJC5kMy5zZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZCk7XG4gICAgICAgICAgICB9KS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAkJC5mb2N1c2VkVGFyZ2V0SWRzID0gW107XG4gICAgICAgICQkLmRlZm9jdXNlZFRhcmdldElkcyA9IFtdO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9mbi54Z3JpZHMgPSBmdW5jdGlvbiAoZ3JpZHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAgICAgaWYgKCFncmlkcykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5ncmlkX3hfbGluZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLmdyaWRfeF9saW5lcyA9IGdyaWRzO1xuICAgICAgICAkJC5yZWRyYXdXaXRob3V0UmVzY2FsZSgpO1xuICAgICAgICByZXR1cm4gY29uZmlnLmdyaWRfeF9saW5lcztcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ZuLnhncmlkcy5hZGQgPSBmdW5jdGlvbiAoZ3JpZHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueGdyaWRzKCQkLmNvbmZpZy5ncmlkX3hfbGluZXMuY29uY2F0KGdyaWRzID8gZ3JpZHMgOiBbXSkpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfZm4ueGdyaWRzLnJlbW92ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgLy8gVE9ETzogbXVsdGlwbGVcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbDtcbiAgICAgICAgJCQucmVtb3ZlR3JpZExpbmVzKHBhcmFtcywgdHJ1ZSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ZuLnlncmlkcyA9IGZ1bmN0aW9uIChncmlkcykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICAgICBpZiAoIWdyaWRzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLmdyaWRfeV9saW5lcztcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuZ3JpZF95X2xpbmVzID0gZ3JpZHM7XG4gICAgICAgICQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XG4gICAgICAgIHJldHVybiBjb25maWcuZ3JpZF95X2xpbmVzO1xuICAgIH07XG4gICAgYzNfY2hhcnRfZm4ueWdyaWRzLmFkZCA9IGZ1bmN0aW9uIChncmlkcykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsO1xuICAgICAgICByZXR1cm4gdGhpcy55Z3JpZHMoJCQuY29uZmlnLmdyaWRfeV9saW5lcy5jb25jYXQoZ3JpZHMgPyBncmlkcyA6IFtdKSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9mbi55Z3JpZHMucmVtb3ZlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAvLyBUT0RPOiBtdWx0aXBsZVxuICAgICAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsO1xuICAgICAgICAkJC5yZW1vdmVHcmlkTGluZXMocGFyYW1zLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ZuLmdyb3VwcyA9IGZ1bmN0aW9uIChncm91cHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGdyb3VwcykpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuZGF0YV9ncm91cHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLmRhdGFfZ3JvdXBzID0gZ3JvdXBzO1xuICAgICAgICAkJC5yZWRyYXcoKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5kYXRhX2dyb3VwcztcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfZm4ubGVnZW5kID0gZnVuY3Rpb24gKCkge307XG4gICAgYzNfY2hhcnRfZm4ubGVnZW5kLnNob3cgPSBmdW5jdGlvbiAodGFyZ2V0SWRzKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWw7XG4gICAgICAgICQkLnNob3dMZWdlbmQoJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKSk7XG4gICAgICAgICQkLnVwZGF0ZUFuZFJlZHJhdyh7IHdpdGhMZWdlbmQ6IHRydWUgfSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9mbi5sZWdlbmQuaGlkZSA9IGZ1bmN0aW9uICh0YXJnZXRJZHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbDtcbiAgICAgICAgJCQuaGlkZUxlZ2VuZCgkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpKTtcbiAgICAgICAgJCQudXBkYXRlQW5kUmVkcmF3KHsgd2l0aExlZ2VuZDogdHJ1ZSB9KTtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfZm4ubG9hZCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWwsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgICAgIC8vIHVwZGF0ZSB4cyBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKGFyZ3MueHMpIHtcbiAgICAgICAgICAgICQkLmFkZFhzKGFyZ3MueHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBuYW1lcyBpZiBleGlzdHNcbiAgICAgICAgaWYgKCduYW1lcycgaW4gYXJncykge1xuICAgICAgICAgICAgYzNfY2hhcnRfZm4uZGF0YS5uYW1lcy5iaW5kKHRoaXMpKGFyZ3MubmFtZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBjbGFzc2VzIGlmIGV4aXN0c1xuICAgICAgICBpZiAoJ2NsYXNzZXMnIGluIGFyZ3MpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGFyZ3MuY2xhc3NlcykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZGF0YV9jbGFzc2VzW2lkXSA9IGFyZ3MuY2xhc3Nlc1tpZF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgY2F0ZWdvcmllcyBpZiBleGlzdHNcbiAgICAgICAgaWYgKCdjYXRlZ29yaWVzJyBpbiBhcmdzICYmICQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xuICAgICAgICAgICAgY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gYXJncy5jYXRlZ29yaWVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBheGVzIGlmIGV4aXN0c1xuICAgICAgICBpZiAoJ2F4ZXMnIGluIGFyZ3MpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGFyZ3MuYXhlcykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZGF0YV9heGVzW2lkXSA9IGFyZ3MuYXhlc1tpZF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgY29sb3JzIGlmIGV4aXN0c1xuICAgICAgICBpZiAoJ2NvbG9ycycgaW4gYXJncykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXJncy5jb2xvcnMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmRhdGFfY29sb3JzW2lkXSA9IGFyZ3MuY29sb3JzW2lkXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVzZSBjYWNoZSBpZiBleGlzdHNcbiAgICAgICAgaWYgKCdjYWNoZUlkcycgaW4gYXJncyAmJiAkJC5oYXNDYWNoZXMoYXJncy5jYWNoZUlkcykpIHtcbiAgICAgICAgICAgICQkLmxvYWQoJCQuZ2V0Q2FjaGVzKGFyZ3MuY2FjaGVJZHMpLCBhcmdzLmRvbmUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVubG9hZCBpZiBuZWVkZWRcbiAgICAgICAgaWYgKCd1bmxvYWQnIGluIGFyZ3MpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGRvIG5vdCB1bmxvYWQgaWYgdGFyZ2V0IHdpbGwgbG9hZCAoaW5jbHVkZWQgaW4gdXJsL3Jvd3MvY29sdW1ucylcbiAgICAgICAgICAgICQkLnVubG9hZCgkJC5tYXBUb1RhcmdldElkcyh0eXBlb2YgYXJncy51bmxvYWQgPT09ICdib29sZWFuJyAmJiBhcmdzLnVubG9hZCA/IG51bGwgOiBhcmdzLnVubG9hZCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkJC5sb2FkRnJvbUFyZ3MoYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQkLmxvYWRGcm9tQXJncyhhcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjM19jaGFydF9mbi51bmxvYWQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsO1xuICAgICAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICAgICAgaWYgKGFyZ3MgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgYXJncyA9IHsgaWRzOiBhcmdzIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhcmdzID0geyBpZHM6IFthcmdzXSB9O1xuICAgICAgICB9XG4gICAgICAgICQkLnVubG9hZCgkJC5tYXBUb1RhcmdldElkcyhhcmdzLmlkcyksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQkLnJlZHJhdyh7IHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLCB3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSwgd2l0aExlZ2VuZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGlmIChhcmdzLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBhcmdzLmRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ZuLnJlZ2lvbnMgPSBmdW5jdGlvbiAocmVnaW9ucykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICAgICBpZiAoIXJlZ2lvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcucmVnaW9ucztcbiAgICAgICAgfVxuICAgICAgICBjb25maWcucmVnaW9ucyA9IHJlZ2lvbnM7XG4gICAgICAgICQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XG4gICAgICAgIHJldHVybiBjb25maWcucmVnaW9ucztcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ZuLnJlZ2lvbnMuYWRkID0gZnVuY3Rpb24gKHJlZ2lvbnMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAgICAgaWYgKCFyZWdpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLnJlZ2lvbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLnJlZ2lvbnMgPSBjb25maWcucmVnaW9ucy5jb25jYXQocmVnaW9ucyk7XG4gICAgICAgICQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XG4gICAgICAgIHJldHVybiBjb25maWcucmVnaW9ucztcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ZuLnJlZ2lvbnMucmVtb3ZlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgY2xhc3NlcyxcbiAgICAgICAgICAgIHJlZ2lvbnM7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGR1cmF0aW9uID0gJCQuZ2V0T3B0aW9uKG9wdGlvbnMsIFwiZHVyYXRpb25cIiwgY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24pO1xuICAgICAgICBjbGFzc2VzID0gJCQuZ2V0T3B0aW9uKG9wdGlvbnMsIFwiY2xhc3Nlc1wiLCBbQ0xBU1MucmVnaW9uXSk7XG5cbiAgICAgICAgcmVnaW9ucyA9ICQkLm1haW4uc2VsZWN0KCcuJyArIENMQVNTLnJlZ2lvbnMpLnNlbGVjdEFsbChjbGFzc2VzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuICcuJyArIGM7XG4gICAgICAgIH0pKTtcbiAgICAgICAgKGR1cmF0aW9uID8gcmVnaW9ucy50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pIDogcmVnaW9ucykuc3R5bGUoJ29wYWNpdHknLCAwKS5yZW1vdmUoKTtcblxuICAgICAgICBjb25maWcucmVnaW9ucyA9IGNvbmZpZy5yZWdpb25zLmZpbHRlcihmdW5jdGlvbiAocmVnaW9uKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghcmVnaW9uWydjbGFzcyddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWdpb25bJ2NsYXNzJ10uc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsYXNzZXMuaW5kZXhPZihjKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAhZm91bmQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjb25maWcucmVnaW9ucztcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfZm4uc2VsZWN0ZWQgPSBmdW5jdGlvbiAodGFyZ2V0SWQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgICAgIGQzID0gJCQuZDM7XG4gICAgICAgIHJldHVybiBkMy5tZXJnZSgkJC5tYWluLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5zaGFwZXMgKyAkJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCh0YXJnZXRJZCkpLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5zaGFwZSkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkMy5zZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCk7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBkLl9fZGF0YV9fO3JldHVybiBkYXRhLmRhdGEgPyBkYXRhLmRhdGEgOiBkYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ZuLnNlbGVjdCA9IGZ1bmN0aW9uIChpZHMsIGluZGljZXMsIHJlc2V0T3RoZXIpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgICAgIGQzID0gJCQuZDMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgICAgIGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAkJC5tYWluLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5zaGFwZXMpLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5zaGFwZSkuZWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gZDMuc2VsZWN0KHRoaXMpLFxuICAgICAgICAgICAgICAgIGlkID0gZC5kYXRhID8gZC5kYXRhLmlkIDogZC5pZCxcbiAgICAgICAgICAgICAgICB0b2dnbGUgPSAkJC5nZXRUb2dnbGUodGhpcywgZCkuYmluZCgkJCksXG4gICAgICAgICAgICAgICAgaXNUYXJnZXRJZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkIHx8ICFpZHMgfHwgaWRzLmluZGV4T2YoaWQpID49IDAsXG4gICAgICAgICAgICAgICAgaXNUYXJnZXRJbmRleCA9ICFpbmRpY2VzIHx8IGluZGljZXMuaW5kZXhPZihpKSA+PSAwLFxuICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcbiAgICAgICAgICAgIC8vIGxpbmUvYXJlYSBzZWxlY3Rpb24gbm90IHN1cHBvcnRlZCB5ZXRcbiAgICAgICAgICAgIGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmxpbmUpIHx8IHNoYXBlLmNsYXNzZWQoQ0xBU1MuYXJlYSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNUYXJnZXRJZCAmJiBpc1RhcmdldEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkgJiYgIWlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlKHRydWUsIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsIHRydWUpLCBkLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRGVmaW5lZChyZXNldE90aGVyKSAmJiByZXNldE90aGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlKGZhbHNlLCBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCBmYWxzZSksIGQsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9mbi51bnNlbGVjdCA9IGZ1bmN0aW9uIChpZHMsIGluZGljZXMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgICAgIGQzID0gJCQuZDMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgICAgIGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAkJC5tYWluLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5zaGFwZXMpLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5zaGFwZSkuZWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gZDMuc2VsZWN0KHRoaXMpLFxuICAgICAgICAgICAgICAgIGlkID0gZC5kYXRhID8gZC5kYXRhLmlkIDogZC5pZCxcbiAgICAgICAgICAgICAgICB0b2dnbGUgPSAkJC5nZXRUb2dnbGUodGhpcywgZCkuYmluZCgkJCksXG4gICAgICAgICAgICAgICAgaXNUYXJnZXRJZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkIHx8ICFpZHMgfHwgaWRzLmluZGV4T2YoaWQpID49IDAsXG4gICAgICAgICAgICAgICAgaXNUYXJnZXRJbmRleCA9ICFpbmRpY2VzIHx8IGluZGljZXMuaW5kZXhPZihpKSA+PSAwLFxuICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcbiAgICAgICAgICAgIC8vIGxpbmUvYXJlYSBzZWxlY3Rpb24gbm90IHN1cHBvcnRlZCB5ZXRcbiAgICAgICAgICAgIGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmxpbmUpIHx8IHNoYXBlLmNsYXNzZWQoQ0xBU1MuYXJlYSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNUYXJnZXRJZCAmJiBpc1RhcmdldEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZShmYWxzZSwgc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgZmFsc2UpLCBkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ZuLnNob3cgPSBmdW5jdGlvbiAodGFyZ2V0SWRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWwsXG4gICAgICAgICAgICB0YXJnZXRzO1xuXG4gICAgICAgIHRhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcyk7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICQkLnJlbW92ZUhpZGRlblRhcmdldElkcyh0YXJnZXRJZHMpO1xuICAgICAgICB0YXJnZXRzID0gJCQuc3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHModGFyZ2V0SWRzKSk7XG5cbiAgICAgICAgdGFyZ2V0cy50cmFuc2l0aW9uKCkuc3R5bGUoJ29wYWNpdHknLCAxLCAnaW1wb3J0YW50JykuY2FsbCgkJC5lbmRhbGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRhcmdldHMuc3R5bGUoJ29wYWNpdHknLCBudWxsKS5zdHlsZSgnb3BhY2l0eScsIDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob3B0aW9ucy53aXRoTGVnZW5kKSB7XG4gICAgICAgICAgICAkJC5zaG93TGVnZW5kKHRhcmdldElkcyk7XG4gICAgICAgIH1cblxuICAgICAgICAkJC5yZWRyYXcoeyB3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSwgd2l0aFVwZGF0ZVhEb21haW46IHRydWUsIHdpdGhMZWdlbmQ6IHRydWUgfSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ZuLmhpZGUgPSBmdW5jdGlvbiAodGFyZ2V0SWRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWwsXG4gICAgICAgICAgICB0YXJnZXRzO1xuXG4gICAgICAgIHRhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcyk7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICQkLmFkZEhpZGRlblRhcmdldElkcyh0YXJnZXRJZHMpO1xuICAgICAgICB0YXJnZXRzID0gJCQuc3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHModGFyZ2V0SWRzKSk7XG5cbiAgICAgICAgdGFyZ2V0cy50cmFuc2l0aW9uKCkuc3R5bGUoJ29wYWNpdHknLCAwLCAnaW1wb3J0YW50JykuY2FsbCgkJC5lbmRhbGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRhcmdldHMuc3R5bGUoJ29wYWNpdHknLCBudWxsKS5zdHlsZSgnb3BhY2l0eScsIDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob3B0aW9ucy53aXRoTGVnZW5kKSB7XG4gICAgICAgICAgICAkJC5oaWRlTGVnZW5kKHRhcmdldElkcyk7XG4gICAgICAgIH1cblxuICAgICAgICAkJC5yZWRyYXcoeyB3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSwgd2l0aFVwZGF0ZVhEb21haW46IHRydWUsIHdpdGhMZWdlbmQ6IHRydWUgfSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ZuLnRvZ2dsZSA9IGZ1bmN0aW9uICh0YXJnZXRJZHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgJCQgPSB0aGlzLmludGVybmFsO1xuICAgICAgICAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldElkKSB7XG4gICAgICAgICAgICAkJC5pc1RhcmdldFRvU2hvdyh0YXJnZXRJZCkgPyB0aGF0LmhpZGUodGFyZ2V0SWQsIG9wdGlvbnMpIDogdGhhdC5zaG93KHRhcmdldElkLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ZuLnRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBjM19jaGFydF9mbi50b29sdGlwLnNob3cgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBtb3VzZTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgbW91c2UgcG9zaXRpb24gb24gdGhlIGNoYXJ0XG4gICAgICAgIGlmIChhcmdzLm1vdXNlKSB7XG4gICAgICAgICAgICBtb3VzZSA9IGFyZ3MubW91c2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXRlcm1pbmUgZm9jdXMgZGF0YVxuICAgICAgICBpZiAoYXJncy5kYXRhKSB7XG4gICAgICAgICAgICBpZiAoJCQuaXNNdWx0aXBsZVgoKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIG11bHRpcGxlIHhzLCB0YXJnZXQgcG9pbnQgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IG1vdXNlXG4gICAgICAgICAgICAgICAgbW91c2UgPSBbJCQueChhcmdzLmRhdGEueCksICQkLmdldFlTY2FsZShhcmdzLmRhdGEuaWQpKGFyZ3MuZGF0YS52YWx1ZSldO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2hlbiB0b29sdGlwX2dyb3VwZWQgPSBmYWxzZVxuICAgICAgICAgICAgICAgIGluZGV4ID0gaXNWYWx1ZShhcmdzLmRhdGEuaW5kZXgpID8gYXJncy5kYXRhLmluZGV4IDogJCQuZ2V0SW5kZXhCeVgoYXJncy5kYXRhLngpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmdzLnggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpbmRleCA9ICQkLmdldEluZGV4QnlYKGFyZ3MueCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3MuaW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpbmRleCA9IGFyZ3MuaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbXVsYXRlIG1vdXNlIGV2ZW50cyB0byBzaG93XG4gICAgICAgICQkLmRpc3BhdGNoRXZlbnQoJ21vdXNlb3ZlcicsIGluZGV4LCBtb3VzZSk7XG4gICAgICAgICQkLmRpc3BhdGNoRXZlbnQoJ21vdXNlbW92ZScsIGluZGV4LCBtb3VzZSk7XG5cbiAgICAgICAgJCQuY29uZmlnLnRvb2x0aXBfb25zaG93LmNhbGwoJCQsIGFyZ3MuZGF0YSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9mbi50b29sdGlwLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE86IGdldCB0YXJnZXQgZGF0YSBieSBjaGVja2luZyB0aGUgc3RhdGUgb2YgZm9jdXNcbiAgICAgICAgdGhpcy5pbnRlcm5hbC5kaXNwYXRjaEV2ZW50KCdtb3VzZW91dCcsIDApO1xuXG4gICAgICAgIHRoaXMuaW50ZXJuYWwuY29uZmlnLnRvb2x0aXBfb25oaWRlLmNhbGwodGhpcyk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ZuLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0eXBlLCB0YXJnZXRJZHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbCxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBbJ3BpZScsICdkb251dCddLmluZGV4T2YodHlwZSkgPj0gMCA/IHsgd2l0aFRyYW5zZm9ybTogdHJ1ZSB9IDogbnVsbDtcbiAgICAgICAgJCQudHJhbnNmb3JtVG8odGFyZ2V0SWRzLCB0eXBlLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udHJhbnNmb3JtVG8gPSBmdW5jdGlvbiAodGFyZ2V0SWRzLCB0eXBlLCBvcHRpb25zRm9yUmVkcmF3KSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICB3aXRoVHJhbnNpdGlvbkZvckF4aXMgPSAhJCQuaGFzQXJjVHlwZSgpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNGb3JSZWRyYXcgfHwgeyB3aXRoVHJhbnNpdGlvbkZvckF4aXM6IHdpdGhUcmFuc2l0aW9uRm9yQXhpcyB9O1xuICAgICAgICBvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtID0gZmFsc2U7XG4gICAgICAgICQkLnRyYW5zaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgJCQuc2V0VGFyZ2V0VHlwZSh0YXJnZXRJZHMsIHR5cGUpO1xuICAgICAgICAkJC51cGRhdGVUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cyk7IC8vIHRoaXMgaXMgbmVlZGVkIHdoZW4gdHJhbnNmb3JtaW5nIHRvIGFyY1xuICAgICAgICAkJC51cGRhdGVBbmRSZWRyYXcob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ZuLnggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgJCQudXBkYXRlVGFyZ2V0WCgkJC5kYXRhLnRhcmdldHMsIHgpO1xuICAgICAgICAgICAgJCQucmVkcmF3KHsgd2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsIHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkJC5kYXRhLnhzO1xuICAgIH07XG4gICAgYzNfY2hhcnRfZm4ueHMgPSBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICQkLnVwZGF0ZVRhcmdldFhzKCQkLmRhdGEudGFyZ2V0cywgeHMpO1xuICAgICAgICAgICAgJCQucmVkcmF3KHsgd2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsIHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkJC5kYXRhLnhzO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9mbi56b29tID0gZnVuY3Rpb24gKGRvbWFpbikge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsO1xuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICBpZiAoJCQuaXNUaW1lU2VyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBkb21haW4gPSBkb21haW4ubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkJC5wYXJzZURhdGUoeCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkJC5icnVzaC5leHRlbnQoZG9tYWluKTtcbiAgICAgICAgICAgICQkLnJlZHJhdyh7IHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLCB3aXRoWTogJCQuY29uZmlnLnpvb21fcmVzY2FsZSB9KTtcbiAgICAgICAgICAgICQkLmNvbmZpZy56b29tX29uem9vbS5jYWxsKHRoaXMsICQkLngub3JnRG9tYWluKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkJC5icnVzaC5leHRlbnQoKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ZuLnpvb20uZW5hYmxlID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcy5pbnRlcm5hbDtcbiAgICAgICAgJCQuY29uZmlnLnpvb21fZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgICQkLnVwZGF0ZUFuZFJlZHJhdygpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfZm4udW56b29tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsO1xuICAgICAgICAkJC5icnVzaC5jbGVhcigpLnVwZGF0ZSgpO1xuICAgICAgICAkJC5yZWRyYXcoeyB3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSB9KTtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfZm4uem9vbS5tYXggPSBmdW5jdGlvbiAobWF4KSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMuaW50ZXJuYWwsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBkMyA9ICQkLmQzO1xuICAgICAgICBpZiAobWF4ID09PSAwIHx8IG1heCkge1xuICAgICAgICAgICAgY29uZmlnLnpvb21feF9tYXggPSBkMy5tYXgoWyQkLm9yZ1hEb21haW5bMV0sIG1heF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy56b29tX3hfbWF4O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ZuLnpvb20ubWluID0gZnVuY3Rpb24gKG1pbikge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLmludGVybmFsLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgZDMgPSAkJC5kMztcbiAgICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy56b29tX3hfbWluID0gZDMubWluKFskJC5vcmdYRG9tYWluWzBdLCBtaW5dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuem9vbV94X21pbjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjM19jaGFydF9mbi56b29tLnJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHJhbmdlLm1heCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbWFpbi5tYXgocmFuZ2UubWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmFuZ2UubWluKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tYWluLm1pbihyYW5nZS5taW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtYXg6IHRoaXMuZG9tYWluLm1heCgpLFxuICAgICAgICAgICAgICAgIG1pbjogdGhpcy5kb21haW4ubWluKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaW5pdFBpZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGQzID0gJCQuZDM7XG4gICAgICAgICQkLnBpZSA9IGQzLmxheW91dC5waWUoKS52YWx1ZShmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQudmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhICsgYi52YWx1ZTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9KTtcbiAgICAgICAgJCQucGllLnNvcnQoJCQuZ2V0T3JkZXJGdW5jdGlvbigpIHx8IG51bGwpO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi51cGRhdGVSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICB3ID0gY29uZmlnLmdhdWdlX3dpZHRoIHx8IGNvbmZpZy5kb251dF93aWR0aCxcbiAgICAgICAgICAgIGdhdWdlQXJjV2lkdGggPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykubGVuZ3RoICogJCQuY29uZmlnLmdhdWdlX2FyY3NfbWluV2lkdGg7XG4gICAgICAgICQkLnJhZGl1c0V4cGFuZGVkID0gTWF0aC5taW4oJCQuYXJjV2lkdGgsICQkLmFyY0hlaWdodCkgLyAyICogKCQkLmhhc1R5cGUoJ2dhdWdlJykgPyAwLjg1IDogMSk7XG4gICAgICAgICQkLnJhZGl1cyA9ICQkLnJhZGl1c0V4cGFuZGVkICogMC45NTtcbiAgICAgICAgJCQuaW5uZXJSYWRpdXNSYXRpbyA9IHcgPyAoJCQucmFkaXVzIC0gdykgLyAkJC5yYWRpdXMgOiAwLjY7XG4gICAgICAgICQkLmlubmVyUmFkaXVzID0gJCQuaGFzVHlwZSgnZG9udXQnKSB8fCAkJC5oYXNUeXBlKCdnYXVnZScpID8gJCQucmFkaXVzICogJCQuaW5uZXJSYWRpdXNSYXRpbyA6IDA7XG4gICAgICAgICQkLmdhdWdlQXJjV2lkdGggPSB3ID8gdyA6IGdhdWdlQXJjV2lkdGggPD0gJCQucmFkaXVzIC0gJCQuaW5uZXJSYWRpdXMgPyAkJC5yYWRpdXMgLSAkJC5pbm5lclJhZGl1cyA6IGdhdWdlQXJjV2lkdGggPD0gJCQucmFkaXVzID8gZ2F1Z2VBcmNXaWR0aCA6ICQkLnJhZGl1cztcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udXBkYXRlQXJjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICAkJC5zdmdBcmMgPSAkJC5nZXRTdmdBcmMoKTtcbiAgICAgICAgJCQuc3ZnQXJjRXhwYW5kZWQgPSAkJC5nZXRTdmdBcmNFeHBhbmRlZCgpO1xuICAgICAgICAkJC5zdmdBcmNFeHBhbmRlZFN1YiA9ICQkLmdldFN2Z0FyY0V4cGFuZGVkKDAuOTgpO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi51cGRhdGVBbmdsZSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBmb3VuZCA9IGZhbHNlLFxuICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgZ01pbixcbiAgICAgICAgICAgIGdNYXgsXG4gICAgICAgICAgICBnVGljLFxuICAgICAgICAgICAgZ1ZhbHVlO1xuXG4gICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgICQkLnBpZSgkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykpLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGlmICghZm91bmQgJiYgdC5kYXRhLmlkID09PSBkLmRhdGEuaWQpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZCA9IHQ7XG4gICAgICAgICAgICAgICAgZC5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc05hTihkLnN0YXJ0QW5nbGUpKSB7XG4gICAgICAgICAgICBkLnN0YXJ0QW5nbGUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hTihkLmVuZEFuZ2xlKSkge1xuICAgICAgICAgICAgZC5lbmRBbmdsZSA9IGQuc3RhcnRBbmdsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJCQuaXNHYXVnZVR5cGUoZC5kYXRhKSkge1xuICAgICAgICAgICAgZ01pbiA9IGNvbmZpZy5nYXVnZV9taW47XG4gICAgICAgICAgICBnTWF4ID0gY29uZmlnLmdhdWdlX21heDtcbiAgICAgICAgICAgIGdUaWMgPSBNYXRoLlBJICogKGNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMiA6IDEpIC8gKGdNYXggLSBnTWluKTtcbiAgICAgICAgICAgIGdWYWx1ZSA9IGQudmFsdWUgPCBnTWluID8gMCA6IGQudmFsdWUgPCBnTWF4ID8gZC52YWx1ZSAtIGdNaW4gOiBnTWF4IC0gZ01pbjtcbiAgICAgICAgICAgIGQuc3RhcnRBbmdsZSA9IGNvbmZpZy5nYXVnZV9zdGFydGluZ0FuZ2xlO1xuICAgICAgICAgICAgZC5lbmRBbmdsZSA9IGQuc3RhcnRBbmdsZSArIGdUaWMgKiBnVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kID8gZCA6IG51bGw7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldFN2Z0FyYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGhhc0dhdWdlVHlwZSA9ICQkLmhhc1R5cGUoJ2dhdWdlJyksXG4gICAgICAgICAgICBzaW5nbGVBcmNXaWR0aCA9ICQkLmdhdWdlQXJjV2lkdGggLyAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykubGVuZ3RoLFxuICAgICAgICAgICAgYXJjID0gJCQuZDMuc3ZnLmFyYygpLm91dGVyUmFkaXVzKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzR2F1Z2VUeXBlID8gJCQucmFkaXVzIC0gc2luZ2xlQXJjV2lkdGggKiBkLmluZGV4IDogJCQucmFkaXVzO1xuICAgICAgICB9KS5pbm5lclJhZGl1cyhmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhc0dhdWdlVHlwZSA/ICQkLnJhZGl1cyAtIHNpbmdsZUFyY1dpZHRoICogKGQuaW5kZXggKyAxKSA6ICQkLmlubmVyUmFkaXVzO1xuICAgICAgICB9KSxcbiAgICAgICAgICAgIG5ld0FyYyA9IGZ1bmN0aW9uIG5ld0FyYyhkLCB3aXRob3V0VXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlZDtcbiAgICAgICAgICAgIGlmICh3aXRob3V0VXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyYyhkKTtcbiAgICAgICAgICAgIH0gLy8gZm9yIGludGVycG9sYXRlXG4gICAgICAgICAgICB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlZCA/IGFyYyh1cGRhdGVkKSA6IFwiTSAwIDBcIjtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETzogZXh0ZW5kcyBhbGwgZnVuY3Rpb25cbiAgICAgICAgbmV3QXJjLmNlbnRyb2lkID0gYXJjLmNlbnRyb2lkO1xuICAgICAgICByZXR1cm4gbmV3QXJjO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRTdmdBcmNFeHBhbmRlZCA9IGZ1bmN0aW9uIChyYXRlKSB7XG4gICAgICAgIHJhdGUgPSByYXRlIHx8IDE7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBoYXNHYXVnZVR5cGUgPSAkJC5oYXNUeXBlKCdnYXVnZScpLFxuICAgICAgICAgICAgc2luZ2xlQXJjV2lkdGggPSAkJC5nYXVnZUFyY1dpZHRoIC8gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aCxcbiAgICAgICAgICAgIGV4cGFuZFdpZHRoID0gTWF0aC5taW4oJCQucmFkaXVzRXhwYW5kZWQgKiByYXRlIC0gJCQucmFkaXVzLCBzaW5nbGVBcmNXaWR0aCAqIDAuOCAtICgxIC0gcmF0ZSkgKiAxMDApLFxuICAgICAgICAgICAgYXJjID0gJCQuZDMuc3ZnLmFyYygpLm91dGVyUmFkaXVzKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzR2F1Z2VUeXBlID8gJCQucmFkaXVzIC0gc2luZ2xlQXJjV2lkdGggKiBkLmluZGV4ICsgZXhwYW5kV2lkdGggOiAkJC5yYWRpdXNFeHBhbmRlZCAqIHJhdGU7XG4gICAgICAgIH0pLmlubmVyUmFkaXVzKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzR2F1Z2VUeXBlID8gJCQucmFkaXVzIC0gc2luZ2xlQXJjV2lkdGggKiAoZC5pbmRleCArIDEpIDogJCQuaW5uZXJSYWRpdXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlZCA/IGFyYyh1cGRhdGVkKSA6IFwiTSAwIDBcIjtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0QXJjID0gZnVuY3Rpb24gKGQsIHdpdGhvdXRVcGRhdGUsIGZvcmNlKSB7XG4gICAgICAgIHJldHVybiBmb3JjZSB8fCB0aGlzLmlzQXJjVHlwZShkLmRhdGEpID8gdGhpcy5zdmdBcmMoZCwgd2l0aG91dFVwZGF0ZSkgOiBcIk0gMCAwXCI7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnRyYW5zZm9ybUZvckFyY0xhYmVsID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKSxcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIGgsXG4gICAgICAgICAgICByYXRpbyxcbiAgICAgICAgICAgIHRyYW5zbGF0ZSA9IFwiXCIsXG4gICAgICAgICAgICBoYXNHYXVnZSA9ICQkLmhhc1R5cGUoJ2dhdWdlJyk7XG4gICAgICAgIGlmICh1cGRhdGVkICYmICFoYXNHYXVnZSkge1xuICAgICAgICAgICAgYyA9IHRoaXMuc3ZnQXJjLmNlbnRyb2lkKHVwZGF0ZWQpO1xuICAgICAgICAgICAgeCA9IGlzTmFOKGNbMF0pID8gMCA6IGNbMF07XG4gICAgICAgICAgICB5ID0gaXNOYU4oY1sxXSkgPyAwIDogY1sxXTtcbiAgICAgICAgICAgIGggPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgICAgICAgICBpZiAoJCQuaGFzVHlwZSgnZG9udXQnKSAmJiBjb25maWcuZG9udXRfbGFiZWxfcmF0aW8pIHtcbiAgICAgICAgICAgICAgICByYXRpbyA9IGlzRnVuY3Rpb24oY29uZmlnLmRvbnV0X2xhYmVsX3JhdGlvKSA/IGNvbmZpZy5kb251dF9sYWJlbF9yYXRpbyhkLCAkJC5yYWRpdXMsIGgpIDogY29uZmlnLmRvbnV0X2xhYmVsX3JhdGlvO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkJC5oYXNUeXBlKCdwaWUnKSAmJiBjb25maWcucGllX2xhYmVsX3JhdGlvKSB7XG4gICAgICAgICAgICAgICAgcmF0aW8gPSBpc0Z1bmN0aW9uKGNvbmZpZy5waWVfbGFiZWxfcmF0aW8pID8gY29uZmlnLnBpZV9sYWJlbF9yYXRpbyhkLCAkJC5yYWRpdXMsIGgpIDogY29uZmlnLnBpZV9sYWJlbF9yYXRpbztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmF0aW8gPSAkJC5yYWRpdXMgJiYgaCA/ICgzNiAvICQkLnJhZGl1cyA+IDAuMzc1ID8gMS4xNzUgLSAzNiAvICQkLnJhZGl1cyA6IDAuOCkgKiAkJC5yYWRpdXMgLyBoIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zbGF0ZSA9IFwidHJhbnNsYXRlKFwiICsgeCAqIHJhdGlvICsgJywnICsgeSAqIHJhdGlvICsgXCIpXCI7XG4gICAgICAgIH0gZWxzZSBpZiAodXBkYXRlZCAmJiBoYXNHYXVnZSAmJiAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIHkxID0gTWF0aC5zaW4odXBkYXRlZC5lbmRBbmdsZSAtIE1hdGguUEkgLyAyKTtcbiAgICAgICAgICAgIHggPSBNYXRoLmNvcyh1cGRhdGVkLmVuZEFuZ2xlIC0gTWF0aC5QSSAvIDIpICogKCQkLnJhZGl1c0V4cGFuZGVkICsgMjUpO1xuICAgICAgICAgICAgeSA9IHkxICogKCQkLnJhZGl1c0V4cGFuZGVkICsgMTUgLSBNYXRoLmFicyh5MSAqIDEwKSkgKyAzO1xuICAgICAgICAgICAgdHJhbnNsYXRlID0gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgJywnICsgeSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2xhdGU7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldEFyY1JhdGlvID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIHdob2xlID0gTWF0aC5QSSAqICgkJC5oYXNUeXBlKCdnYXVnZScpICYmICFjb25maWcuZ2F1Z2VfZnVsbENpcmNsZSA/IDEgOiAyKTtcbiAgICAgICAgcmV0dXJuIGQgPyAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyB3aG9sZSA6IG51bGw7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmNvbnZlcnRUb0FyY0RhdGEgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROYW1lKHtcbiAgICAgICAgICAgIGlkOiBkLmRhdGEuaWQsXG4gICAgICAgICAgICB2YWx1ZTogZC52YWx1ZSxcbiAgICAgICAgICAgIHJhdGlvOiB0aGlzLmdldEFyY1JhdGlvKGQpLFxuICAgICAgICAgICAgaW5kZXg6IGQuaW5kZXhcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnRleHRGb3JBcmNMYWJlbCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICB1cGRhdGVkLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICByYXRpbyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgZm9ybWF0O1xuICAgICAgICBpZiAoISQkLnNob3VsZFNob3dBcmNMYWJlbCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XG4gICAgICAgIHZhbHVlID0gdXBkYXRlZCA/IHVwZGF0ZWQudmFsdWUgOiBudWxsO1xuICAgICAgICByYXRpbyA9ICQkLmdldEFyY1JhdGlvKHVwZGF0ZWQpO1xuICAgICAgICBpZCA9IGQuZGF0YS5pZDtcbiAgICAgICAgaWYgKCEkJC5oYXNUeXBlKCdnYXVnZScpICYmICEkJC5tZWV0c0FyY0xhYmVsVGhyZXNob2xkKHJhdGlvKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0ID0gJCQuZ2V0QXJjTGFiZWxGb3JtYXQoKTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdCA/IGZvcm1hdCh2YWx1ZSwgcmF0aW8sIGlkKSA6ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdCh2YWx1ZSwgcmF0aW8pO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi50ZXh0Rm9yR2F1Z2VNaW5NYXggPSBmdW5jdGlvbiAodmFsdWUsIGlzTWF4KSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBmb3JtYXQgPSAkJC5nZXRHYXVnZUxhYmVsRXh0ZW50cygpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXQgPyBmb3JtYXQodmFsdWUsIGlzTWF4KSA6IHZhbHVlO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5leHBhbmRBcmMgPSBmdW5jdGlvbiAodGFyZ2V0SWRzKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBpbnRlcnZhbDtcblxuICAgICAgICAvLyBNRU1POiBhdm9pZCB0byBjYW5jZWwgdHJhbnNpdGlvblxuICAgICAgICBpZiAoJCQudHJhbnNpdGluZykge1xuICAgICAgICAgICAgaW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghJCQudHJhbnNpdGluZykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkJC5sZWdlbmQuc2VsZWN0QWxsKCcuYzMtbGVnZW5kLWl0ZW0tZm9jdXNlZCcpLnNpemUoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQkLmV4cGFuZEFyYyh0YXJnZXRJZHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKTtcblxuICAgICAgICAkJC5zdmcuc2VsZWN0QWxsKCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMsICcuJyArIENMQVNTLmNoYXJ0QXJjKSkuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgaWYgKCEkJC5zaG91bGRFeHBhbmQoZC5kYXRhLmlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQkLmQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoJ3BhdGgnKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oJCQuZXhwYW5kRHVyYXRpb24oZC5kYXRhLmlkKSkuYXR0cihcImRcIiwgJCQuc3ZnQXJjRXhwYW5kZWQpLnRyYW5zaXRpb24oKS5kdXJhdGlvbigkJC5leHBhbmREdXJhdGlvbihkLmRhdGEuaWQpICogMikuYXR0cihcImRcIiwgJCQuc3ZnQXJjRXhwYW5kZWRTdWIpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoJCQuaXNEb251dFR5cGUoZC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsYmFjayBoZXJlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi51bmV4cGFuZEFyYyA9IGZ1bmN0aW9uICh0YXJnZXRJZHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcblxuICAgICAgICBpZiAoJCQudHJhbnNpdGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKTtcblxuICAgICAgICAkJC5zdmcuc2VsZWN0QWxsKCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMsICcuJyArIENMQVNTLmNoYXJ0QXJjKSkuc2VsZWN0QWxsKCdwYXRoJykudHJhbnNpdGlvbigpLmR1cmF0aW9uKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gJCQuZXhwYW5kRHVyYXRpb24oZC5kYXRhLmlkKTtcbiAgICAgICAgfSkuYXR0cihcImRcIiwgJCQuc3ZnQXJjKTtcbiAgICAgICAgJCQuc3ZnLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5hcmMpO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5leHBhbmREdXJhdGlvbiA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuXG4gICAgICAgIGlmICgkJC5pc0RvbnV0VHlwZShpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuZG9udXRfZXhwYW5kX2R1cmF0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKCQkLmlzR2F1Z2VUeXBlKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5nYXVnZV9leHBhbmRfZHVyYXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAoJCQuaXNQaWVUeXBlKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5waWVfZXhwYW5kX2R1cmF0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDUwO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnNob3VsZEV4cGFuZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICAgICByZXR1cm4gJCQuaXNEb251dFR5cGUoaWQpICYmIGNvbmZpZy5kb251dF9leHBhbmQgfHwgJCQuaXNHYXVnZVR5cGUoaWQpICYmIGNvbmZpZy5nYXVnZV9leHBhbmQgfHwgJCQuaXNQaWVUeXBlKGlkKSAmJiBjb25maWcucGllX2V4cGFuZDtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uc2hvdWxkU2hvd0FyY0xhYmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgc2hvdWxkU2hvdyA9IHRydWU7XG4gICAgICAgIGlmICgkJC5oYXNUeXBlKCdkb251dCcpKSB7XG4gICAgICAgICAgICBzaG91bGRTaG93ID0gY29uZmlnLmRvbnV0X2xhYmVsX3Nob3c7XG4gICAgICAgIH0gZWxzZSBpZiAoJCQuaGFzVHlwZSgncGllJykpIHtcbiAgICAgICAgICAgIHNob3VsZFNob3cgPSBjb25maWcucGllX2xhYmVsX3Nob3c7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2hlbiBnYXVnZSwgYWx3YXlzIHRydWVcbiAgICAgICAgcmV0dXJuIHNob3VsZFNob3c7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLm1lZXRzQXJjTGFiZWxUaHJlc2hvbGQgPSBmdW5jdGlvbiAocmF0aW8pIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIHRocmVzaG9sZCA9ICQkLmhhc1R5cGUoJ2RvbnV0JykgPyBjb25maWcuZG9udXRfbGFiZWxfdGhyZXNob2xkIDogY29uZmlnLnBpZV9sYWJlbF90aHJlc2hvbGQ7XG4gICAgICAgIHJldHVybiByYXRpbyA+PSB0aHJlc2hvbGQ7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldEFyY0xhYmVsRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLnBpZV9sYWJlbF9mb3JtYXQ7XG4gICAgICAgIGlmICgkJC5oYXNUeXBlKCdnYXVnZScpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuZ2F1Z2VfbGFiZWxfZm9ybWF0O1xuICAgICAgICB9IGVsc2UgaWYgKCQkLmhhc1R5cGUoJ2RvbnV0JykpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5kb251dF9sYWJlbF9mb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0R2F1Z2VMYWJlbEV4dGVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgICAgIHJldHVybiBjb25maWcuZ2F1Z2VfbGFiZWxfZXh0ZW50cztcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0QXJjVGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgIHJldHVybiAkJC5oYXNUeXBlKCdkb251dCcpID8gJCQuY29uZmlnLmRvbnV0X3RpdGxlIDogXCJcIjtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udXBkYXRlVGFyZ2V0c0ZvckFyYyA9IGZ1bmN0aW9uICh0YXJnZXRzKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBtYWluID0gJCQubWFpbixcbiAgICAgICAgICAgIG1haW5QaWVVcGRhdGUsXG4gICAgICAgICAgICBtYWluUGllRW50ZXIsXG4gICAgICAgICAgICBjbGFzc0NoYXJ0QXJjID0gJCQuY2xhc3NDaGFydEFyYy5iaW5kKCQkKSxcbiAgICAgICAgICAgIGNsYXNzQXJjcyA9ICQkLmNsYXNzQXJjcy5iaW5kKCQkKSxcbiAgICAgICAgICAgIGNsYXNzRm9jdXMgPSAkJC5jbGFzc0ZvY3VzLmJpbmQoJCQpO1xuICAgICAgICBtYWluUGllVXBkYXRlID0gbWFpbi5zZWxlY3QoJy4nICsgQ0xBU1MuY2hhcnRBcmNzKS5zZWxlY3RBbGwoJy4nICsgQ0xBU1MuY2hhcnRBcmMpLmRhdGEoJCQucGllKHRhcmdldHMpKS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFzc0NoYXJ0QXJjKGQpICsgY2xhc3NGb2N1cyhkLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgbWFpblBpZUVudGVyID0gbWFpblBpZVVwZGF0ZS5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRBcmMpO1xuICAgICAgICBtYWluUGllRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCBjbGFzc0FyY3MpO1xuICAgICAgICBtYWluUGllRW50ZXIuYXBwZW5kKFwidGV4dFwiKS5hdHRyKFwiZHlcIiwgJCQuaGFzVHlwZSgnZ2F1Z2UnKSA/IFwiLS4xZW1cIiA6IFwiLjM1ZW1cIikuc3R5bGUoXCJvcGFjaXR5XCIsIDApLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG4gICAgICAgIC8vIE1FTU86IGNhbiBub3Qga2VlcCBzYW1lIGNvbG9yLi4uLCBidXQgbm90IGJhZCB0byB1cGRhdGUgY29sb3IgaW4gcmVkcmF3XG4gICAgICAgIC8vbWFpblBpZVVwZGF0ZS5leGl0KCkucmVtb3ZlKCk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmluaXRBcmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgICQkLmFyY3MgPSAkJC5tYWluLnNlbGVjdCgnLicgKyBDTEFTUy5jaGFydCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRBcmNzKS5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZSgnYXJjJykpO1xuICAgICAgICAkJC5hcmNzLmFwcGVuZCgndGV4dCcpLmF0dHIoJ2NsYXNzJywgQ0xBU1MuY2hhcnRBcmNzVGl0bGUpLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikudGV4dCgkJC5nZXRBcmNUaXRsZSgpKTtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ucmVkcmF3QXJjID0gZnVuY3Rpb24gKGR1cmF0aW9uLCBkdXJhdGlvbkZvckV4aXQsIHdpdGhUcmFuc2Zvcm0pIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGQzID0gJCQuZDMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBtYWluID0gJCQubWFpbixcbiAgICAgICAgICAgIG1haW5BcmMsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQXJjLFxuICAgICAgICAgICAgbWFpbkFyY0xhYmVsTGluZSxcbiAgICAgICAgICAgIGhhc0dhdWdlVHlwZSA9ICQkLmhhc1R5cGUoJ2dhdWdlJyk7XG4gICAgICAgIG1haW5BcmMgPSBtYWluLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5hcmNzKS5zZWxlY3RBbGwoJy4nICsgQ0xBU1MuYXJjKS5kYXRhKCQkLmFyY0RhdGEuYmluZCgkJCkpO1xuICAgICAgICBtYWluQXJjLmVudGVyKCkuYXBwZW5kKCdwYXRoJykuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJjLmJpbmQoJCQpKS5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAkJC5jb2xvcihkLmRhdGEpO1xuICAgICAgICB9KS5zdHlsZShcImN1cnNvclwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkgPyBcInBvaW50ZXJcIiA6IG51bGw7XG4gICAgICAgIH0pLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGlmICgkJC5pc0dhdWdlVHlwZShkLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZC5zdGFydEFuZ2xlID0gZC5lbmRBbmdsZSA9IGNvbmZpZy5nYXVnZV9zdGFydGluZ0FuZ2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzR2F1Z2VUeXBlKSB7XG4gICAgICAgICAgICBtYWluQXJjTGFiZWxMaW5lID0gbWFpbi5zZWxlY3RBbGwoJy4nICsgQ0xBU1MuYXJjcykuc2VsZWN0QWxsKCcuJyArIENMQVNTLmFyY0xhYmVsTGluZSkuZGF0YSgkJC5hcmNEYXRhLmJpbmQoJCQpKTtcbiAgICAgICAgICAgIG1haW5BcmNMYWJlbExpbmUuZW50ZXIoKS5hcHBlbmQoJ3JlY3QnKS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ0xBU1MuYXJjTGFiZWxMaW5lICsgJyAnICsgQ0xBU1MudGFyZ2V0ICsgJyAnICsgQ0xBU1MudGFyZ2V0ICsgJy0nICsgZC5kYXRhLmlkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIG1haW5BcmNMYWJlbExpbmUuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFpbkFyY0xhYmVsTGluZS5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5jb2xvcl9wYXR0ZXJuLmxlbmd0aCA+IDAgPyAkJC5sZXZlbENvbG9yKGQuZGF0YS52YWx1ZXNbMF0udmFsdWUpIDogJCQuY29sb3IoZC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9KS5zdHlsZShcImRpc3BsYXlcIiwgY29uZmlnLmdhdWdlX2xhYmVsTGluZV9zaG93ID8gXCJcIiA6IFwibm9uZVwiKS5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVUaGlja25lc3MgPSAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkJC5oaWRkZW5UYXJnZXRJZHMuaW5kZXhPZihkLmRhdGEuaWQpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckxpbmVMZW5ndGggPSAkJC5nYXVnZUFyY1dpZHRoIC8gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aCAqICh1cGRhdGVkLmluZGV4ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUFuZ2xlID0gdXBkYXRlZC5lbmRBbmdsZSAtIE1hdGguUEkgLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyY0lubmVyUmFkaXVzID0gJCQucmFkaXVzIC0gaW5uZXJMaW5lTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvbmluZ0FuZ2xlID0gbGluZUFuZ2xlIC0gKGFyY0lubmVyUmFkaXVzID09PSAwID8gMCA6IDEgLyBhcmNJbm5lclJhZGl1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lTGVuZ3RoID0gJCQucmFkaXVzRXhwYW5kZWQgLSAkJC5yYWRpdXMgKyBpbm5lckxpbmVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gTWF0aC5jb3MobGluZVBvc2l0aW9uaW5nQW5nbGUpICogYXJjSW5uZXJSYWRpdXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gTWF0aC5zaW4obGluZVBvc2l0aW9uaW5nQW5nbGUpICogYXJjSW5uZXJSYWRpdXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gPSBcInJvdGF0ZShcIiArIGxpbmVBbmdsZSAqIDE4MCAvIE1hdGguUEkgKyBcIiwgXCIgKyB4ICsgXCIsIFwiICsgeSArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKHsgeDogeCwgeTogeSwgd2lkdGg6IGxpbmVMZW5ndGgsIGhlaWdodDogbGluZVRoaWNrbmVzcywgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfSkuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIFwiMCwgXCIgKyAobGluZUxlbmd0aCArIGxpbmVUaGlja25lc3MpICsgXCIsIDBcIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFpbkFyYy5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gISQkLmlzR2F1Z2VUeXBlKGQuZGF0YSkgJiYgd2l0aFRyYW5zZm9ybSA/IFwic2NhbGUoMClcIiA6IFwiXCI7XG4gICAgICAgIH0pLm9uKCdtb3VzZW92ZXInLCBjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlZCwgYXJjRGF0YTtcbiAgICAgICAgICAgIGlmICgkJC50cmFuc2l0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCB3aGlsZSB0cmFuc2l0aW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBhcmNEYXRhID0gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKTtcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2l0aW9uc1xuICAgICAgICAgICAgICAgICQkLmV4cGFuZEFyYyh1cGRhdGVkLmRhdGEuaWQpO1xuICAgICAgICAgICAgICAgICQkLmFwaS5mb2N1cyh1cGRhdGVkLmRhdGEuaWQpO1xuICAgICAgICAgICAgICAgICQkLnRvZ2dsZUZvY3VzTGVnZW5kKHVwZGF0ZWQuZGF0YS5pZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgJCQuY29uZmlnLmRhdGFfb25tb3VzZW92ZXIoYXJjRGF0YSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gOiBudWxsKS5vbignbW91c2Vtb3ZlJywgY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKSxcbiAgICAgICAgICAgICAgICBhcmNEYXRhLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkRGF0YTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgYXJjRGF0YSA9ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCksIHNlbGVjdGVkRGF0YSA9IFthcmNEYXRhXTtcbiAgICAgICAgICAgICAgICAkJC5zaG93VG9vbHRpcChzZWxlY3RlZERhdGEsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IDogbnVsbCkub24oJ21vdXNlb3V0JywgY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZWQsIGFyY0RhdGE7XG4gICAgICAgICAgICBpZiAoJCQudHJhbnNpdGluZykge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgYXJjRGF0YSA9ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCk7XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNpdGlvbnNcbiAgICAgICAgICAgICAgICAkJC51bmV4cGFuZEFyYyh1cGRhdGVkLmRhdGEuaWQpO1xuICAgICAgICAgICAgICAgICQkLmFwaS5yZXZlcnQoKTtcbiAgICAgICAgICAgICAgICAkJC5yZXZlcnRMZWdlbmQoKTtcbiAgICAgICAgICAgICAgICAkJC5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgICQkLmNvbmZpZy5kYXRhX29ubW91c2VvdXQoYXJjRGF0YSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gOiBudWxsKS5vbignY2xpY2snLCBjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZCA/IGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpLFxuICAgICAgICAgICAgICAgIGFyY0RhdGE7XG4gICAgICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIGFyY0RhdGEgPSAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpO1xuICAgICAgICAgICAgICAgIGlmICgkJC50b2dnbGVTaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAkJC50b2dnbGVTaGFwZSh0aGlzLCBhcmNEYXRhLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJCQuY29uZmlnLmRhdGFfb25jbGljay5jYWxsKCQkLmFwaSwgYXJjRGF0YSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gOiBudWxsKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQkLnRyYW5zaXRpbmcgPSB0cnVlO1xuICAgICAgICB9KS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmF0dHJUd2VlbihcImRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCksXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGU7XG4gICAgICAgICAgICBpZiAoIXVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJNIDAgMFwiO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudCA9PT0gZCkge1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSB7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IE1hdGguUEkqMixcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgZW5kQW5nbGU6IE1hdGguUEkqMixcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50LnN0YXJ0QW5nbGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMuX2N1cnJlbnQuZW5kQW5nbGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudC5lbmRBbmdsZSA9IHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludGVycG9sYXRlID0gZDMuaW50ZXJwb2xhdGUodGhpcy5fY3VycmVudCwgdXBkYXRlZCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdGUoMCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGVkID0gaW50ZXJwb2xhdGUodCk7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkLmRhdGEgPSBkLmRhdGE7IC8vIGRhdGEuaWQgd2lsbCBiZSB1cGRhdGVkIGJ5IGludGVycG9yYXRvclxuICAgICAgICAgICAgICAgIHJldHVybiAkJC5nZXRBcmMoaW50ZXJwb2xhdGVkLCB0cnVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgd2l0aFRyYW5zZm9ybSA/IFwic2NhbGUoMSlcIiA6IFwiXCIpLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuICQkLmxldmVsQ29sb3IgPyAkJC5sZXZlbENvbG9yKGQuZGF0YS52YWx1ZXNbMF0udmFsdWUpIDogJCQuY29sb3IoZC5kYXRhLmlkKTtcbiAgICAgICAgfSkgLy8gV2hlcmUgZ2F1Z2UgcmVhZGluZyBjb2xvciB3b3VsZCByZWNlaXZlIGN1c3RvbWl6YXRpb24uXG4gICAgICAgIC5jYWxsKCQkLmVuZGFsbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCQudHJhbnNpdGluZyA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgbWFpbkFyYy5leGl0KCkudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdCkuc3R5bGUoJ29wYWNpdHknLCAwKS5yZW1vdmUoKTtcbiAgICAgICAgbWFpbi5zZWxlY3RBbGwoJy4nICsgQ0xBU1MuY2hhcnRBcmMpLnNlbGVjdCgndGV4dCcpLnN0eWxlKFwib3BhY2l0eVwiLCAwKS5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gJCQuaXNHYXVnZVR5cGUoZC5kYXRhKSA/IENMQVNTLmdhdWdlVmFsdWUgOiAnJztcbiAgICAgICAgfSkudGV4dCgkJC50ZXh0Rm9yQXJjTGFiZWwuYmluZCgkJCkpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQudHJhbnNmb3JtRm9yQXJjTGFiZWwuYmluZCgkJCkpLnN0eWxlKCdmb250LXNpemUnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuICQkLmlzR2F1Z2VUeXBlKGQuZGF0YSkgJiYgJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aCA9PT0gMSA/IE1hdGgucm91bmQoJCQucmFkaXVzIC8gNSkgKyAncHgnIDogJyc7XG4gICAgICAgIH0pLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gJCQuaXNUYXJnZXRUb1Nob3coZC5kYXRhLmlkKSAmJiAkJC5pc0FyY1R5cGUoZC5kYXRhKSA/IDEgOiAwO1xuICAgICAgICB9KTtcbiAgICAgICAgbWFpbi5zZWxlY3QoJy4nICsgQ0xBU1MuY2hhcnRBcmNzVGl0bGUpLnN0eWxlKFwib3BhY2l0eVwiLCAkJC5oYXNUeXBlKCdkb251dCcpIHx8IGhhc0dhdWdlVHlwZSA/IDEgOiAwKTtcblxuICAgICAgICBpZiAoaGFzR2F1Z2VUeXBlKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAgICAgYmFja2dyb3VuZEFyYyA9ICQkLmFyY3Muc2VsZWN0KCdnLicgKyBDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kKS5zZWxlY3RBbGwoJ3BhdGguJyArIENMQVNTLmNoYXJ0QXJjc0JhY2tncm91bmQpLmRhdGEoJCQuZGF0YS50YXJnZXRzKTtcbiAgICAgICAgICAgIGJhY2tncm91bmRBcmMuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpO1xuICAgICAgICAgICAgYmFja2dyb3VuZEFyYy5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ0xBU1MuY2hhcnRBcmNzQmFja2dyb3VuZCArICcgJyArIENMQVNTLmNoYXJ0QXJjc0JhY2tncm91bmQgKyAnLScgKyBpO1xuICAgICAgICAgICAgfSkuYXR0cihcImRcIiwgZnVuY3Rpb24gKGQxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCQkLmhpZGRlblRhcmdldElkcy5pbmRleE9mKGQxLmlkKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk0gMCAwXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFt7IHZhbHVlOiBjb25maWcuZ2F1Z2VfbWF4IH1dLFxuICAgICAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBjb25maWcuZ2F1Z2Vfc3RhcnRpbmdBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kQW5nbGU6IC0xICogY29uZmlnLmdhdWdlX3N0YXJ0aW5nQW5nbGUgKiAoY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgPyBNYXRoLlBJIDogMSksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCsrXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJCQuZ2V0QXJjKGQsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQXJjLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgJCQuYXJjcy5zZWxlY3QoJy4nICsgQ0xBU1MuY2hhcnRBcmNzR2F1Z2VVbml0KS5hdHRyKFwiZHlcIiwgXCIuNzVlbVwiKS50ZXh0KGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93ID8gY29uZmlnLmdhdWdlX3VuaXRzIDogJycpO1xuICAgICAgICAgICAgJCQuYXJjcy5zZWxlY3QoJy4nICsgQ0xBU1MuY2hhcnRBcmNzR2F1Z2VNaW4pLmF0dHIoXCJkeFwiLCAtMSAqICgkJC5pbm5lclJhZGl1cyArICgkJC5yYWRpdXMgLSAkJC5pbm5lclJhZGl1cykgLyAoY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgPyAxIDogMikpICsgXCJweFwiKS5hdHRyKFwiZHlcIiwgXCIxLjJlbVwiKS50ZXh0KGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93ID8gJCQudGV4dEZvckdhdWdlTWluTWF4KGNvbmZpZy5nYXVnZV9taW4sIGZhbHNlKSA6ICcnKTtcbiAgICAgICAgICAgICQkLmFyY3Muc2VsZWN0KCcuJyArIENMQVNTLmNoYXJ0QXJjc0dhdWdlTWF4KS5hdHRyKFwiZHhcIiwgJCQuaW5uZXJSYWRpdXMgKyAoJCQucmFkaXVzIC0gJCQuaW5uZXJSYWRpdXMpIC8gKGNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMSA6IDIpICsgXCJweFwiKS5hdHRyKFwiZHlcIiwgXCIxLjJlbVwiKS50ZXh0KGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93ID8gJCQudGV4dEZvckdhdWdlTWluTWF4KGNvbmZpZy5nYXVnZV9tYXgsIHRydWUpIDogJycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5pbml0R2F1Z2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmNzID0gdGhpcy5hcmNzO1xuICAgICAgICBpZiAodGhpcy5oYXNUeXBlKCdnYXVnZScpKSB7XG4gICAgICAgICAgICBhcmNzLmFwcGVuZCgnZycpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kKTtcbiAgICAgICAgICAgIGFyY3MuYXBwZW5kKFwidGV4dFwiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRBcmNzR2F1Z2VVbml0KS5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICAgICAgICAgICAgYXJjcy5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydEFyY3NHYXVnZU1pbikuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgIGFyY3MuYXBwZW5kKFwidGV4dFwiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRBcmNzR2F1Z2VNYXgpLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldEdhdWdlTGFiZWxIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5nYXVnZV9sYWJlbF9zaG93ID8gMjAgOiAwO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5oYXNDYWNoZXMgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIShpZHNbaV0gaW4gdGhpcy5jYWNoZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5hZGRDYWNoZSA9IGZ1bmN0aW9uIChpZCwgdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuY2FjaGVbaWRdID0gdGhpcy5jbG9uZVRhcmdldCh0YXJnZXQpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0Q2FjaGVzID0gZnVuY3Rpb24gKGlkcykge1xuICAgICAgICB2YXIgdGFyZ2V0cyA9IFtdLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlkc1tpXSBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0cy5wdXNoKHRoaXMuY2xvbmVUYXJnZXQodGhpcy5jYWNoZVtpZHNbaV1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldHM7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmNhdGVnb3J5TmFtZSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgcmV0dXJuIGkgPCBjb25maWcuYXhpc194X2NhdGVnb3JpZXMubGVuZ3RoID8gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzW2ldIDogaTtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2VuZXJhdGVDbGFzcyA9IGZ1bmN0aW9uIChwcmVmaXgsIHRhcmdldElkKSB7XG4gICAgICAgIHJldHVybiBcIiBcIiArIHByZWZpeCArIFwiIFwiICsgcHJlZml4ICsgdGhpcy5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCh0YXJnZXRJZCk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5jbGFzc1RleHQgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnRleHQsIGQuaW5kZXgpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uY2xhc3NUZXh0cyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MudGV4dHMsIGQuaWQpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uY2xhc3NTaGFwZSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1Muc2hhcGUsIGQuaW5kZXgpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uY2xhc3NTaGFwZXMgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnNoYXBlcywgZC5pZCk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5jbGFzc0xpbmUgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmxpbmUsIGQuaWQpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uY2xhc3NMaW5lcyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmxpbmVzLCBkLmlkKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmNsYXNzQ2lyY2xlID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5jaXJjbGUsIGQuaW5kZXgpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uY2xhc3NDaXJjbGVzID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuY2lyY2xlcywgZC5pZCk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5jbGFzc0JhciA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzU2hhcGUoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYmFyLCBkLmluZGV4KTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmNsYXNzQmFycyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmJhcnMsIGQuaWQpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uY2xhc3NBcmMgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQuZGF0YSkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYXJjLCBkLmRhdGEuaWQpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uY2xhc3NBcmNzID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZC5kYXRhKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5hcmNzLCBkLmRhdGEuaWQpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uY2xhc3NBcmVhID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5hcmVhLCBkLmlkKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmNsYXNzQXJlYXMgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc1NoYXBlcyhkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5hcmVhcywgZC5pZCk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5jbGFzc1JlZ2lvbiA9IGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MucmVnaW9uLCBpKSArICcgJyArICgnY2xhc3MnIGluIGQgPyBkWydjbGFzcyddIDogJycpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uY2xhc3NFdmVudCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuZXZlbnRSZWN0LCBkLmluZGV4KTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmNsYXNzVGFyZ2V0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgIHZhciBhZGRpdGlvbmFsQ2xhc3NTdWZmaXggPSAkJC5jb25maWcuZGF0YV9jbGFzc2VzW2lkXSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxDbGFzcyA9ICcnO1xuICAgICAgICBpZiAoYWRkaXRpb25hbENsYXNzU3VmZml4KSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsQ2xhc3MgPSAnICcgKyBDTEFTUy50YXJnZXQgKyAnLScgKyBhZGRpdGlvbmFsQ2xhc3NTdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICQkLmdlbmVyYXRlQ2xhc3MoQ0xBU1MudGFyZ2V0LCBpZCkgKyBhZGRpdGlvbmFsQ2xhc3M7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5jbGFzc0ZvY3VzID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NGb2N1c2VkKGQpICsgdGhpcy5jbGFzc0RlZm9jdXNlZChkKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmNsYXNzRm9jdXNlZCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAnICcgKyAodGhpcy5mb2N1c2VkVGFyZ2V0SWRzLmluZGV4T2YoZC5pZCkgPj0gMCA/IENMQVNTLmZvY3VzZWQgOiAnJyk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5jbGFzc0RlZm9jdXNlZCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAnICcgKyAodGhpcy5kZWZvY3VzZWRUYXJnZXRJZHMuaW5kZXhPZihkLmlkKSA+PSAwID8gQ0xBU1MuZGVmb2N1c2VkIDogJycpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uY2xhc3NDaGFydFRleHQgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gQ0xBU1MuY2hhcnRUZXh0ICsgdGhpcy5jbGFzc1RhcmdldChkLmlkKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmNsYXNzQ2hhcnRMaW5lID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIENMQVNTLmNoYXJ0TGluZSArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5jbGFzc0NoYXJ0QmFyID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIENMQVNTLmNoYXJ0QmFyICsgdGhpcy5jbGFzc1RhcmdldChkLmlkKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmNsYXNzQ2hhcnRBcmMgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gQ0xBU1MuY2hhcnRBcmMgKyB0aGlzLmNsYXNzVGFyZ2V0KGQuZGF0YS5pZCk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCA9IGZ1bmN0aW9uICh0YXJnZXRJZCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0SWQgfHwgdGFyZ2V0SWQgPT09IDAgPyAoJy0nICsgdGFyZ2V0SWQpLnJlcGxhY2UoL1tcXHM/IUAjJCVeJiooKV89KywuPD4nXCI6O1xcW1xcXVxcL3x+YHt9XFxcXF0vZywgJy0nKSA6ICcnO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uc2VsZWN0b3JUYXJnZXQgPSBmdW5jdGlvbiAoaWQsIHByZWZpeCkge1xuICAgICAgICByZXR1cm4gKHByZWZpeCB8fCAnJykgKyAnLicgKyBDTEFTUy50YXJnZXQgKyB0aGlzLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGlkKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnNlbGVjdG9yVGFyZ2V0cyA9IGZ1bmN0aW9uIChpZHMsIHByZWZpeCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICBpZHMgPSBpZHMgfHwgW107XG4gICAgICAgIHJldHVybiBpZHMubGVuZ3RoID8gaWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkJC5zZWxlY3RvclRhcmdldChpZCwgcHJlZml4KTtcbiAgICAgICAgfSkgOiBudWxsO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uc2VsZWN0b3JMZWdlbmQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuICcuJyArIENMQVNTLmxlZ2VuZEl0ZW0gKyB0aGlzLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGlkKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnNlbGVjdG9yTGVnZW5kcyA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGlkcyAmJiBpZHMubGVuZ3RoID8gaWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkJC5zZWxlY3RvckxlZ2VuZChpZCk7XG4gICAgICAgIH0pIDogbnVsbDtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0Q2xpcFBhdGggPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGlzSUU5ID0gd2luZG93Lm5hdmlnYXRvci5hcHBWZXJzaW9uLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIm1zaWUgOS5cIikgPj0gMDtcbiAgICAgICAgcmV0dXJuIFwidXJsKFwiICsgKGlzSUU5ID8gXCJcIiA6IGRvY3VtZW50LlVSTC5zcGxpdCgnIycpWzBdKSArIFwiI1wiICsgaWQgKyBcIilcIjtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmFwcGVuZENsaXAgPSBmdW5jdGlvbiAocGFyZW50LCBpZCkge1xuICAgICAgICByZXR1cm4gcGFyZW50LmFwcGVuZChcImNsaXBQYXRoXCIpLmF0dHIoXCJpZFwiLCBpZCkuYXBwZW5kKFwicmVjdFwiKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldEF4aXNDbGlwWCA9IGZ1bmN0aW9uIChmb3JIb3Jpem9udGFsKSB7XG4gICAgICAgIC8vIGF4aXMgbGluZSB3aWR0aCArIHBhZGRpbmcgZm9yIGxlZnRcbiAgICAgICAgdmFyIGxlZnQgPSBNYXRoLm1heCgzMCwgdGhpcy5tYXJnaW4ubGVmdCk7XG4gICAgICAgIHJldHVybiBmb3JIb3Jpem9udGFsID8gLSgxICsgbGVmdCkgOiAtKGxlZnQgLSAxKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldEF4aXNDbGlwWSA9IGZ1bmN0aW9uIChmb3JIb3Jpem9udGFsKSB7XG4gICAgICAgIHJldHVybiBmb3JIb3Jpem9udGFsID8gLTIwIDogLXRoaXMubWFyZ2luLnRvcDtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldFhBeGlzQ2xpcFggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgIHJldHVybiAkJC5nZXRBeGlzQ2xpcFgoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0WEF4aXNDbGlwWSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgcmV0dXJuICQkLmdldEF4aXNDbGlwWSghJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRZQXhpc0NsaXBYID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gJCQuY29uZmlnLmF4aXNfeV9pbm5lciA/IC0xIDogJCQuZ2V0QXhpc0NsaXBYKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0WUF4aXNDbGlwWSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgcmV0dXJuICQkLmdldEF4aXNDbGlwWSgkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldEF4aXNDbGlwV2lkdGggPSBmdW5jdGlvbiAoZm9ySG9yaXpvbnRhbCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KDMwLCAkJC5tYXJnaW4ubGVmdCksXG4gICAgICAgICAgICByaWdodCA9IE1hdGgubWF4KDMwLCAkJC5tYXJnaW4ucmlnaHQpO1xuICAgICAgICAvLyB3aWR0aCArIGF4aXMgbGluZSB3aWR0aCArIHBhZGRpbmcgZm9yIGxlZnQvcmlnaHRcbiAgICAgICAgcmV0dXJuIGZvckhvcml6b250YWwgPyAkJC53aWR0aCArIDIgKyBsZWZ0ICsgcmlnaHQgOiAkJC5tYXJnaW4ubGVmdCArIDIwO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0QXhpc0NsaXBIZWlnaHQgPSBmdW5jdGlvbiAoZm9ySG9yaXpvbnRhbCkge1xuICAgICAgICAvLyBsZXNzIHRoYW4gMjAgaXMgbm90IGVub3VnaCB0byBzaG93IHRoZSBheGlzIGxhYmVsICdvdXRlcicgd2l0aG91dCBsZWdlbmRcbiAgICAgICAgcmV0dXJuIChmb3JIb3Jpem9udGFsID8gdGhpcy5tYXJnaW4uYm90dG9tIDogdGhpcy5tYXJnaW4udG9wICsgdGhpcy5oZWlnaHQpICsgMjA7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRYQXhpc0NsaXBXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgcmV0dXJuICQkLmdldEF4aXNDbGlwV2lkdGgoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0WEF4aXNDbGlwSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gJCQuZ2V0QXhpc0NsaXBIZWlnaHQoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0WUF4aXNDbGlwV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgIHJldHVybiAkJC5nZXRBeGlzQ2xpcFdpZHRoKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpICsgKCQkLmNvbmZpZy5heGlzX3lfaW5uZXIgPyAyMCA6IDApO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0WUF4aXNDbGlwSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gJCQuZ2V0QXhpc0NsaXBIZWlnaHQoJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdlbmVyYXRlQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBkMyA9ICQkLmQzLFxuICAgICAgICAgICAgY29sb3JzID0gY29uZmlnLmRhdGFfY29sb3JzLFxuICAgICAgICAgICAgcGF0dGVybiA9IG5vdEVtcHR5KGNvbmZpZy5jb2xvcl9wYXR0ZXJuKSA/IGNvbmZpZy5jb2xvcl9wYXR0ZXJuIDogZDMuc2NhbGUuY2F0ZWdvcnkxMCgpLnJhbmdlKCksXG4gICAgICAgICAgICBjYWxsYmFjayA9IGNvbmZpZy5kYXRhX2NvbG9yLFxuICAgICAgICAgICAgaWRzID0gW107XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBkLmlkIHx8IGQuZGF0YSAmJiBkLmRhdGEuaWQgfHwgZCxcbiAgICAgICAgICAgICAgICBjb2xvcjtcblxuICAgICAgICAgICAgLy8gaWYgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmIChjb2xvcnNbaWRdIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb2xvciA9IGNvbG9yc1tpZF0oZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBzcGVjaWZpZWQsIGNob29zZSB0aGF0IGNvbG9yXG4gICAgICAgICAgICBlbHNlIGlmIChjb2xvcnNbaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3JzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgbm90IHNwZWNpZmllZCwgY2hvb3NlIGZyb20gcGF0dGVyblxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkcy5pbmRleE9mKGlkKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IHBhdHRlcm5baWRzLmluZGV4T2YoaWQpICUgcGF0dGVybi5sZW5ndGhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzW2lkXSA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGNhbGxiYWNrKGNvbG9yLCBkKSA6IGNvbG9yO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2VuZXJhdGVMZXZlbENvbG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgY29sb3JzID0gY29uZmlnLmNvbG9yX3BhdHRlcm4sXG4gICAgICAgICAgICB0aHJlc2hvbGQgPSBjb25maWcuY29sb3JfdGhyZXNob2xkLFxuICAgICAgICAgICAgYXNWYWx1ZSA9IHRocmVzaG9sZC51bml0ID09PSAndmFsdWUnLFxuICAgICAgICAgICAgdmFsdWVzID0gdGhyZXNob2xkLnZhbHVlcyAmJiB0aHJlc2hvbGQudmFsdWVzLmxlbmd0aCA/IHRocmVzaG9sZC52YWx1ZXMgOiBbXSxcbiAgICAgICAgICAgIG1heCA9IHRocmVzaG9sZC5tYXggfHwgMTAwO1xuICAgICAgICByZXR1cm4gbm90RW1wdHkoY29uZmlnLmNvbG9yX3RocmVzaG9sZCkgPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIHYsXG4gICAgICAgICAgICAgICAgY29sb3IgPSBjb2xvcnNbY29sb3JzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHYgPSBhc1ZhbHVlID8gdmFsdWUgOiB2YWx1ZSAqIDEwMCAvIG1heDtcbiAgICAgICAgICAgICAgICBpZiAodiA8IHZhbHVlc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGNvbG9yc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICB9IDogbnVsbDtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0RGVmYXVsdENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIGJpbmR0bzogJyNjaGFydCcsXG4gICAgICAgICAgICBzdmdfY2xhc3NuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaXplX3dpZHRoOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaXplX2hlaWdodDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFkZGluZ19sZWZ0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYWRkaW5nX3JpZ2h0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYWRkaW5nX3RvcDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFkZGluZ19ib3R0b206IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlc2l6ZV9hdXRvOiB0cnVlLFxuICAgICAgICAgICAgem9vbV9lbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHpvb21fZXh0ZW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB6b29tX3ByaXZpbGVnZWQ6IGZhbHNlLFxuICAgICAgICAgICAgem9vbV9yZXNjYWxlOiBmYWxzZSxcbiAgICAgICAgICAgIHpvb21fb256b29tOiBmdW5jdGlvbiB6b29tX29uem9vbSgpIHt9LFxuICAgICAgICAgICAgem9vbV9vbnpvb21zdGFydDogZnVuY3Rpb24gem9vbV9vbnpvb21zdGFydCgpIHt9LFxuICAgICAgICAgICAgem9vbV9vbnpvb21lbmQ6IGZ1bmN0aW9uIHpvb21fb256b29tZW5kKCkge30sXG4gICAgICAgICAgICB6b29tX3hfbWluOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB6b29tX3hfbWF4OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpbnRlcmFjdGlvbl9icmlnaHRlbjogdHJ1ZSxcbiAgICAgICAgICAgIGludGVyYWN0aW9uX2VuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBvbm1vdXNlb3ZlcjogZnVuY3Rpb24gb25tb3VzZW92ZXIoKSB7fSxcbiAgICAgICAgICAgIG9ubW91c2VvdXQ6IGZ1bmN0aW9uIG9ubW91c2VvdXQoKSB7fSxcbiAgICAgICAgICAgIG9ucmVzaXplOiBmdW5jdGlvbiBvbnJlc2l6ZSgpIHt9LFxuICAgICAgICAgICAgb25yZXNpemVkOiBmdW5jdGlvbiBvbnJlc2l6ZWQoKSB7fSxcbiAgICAgICAgICAgIG9uaW5pdDogZnVuY3Rpb24gb25pbml0KCkge30sXG4gICAgICAgICAgICBvbnJlbmRlcmVkOiBmdW5jdGlvbiBvbnJlbmRlcmVkKCkge30sXG4gICAgICAgICAgICB0cmFuc2l0aW9uX2R1cmF0aW9uOiAzNTAsXG4gICAgICAgICAgICBkYXRhX3g6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRhdGFfeHM6IHt9LFxuICAgICAgICAgICAgZGF0YV94Rm9ybWF0OiAnJVktJW0tJWQnLFxuICAgICAgICAgICAgZGF0YV94TG9jYWx0aW1lOiB0cnVlLFxuICAgICAgICAgICAgZGF0YV94U29ydDogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGFfaWRDb252ZXJ0ZXI6IGZ1bmN0aW9uIGRhdGFfaWRDb252ZXJ0ZXIoaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YV9uYW1lczoge30sXG4gICAgICAgICAgICBkYXRhX2NsYXNzZXM6IHt9LFxuICAgICAgICAgICAgZGF0YV9ncm91cHM6IFtdLFxuICAgICAgICAgICAgZGF0YV9heGVzOiB7fSxcbiAgICAgICAgICAgIGRhdGFfdHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGF0YV90eXBlczoge30sXG4gICAgICAgICAgICBkYXRhX2xhYmVsczoge30sXG4gICAgICAgICAgICBkYXRhX29yZGVyOiAnZGVzYycsXG4gICAgICAgICAgICBkYXRhX3JlZ2lvbnM6IHt9LFxuICAgICAgICAgICAgZGF0YV9jb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGF0YV9jb2xvcnM6IHt9LFxuICAgICAgICAgICAgZGF0YV9oaWRlOiBmYWxzZSxcbiAgICAgICAgICAgIGRhdGFfZmlsdGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkYXRhX3NlbGVjdGlvbl9lbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGRhdGFfc2VsZWN0aW9uX2dyb3VwZWQ6IGZhbHNlLFxuICAgICAgICAgICAgZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlOiBmdW5jdGlvbiBkYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGU6IHRydWUsXG4gICAgICAgICAgICBkYXRhX3NlbGVjdGlvbl9kcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgICAgICAgZGF0YV9vbmNsaWNrOiBmdW5jdGlvbiBkYXRhX29uY2xpY2soKSB7fSxcbiAgICAgICAgICAgIGRhdGFfb25tb3VzZW92ZXI6IGZ1bmN0aW9uIGRhdGFfb25tb3VzZW92ZXIoKSB7fSxcbiAgICAgICAgICAgIGRhdGFfb25tb3VzZW91dDogZnVuY3Rpb24gZGF0YV9vbm1vdXNlb3V0KCkge30sXG4gICAgICAgICAgICBkYXRhX29uc2VsZWN0ZWQ6IGZ1bmN0aW9uIGRhdGFfb25zZWxlY3RlZCgpIHt9LFxuICAgICAgICAgICAgZGF0YV9vbnVuc2VsZWN0ZWQ6IGZ1bmN0aW9uIGRhdGFfb251bnNlbGVjdGVkKCkge30sXG4gICAgICAgICAgICBkYXRhX3VybDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGF0YV9oZWFkZXJzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkYXRhX2pzb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRhdGFfcm93czogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGF0YV9jb2x1bW5zOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkYXRhX21pbWVUeXBlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkYXRhX2tleXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIGNvbmZpZ3VyYXRpb24gZm9yIG5vIHBsb3QtYWJsZSBkYXRhIHN1cHBsaWVkLlxuICAgICAgICAgICAgZGF0YV9lbXB0eV9sYWJlbF90ZXh0OiBcIlwiLFxuICAgICAgICAgICAgLy8gc3ViY2hhcnRcbiAgICAgICAgICAgIHN1YmNoYXJ0X3Nob3c6IGZhbHNlLFxuICAgICAgICAgICAgc3ViY2hhcnRfc2l6ZV9oZWlnaHQ6IDYwLFxuICAgICAgICAgICAgc3ViY2hhcnRfYXhpc194X3Nob3c6IHRydWUsXG4gICAgICAgICAgICBzdWJjaGFydF9vbmJydXNoOiBmdW5jdGlvbiBzdWJjaGFydF9vbmJydXNoKCkge30sXG4gICAgICAgICAgICAvLyBjb2xvclxuICAgICAgICAgICAgY29sb3JfcGF0dGVybjogW10sXG4gICAgICAgICAgICBjb2xvcl90aHJlc2hvbGQ6IHt9LFxuICAgICAgICAgICAgLy8gbGVnZW5kXG4gICAgICAgICAgICBsZWdlbmRfc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIGxlZ2VuZF9oaWRlOiBmYWxzZSxcbiAgICAgICAgICAgIGxlZ2VuZF9wb3NpdGlvbjogJ2JvdHRvbScsXG4gICAgICAgICAgICBsZWdlbmRfaW5zZXRfYW5jaG9yOiAndG9wLWxlZnQnLFxuICAgICAgICAgICAgbGVnZW5kX2luc2V0X3g6IDEwLFxuICAgICAgICAgICAgbGVnZW5kX2luc2V0X3k6IDAsXG4gICAgICAgICAgICBsZWdlbmRfaW5zZXRfc3RlcDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGVnZW5kX2l0ZW1fb25jbGljazogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGVnZW5kX2l0ZW1fb25tb3VzZW92ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxlZ2VuZF9pdGVtX29ubW91c2VvdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxlZ2VuZF9lcXVhbGx5OiBmYWxzZSxcbiAgICAgICAgICAgIGxlZ2VuZF9wYWRkaW5nOiAwLFxuICAgICAgICAgICAgbGVnZW5kX2l0ZW1fdGlsZV93aWR0aDogMTAsXG4gICAgICAgICAgICBsZWdlbmRfaXRlbV90aWxlX2hlaWdodDogMTAsXG4gICAgICAgICAgICAvLyBheGlzXG4gICAgICAgICAgICBheGlzX3JvdGF0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgYXhpc194X3Nob3c6IHRydWUsXG4gICAgICAgICAgICBheGlzX3hfdHlwZTogJ2luZGV4ZWQnLFxuICAgICAgICAgICAgYXhpc194X2xvY2FsdGltZTogdHJ1ZSxcbiAgICAgICAgICAgIGF4aXNfeF9jYXRlZ29yaWVzOiBbXSxcbiAgICAgICAgICAgIGF4aXNfeF90aWNrX2NlbnRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgIGF4aXNfeF90aWNrX2Zvcm1hdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYXhpc194X3RpY2tfY3VsbGluZzoge30sXG4gICAgICAgICAgICBheGlzX3hfdGlja19jdWxsaW5nX21heDogMTAsXG4gICAgICAgICAgICBheGlzX3hfdGlja19jb3VudDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYXhpc194X3RpY2tfZml0OiB0cnVlLFxuICAgICAgICAgICAgYXhpc194X3RpY2tfdmFsdWVzOiBudWxsLFxuICAgICAgICAgICAgYXhpc194X3RpY2tfcm90YXRlOiAwLFxuICAgICAgICAgICAgYXhpc194X3RpY2tfb3V0ZXI6IHRydWUsXG4gICAgICAgICAgICBheGlzX3hfdGlja19tdWx0aWxpbmU6IHRydWUsXG4gICAgICAgICAgICBheGlzX3hfdGlja19tdWx0aWxpbmVNYXg6IDAsXG4gICAgICAgICAgICBheGlzX3hfdGlja193aWR0aDogbnVsbCxcbiAgICAgICAgICAgIGF4aXNfeF9tYXg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNfeF9taW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNfeF9wYWRkaW5nOiB7fSxcbiAgICAgICAgICAgIGF4aXNfeF9oZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNfeF9leHRlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNfeF9sYWJlbDoge30sXG4gICAgICAgICAgICBheGlzX3hfaW5uZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNfeV9zaG93OiB0cnVlLFxuICAgICAgICAgICAgYXhpc195X3R5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNfeV9tYXg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNfeV9taW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNfeV9pbnZlcnRlZDogZmFsc2UsXG4gICAgICAgICAgICBheGlzX3lfY2VudGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBheGlzX3lfaW5uZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNfeV9sYWJlbDoge30sXG4gICAgICAgICAgICBheGlzX3lfdGlja19mb3JtYXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNfeV90aWNrX291dGVyOiB0cnVlLFxuICAgICAgICAgICAgYXhpc195X3RpY2tfdmFsdWVzOiBudWxsLFxuICAgICAgICAgICAgYXhpc195X3RpY2tfcm90YXRlOiAwLFxuICAgICAgICAgICAgYXhpc195X3RpY2tfY291bnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNfeV90aWNrX3RpbWVfdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNfeV90aWNrX3RpbWVfaW50ZXJ2YWw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNfeV9wYWRkaW5nOiB7fSxcbiAgICAgICAgICAgIGF4aXNfeV9kZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBheGlzX3kyX3Nob3c6IGZhbHNlLFxuICAgICAgICAgICAgYXhpc195Ml9tYXg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNfeTJfbWluOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBheGlzX3kyX2ludmVydGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGF4aXNfeTJfY2VudGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBheGlzX3kyX2lubmVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBheGlzX3kyX2xhYmVsOiB7fSxcbiAgICAgICAgICAgIGF4aXNfeTJfdGlja19mb3JtYXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNfeTJfdGlja19vdXRlcjogdHJ1ZSxcbiAgICAgICAgICAgIGF4aXNfeTJfdGlja192YWx1ZXM6IG51bGwsXG4gICAgICAgICAgICBheGlzX3kyX3RpY2tfY291bnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNfeTJfcGFkZGluZzoge30sXG4gICAgICAgICAgICBheGlzX3kyX2RlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIGdyaWRcbiAgICAgICAgICAgIGdyaWRfeF9zaG93OiBmYWxzZSxcbiAgICAgICAgICAgIGdyaWRfeF90eXBlOiAndGljaycsXG4gICAgICAgICAgICBncmlkX3hfbGluZXM6IFtdLFxuICAgICAgICAgICAgZ3JpZF95X3Nob3c6IGZhbHNlLFxuICAgICAgICAgICAgLy8gbm90IHVzZWRcbiAgICAgICAgICAgIC8vIGdyaWRfeV90eXBlOiAndGljaycsXG4gICAgICAgICAgICBncmlkX3lfbGluZXM6IFtdLFxuICAgICAgICAgICAgZ3JpZF95X3RpY2tzOiAxMCxcbiAgICAgICAgICAgIGdyaWRfZm9jdXNfc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIGdyaWRfbGluZXNfZnJvbnQ6IHRydWUsXG4gICAgICAgICAgICAvLyBwb2ludCAtIHBvaW50IG9mIGVhY2ggZGF0YVxuICAgICAgICAgICAgcG9pbnRfc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIHBvaW50X3I6IDIuNSxcbiAgICAgICAgICAgIHBvaW50X3NlbnNpdGl2aXR5OiAxMCxcbiAgICAgICAgICAgIHBvaW50X2ZvY3VzX2V4cGFuZF9lbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgcG9pbnRfZm9jdXNfZXhwYW5kX3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBvaW50X3NlbGVjdF9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBsaW5lXG4gICAgICAgICAgICBsaW5lX2Nvbm5lY3ROdWxsOiBmYWxzZSxcbiAgICAgICAgICAgIGxpbmVfc3RlcF90eXBlOiAnc3RlcCcsXG4gICAgICAgICAgICAvLyBiYXJcbiAgICAgICAgICAgIGJhcl93aWR0aDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYmFyX3dpZHRoX3JhdGlvOiAwLjYsXG4gICAgICAgICAgICBiYXJfd2lkdGhfbWF4OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBiYXJfemVyb2Jhc2VkOiB0cnVlLFxuICAgICAgICAgICAgYmFyX3NwYWNlOiAwLFxuICAgICAgICAgICAgLy8gYXJlYVxuICAgICAgICAgICAgYXJlYV96ZXJvYmFzZWQ6IHRydWUsXG4gICAgICAgICAgICBhcmVhX2Fib3ZlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIHBpZVxuICAgICAgICAgICAgcGllX2xhYmVsX3Nob3c6IHRydWUsXG4gICAgICAgICAgICBwaWVfbGFiZWxfZm9ybWF0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwaWVfbGFiZWxfdGhyZXNob2xkOiAwLjA1LFxuICAgICAgICAgICAgcGllX2xhYmVsX3JhdGlvOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwaWVfZXhwYW5kOiB7fSxcbiAgICAgICAgICAgIHBpZV9leHBhbmRfZHVyYXRpb246IDUwLFxuICAgICAgICAgICAgLy8gZ2F1Z2VcbiAgICAgICAgICAgIGdhdWdlX2Z1bGxDaXJjbGU6IGZhbHNlLFxuICAgICAgICAgICAgZ2F1Z2VfbGFiZWxfc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIGdhdWdlX2xhYmVsTGluZV9zaG93OiB0cnVlLFxuICAgICAgICAgICAgZ2F1Z2VfbGFiZWxfZm9ybWF0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBnYXVnZV9taW46IDAsXG4gICAgICAgICAgICBnYXVnZV9tYXg6IDEwMCxcbiAgICAgICAgICAgIGdhdWdlX3N0YXJ0aW5nQW5nbGU6IC0xICogTWF0aC5QSSAvIDIsXG4gICAgICAgICAgICBnYXVnZV9sYWJlbF9leHRlbnRzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBnYXVnZV91bml0czogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ2F1Z2Vfd2lkdGg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGdhdWdlX2FyY3NfbWluV2lkdGg6IDUsXG4gICAgICAgICAgICBnYXVnZV9leHBhbmQ6IHt9LFxuICAgICAgICAgICAgZ2F1Z2VfZXhwYW5kX2R1cmF0aW9uOiA1MCxcbiAgICAgICAgICAgIC8vIGRvbnV0XG4gICAgICAgICAgICBkb251dF9sYWJlbF9zaG93OiB0cnVlLFxuICAgICAgICAgICAgZG9udXRfbGFiZWxfZm9ybWF0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkb251dF9sYWJlbF90aHJlc2hvbGQ6IDAuMDUsXG4gICAgICAgICAgICBkb251dF9sYWJlbF9yYXRpbzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZG9udXRfd2lkdGg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRvbnV0X3RpdGxlOiBcIlwiLFxuICAgICAgICAgICAgZG9udXRfZXhwYW5kOiB7fSxcbiAgICAgICAgICAgIGRvbnV0X2V4cGFuZF9kdXJhdGlvbjogNTAsXG4gICAgICAgICAgICAvLyBzcGxpbmVcbiAgICAgICAgICAgIHNwbGluZV9pbnRlcnBvbGF0aW9uX3R5cGU6ICdjYXJkaW5hbCcsXG4gICAgICAgICAgICAvLyByZWdpb24gLSByZWdpb24gdG8gY2hhbmdlIHN0eWxlXG4gICAgICAgICAgICByZWdpb25zOiBbXSxcbiAgICAgICAgICAgIC8vIHRvb2x0aXAgLSBzaG93IHdoZW4gbW91c2VvdmVyIG9uIGVhY2ggZGF0YVxuICAgICAgICAgICAgdG9vbHRpcF9zaG93OiB0cnVlLFxuICAgICAgICAgICAgdG9vbHRpcF9ncm91cGVkOiB0cnVlLFxuICAgICAgICAgICAgdG9vbHRpcF9vcmRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdG9vbHRpcF9mb3JtYXRfdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRvb2x0aXBfZm9ybWF0X25hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRvb2x0aXBfZm9ybWF0X3ZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0b29sdGlwX3Bvc2l0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0b29sdGlwX2NvbnRlbnRzOiBmdW5jdGlvbiB0b29sdGlwX2NvbnRlbnRzKGQsIGRlZmF1bHRUaXRsZUZvcm1hdCwgZGVmYXVsdFZhbHVlRm9ybWF0LCBjb2xvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRvb2x0aXBDb250ZW50ID8gdGhpcy5nZXRUb29sdGlwQ29udGVudChkLCBkZWZhdWx0VGl0bGVGb3JtYXQsIGRlZmF1bHRWYWx1ZUZvcm1hdCwgY29sb3IpIDogJyc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9vbHRpcF9pbml0X3Nob3c6IGZhbHNlLFxuICAgICAgICAgICAgdG9vbHRpcF9pbml0X3g6IDAsXG4gICAgICAgICAgICB0b29sdGlwX2luaXRfcG9zaXRpb246IHsgdG9wOiAnMHB4JywgbGVmdDogJzUwcHgnIH0sXG4gICAgICAgICAgICB0b29sdGlwX29uc2hvdzogZnVuY3Rpb24gdG9vbHRpcF9vbnNob3coKSB7fSxcbiAgICAgICAgICAgIHRvb2x0aXBfb25oaWRlOiBmdW5jdGlvbiB0b29sdGlwX29uaGlkZSgpIHt9LFxuICAgICAgICAgICAgLy8gdGl0bGVcbiAgICAgICAgICAgIHRpdGxlX3RleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRpdGxlX3BhZGRpbmc6IHtcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aXRsZV9wb3NpdGlvbjogJ3RvcC1jZW50ZXInXG4gICAgICAgIH07XG5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5hZGRpdGlvbmFsQ29uZmlnKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGNvbmZpZ1trZXldID0gdGhpcy5hZGRpdGlvbmFsQ29uZmlnW2tleV07XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5hZGRpdGlvbmFsQ29uZmlnID0ge307XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5sb2FkQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgdGhpc19jb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICByZWFkO1xuICAgICAgICBmdW5jdGlvbiBmaW5kKCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXMuc2hpZnQoKTtcbiAgICAgICAgICAgIC8vICAgICAgICBjb25zb2xlLmxvZyhcImtleSA9PlwiLCBrZXksIFwiLCB0YXJnZXQgPT5cIiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChrZXkgJiYgdGFyZ2V0ICYmICh0eXBlb2YgdGFyZ2V0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0YXJnZXQpKSA9PT0gJ29iamVjdCcgJiYga2V5IGluIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaW5kKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXNfY29uZmlnKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGNvbmZpZztcbiAgICAgICAgICAgIGtleXMgPSBrZXkuc3BsaXQoJ18nKTtcbiAgICAgICAgICAgIHJlYWQgPSBmaW5kKCk7XG4gICAgICAgICAgICAvLyAgICAgICAgY29uc29sZS5sb2coXCJDT05GSUcgOiBcIiwga2V5LCByZWFkKTtcbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmVhZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzX2NvbmZpZ1trZXldID0gcmVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmNvbnZlcnRVcmxUb0RhdGEgPSBmdW5jdGlvbiAodXJsLCBtaW1lVHlwZSwgaGVhZGVycywga2V5cywgZG9uZSkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgdHlwZSA9IG1pbWVUeXBlID8gbWltZVR5cGUgOiAnY3N2JztcbiAgICAgICAgdmFyIHJlcSA9ICQkLmQzLnhocih1cmwpO1xuICAgICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgcmVxLmhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXEuZ2V0KGZ1bmN0aW9uIChlcnJvciwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIGQ7XG4gICAgICAgICAgICB2YXIgZGF0YVJlc3BvbnNlID0gZGF0YS5yZXNwb25zZSB8fCBkYXRhLnJlc3BvbnNlVGV4dDsgLy8gRml4ZXMgSUU5IFhIUiBpc3N1ZTsgc2VlICMxMzQ1XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IucmVzcG9uc2VVUkwgKyAnICcgKyBlcnJvci5zdGF0dXMgKyAnICgnICsgZXJyb3Iuc3RhdHVzVGV4dCArICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgICAgICAgICAgZCA9ICQkLmNvbnZlcnRKc29uVG9EYXRhKEpTT04ucGFyc2UoZGF0YVJlc3BvbnNlKSwga2V5cyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0c3YnKSB7XG4gICAgICAgICAgICAgICAgZCA9ICQkLmNvbnZlcnRUc3ZUb0RhdGEoZGF0YVJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZCA9ICQkLmNvbnZlcnRDc3ZUb0RhdGEoZGF0YVJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUuY2FsbCgkJCwgZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uY29udmVydFhzdlRvRGF0YSA9IGZ1bmN0aW9uICh4c3YsIHBhcnNlcikge1xuICAgICAgICB2YXIgcm93cyA9IHBhcnNlci5wYXJzZVJvd3MoeHN2KSxcbiAgICAgICAgICAgIGQ7XG4gICAgICAgIGlmIChyb3dzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZCA9IFt7fV07XG4gICAgICAgICAgICByb3dzWzBdLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgZFswXVtpZF0gPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkID0gcGFyc2VyLnBhcnNlKHhzdik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5jb252ZXJ0Q3N2VG9EYXRhID0gZnVuY3Rpb24gKGNzdikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0WHN2VG9EYXRhKGNzdiwgdGhpcy5kMy5jc3YpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uY29udmVydFRzdlRvRGF0YSA9IGZ1bmN0aW9uICh0c3YpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFhzdlRvRGF0YSh0c3YsIHRoaXMuZDMudHN2KTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmNvbnZlcnRKc29uVG9EYXRhID0gZnVuY3Rpb24gKGpzb24sIGtleXMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIG5ld19yb3dzID0gW10sXG4gICAgICAgICAgICB0YXJnZXRLZXlzLFxuICAgICAgICAgICAgZGF0YTtcbiAgICAgICAgaWYgKGtleXMpIHtcbiAgICAgICAgICAgIC8vIHdoZW4ga2V5cyBzcGVjaWZpZWQsIGpzb24gd291bGQgYmUgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBvYmplY3RzXG4gICAgICAgICAgICBpZiAoa2V5cy54KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0S2V5cyA9IGtleXMudmFsdWUuY29uY2F0KGtleXMueCk7XG4gICAgICAgICAgICAgICAgJCQuY29uZmlnLmRhdGFfeCA9IGtleXMueDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0S2V5cyA9IGtleXMudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdfcm93cy5wdXNoKHRhcmdldEtleXMpO1xuICAgICAgICAgICAganNvbi5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld19yb3cgPSBbXTtcbiAgICAgICAgICAgICAgICB0YXJnZXRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHVuZGVmaW5lZCB0byBudWxsIGJlY2F1c2UgdW5kZWZpbmVkIGRhdGEgd2lsbCBiZSByZW1vdmVkIGluIGNvbnZlcnREYXRhVG9UYXJnZXRzKClcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSAkJC5maW5kVmFsdWVJbkpzb24obywga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdfcm93LnB1c2godik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbmV3X3Jvd3MucHVzaChuZXdfcm93KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGF0YSA9ICQkLmNvbnZlcnRSb3dzVG9EYXRhKG5ld19yb3dzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGpzb24pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIG5ld19yb3dzLnB1c2goW2tleV0uY29uY2F0KGpzb25ba2V5XSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkYXRhID0gJCQuY29udmVydENvbHVtbnNUb0RhdGEobmV3X3Jvd3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZmluZFZhbHVlSW5Kc29uID0gZnVuY3Rpb24gKG9iamVjdCwgcGF0aCkge1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFsoXFx3KylcXF0vZywgJy4kMScpOyAvLyBjb252ZXJ0IGluZGV4ZXMgdG8gcHJvcGVydGllcyAocmVwbGFjZSBbXSB3aXRoIC4pXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC4vLCAnJyk7IC8vIHN0cmlwIGEgbGVhZGluZyBkb3RcbiAgICAgICAgdmFyIHBhdGhBcnJheSA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBrID0gcGF0aEFycmF5W2ldO1xuICAgICAgICAgICAgaWYgKGsgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIHJvd3MgdG8gbm9ybWFsaXplZCBkYXRhLlxuICAgICAqIEBwYXJhbSB7YW55W11bXX0gcm93cyBUaGUgcm93IGRhdGFcbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAgICAgKi9cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5jb252ZXJ0Um93c1RvRGF0YSA9IGZ1bmN0aW9uIChyb3dzKSB7XG4gICAgICAgIHZhciBuZXdSb3dzID0gW107XG4gICAgICAgIHZhciBrZXlzID0gcm93c1swXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuZXdSb3cgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcm93c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChyb3dzW2ldW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTb3VyY2UgZGF0YSBpcyBtaXNzaW5nIGEgY29tcG9uZW50IGF0IChcIiArIGkgKyBcIixcIiArIGogKyBcIikhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdSb3dba2V5c1tqXV0gPSByb3dzW2ldW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3Um93cy5wdXNoKG5ld1Jvdyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1Jvd3M7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjb2x1bW5zIHRvIG5vcm1hbGl6ZWQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge2FueVtdW119IGNvbHVtbnMgVGhlIGNvbHVtbiBkYXRhXG4gICAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAgICovXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uY29udmVydENvbHVtbnNUb0RhdGEgPSBmdW5jdGlvbiAoY29sdW1ucykge1xuICAgICAgICB2YXIgbmV3Um93cyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGNvbHVtbnNbaV1bMF07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGNvbHVtbnNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQobmV3Um93c1tqIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Jvd3NbaiAtIDFdID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChjb2x1bW5zW2ldW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTb3VyY2UgZGF0YSBpcyBtaXNzaW5nIGEgY29tcG9uZW50IGF0IChcIiArIGkgKyBcIixcIiArIGogKyBcIikhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdSb3dzW2ogLSAxXVtrZXldID0gY29sdW1uc1tpXVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdSb3dzO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5jb252ZXJ0RGF0YVRvVGFyZ2V0cyA9IGZ1bmN0aW9uIChkYXRhLCBhcHBlbmRYcykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgaWRzID0gJCQuZDMua2V5cyhkYXRhWzBdKS5maWx0ZXIoJCQuaXNOb3RYLCAkJCksXG4gICAgICAgICAgICB4cyA9ICQkLmQzLmtleXMoZGF0YVswXSkuZmlsdGVyKCQkLmlzWCwgJCQpLFxuICAgICAgICAgICAgdGFyZ2V0cztcblxuICAgICAgICAvLyBzYXZlIHggZm9yIHVwZGF0ZSBkYXRhIGJ5IGxvYWQgd2hlbiBjdXN0b20geCBhbmQgYzMueCBBUElcbiAgICAgICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgeEtleSA9ICQkLmdldFhLZXkoaWQpO1xuXG4gICAgICAgICAgICBpZiAoJCQuaXNDdXN0b21YKCkgfHwgJCQuaXNUaW1lU2VyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpbmNsdWRlZCBpbiBpbnB1dCBkYXRhXG4gICAgICAgICAgICAgICAgaWYgKHhzLmluZGV4T2YoeEtleSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAkJC5kYXRhLnhzW2lkXSA9IChhcHBlbmRYcyAmJiAkJC5kYXRhLnhzW2lkXSA/ICQkLmRhdGEueHNbaWRdIDogW10pLmNvbmNhdChkYXRhLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRbeEtleV07XG4gICAgICAgICAgICAgICAgICAgIH0pLmZpbHRlcihpc1ZhbHVlKS5tYXAoZnVuY3Rpb24gKHJhd1gsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkJC5nZW5lcmF0ZVRhcmdldFgocmF3WCwgaWQsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBpbmNsdWRlZCBpbiBpbnB1dCBkYXRhLCBmaW5kIGZyb20gcHJlbG9hZGVkIGRhdGEgb2Ygb3RoZXIgaWQncyB4XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLmRhdGFfeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCQuZGF0YS54c1tpZF0gPSAkJC5nZXRPdGhlclRhcmdldFhzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90IGluY2x1ZGVkIGluIGlucHV0IGRhdGEsIGZpbmQgZnJvbSBwcmVsb2FkZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub3RFbXB0eShjb25maWcuZGF0YV94cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkJC5kYXRhLnhzW2lkXSA9ICQkLmdldFhWYWx1ZXNPZlhLZXkoeEtleSwgJCQuZGF0YS50YXJnZXRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBNRU1POiBpZiBubyB4IGluY2x1ZGVkLCB1c2Ugc2FtZSB4IG9mIGN1cnJlbnQgd2lsbCBiZSB1c2VkXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQkLmRhdGEueHNbaWRdID0gZGF0YS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNoZWNrIHggaXMgZGVmaW5lZFxuICAgICAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIGlmICghJCQuZGF0YS54c1tpZF0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggaXMgbm90IGRlZmluZWQgZm9yIGlkID0gXCInICsgaWQgKyAnXCIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgdG8gdGFyZ2V0XG4gICAgICAgIHRhcmdldHMgPSBpZHMubWFwKGZ1bmN0aW9uIChpZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjb252ZXJ0ZWRJZCA9IGNvbmZpZy5kYXRhX2lkQ29udmVydGVyKGlkKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGNvbnZlcnRlZElkLFxuICAgICAgICAgICAgICAgIGlkX29yZzogaWQsXG4gICAgICAgICAgICAgICAgdmFsdWVzOiBkYXRhLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeEtleSA9ICQkLmdldFhLZXkoaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3WCA9IGRbeEtleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRbaWRdICE9PSBudWxsICYmICFpc05hTihkW2lkXSkgPyArZFtpZF0gOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHggYXMgY2F0ZWdvcmllcyBpZiBjdXN0b20geCBhbmQgY2F0ZWdvcml6ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQkLmlzQ3VzdG9tWCgpICYmICQkLmlzQ2F0ZWdvcml6ZWQoKSAmJiAhaXNVbmRlZmluZWQocmF3WCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiBpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmluZGV4T2YocmF3WCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuYXhpc194X2NhdGVnb3JpZXMucHVzaChyYXdYKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSAkJC5nZW5lcmF0ZVRhcmdldFgocmF3WCwgaWQsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcmsgYXMgeCA9IHVuZGVmaW5lZCBpZiB2YWx1ZSBpcyB1bmRlZmluZWQgYW5kIGZpbHRlciB0byByZW1vdmUgYWZ0ZXIgbWFwcGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChkW2lkXSkgfHwgJCQuZGF0YS54c1tpZF0ubGVuZ3RoIDw9IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogeCwgdmFsdWU6IHZhbHVlLCBpZDogY29udmVydGVkSWQgfTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRGVmaW5lZCh2LngpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBmaW5pc2ggdGFyZ2V0c1xuICAgICAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgLy8gc29ydCB2YWx1ZXMgYnkgaXRzIHhcbiAgICAgICAgICAgIGlmIChjb25maWcuZGF0YV94U29ydCkge1xuICAgICAgICAgICAgICAgIHQudmFsdWVzID0gdC52YWx1ZXMuc29ydChmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IHYxLnggfHwgdjEueCA9PT0gMCA/IHYxLnggOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gdjIueCB8fCB2Mi54ID09PSAwID8gdjIueCA6IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geDEgLSB4MjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluZGV4aW5nIGVhY2ggdmFsdWVcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgdC52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHYuaW5kZXggPSBpKys7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHRoaXMgbmVlZHMgdG8gYmUgc29ydGVkIGJlY2F1c2UgaXRzIGluZGV4IGFuZCB2YWx1ZS5pbmRleCBpcyBpZGVudGljYWxcbiAgICAgICAgICAgICQkLmRhdGEueHNbdC5pZF0uc29ydChmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYxIC0gdjI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY2FjaGUgaW5mb3JtYXRpb24gYWJvdXQgdmFsdWVzXG4gICAgICAgICQkLmhhc05lZ2F0aXZlVmFsdWUgPSAkJC5oYXNOZWdhdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpO1xuICAgICAgICAkJC5oYXNQb3NpdGl2ZVZhbHVlID0gJCQuaGFzUG9zaXRpdmVWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzKTtcblxuICAgICAgICAvLyBzZXQgdGFyZ2V0IHR5cGVzXG4gICAgICAgIGlmIChjb25maWcuZGF0YV90eXBlKSB7XG4gICAgICAgICAgICAkJC5zZXRUYXJnZXRUeXBlKCQkLm1hcFRvSWRzKHRhcmdldHMpLmZpbHRlcihmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIShpZCBpbiBjb25maWcuZGF0YV90eXBlcyk7XG4gICAgICAgICAgICB9KSwgY29uZmlnLmRhdGFfdHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWNoZSBhcyBvcmlnaW5hbCBpZCBrZXllZFxuICAgICAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICQkLmFkZENhY2hlKGQuaWRfb3JnLCBkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldHM7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmlzWCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5kYXRhX3ggJiYga2V5ID09PSBjb25maWcuZGF0YV94IHx8IG5vdEVtcHR5KGNvbmZpZy5kYXRhX3hzKSAmJiBoYXNWYWx1ZShjb25maWcuZGF0YV94cywga2V5KTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmlzTm90WCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzWChrZXkpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0WEtleSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICAgICByZXR1cm4gY29uZmlnLmRhdGFfeCA/IGNvbmZpZy5kYXRhX3ggOiBub3RFbXB0eShjb25maWcuZGF0YV94cykgPyBjb25maWcuZGF0YV94c1tpZF0gOiBudWxsO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0WFZhbHVlc09mWEtleSA9IGZ1bmN0aW9uIChrZXksIHRhcmdldHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIHhWYWx1ZXMsXG4gICAgICAgICAgICBpZHMgPSB0YXJnZXRzICYmIG5vdEVtcHR5KHRhcmdldHMpID8gJCQubWFwVG9JZHModGFyZ2V0cykgOiBbXTtcbiAgICAgICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICBpZiAoJCQuZ2V0WEtleShpZCkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIHhWYWx1ZXMgPSAkJC5kYXRhLnhzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB4VmFsdWVzO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0SW5kZXhCeVggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgZGF0YSA9ICQkLmZpbHRlckJ5WCgkJC5kYXRhLnRhcmdldHMsIHgpO1xuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGggPyBkYXRhWzBdLmluZGV4IDogbnVsbDtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldFhWYWx1ZSA9IGZ1bmN0aW9uIChpZCwgaSkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gaWQgaW4gJCQuZGF0YS54cyAmJiAkJC5kYXRhLnhzW2lkXSAmJiBpc1ZhbHVlKCQkLmRhdGEueHNbaWRdW2ldKSA/ICQkLmRhdGEueHNbaWRdW2ldIDogaTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldE90aGVyVGFyZ2V0WHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBpZHNGb3JYID0gT2JqZWN0LmtleXMoJCQuZGF0YS54cyk7XG4gICAgICAgIHJldHVybiBpZHNGb3JYLmxlbmd0aCA/ICQkLmRhdGEueHNbaWRzRm9yWFswXV0gOiBudWxsO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0T3RoZXJUYXJnZXRYID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciB4cyA9IHRoaXMuZ2V0T3RoZXJUYXJnZXRYcygpO1xuICAgICAgICByZXR1cm4geHMgJiYgaW5kZXggPCB4cy5sZW5ndGggPyB4c1tpbmRleF0gOiBudWxsO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uYWRkWHMgPSBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXMoeHMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAkJC5jb25maWcuZGF0YV94c1tpZF0gPSB4c1tpZF07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaGFzTXVsdGlwbGVYID0gZnVuY3Rpb24gKHhzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmQzLnNldChPYmplY3Qua2V5cyh4cykubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHhzW2lkXTtcbiAgICAgICAgfSkpLnNpemUoKSA+IDE7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5pc011bHRpcGxlWCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5vdEVtcHR5KHRoaXMuY29uZmlnLmRhdGFfeHMpIHx8ICF0aGlzLmNvbmZpZy5kYXRhX3hTb3J0IHx8IHRoaXMuaGFzVHlwZSgnc2NhdHRlcicpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uYWRkTmFtZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBuYW1lO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgbmFtZSA9ICQkLmNvbmZpZy5kYXRhX25hbWVzW2RhdGEuaWRdO1xuICAgICAgICAgICAgZGF0YS5uYW1lID0gbmFtZSAhPT0gdW5kZWZpbmVkID8gbmFtZSA6IGRhdGEuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRWYWx1ZU9uSW5kZXggPSBmdW5jdGlvbiAodmFsdWVzLCBpbmRleCkge1xuICAgICAgICB2YXIgdmFsdWVPbkluZGV4ID0gdmFsdWVzLmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHYuaW5kZXggPT09IGluZGV4O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlT25JbmRleC5sZW5ndGggPyB2YWx1ZU9uSW5kZXhbMF0gOiBudWxsO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udXBkYXRlVGFyZ2V0WCA9IGZ1bmN0aW9uICh0YXJnZXRzLCB4KSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdC52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgICAgIHYueCA9ICQkLmdlbmVyYXRlVGFyZ2V0WCh4W2ldLCB0LmlkLCBpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJCQuZGF0YS54c1t0LmlkXSA9IHg7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udXBkYXRlVGFyZ2V0WHMgPSBmdW5jdGlvbiAodGFyZ2V0cywgeHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBpZiAoeHNbdC5pZF0pIHtcbiAgICAgICAgICAgICAgICAkJC51cGRhdGVUYXJnZXRYKFt0XSwgeHNbdC5pZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdlbmVyYXRlVGFyZ2V0WCA9IGZ1bmN0aW9uIChyYXdYLCBpZCwgaW5kZXgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIHg7XG4gICAgICAgIGlmICgkJC5pc1RpbWVTZXJpZXMoKSkge1xuICAgICAgICAgICAgeCA9IHJhd1ggPyAkJC5wYXJzZURhdGUocmF3WCkgOiAkJC5wYXJzZURhdGUoJCQuZ2V0WFZhbHVlKGlkLCBpbmRleCkpO1xuICAgICAgICB9IGVsc2UgaWYgKCQkLmlzQ3VzdG9tWCgpICYmICEkJC5pc0NhdGVnb3JpemVkKCkpIHtcbiAgICAgICAgICAgIHggPSBpc1ZhbHVlKHJhd1gpID8gK3Jhd1ggOiAkJC5nZXRYVmFsdWUoaWQsIGluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmNsb25lVGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRhcmdldC5pZCxcbiAgICAgICAgICAgIGlkX29yZzogdGFyZ2V0LmlkX29yZyxcbiAgICAgICAgICAgIHZhbHVlczogdGFyZ2V0LnZhbHVlcy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBkLngsIHZhbHVlOiBkLnZhbHVlLCBpZDogZC5pZCB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnVwZGF0ZVhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICBpZiAoJCQuZGF0YS50YXJnZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgJCQueHMgPSBbXTtcbiAgICAgICAgICAgICQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICQkLnhzW3YuaW5kZXhdID0gdi54O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldFByZXZYID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLnhzW2kgLSAxXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ICE9PSAndW5kZWZpbmVkJyA/IHggOiBudWxsO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0TmV4dFggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgeCA9IHRoaXMueHNbaSArIDFdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHggIT09ICd1bmRlZmluZWQnID8geCA6IG51bGw7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRNYXhEYXRhQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgIHJldHVybiAkJC5kMy5tYXgoJCQuZGF0YS50YXJnZXRzLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQudmFsdWVzLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRNYXhEYXRhQ291bnRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0cykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGFyZ2V0cy5sZW5ndGgsXG4gICAgICAgICAgICBtYXggPSAwLFxuICAgICAgICAgICAgbWF4VGFyZ2V0O1xuICAgICAgICBpZiAobGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHQudmFsdWVzLmxlbmd0aCA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhUYXJnZXQgPSB0O1xuICAgICAgICAgICAgICAgICAgICBtYXggPSB0LnZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXhUYXJnZXQgPSBsZW5ndGggPyB0YXJnZXRzWzBdIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4VGFyZ2V0O1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0RWRnZVggPSBmdW5jdGlvbiAodGFyZ2V0cykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gIXRhcmdldHMubGVuZ3RoID8gWzAsIDBdIDogWyQkLmQzLm1pbih0YXJnZXRzLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQudmFsdWVzWzBdLng7XG4gICAgICAgIH0pLCAkJC5kMy5tYXgodGFyZ2V0cywgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXS54O1xuICAgICAgICB9KV07XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5tYXBUb0lkcyA9IGZ1bmN0aW9uICh0YXJnZXRzKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRzLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQuaWQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ubWFwVG9UYXJnZXRJZHMgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBpZHMgPyBbXS5jb25jYXQoaWRzKSA6ICQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5oYXNUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0cywgaWQpIHtcbiAgICAgICAgdmFyIGlkcyA9IHRoaXMubWFwVG9JZHModGFyZ2V0cyksXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaWRzW2ldID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmlzVGFyZ2V0VG9TaG93ID0gZnVuY3Rpb24gKHRhcmdldElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZGRlblRhcmdldElkcy5pbmRleE9mKHRhcmdldElkKSA8IDA7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5pc0xlZ2VuZFRvU2hvdyA9IGZ1bmN0aW9uICh0YXJnZXRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWRkZW5MZWdlbmRJZHMuaW5kZXhPZih0YXJnZXRJZCkgPCAwO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZmlsdGVyVGFyZ2V0c1RvU2hvdyA9IGZ1bmN0aW9uICh0YXJnZXRzKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0YXJnZXRzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuICQkLmlzVGFyZ2V0VG9TaG93KHQuaWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLm1hcFRhcmdldHNUb1VuaXF1ZVhzID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgdmFyIHhzID0gJCQuZDMuc2V0KCQkLmQzLm1lcmdlKHRhcmdldHMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdC52YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICt2Lng7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpKS52YWx1ZXMoKTtcbiAgICAgICAgeHMgPSAkJC5pc1RpbWVTZXJpZXMoKSA/IHhzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCt4KTtcbiAgICAgICAgfSkgOiB4cy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiAreDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB4cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uYWRkSGlkZGVuVGFyZ2V0SWRzID0gZnVuY3Rpb24gKHRhcmdldElkcykge1xuICAgICAgICB0YXJnZXRJZHMgPSB0YXJnZXRJZHMgaW5zdGFuY2VvZiBBcnJheSA/IHRhcmdldElkcyA6IG5ldyBBcnJheSh0YXJnZXRJZHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGlkZGVuVGFyZ2V0SWRzLmluZGV4T2YodGFyZ2V0SWRzW2ldKSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGRlblRhcmdldElkcyA9IHRoaXMuaGlkZGVuVGFyZ2V0SWRzLmNvbmNhdCh0YXJnZXRJZHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5yZW1vdmVIaWRkZW5UYXJnZXRJZHMgPSBmdW5jdGlvbiAodGFyZ2V0SWRzKSB7XG4gICAgICAgIHRoaXMuaGlkZGVuVGFyZ2V0SWRzID0gdGhpcy5oaWRkZW5UYXJnZXRJZHMuZmlsdGVyKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldElkcy5pbmRleE9mKGlkKSA8IDA7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uYWRkSGlkZGVuTGVnZW5kSWRzID0gZnVuY3Rpb24gKHRhcmdldElkcykge1xuICAgICAgICB0YXJnZXRJZHMgPSB0YXJnZXRJZHMgaW5zdGFuY2VvZiBBcnJheSA/IHRhcmdldElkcyA6IG5ldyBBcnJheSh0YXJnZXRJZHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGlkZGVuTGVnZW5kSWRzLmluZGV4T2YodGFyZ2V0SWRzW2ldKSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGRlbkxlZ2VuZElkcyA9IHRoaXMuaGlkZGVuTGVnZW5kSWRzLmNvbmNhdCh0YXJnZXRJZHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5yZW1vdmVIaWRkZW5MZWdlbmRJZHMgPSBmdW5jdGlvbiAodGFyZ2V0SWRzKSB7XG4gICAgICAgIHRoaXMuaGlkZGVuTGVnZW5kSWRzID0gdGhpcy5oaWRkZW5MZWdlbmRJZHMuZmlsdGVyKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldElkcy5pbmRleE9mKGlkKSA8IDA7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0VmFsdWVzQXNJZEtleWVkID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgICAgICAgdmFyIHlzID0ge307XG4gICAgICAgIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgeXNbdC5pZF0gPSBbXTtcbiAgICAgICAgICAgIHQudmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICB5c1t0LmlkXS5wdXNoKHYudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geXM7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5jaGVja1ZhbHVlSW5UYXJnZXRzID0gZnVuY3Rpb24gKHRhcmdldHMsIGNoZWNrZXIpIHtcbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKHRhcmdldHMpLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICB2YWx1ZXM7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHRhcmdldHNbaWRzW2ldXS52YWx1ZXM7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrZXIodmFsdWVzW2pdLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaGFzTmVnYXRpdmVWYWx1ZUluVGFyZ2V0cyA9IGZ1bmN0aW9uICh0YXJnZXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrVmFsdWVJblRhcmdldHModGFyZ2V0cywgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2IDwgMDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5oYXNQb3NpdGl2ZVZhbHVlSW5UYXJnZXRzID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHYgPiAwO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmlzT3JkZXJEZXNjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIHJldHVybiB0eXBlb2YgY29uZmlnLmRhdGFfb3JkZXIgPT09ICdzdHJpbmcnICYmIGNvbmZpZy5kYXRhX29yZGVyLnRvTG93ZXJDYXNlKCkgPT09ICdkZXNjJztcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmlzT3JkZXJBc2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjb25maWcuZGF0YV9vcmRlciA9PT0gJ3N0cmluZycgJiYgY29uZmlnLmRhdGFfb3JkZXIudG9Mb3dlckNhc2UoKSA9PT0gJ2FzYyc7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRPcmRlckZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgb3JkZXJBc2MgPSAkJC5pc09yZGVyQXNjKCksXG4gICAgICAgICAgICBvcmRlckRlc2MgPSAkJC5pc09yZGVyRGVzYygpO1xuICAgICAgICBpZiAob3JkZXJBc2MgfHwgb3JkZXJEZXNjKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQxLCB0Mikge1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VyID0gZnVuY3Rpb24gcmVkdWNlcihwLCBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwICsgTWF0aC5hYnMoYy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgdDFTdW0gPSB0MS52YWx1ZXMucmVkdWNlKHJlZHVjZXIsIDApLFxuICAgICAgICAgICAgICAgICAgICB0MlN1bSA9IHQyLnZhbHVlcy5yZWR1Y2UocmVkdWNlciwgMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yZGVyRGVzYyA/IHQyU3VtIC0gdDFTdW0gOiB0MVN1bSAtIHQyU3VtO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5kYXRhX29yZGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5kYXRhX29yZGVyO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoY29uZmlnLmRhdGFfb3JkZXIpKSB7XG4gICAgICAgICAgICB2YXIgb3JkZXIgPSBjb25maWcuZGF0YV9vcmRlcjtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodDEsIHQyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yZGVyLmluZGV4T2YodDEuaWQpIC0gb3JkZXIuaW5kZXhPZih0Mi5pZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5vcmRlclRhcmdldHMgPSBmdW5jdGlvbiAodGFyZ2V0cykge1xuICAgICAgICB2YXIgZmN0ID0gdGhpcy5nZXRPcmRlckZ1bmN0aW9uKCk7XG4gICAgICAgIGlmIChmY3QpIHtcbiAgICAgICAgICAgIHRhcmdldHMuc29ydChmY3QpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNPcmRlckFzYygpIHx8IHRoaXMuaXNPcmRlckRlc2MoKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldHMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRzO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZmlsdGVyQnlYID0gZnVuY3Rpb24gKHRhcmdldHMsIHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZDMubWVyZ2UodGFyZ2V0cy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnZhbHVlcztcbiAgICAgICAgfSkpLmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHYueCAtIHggPT09IDA7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZmlsdGVyUmVtb3ZlTnVsbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzVmFsdWUoZC52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZmlsdGVyQnlYRG9tYWluID0gZnVuY3Rpb24gKHRhcmdldHMsIHhEb21haW4pIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldHMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiB0LmlkLFxuICAgICAgICAgICAgICAgIGlkX29yZzogdC5pZF9vcmcsXG4gICAgICAgICAgICAgICAgdmFsdWVzOiB0LnZhbHVlcy5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhEb21haW5bMF0gPD0gdi54ICYmIHYueCA8PSB4RG9tYWluWzFdO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmhhc0RhdGFMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5kYXRhX2xhYmVscyA9PT0gJ2Jvb2xlYW4nICYmIGNvbmZpZy5kYXRhX2xhYmVscykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihjb25maWcuZGF0YV9sYWJlbHMpID09PSAnb2JqZWN0JyAmJiBub3RFbXB0eShjb25maWcuZGF0YV9sYWJlbHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXREYXRhTGFiZWxMZW5ndGggPSBmdW5jdGlvbiAobWluLCBtYXgsIGtleSkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgbGVuZ3RocyA9IFswLCAwXSxcbiAgICAgICAgICAgIHBhZGRpbmdDb2VmID0gMS4zO1xuICAgICAgICAkJC5zZWxlY3RDaGFydC5zZWxlY3QoJ3N2ZycpLnNlbGVjdEFsbCgnLmR1bW15JykuZGF0YShbbWluLCBtYXhdKS5lbnRlcigpLmFwcGVuZCgndGV4dCcpLnRleHQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAkJC5kYXRhTGFiZWxGb3JtYXQoZC5pZCkoZCk7XG4gICAgICAgIH0pLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIGxlbmd0aHNbaV0gPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2tleV0gKiBwYWRkaW5nQ29lZjtcbiAgICAgICAgfSkucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiBsZW5ndGhzO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaXNOb25lQXJjID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzVGFyZ2V0KHRoaXMuZGF0YS50YXJnZXRzLCBkLmlkKTtcbiAgICB9LCBjM19jaGFydF9pbnRlcm5hbF9mbi5pc0FyYyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAnZGF0YScgaW4gZCAmJiB0aGlzLmhhc1RhcmdldCh0aGlzLmRhdGEudGFyZ2V0cywgZC5kYXRhLmlkKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmZpbmRTYW1lWE9mVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcywgaW5kZXgpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICB0YXJnZXRYID0gdmFsdWVzW2luZGV4XS54LFxuICAgICAgICAgICAgc2FtZXMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHRhcmdldFggIT09IHZhbHVlc1tpXS54KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYW1lcy5wdXNoKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gaW5kZXg7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRYICE9PSB2YWx1ZXNbaV0ueCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2FtZXMucHVzaCh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYW1lcztcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyA9IGZ1bmN0aW9uICh0YXJnZXRzLCBwb3MpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNhbmRpZGF0ZXM7XG5cbiAgICAgICAgLy8gbWFwIHRvIGFycmF5IG9mIGNsb3Nlc3QgcG9pbnRzIG9mIGVhY2ggdGFyZ2V0XG4gICAgICAgIGNhbmRpZGF0ZXMgPSB0YXJnZXRzLm1hcChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gJCQuZmluZENsb3Nlc3QodGFyZ2V0LnZhbHVlcywgcG9zKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZGVjaWRlIGNsb3Nlc3QgcG9pbnQgYW5kIHJldHVyblxuICAgICAgICByZXR1cm4gJCQuZmluZENsb3Nlc3QoY2FuZGlkYXRlcywgcG9zKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmZpbmRDbG9zZXN0ID0gZnVuY3Rpb24gKHZhbHVlcywgcG9zKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBtaW5EaXN0ID0gJCQuY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5LFxuICAgICAgICAgICAgY2xvc2VzdDtcblxuICAgICAgICAvLyBmaW5kIG1vdXNlb3ZlcmluZyBiYXJcbiAgICAgICAgdmFsdWVzLmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHYgJiYgJCQuaXNCYXJUeXBlKHYuaWQpO1xuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSAkJC5tYWluLnNlbGVjdCgnLicgKyBDTEFTUy5iYXJzICsgJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodi5pZCkgKyAnIC4nICsgQ0xBU1MuYmFyICsgJy0nICsgdi5pbmRleCkubm9kZSgpO1xuICAgICAgICAgICAgaWYgKCFjbG9zZXN0ICYmICQkLmlzV2l0aGluQmFyKHNoYXBlKSkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBmaW5kIGNsb3Nlc3QgcG9pbnQgZnJvbSBub24tYmFyXG4gICAgICAgIHZhbHVlcy5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2ICYmICEkJC5pc0JhclR5cGUodi5pZCk7XG4gICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciBkID0gJCQuZGlzdCh2LCBwb3MpO1xuICAgICAgICAgICAgaWYgKGQgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgbWluRGlzdCA9IGQ7XG4gICAgICAgICAgICAgICAgY2xvc2VzdCA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjbG9zZXN0O1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZGlzdCA9IGZ1bmN0aW9uIChkYXRhLCBwb3MpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIHhJbmRleCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAxIDogMCxcbiAgICAgICAgICAgIHlJbmRleCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAwIDogMSxcbiAgICAgICAgICAgIHkgPSAkJC5jaXJjbGVZKGRhdGEsIGRhdGEuaW5kZXgpLFxuICAgICAgICAgICAgeCA9ICQkLngoZGF0YS54KTtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4IC0gcG9zW3hJbmRleF0sIDIpICsgTWF0aC5wb3coeSAtIHBvc1t5SW5kZXhdLCAyKSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5jb252ZXJ0VmFsdWVzVG9TdGVwID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICB2YXIgY29udmVydGVkID0gW10uY29uY2F0KHZhbHVlcyksXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGlmICghdGhpcy5pc0NhdGVnb3JpemVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSB2YWx1ZXMubGVuZ3RoICsgMTsgMCA8IGk7IGktLSkge1xuICAgICAgICAgICAgY29udmVydGVkW2ldID0gY29udmVydGVkW2kgLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnZlcnRlZFswXSA9IHtcbiAgICAgICAgICAgIHg6IGNvbnZlcnRlZFswXS54IC0gMSxcbiAgICAgICAgICAgIHZhbHVlOiBjb252ZXJ0ZWRbMF0udmFsdWUsXG4gICAgICAgICAgICBpZDogY29udmVydGVkWzBdLmlkXG4gICAgICAgIH07XG4gICAgICAgIGNvbnZlcnRlZFt2YWx1ZXMubGVuZ3RoICsgMV0gPSB7XG4gICAgICAgICAgICB4OiBjb252ZXJ0ZWRbdmFsdWVzLmxlbmd0aF0ueCArIDEsXG4gICAgICAgICAgICB2YWx1ZTogY29udmVydGVkW3ZhbHVlcy5sZW5ndGhdLnZhbHVlLFxuICAgICAgICAgICAgaWQ6IGNvbnZlcnRlZFt2YWx1ZXMubGVuZ3RoXS5pZFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBjb252ZXJ0ZWQ7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi51cGRhdGVEYXRhQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChuYW1lLCBhdHRycykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgY3VycmVudCA9IGNvbmZpZ1snZGF0YV8nICsgbmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRbaWRdID0gYXR0cnNbaWRdO1xuICAgICAgICB9KTtcbiAgICAgICAgJCQucmVkcmF3KHsgd2l0aExlZ2VuZDogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmxvYWQgPSBmdW5jdGlvbiAodGFyZ2V0cywgYXJncykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICBpZiAodGFyZ2V0cykge1xuICAgICAgICAgICAgLy8gZmlsdGVyIGxvYWRpbmcgdGFyZ2V0cyBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmIChhcmdzLmZpbHRlcikge1xuICAgICAgICAgICAgICAgIHRhcmdldHMgPSB0YXJnZXRzLmZpbHRlcihhcmdzLmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgdHlwZSBpZiBhcmdzLnR5cGVzIHx8IGFyZ3MudHlwZSBzcGVjaWZpZWRcbiAgICAgICAgICAgIGlmIChhcmdzLnR5cGUgfHwgYXJncy50eXBlcykge1xuICAgICAgICAgICAgICAgIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGFyZ3MudHlwZXMgJiYgYXJncy50eXBlc1t0LmlkXSA/IGFyZ3MudHlwZXNbdC5pZF0gOiBhcmdzLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICQkLnNldFRhcmdldFR5cGUodC5pZCwgdHlwZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUvQWRkIGRhdGFcbiAgICAgICAgICAgICQkLmRhdGEudGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkLmlkID09PSB0YXJnZXRzW2ldLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnZhbHVlcyA9IHRhcmdldHNbaV0udmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmNvbmNhdCh0YXJnZXRzKTsgLy8gYWRkIHJlbWFpbmVkXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGFyZ2V0c1xuICAgICAgICAkJC51cGRhdGVUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cyk7XG5cbiAgICAgICAgLy8gUmVkcmF3IHdpdGggbmV3IHRhcmdldHNcbiAgICAgICAgJCQucmVkcmF3KHsgd2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsIHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLCB3aXRoTGVnZW5kOiB0cnVlIH0pO1xuXG4gICAgICAgIGlmIChhcmdzLmRvbmUpIHtcbiAgICAgICAgICAgIGFyZ3MuZG9uZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5sb2FkRnJvbUFyZ3MgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICBpZiAoYXJncy5kYXRhKSB7XG4gICAgICAgICAgICAkJC5sb2FkKCQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGFyZ3MuZGF0YSksIGFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MudXJsKSB7XG4gICAgICAgICAgICAkJC5jb252ZXJ0VXJsVG9EYXRhKGFyZ3MudXJsLCBhcmdzLm1pbWVUeXBlLCBhcmdzLmhlYWRlcnMsIGFyZ3Mua2V5cywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAkJC5sb2FkKCQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGRhdGEpLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MuanNvbikge1xuICAgICAgICAgICAgJCQubG9hZCgkJC5jb252ZXJ0RGF0YVRvVGFyZ2V0cygkJC5jb252ZXJ0SnNvblRvRGF0YShhcmdzLmpzb24sIGFyZ3Mua2V5cykpLCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmdzLnJvd3MpIHtcbiAgICAgICAgICAgICQkLmxvYWQoJCQuY29udmVydERhdGFUb1RhcmdldHMoJCQuY29udmVydFJvd3NUb0RhdGEoYXJncy5yb3dzKSksIGFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MuY29sdW1ucykge1xuICAgICAgICAgICAgJCQubG9hZCgkJC5jb252ZXJ0RGF0YVRvVGFyZ2V0cygkJC5jb252ZXJ0Q29sdW1uc1RvRGF0YShhcmdzLmNvbHVtbnMpKSwgYXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkJC5sb2FkKG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi51bmxvYWQgPSBmdW5jdGlvbiAodGFyZ2V0SWRzLCBkb25lKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgZG9uZSA9IGZ1bmN0aW9uIGRvbmUoKSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaWx0ZXIgZXhpc3RpbmcgdGFyZ2V0XG4gICAgICAgIHRhcmdldElkcyA9IHRhcmdldElkcy5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJCQuaGFzVGFyZ2V0KCQkLmRhdGEudGFyZ2V0cywgaWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgbm8gdGFyZ2V0LCBjYWxsIGRvbmUgYW5kIHJldHVyblxuICAgICAgICBpZiAoIXRhcmdldElkcyB8fCB0YXJnZXRJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgJCQuc3ZnLnNlbGVjdEFsbCh0YXJnZXRJZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuICQkLnNlbGVjdG9yVGFyZ2V0KGlkKTtcbiAgICAgICAgfSkpLnRyYW5zaXRpb24oKS5zdHlsZSgnb3BhY2l0eScsIDApLnJlbW92ZSgpLmNhbGwoJCQuZW5kYWxsLCBkb25lKTtcbiAgICAgICAgdGFyZ2V0SWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAvLyBSZXNldCBmYWRlaW4gZm9yIGZ1dHVyZSBsb2FkXG4gICAgICAgICAgICAkJC53aXRob3V0RmFkZUluW2lkXSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRhcmdldCdzIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoJCQubGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgJCQubGVnZW5kLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5sZWdlbmRJdGVtICsgJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0YXJnZXRcbiAgICAgICAgICAgICQkLmRhdGEudGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdC5pZCAhPT0gaWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldFlEb21haW5NaW4gPSBmdW5jdGlvbiAodGFyZ2V0cykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgaWRzID0gJCQubWFwVG9JZHModGFyZ2V0cyksXG4gICAgICAgICAgICB5cyA9ICQkLmdldFZhbHVlc0FzSWRLZXllZCh0YXJnZXRzKSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgYmFzZUlkLFxuICAgICAgICAgICAgaWRzSW5Hcm91cCxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgaGFzTmVnYXRpdmVWYWx1ZTtcbiAgICAgICAgaWYgKGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBoYXNOZWdhdGl2ZVZhbHVlID0gJCQuaGFzTmVnYXRpdmVWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzKTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgYmFzZUlkXG4gICAgICAgICAgICAgICAgaWRzSW5Hcm91cCA9IGNvbmZpZy5kYXRhX2dyb3Vwc1tqXS5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZHMuaW5kZXhPZihpZCkgPj0gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaWRzSW5Hcm91cC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJhc2VJZCA9IGlkc0luR3JvdXBbMF07XG4gICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgbmVnYXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAgICAgaWYgKGhhc05lZ2F0aXZlVmFsdWUgJiYgeXNbYmFzZUlkXSkge1xuICAgICAgICAgICAgICAgICAgICB5c1tiYXNlSWRdLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlzW2Jhc2VJZF1baV0gPSB2IDwgMCA/IHYgOiAwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBtaW5cbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAxOyBrIDwgaWRzSW5Hcm91cC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IGlkc0luR3JvdXBba107XG4gICAgICAgICAgICAgICAgICAgIGlmICgheXNbaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5c1tpZF0uZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQkLmF4aXMuZ2V0SWQoaWQpID09PSAkJC5heGlzLmdldElkKGJhc2VJZCkgJiYgeXNbYmFzZUlkXSAmJiAhKGhhc05lZ2F0aXZlVmFsdWUgJiYgK3YgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlzW2Jhc2VJZF1baV0gKz0gK3Y7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJCQuZDMubWluKE9iamVjdC5rZXlzKHlzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuICQkLmQzLm1pbih5c1trZXldKTtcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0WURvbWFpbk1heCA9IGZ1bmN0aW9uICh0YXJnZXRzKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBpZHMgPSAkJC5tYXBUb0lkcyh0YXJnZXRzKSxcbiAgICAgICAgICAgIHlzID0gJCQuZ2V0VmFsdWVzQXNJZEtleWVkKHRhcmdldHMpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICBiYXNlSWQsXG4gICAgICAgICAgICBpZHNJbkdyb3VwLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBoYXNQb3NpdGl2ZVZhbHVlO1xuICAgICAgICBpZiAoY29uZmlnLmRhdGFfZ3JvdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGhhc1Bvc2l0aXZlVmFsdWUgPSAkJC5oYXNQb3NpdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBiYXNlSWRcbiAgICAgICAgICAgICAgICBpZHNJbkdyb3VwID0gY29uZmlnLmRhdGFfZ3JvdXBzW2pdLmZpbHRlcihmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkcy5pbmRleE9mKGlkKSA+PSAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpZHNJbkdyb3VwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmFzZUlkID0gaWRzSW5Hcm91cFswXTtcbiAgICAgICAgICAgICAgICAvLyBDb25zaWRlciBwb3NpdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICBpZiAoaGFzUG9zaXRpdmVWYWx1ZSAmJiB5c1tiYXNlSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHlzW2Jhc2VJZF0uZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeXNbYmFzZUlkXVtpXSA9IHYgPiAwID8gdiA6IDA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIG1heFxuICAgICAgICAgICAgICAgIGZvciAoayA9IDE7IGsgPCBpZHNJbkdyb3VwLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gaWRzSW5Hcm91cFtrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF5c1tpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlzW2lkXS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJCQuYXhpcy5nZXRJZChpZCkgPT09ICQkLmF4aXMuZ2V0SWQoYmFzZUlkKSAmJiB5c1tiYXNlSWRdICYmICEoaGFzUG9zaXRpdmVWYWx1ZSAmJiArdiA8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeXNbYmFzZUlkXVtpXSArPSArdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkJC5kMy5tYXgoT2JqZWN0LmtleXMoeXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gJCQuZDMubWF4KHlzW2tleV0pO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRZRG9tYWluID0gZnVuY3Rpb24gKHRhcmdldHMsIGF4aXNJZCwgeERvbWFpbikge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgdGFyZ2V0c0J5QXhpc0lkID0gdGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiAkJC5heGlzLmdldElkKHQuaWQpID09PSBheGlzSWQ7XG4gICAgICAgIH0pLFxuICAgICAgICAgICAgeVRhcmdldHMgPSB4RG9tYWluID8gJCQuZmlsdGVyQnlYRG9tYWluKHRhcmdldHNCeUF4aXNJZCwgeERvbWFpbikgOiB0YXJnZXRzQnlBeGlzSWQsXG4gICAgICAgICAgICB5TWluID0gYXhpc0lkID09PSAneTInID8gY29uZmlnLmF4aXNfeTJfbWluIDogY29uZmlnLmF4aXNfeV9taW4sXG4gICAgICAgICAgICB5TWF4ID0gYXhpc0lkID09PSAneTInID8gY29uZmlnLmF4aXNfeTJfbWF4IDogY29uZmlnLmF4aXNfeV9tYXgsXG4gICAgICAgICAgICB5RG9tYWluTWluID0gJCQuZ2V0WURvbWFpbk1pbih5VGFyZ2V0cyksXG4gICAgICAgICAgICB5RG9tYWluTWF4ID0gJCQuZ2V0WURvbWFpbk1heCh5VGFyZ2V0cyksXG4gICAgICAgICAgICBkb21haW4sXG4gICAgICAgICAgICBkb21haW5MZW5ndGgsXG4gICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgcGFkZGluZ190b3AsXG4gICAgICAgICAgICBwYWRkaW5nX2JvdHRvbSxcbiAgICAgICAgICAgIGNlbnRlciA9IGF4aXNJZCA9PT0gJ3kyJyA/IGNvbmZpZy5heGlzX3kyX2NlbnRlciA6IGNvbmZpZy5heGlzX3lfY2VudGVyLFxuICAgICAgICAgICAgeURvbWFpbkFicyxcbiAgICAgICAgICAgIGxlbmd0aHMsXG4gICAgICAgICAgICBkaWZmLFxuICAgICAgICAgICAgcmF0aW8sXG4gICAgICAgICAgICBpc0FsbFBvc2l0aXZlLFxuICAgICAgICAgICAgaXNBbGxOZWdhdGl2ZSxcbiAgICAgICAgICAgIGlzWmVyb0Jhc2VkID0gJCQuaGFzVHlwZSgnYmFyJywgeVRhcmdldHMpICYmIGNvbmZpZy5iYXJfemVyb2Jhc2VkIHx8ICQkLmhhc1R5cGUoJ2FyZWEnLCB5VGFyZ2V0cykgJiYgY29uZmlnLmFyZWFfemVyb2Jhc2VkLFxuICAgICAgICAgICAgaXNJbnZlcnRlZCA9IGF4aXNJZCA9PT0gJ3kyJyA/IGNvbmZpZy5heGlzX3kyX2ludmVydGVkIDogY29uZmlnLmF4aXNfeV9pbnZlcnRlZCxcbiAgICAgICAgICAgIHNob3dIb3Jpem9udGFsRGF0YUxhYmVsID0gJCQuaGFzRGF0YUxhYmVsKCkgJiYgY29uZmlnLmF4aXNfcm90YXRlZCxcbiAgICAgICAgICAgIHNob3dWZXJ0aWNhbERhdGFMYWJlbCA9ICQkLmhhc0RhdGFMYWJlbCgpICYmICFjb25maWcuYXhpc19yb3RhdGVkO1xuXG4gICAgICAgIC8vIE1FTU86IGF2b2lkIGludmVydGluZyBkb21haW4gdW5leHBlY3RlZGx5XG4gICAgICAgIHlEb21haW5NaW4gPSBpc1ZhbHVlKHlNaW4pID8geU1pbiA6IGlzVmFsdWUoeU1heCkgPyB5RG9tYWluTWluIDwgeU1heCA/IHlEb21haW5NaW4gOiB5TWF4IC0gMTAgOiB5RG9tYWluTWluO1xuICAgICAgICB5RG9tYWluTWF4ID0gaXNWYWx1ZSh5TWF4KSA/IHlNYXggOiBpc1ZhbHVlKHlNaW4pID8geU1pbiA8IHlEb21haW5NYXggPyB5RG9tYWluTWF4IDogeU1pbiArIDEwIDogeURvbWFpbk1heDtcblxuICAgICAgICBpZiAoeVRhcmdldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyB1c2UgY3VycmVudCBkb21haW4gaWYgdGFyZ2V0IG9mIGF4aXNJZCBpcyBub25lXG4gICAgICAgICAgICByZXR1cm4gYXhpc0lkID09PSAneTInID8gJCQueTIuZG9tYWluKCkgOiAkJC55LmRvbWFpbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hTih5RG9tYWluTWluKSkge1xuICAgICAgICAgICAgLy8gc2V0IG1pbmltdW0gdG8gemVybyB3aGVuIG5vdCBudW1iZXJcbiAgICAgICAgICAgIHlEb21haW5NaW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hTih5RG9tYWluTWF4KSkge1xuICAgICAgICAgICAgLy8gc2V0IG1heGltdW0gdG8gaGF2ZSBzYW1lIHZhbHVlIGFzIHlEb21haW5NaW5cbiAgICAgICAgICAgIHlEb21haW5NYXggPSB5RG9tYWluTWluO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5RG9tYWluTWluID09PSB5RG9tYWluTWF4KSB7XG4gICAgICAgICAgICB5RG9tYWluTWluIDwgMCA/IHlEb21haW5NYXggPSAwIDogeURvbWFpbk1pbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaXNBbGxQb3NpdGl2ZSA9IHlEb21haW5NaW4gPj0gMCAmJiB5RG9tYWluTWF4ID49IDA7XG4gICAgICAgIGlzQWxsTmVnYXRpdmUgPSB5RG9tYWluTWluIDw9IDAgJiYgeURvbWFpbk1heCA8PSAwO1xuXG4gICAgICAgIC8vIENhbmNlbCB6ZXJvYmFzZWQgaWYgYXhpc18qX21pbiAvIGF4aXNfKl9tYXggc3BlY2lmaWVkXG4gICAgICAgIGlmIChpc1ZhbHVlKHlNaW4pICYmIGlzQWxsUG9zaXRpdmUgfHwgaXNWYWx1ZSh5TWF4KSAmJiBpc0FsbE5lZ2F0aXZlKSB7XG4gICAgICAgICAgICBpc1plcm9CYXNlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmFyL0FyZWEgY2hhcnQgc2hvdWxkIGJlIDAtYmFzZWQgaWYgYWxsIHBvc2l0aXZlfG5lZ2F0aXZlXG4gICAgICAgIGlmIChpc1plcm9CYXNlZCkge1xuICAgICAgICAgICAgaWYgKGlzQWxsUG9zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICB5RG9tYWluTWluID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FsbE5lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgeURvbWFpbk1heCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkb21haW5MZW5ndGggPSBNYXRoLmFicyh5RG9tYWluTWF4IC0geURvbWFpbk1pbik7XG4gICAgICAgIHBhZGRpbmcgPSBwYWRkaW5nX3RvcCA9IHBhZGRpbmdfYm90dG9tID0gZG9tYWluTGVuZ3RoICogMC4xO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2VudGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgeURvbWFpbkFicyA9IE1hdGgubWF4KE1hdGguYWJzKHlEb21haW5NaW4pLCBNYXRoLmFicyh5RG9tYWluTWF4KSk7XG4gICAgICAgICAgICB5RG9tYWluTWF4ID0gY2VudGVyICsgeURvbWFpbkFicztcbiAgICAgICAgICAgIHlEb21haW5NaW4gPSBjZW50ZXIgLSB5RG9tYWluQWJzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBwYWRkaW5nIGZvciBkYXRhIGxhYmVsXG4gICAgICAgIGlmIChzaG93SG9yaXpvbnRhbERhdGFMYWJlbCkge1xuICAgICAgICAgICAgbGVuZ3RocyA9ICQkLmdldERhdGFMYWJlbExlbmd0aCh5RG9tYWluTWluLCB5RG9tYWluTWF4LCAnd2lkdGgnKTtcbiAgICAgICAgICAgIGRpZmYgPSBkaWZmRG9tYWluKCQkLnkucmFuZ2UoKSk7XG4gICAgICAgICAgICByYXRpbyA9IFtsZW5ndGhzWzBdIC8gZGlmZiwgbGVuZ3Roc1sxXSAvIGRpZmZdO1xuICAgICAgICAgICAgcGFkZGluZ190b3AgKz0gZG9tYWluTGVuZ3RoICogKHJhdGlvWzFdIC8gKDEgLSByYXRpb1swXSAtIHJhdGlvWzFdKSk7XG4gICAgICAgICAgICBwYWRkaW5nX2JvdHRvbSArPSBkb21haW5MZW5ndGggKiAocmF0aW9bMF0gLyAoMSAtIHJhdGlvWzBdIC0gcmF0aW9bMV0pKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaG93VmVydGljYWxEYXRhTGFiZWwpIHtcbiAgICAgICAgICAgIGxlbmd0aHMgPSAkJC5nZXREYXRhTGFiZWxMZW5ndGgoeURvbWFpbk1pbiwgeURvbWFpbk1heCwgJ2hlaWdodCcpO1xuICAgICAgICAgICAgcGFkZGluZ190b3AgKz0gJCQuYXhpcy5jb252ZXJ0UGl4ZWxzVG9BeGlzUGFkZGluZyhsZW5ndGhzWzFdLCBkb21haW5MZW5ndGgpO1xuICAgICAgICAgICAgcGFkZGluZ19ib3R0b20gKz0gJCQuYXhpcy5jb252ZXJ0UGl4ZWxzVG9BeGlzUGFkZGluZyhsZW5ndGhzWzBdLCBkb21haW5MZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzSWQgPT09ICd5JyAmJiBub3RFbXB0eShjb25maWcuYXhpc195X3BhZGRpbmcpKSB7XG4gICAgICAgICAgICBwYWRkaW5nX3RvcCA9ICQkLmF4aXMuZ2V0UGFkZGluZyhjb25maWcuYXhpc195X3BhZGRpbmcsICd0b3AnLCBwYWRkaW5nX3RvcCwgZG9tYWluTGVuZ3RoKTtcbiAgICAgICAgICAgIHBhZGRpbmdfYm90dG9tID0gJCQuYXhpcy5nZXRQYWRkaW5nKGNvbmZpZy5heGlzX3lfcGFkZGluZywgJ2JvdHRvbScsIHBhZGRpbmdfYm90dG9tLCBkb21haW5MZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzSWQgPT09ICd5MicgJiYgbm90RW1wdHkoY29uZmlnLmF4aXNfeTJfcGFkZGluZykpIHtcbiAgICAgICAgICAgIHBhZGRpbmdfdG9wID0gJCQuYXhpcy5nZXRQYWRkaW5nKGNvbmZpZy5heGlzX3kyX3BhZGRpbmcsICd0b3AnLCBwYWRkaW5nX3RvcCwgZG9tYWluTGVuZ3RoKTtcbiAgICAgICAgICAgIHBhZGRpbmdfYm90dG9tID0gJCQuYXhpcy5nZXRQYWRkaW5nKGNvbmZpZy5heGlzX3kyX3BhZGRpbmcsICdib3R0b20nLCBwYWRkaW5nX2JvdHRvbSwgZG9tYWluTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYXIvQXJlYSBjaGFydCBzaG91bGQgYmUgMC1iYXNlZCBpZiBhbGwgcG9zaXRpdmV8bmVnYXRpdmVcbiAgICAgICAgaWYgKGlzWmVyb0Jhc2VkKSB7XG4gICAgICAgICAgICBpZiAoaXNBbGxQb3NpdGl2ZSkge1xuICAgICAgICAgICAgICAgIHBhZGRpbmdfYm90dG9tID0geURvbWFpbk1pbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FsbE5lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgcGFkZGluZ190b3AgPSAteURvbWFpbk1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkb21haW4gPSBbeURvbWFpbk1pbiAtIHBhZGRpbmdfYm90dG9tLCB5RG9tYWluTWF4ICsgcGFkZGluZ190b3BdO1xuICAgICAgICByZXR1cm4gaXNJbnZlcnRlZCA/IGRvbWFpbi5yZXZlcnNlKCkgOiBkb21haW47XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRYRG9tYWluTWluID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAgICAgcmV0dXJuIGlzRGVmaW5lZChjb25maWcuYXhpc194X21pbikgPyAkJC5pc1RpbWVTZXJpZXMoKSA/IHRoaXMucGFyc2VEYXRlKGNvbmZpZy5heGlzX3hfbWluKSA6IGNvbmZpZy5heGlzX3hfbWluIDogJCQuZDMubWluKHRhcmdldHMsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gJCQuZDMubWluKHQudmFsdWVzLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2Lng7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRYRG9tYWluTWF4ID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAgICAgcmV0dXJuIGlzRGVmaW5lZChjb25maWcuYXhpc194X21heCkgPyAkJC5pc1RpbWVTZXJpZXMoKSA/IHRoaXMucGFyc2VEYXRlKGNvbmZpZy5heGlzX3hfbWF4KSA6IGNvbmZpZy5heGlzX3hfbWF4IDogJCQuZDMubWF4KHRhcmdldHMsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gJCQuZDMubWF4KHQudmFsdWVzLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2Lng7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRYRG9tYWluUGFkZGluZyA9IGZ1bmN0aW9uIChkb21haW4pIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIGRpZmYgPSBkb21haW5bMV0gLSBkb21haW5bMF0sXG4gICAgICAgICAgICBtYXhEYXRhQ291bnQsXG4gICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgcGFkZGluZ0xlZnQsXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ7XG4gICAgICAgIGlmICgkJC5pc0NhdGVnb3JpemVkKCkpIHtcbiAgICAgICAgICAgIHBhZGRpbmcgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKCQkLmhhc1R5cGUoJ2JhcicpKSB7XG4gICAgICAgICAgICBtYXhEYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcbiAgICAgICAgICAgIHBhZGRpbmcgPSBtYXhEYXRhQ291bnQgPiAxID8gZGlmZiAvIChtYXhEYXRhQ291bnQgLSAxKSAvIDIgOiAwLjU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWRkaW5nID0gZGlmZiAqIDAuMDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90eXBlb2YoY29uZmlnLmF4aXNfeF9wYWRkaW5nKSA9PT0gJ29iamVjdCcgJiYgbm90RW1wdHkoY29uZmlnLmF4aXNfeF9wYWRkaW5nKSkge1xuICAgICAgICAgICAgcGFkZGluZ0xlZnQgPSBpc1ZhbHVlKGNvbmZpZy5heGlzX3hfcGFkZGluZy5sZWZ0KSA/IGNvbmZpZy5heGlzX3hfcGFkZGluZy5sZWZ0IDogcGFkZGluZztcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodCA9IGlzVmFsdWUoY29uZmlnLmF4aXNfeF9wYWRkaW5nLnJpZ2h0KSA/IGNvbmZpZy5heGlzX3hfcGFkZGluZy5yaWdodCA6IHBhZGRpbmc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbmZpZy5heGlzX3hfcGFkZGluZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gcGFkZGluZ1JpZ2h0ID0gY29uZmlnLmF4aXNfeF9wYWRkaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFkZGluZ0xlZnQgPSBwYWRkaW5nUmlnaHQgPSBwYWRkaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxlZnQ6IHBhZGRpbmdMZWZ0LCByaWdodDogcGFkZGluZ1JpZ2h0IH07XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRYRG9tYWluID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIHhEb21haW4gPSBbJCQuZ2V0WERvbWFpbk1pbih0YXJnZXRzKSwgJCQuZ2V0WERvbWFpbk1heCh0YXJnZXRzKV0sXG4gICAgICAgICAgICBmaXJzdFggPSB4RG9tYWluWzBdLFxuICAgICAgICAgICAgbGFzdFggPSB4RG9tYWluWzFdLFxuICAgICAgICAgICAgcGFkZGluZyA9ICQkLmdldFhEb21haW5QYWRkaW5nKHhEb21haW4pLFxuICAgICAgICAgICAgbWluID0gMCxcbiAgICAgICAgICAgIG1heCA9IDA7XG4gICAgICAgIC8vIHNob3cgY2VudGVyIG9mIHggZG9tYWluIGlmIG1pbiBhbmQgbWF4IGFyZSB0aGUgc2FtZVxuICAgICAgICBpZiAoZmlyc3RYIC0gbGFzdFggPT09IDAgJiYgISQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xuICAgICAgICAgICAgaWYgKCQkLmlzVGltZVNlcmllcygpKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RYID0gbmV3IERhdGUoZmlyc3RYLmdldFRpbWUoKSAqIDAuNSk7XG4gICAgICAgICAgICAgICAgbGFzdFggPSBuZXcgRGF0ZShsYXN0WC5nZXRUaW1lKCkgKiAxLjUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaXJzdFggPSBmaXJzdFggPT09IDAgPyAxIDogZmlyc3RYICogMC41O1xuICAgICAgICAgICAgICAgIGxhc3RYID0gbGFzdFggPT09IDAgPyAtMSA6IGxhc3RYICogMS41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdFggfHwgZmlyc3RYID09PSAwKSB7XG4gICAgICAgICAgICBtaW4gPSAkJC5pc1RpbWVTZXJpZXMoKSA/IG5ldyBEYXRlKGZpcnN0WC5nZXRUaW1lKCkgLSBwYWRkaW5nLmxlZnQpIDogZmlyc3RYIC0gcGFkZGluZy5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0WCB8fCBsYXN0WCA9PT0gMCkge1xuICAgICAgICAgICAgbWF4ID0gJCQuaXNUaW1lU2VyaWVzKCkgPyBuZXcgRGF0ZShsYXN0WC5nZXRUaW1lKCkgKyBwYWRkaW5nLnJpZ2h0KSA6IGxhc3RYICsgcGFkZGluZy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnVwZGF0ZVhEb21haW4gPSBmdW5jdGlvbiAodGFyZ2V0cywgd2l0aFVwZGF0ZVhEb21haW4sIHdpdGhVcGRhdGVPcmdYRG9tYWluLCB3aXRoVHJpbSwgZG9tYWluKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG5cbiAgICAgICAgaWYgKHdpdGhVcGRhdGVPcmdYRG9tYWluKSB7XG4gICAgICAgICAgICAkJC54LmRvbWFpbihkb21haW4gPyBkb21haW4gOiAkJC5kMy5leHRlbnQoJCQuZ2V0WERvbWFpbih0YXJnZXRzKSkpO1xuICAgICAgICAgICAgJCQub3JnWERvbWFpbiA9ICQkLnguZG9tYWluKCk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLnpvb21fZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICQkLnpvb20uc2NhbGUoJCQueCkudXBkYXRlU2NhbGVFeHRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQkLnN1YlguZG9tYWluKCQkLnguZG9tYWluKCkpO1xuICAgICAgICAgICAgaWYgKCQkLmJydXNoKSB7XG4gICAgICAgICAgICAgICAgJCQuYnJ1c2guc2NhbGUoJCQuc3ViWCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpdGhVcGRhdGVYRG9tYWluKSB7XG4gICAgICAgICAgICAkJC54LmRvbWFpbihkb21haW4gPyBkb21haW4gOiAhJCQuYnJ1c2ggfHwgJCQuYnJ1c2guZW1wdHkoKSA/ICQkLm9yZ1hEb21haW4gOiAkJC5icnVzaC5leHRlbnQoKSk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLnpvb21fZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICQkLnpvb20uc2NhbGUoJCQueCkudXBkYXRlU2NhbGVFeHRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyaW0gZG9tYWluIHdoZW4gdG9vIGJpZyBieSB6b29tIG1vdXNlbW92ZSBldmVudFxuICAgICAgICBpZiAod2l0aFRyaW0pIHtcbiAgICAgICAgICAgICQkLnguZG9tYWluKCQkLnRyaW1YRG9tYWluKCQkLngub3JnRG9tYWluKCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkJC54LmRvbWFpbigpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udHJpbVhEb21haW4gPSBmdW5jdGlvbiAoZG9tYWluKSB7XG4gICAgICAgIHZhciB6b29tRG9tYWluID0gdGhpcy5nZXRab29tRG9tYWluKCksXG4gICAgICAgICAgICBtaW4gPSB6b29tRG9tYWluWzBdLFxuICAgICAgICAgICAgbWF4ID0gem9vbURvbWFpblsxXTtcbiAgICAgICAgaWYgKGRvbWFpblswXSA8PSBtaW4pIHtcbiAgICAgICAgICAgIGRvbWFpblsxXSA9ICtkb21haW5bMV0gKyAobWluIC0gZG9tYWluWzBdKTtcbiAgICAgICAgICAgIGRvbWFpblswXSA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4IDw9IGRvbWFpblsxXSkge1xuICAgICAgICAgICAgZG9tYWluWzBdID0gK2RvbWFpblswXSAtIChkb21haW5bMV0gLSBtYXgpO1xuICAgICAgICAgICAgZG9tYWluWzFdID0gbWF4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb21haW47XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmRyYWcgPSBmdW5jdGlvbiAobW91c2UpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIG1haW4gPSAkJC5tYWluLFxuICAgICAgICAgICAgZDMgPSAkJC5kMztcbiAgICAgICAgdmFyIHN4LCBzeSwgbXgsIG15LCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZO1xuXG4gICAgICAgIGlmICgkJC5oYXNBcmNUeXBlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gZG8gbm90aGluZyBpZiBub3Qgc2VsZWN0YWJsZVxuICAgICAgICBpZiAoY29uZmlnLnpvb21fZW5hYmxlZCAmJiAhJCQuem9vbS5hbHREb21haW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBza2lwIGlmIHpvb21hYmxlIGJlY2F1c2Ugb2YgY29uZmxpY3QgZHJhZyBkZWhhdmlvclxuICAgICAgICBpZiAoIWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9tdWx0aXBsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIHNraXAgd2hlbiBzaW5nbGUgc2VsZWN0aW9uIGJlY2F1c2UgZHJhZyBpcyB1c2VkIGZvciBtdWx0aXBsZSBzZWxlY3Rpb25cblxuICAgICAgICBzeCA9ICQkLmRyYWdTdGFydFswXTtcbiAgICAgICAgc3kgPSAkJC5kcmFnU3RhcnRbMV07XG4gICAgICAgIG14ID0gbW91c2VbMF07XG4gICAgICAgIG15ID0gbW91c2VbMV07XG4gICAgICAgIG1pblggPSBNYXRoLm1pbihzeCwgbXgpO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgoc3gsIG14KTtcbiAgICAgICAgbWluWSA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkID8gJCQubWFyZ2luLnRvcCA6IE1hdGgubWluKHN5LCBteSk7XG4gICAgICAgIG1heFkgPSBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCA/ICQkLmhlaWdodCA6IE1hdGgubWF4KHN5LCBteSk7XG5cbiAgICAgICAgbWFpbi5zZWxlY3QoJy4nICsgQ0xBU1MuZHJhZ2FyZWEpLmF0dHIoJ3gnLCBtaW5YKS5hdHRyKCd5JywgbWluWSkuYXR0cignd2lkdGgnLCBtYXhYIC0gbWluWCkuYXR0cignaGVpZ2h0JywgbWF4WSAtIG1pblkpO1xuICAgICAgICAvLyBUT0RPOiBiaW5hcnkgc2VhcmNoIHdoZW4gbXVsdGlwbGUgeHNcbiAgICAgICAgbWFpbi5zZWxlY3RBbGwoJy4nICsgQ0xBU1Muc2hhcGVzKS5zZWxlY3RBbGwoJy4nICsgQ0xBU1Muc2hhcGUpLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCk7XG4gICAgICAgIH0pLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCksXG4gICAgICAgICAgICAgICAgaXNJbmNsdWRlZCA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuSU5DTFVERUQpLFxuICAgICAgICAgICAgICAgIF94LFxuICAgICAgICAgICAgICAgIF95LFxuICAgICAgICAgICAgICAgIF93LFxuICAgICAgICAgICAgICAgIF9oLFxuICAgICAgICAgICAgICAgIHRvZ2dsZSxcbiAgICAgICAgICAgICAgICBpc1dpdGhpbiA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGJveDtcbiAgICAgICAgICAgIGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmNpcmNsZSkpIHtcbiAgICAgICAgICAgICAgICBfeCA9IHNoYXBlLmF0dHIoXCJjeFwiKSAqIDE7XG4gICAgICAgICAgICAgICAgX3kgPSBzaGFwZS5hdHRyKFwiY3lcIikgKiAxO1xuICAgICAgICAgICAgICAgIHRvZ2dsZSA9ICQkLnRvZ2dsZVBvaW50O1xuICAgICAgICAgICAgICAgIGlzV2l0aGluID0gbWluWCA8IF94ICYmIF94IDwgbWF4WCAmJiBtaW5ZIDwgX3kgJiYgX3kgPCBtYXhZO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmJhcikpIHtcbiAgICAgICAgICAgICAgICBib3ggPSBnZXRQYXRoQm94KHRoaXMpO1xuICAgICAgICAgICAgICAgIF94ID0gYm94Lng7XG4gICAgICAgICAgICAgICAgX3kgPSBib3gueTtcbiAgICAgICAgICAgICAgICBfdyA9IGJveC53aWR0aDtcbiAgICAgICAgICAgICAgICBfaCA9IGJveC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdG9nZ2xlID0gJCQudG9nZ2xlUGF0aDtcbiAgICAgICAgICAgICAgICBpc1dpdGhpbiA9ICEobWF4WCA8IF94IHx8IF94ICsgX3cgPCBtaW5YKSAmJiAhKG1heFkgPCBfeSB8fCBfeSArIF9oIDwgbWluWSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGxpbmUvYXJlYSBzZWxlY3Rpb24gbm90IHN1cHBvcnRlZCB5ZXRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNXaXRoaW4gXiBpc0luY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgc2hhcGUuY2xhc3NlZChDTEFTUy5JTkNMVURFRCwgIWlzSW5jbHVkZWQpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGluY2x1ZGVkL3VuaW5jbHVkZWQgY2FsbGJhY2sgaGVyZVxuICAgICAgICAgICAgICAgIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsICFpc1NlbGVjdGVkKTtcbiAgICAgICAgICAgICAgICB0b2dnbGUuY2FsbCgkJCwgIWlzU2VsZWN0ZWQsIHNoYXBlLCBkLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmRyYWdzdGFydCA9IGZ1bmN0aW9uIChtb3VzZSkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICAgICBpZiAoJCQuaGFzQXJjVHlwZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIGRvIG5vdGhpbmcgaWYgbm90IHNlbGVjdGFibGVcbiAgICAgICAgJCQuZHJhZ1N0YXJ0ID0gbW91c2U7XG4gICAgICAgICQkLm1haW4uc2VsZWN0KCcuJyArIENMQVNTLmNoYXJ0KS5hcHBlbmQoJ3JlY3QnKS5hdHRyKCdjbGFzcycsIENMQVNTLmRyYWdhcmVhKS5zdHlsZSgnb3BhY2l0eScsIDAuMSk7XG4gICAgICAgICQkLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZHJhZ2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAgICAgaWYgKCQkLmhhc0FyY1R5cGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBkbyBub3RoaW5nIGlmIG5vdCBzZWxlY3RhYmxlXG4gICAgICAgICQkLm1haW4uc2VsZWN0KCcuJyArIENMQVNTLmRyYWdhcmVhKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTAwKS5zdHlsZSgnb3BhY2l0eScsIDApLnJlbW92ZSgpO1xuICAgICAgICAkJC5tYWluLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5zaGFwZSkuY2xhc3NlZChDTEFTUy5JTkNMVURFRCwgZmFsc2UpO1xuICAgICAgICAkJC5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRZRm9ybWF0ID0gZnVuY3Rpb24gKGZvckFyYykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgZm9ybWF0Rm9yWSA9IGZvckFyYyAmJiAhJCQuaGFzVHlwZSgnZ2F1Z2UnKSA/ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdCA6ICQkLnlGb3JtYXQsXG4gICAgICAgICAgICBmb3JtYXRGb3JZMiA9IGZvckFyYyAmJiAhJCQuaGFzVHlwZSgnZ2F1Z2UnKSA/ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdCA6ICQkLnkyRm9ybWF0O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHYsIHJhdGlvLCBpZCkge1xuICAgICAgICAgICAgdmFyIGZvcm1hdCA9ICQkLmF4aXMuZ2V0SWQoaWQpID09PSAneTInID8gZm9ybWF0Rm9yWTIgOiBmb3JtYXRGb3JZO1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdC5jYWxsKCQkLCB2LCByYXRpbyk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi55Rm9ybWF0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5heGlzX3lfdGlja19mb3JtYXQgPyBjb25maWcuYXhpc195X3RpY2tfZm9ybWF0IDogJCQuZGVmYXVsdFZhbHVlRm9ybWF0O1xuICAgICAgICByZXR1cm4gZm9ybWF0KHYpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ueTJGb3JtYXQgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLmF4aXNfeTJfdGlja19mb3JtYXQgPyBjb25maWcuYXhpc195Ml90aWNrX2Zvcm1hdCA6ICQkLmRlZmF1bHRWYWx1ZUZvcm1hdDtcbiAgICAgICAgcmV0dXJuIGZvcm1hdCh2KTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmRlZmF1bHRWYWx1ZUZvcm1hdCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBpc1ZhbHVlKHYpID8gK3YgOiBcIlwiO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZGVmYXVsdEFyY1ZhbHVlRm9ybWF0ID0gZnVuY3Rpb24gKHYsIHJhdGlvKSB7XG4gICAgICAgIHJldHVybiAocmF0aW8gKiAxMDApLnRvRml4ZWQoMSkgKyAnJSc7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5kYXRhTGFiZWxGb3JtYXQgPSBmdW5jdGlvbiAodGFyZ2V0SWQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGFfbGFiZWxzID0gJCQuY29uZmlnLmRhdGFfbGFiZWxzLFxuICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgZGVmYXVsdEZvcm1hdCA9IGZ1bmN0aW9uIGRlZmF1bHRGb3JtYXQodikge1xuICAgICAgICAgICAgcmV0dXJuIGlzVmFsdWUodikgPyArdiA6IFwiXCI7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGZpbmQgZm9ybWF0IGFjY29yZGluZyB0byBheGlzIGlkXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YV9sYWJlbHMuZm9ybWF0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBkYXRhX2xhYmVscy5mb3JtYXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihkYXRhX2xhYmVscy5mb3JtYXQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKGRhdGFfbGFiZWxzLmZvcm1hdFt0YXJnZXRJZF0pIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBkYXRhX2xhYmVscy5mb3JtYXRbdGFyZ2V0SWRdID09PSB0cnVlID8gZGVmYXVsdEZvcm1hdCA6IGRhdGFfbGFiZWxzLmZvcm1hdFt0YXJnZXRJZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBkZWZhdWx0Rm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmluaXRHcmlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgZDMgPSAkJC5kMztcbiAgICAgICAgJCQuZ3JpZCA9ICQkLm1haW4uYXBwZW5kKCdnJykuYXR0cihcImNsaXAtcGF0aFwiLCAkJC5jbGlwUGF0aEZvckdyaWQpLmF0dHIoJ2NsYXNzJywgQ0xBU1MuZ3JpZCk7XG4gICAgICAgIGlmIChjb25maWcuZ3JpZF94X3Nob3cpIHtcbiAgICAgICAgICAgICQkLmdyaWQuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmdyaWRfeV9zaG93KSB7XG4gICAgICAgICAgICAkJC5ncmlkLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgQ0xBU1MueWdyaWRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmdyaWRfZm9jdXNfc2hvdykge1xuICAgICAgICAgICAgJCQuZ3JpZC5hcHBlbmQoJ2cnKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRGb2N1cykuYXBwZW5kKCdsaW5lJykuYXR0cignY2xhc3MnLCBDTEFTUy54Z3JpZEZvY3VzKTtcbiAgICAgICAgfVxuICAgICAgICAkJC54Z3JpZCA9IGQzLnNlbGVjdEFsbChbXSk7XG4gICAgICAgIGlmICghY29uZmlnLmdyaWRfbGluZXNfZnJvbnQpIHtcbiAgICAgICAgICAgICQkLmluaXRHcmlkTGluZXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaW5pdEdyaWRMaW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGQzID0gJCQuZDM7XG4gICAgICAgICQkLmdyaWRMaW5lcyA9ICQkLm1haW4uYXBwZW5kKCdnJykuYXR0cihcImNsaXAtcGF0aFwiLCAkJC5jbGlwUGF0aEZvckdyaWQpLmF0dHIoJ2NsYXNzJywgQ0xBU1MuZ3JpZCArICcgJyArIENMQVNTLmdyaWRMaW5lcyk7XG4gICAgICAgICQkLmdyaWRMaW5lcy5hcHBlbmQoJ2cnKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRMaW5lcyk7XG4gICAgICAgICQkLmdyaWRMaW5lcy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsIENMQVNTLnlncmlkTGluZXMpO1xuICAgICAgICAkJC54Z3JpZExpbmVzID0gZDMuc2VsZWN0QWxsKFtdKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnVwZGF0ZVhHcmlkID0gZnVuY3Rpb24gKHdpdGhvdXRVcGRhdGUpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIGQzID0gJCQuZDMsXG4gICAgICAgICAgICB4Z3JpZERhdGEgPSAkJC5nZW5lcmF0ZUdyaWREYXRhKGNvbmZpZy5ncmlkX3hfdHlwZSwgJCQueCksXG4gICAgICAgICAgICB0aWNrT2Zmc2V0ID0gJCQuaXNDYXRlZ29yaXplZCgpID8gJCQueEF4aXMudGlja09mZnNldCgpIDogMDtcblxuICAgICAgICAkJC54Z3JpZEF0dHIgPSBjb25maWcuYXhpc19yb3RhdGVkID8ge1xuICAgICAgICAgICAgJ3gxJzogMCxcbiAgICAgICAgICAgICd4Mic6ICQkLndpZHRoLFxuICAgICAgICAgICAgJ3kxJzogZnVuY3Rpb24geTEoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkJC54KGQpIC0gdGlja09mZnNldDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAneTInOiBmdW5jdGlvbiB5MihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkLngoZCkgLSB0aWNrT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IDoge1xuICAgICAgICAgICAgJ3gxJzogZnVuY3Rpb24geDEoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkJC54KGQpICsgdGlja09mZnNldDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAneDInOiBmdW5jdGlvbiB4MihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkLngoZCkgKyB0aWNrT2Zmc2V0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd5MSc6IDAsXG4gICAgICAgICAgICAneTInOiAkJC5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICAkJC54Z3JpZCA9ICQkLm1haW4uc2VsZWN0KCcuJyArIENMQVNTLnhncmlkcykuc2VsZWN0QWxsKCcuJyArIENMQVNTLnhncmlkKS5kYXRhKHhncmlkRGF0YSk7XG4gICAgICAgICQkLnhncmlkLmVudGVyKCkuYXBwZW5kKCdsaW5lJykuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkKTtcbiAgICAgICAgaWYgKCF3aXRob3V0VXBkYXRlKSB7XG4gICAgICAgICAgICAkJC54Z3JpZC5hdHRyKCQkLnhncmlkQXR0cikuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gK2QzLnNlbGVjdCh0aGlzKS5hdHRyKGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAneTEnIDogJ3gxJykgPT09IChjb25maWcuYXhpc19yb3RhdGVkID8gJCQuaGVpZ2h0IDogMCkgPyAwIDogMTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgICQkLnhncmlkLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udXBkYXRlWUdyaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBncmlkVmFsdWVzID0gJCQueUF4aXMudGlja1ZhbHVlcygpIHx8ICQkLnkudGlja3MoY29uZmlnLmdyaWRfeV90aWNrcyk7XG4gICAgICAgICQkLnlncmlkID0gJCQubWFpbi5zZWxlY3QoJy4nICsgQ0xBU1MueWdyaWRzKS5zZWxlY3RBbGwoJy4nICsgQ0xBU1MueWdyaWQpLmRhdGEoZ3JpZFZhbHVlcyk7XG4gICAgICAgICQkLnlncmlkLmVudGVyKCkuYXBwZW5kKCdsaW5lJykuYXR0cignY2xhc3MnLCBDTEFTUy55Z3JpZCk7XG4gICAgICAgICQkLnlncmlkLmF0dHIoXCJ4MVwiLCBjb25maWcuYXhpc19yb3RhdGVkID8gJCQueSA6IDApLmF0dHIoXCJ4MlwiLCBjb25maWcuYXhpc19yb3RhdGVkID8gJCQueSA6ICQkLndpZHRoKS5hdHRyKFwieTFcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/IDAgOiAkJC55KS5hdHRyKFwieTJcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/ICQkLmhlaWdodCA6ICQkLnkpO1xuICAgICAgICAkJC55Z3JpZC5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgICQkLnNtb290aExpbmVzKCQkLnlncmlkLCAnZ3JpZCcpO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5ncmlkVGV4dEFuY2hvciA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLnBvc2l0aW9uID8gZC5wb3NpdGlvbiA6IFwiZW5kXCI7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5ncmlkVGV4dER4ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQucG9zaXRpb24gPT09ICdzdGFydCcgPyA0IDogZC5wb3NpdGlvbiA9PT0gJ21pZGRsZScgPyAwIDogLTQ7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi54R3JpZFRleHRYID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQucG9zaXRpb24gPT09ICdzdGFydCcgPyAtdGhpcy5oZWlnaHQgOiBkLnBvc2l0aW9uID09PSAnbWlkZGxlJyA/IC10aGlzLmhlaWdodCAvIDIgOiAwO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ueUdyaWRUZXh0WCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLnBvc2l0aW9uID09PSAnc3RhcnQnID8gMCA6IGQucG9zaXRpb24gPT09ICdtaWRkbGUnID8gdGhpcy53aWR0aCAvIDIgOiB0aGlzLndpZHRoO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udXBkYXRlR3JpZCA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgbWFpbiA9ICQkLm1haW4sXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICB4Z3JpZExpbmUsXG4gICAgICAgICAgICB5Z3JpZExpbmUsXG4gICAgICAgICAgICB5djtcblxuICAgICAgICAvLyBoaWRlIGlmIGFyYyB0eXBlXG4gICAgICAgICQkLmdyaWQuc3R5bGUoJ3Zpc2liaWxpdHknLCAkJC5oYXNBcmNUeXBlKCkgPyAnaGlkZGVuJyA6ICd2aXNpYmxlJyk7XG5cbiAgICAgICAgbWFpbi5zZWxlY3QoJ2xpbmUuJyArIENMQVNTLnhncmlkRm9jdXMpLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgaWYgKGNvbmZpZy5ncmlkX3hfc2hvdykge1xuICAgICAgICAgICAgJCQudXBkYXRlWEdyaWQoKTtcbiAgICAgICAgfVxuICAgICAgICAkJC54Z3JpZExpbmVzID0gbWFpbi5zZWxlY3QoJy4nICsgQ0xBU1MueGdyaWRMaW5lcykuc2VsZWN0QWxsKCcuJyArIENMQVNTLnhncmlkTGluZSkuZGF0YShjb25maWcuZ3JpZF94X2xpbmVzKTtcbiAgICAgICAgLy8gZW50ZXJcbiAgICAgICAgeGdyaWRMaW5lID0gJCQueGdyaWRMaW5lcy5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIENMQVNTLnhncmlkTGluZSArIChkWydjbGFzcyddID8gJyAnICsgZFsnY2xhc3MnXSA6ICcnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHhncmlkTGluZS5hcHBlbmQoJ2xpbmUnKS5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgICAgIHhncmlkTGluZS5hcHBlbmQoJ3RleHQnKS5hdHRyKFwidGV4dC1hbmNob3JcIiwgJCQuZ3JpZFRleHRBbmNob3IpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/IFwiXCIgOiBcInJvdGF0ZSgtOTApXCIpLmF0dHIoJ2R4JywgJCQuZ3JpZFRleHREeCkuYXR0cignZHknLCAtNSkuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICAvLyB1ZHBhdGVcbiAgICAgICAgLy8gZG9uZSBpbiBkMy50cmFuc2l0aW9uKCkgb2YgdGhlIGVuZCBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgIC8vIGV4aXRcbiAgICAgICAgJCQueGdyaWRMaW5lcy5leGl0KCkudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5zdHlsZShcIm9wYWNpdHlcIiwgMCkucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gWS1HcmlkXG4gICAgICAgIGlmIChjb25maWcuZ3JpZF95X3Nob3cpIHtcbiAgICAgICAgICAgICQkLnVwZGF0ZVlHcmlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgJCQueWdyaWRMaW5lcyA9IG1haW4uc2VsZWN0KCcuJyArIENMQVNTLnlncmlkTGluZXMpLnNlbGVjdEFsbCgnLicgKyBDTEFTUy55Z3JpZExpbmUpLmRhdGEoY29uZmlnLmdyaWRfeV9saW5lcyk7XG4gICAgICAgIC8vIGVudGVyXG4gICAgICAgIHlncmlkTGluZSA9ICQkLnlncmlkTGluZXMuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBDTEFTUy55Z3JpZExpbmUgKyAoZFsnY2xhc3MnXSA/ICcgJyArIGRbJ2NsYXNzJ10gOiAnJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB5Z3JpZExpbmUuYXBwZW5kKCdsaW5lJykuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICB5Z3JpZExpbmUuYXBwZW5kKCd0ZXh0JykuYXR0cihcInRleHQtYW5jaG9yXCIsICQkLmdyaWRUZXh0QW5jaG9yKS5hdHRyKFwidHJhbnNmb3JtXCIsIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcInJvdGF0ZSgtOTApXCIgOiBcIlwiKS5hdHRyKCdkeCcsICQkLmdyaWRUZXh0RHgpLmF0dHIoJ2R5JywgLTUpLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgLy8gdXBkYXRlXG4gICAgICAgIHl2ID0gJCQueXYuYmluZCgkJCk7XG4gICAgICAgICQkLnlncmlkTGluZXMuc2VsZWN0KCdsaW5lJykudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5hdHRyKFwieDFcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/IHl2IDogMCkuYXR0cihcIngyXCIsIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyB5diA6ICQkLndpZHRoKS5hdHRyKFwieTFcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/IDAgOiB5dikuYXR0cihcInkyXCIsIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAkJC5oZWlnaHQgOiB5dikuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAkJC55Z3JpZExpbmVzLnNlbGVjdCgndGV4dCcpLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuYXR0cihcInhcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/ICQkLnhHcmlkVGV4dFguYmluZCgkJCkgOiAkJC55R3JpZFRleHRYLmJpbmQoJCQpKS5hdHRyKFwieVwiLCB5dikudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQudGV4dDtcbiAgICAgICAgfSkuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAvLyBleGl0XG4gICAgICAgICQkLnlncmlkTGluZXMuZXhpdCgpLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuc3R5bGUoXCJvcGFjaXR5XCIsIDApLnJlbW92ZSgpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ucmVkcmF3R3JpZCA9IGZ1bmN0aW9uICh3aXRoVHJhbnNpdGlvbikge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgeHYgPSAkJC54di5iaW5kKCQkKSxcbiAgICAgICAgICAgIGxpbmVzID0gJCQueGdyaWRMaW5lcy5zZWxlY3QoJ2xpbmUnKSxcbiAgICAgICAgICAgIHRleHRzID0gJCQueGdyaWRMaW5lcy5zZWxlY3QoJ3RleHQnKTtcbiAgICAgICAgcmV0dXJuIFsod2l0aFRyYW5zaXRpb24gPyBsaW5lcy50cmFuc2l0aW9uKCkgOiBsaW5lcykuYXR0cihcIngxXCIsIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAwIDogeHYpLmF0dHIoXCJ4MlwiLCBjb25maWcuYXhpc19yb3RhdGVkID8gJCQud2lkdGggOiB4dikuYXR0cihcInkxXCIsIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyB4diA6IDApLmF0dHIoXCJ5MlwiLCBjb25maWcuYXhpc19yb3RhdGVkID8geHYgOiAkJC5oZWlnaHQpLnN0eWxlKFwib3BhY2l0eVwiLCAxKSwgKHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpLmF0dHIoXCJ4XCIsIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAkJC55R3JpZFRleHRYLmJpbmQoJCQpIDogJCQueEdyaWRUZXh0WC5iaW5kKCQkKSkuYXR0cihcInlcIiwgeHYpLnRleHQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLnRleHQ7XG4gICAgICAgIH0pLnN0eWxlKFwib3BhY2l0eVwiLCAxKV07XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5zaG93WEdyaWRGb2N1cyA9IGZ1bmN0aW9uIChzZWxlY3RlZERhdGEpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIGRhdGFUb1Nob3cgPSBzZWxlY3RlZERhdGEuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZCAmJiBpc1ZhbHVlKGQudmFsdWUpO1xuICAgICAgICB9KSxcbiAgICAgICAgICAgIGZvY3VzRWwgPSAkJC5tYWluLnNlbGVjdEFsbCgnbGluZS4nICsgQ0xBU1MueGdyaWRGb2N1cyksXG4gICAgICAgICAgICB4eCA9ICQkLnh4LmJpbmQoJCQpO1xuICAgICAgICBpZiAoIWNvbmZpZy50b29sdGlwX3Nob3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBIaWRlIHdoZW4gc2NhdHRlciBwbG90IGV4aXN0c1xuICAgICAgICBpZiAoJCQuaGFzVHlwZSgnc2NhdHRlcicpIHx8ICQkLmhhc0FyY1R5cGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvY3VzRWwuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKS5kYXRhKFtkYXRhVG9TaG93WzBdXSkuYXR0cihjb25maWcuYXhpc19yb3RhdGVkID8gJ3kxJyA6ICd4MScsIHh4KS5hdHRyKGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAneTInIDogJ3gyJywgeHgpO1xuICAgICAgICAkJC5zbW9vdGhMaW5lcyhmb2N1c0VsLCAnZ3JpZCcpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaGlkZVhHcmlkRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWFpbi5zZWxlY3QoJ2xpbmUuJyArIENMQVNTLnhncmlkRm9jdXMpLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnVwZGF0ZVhncmlkRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgICAgICQkLm1haW4uc2VsZWN0KCdsaW5lLicgKyBDTEFTUy54Z3JpZEZvY3VzKS5hdHRyKFwieDFcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/IDAgOiAtMTApLmF0dHIoXCJ4MlwiLCBjb25maWcuYXhpc19yb3RhdGVkID8gJCQud2lkdGggOiAtMTApLmF0dHIoXCJ5MVwiLCBjb25maWcuYXhpc19yb3RhdGVkID8gLTEwIDogMCkuYXR0cihcInkyXCIsIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAtMTAgOiAkJC5oZWlnaHQpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2VuZXJhdGVHcmlkRGF0YSA9IGZ1bmN0aW9uICh0eXBlLCBzY2FsZSkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgZ3JpZERhdGEgPSBbXSxcbiAgICAgICAgICAgIHhEb21haW4sXG4gICAgICAgICAgICBmaXJzdFllYXIsXG4gICAgICAgICAgICBsYXN0WWVhcixcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICB0aWNrTnVtID0gJCQubWFpbi5zZWxlY3QoXCIuXCIgKyBDTEFTUy5heGlzWCkuc2VsZWN0QWxsKCcudGljaycpLnNpemUoKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgeERvbWFpbiA9ICQkLmdldFhEb21haW4oKTtcbiAgICAgICAgICAgIGZpcnN0WWVhciA9IHhEb21haW5bMF0uZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgIGxhc3RZZWFyID0geERvbWFpblsxXS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgZm9yIChpID0gZmlyc3RZZWFyOyBpIDw9IGxhc3RZZWFyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBncmlkRGF0YS5wdXNoKG5ldyBEYXRlKGkgKyAnLTAxLTAxIDAwOjAwOjAwJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JpZERhdGEgPSBzY2FsZS50aWNrcygxMCk7XG4gICAgICAgICAgICBpZiAoZ3JpZERhdGEubGVuZ3RoID4gdGlja051bSkge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBvbmx5IGludFxuICAgICAgICAgICAgICAgIGdyaWREYXRhID0gZ3JpZERhdGEuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJcIiArIGQpLmluZGV4T2YoJy4nKSA8IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyaWREYXRhO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0R3JpZEZpbHRlclRvUmVtb3ZlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zID8gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgW10uY29uY2F0KHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBwYXJhbSAmJiBsaW5lLnZhbHVlID09PSBwYXJhbS52YWx1ZSB8fCAnY2xhc3MnIGluIHBhcmFtICYmIGxpbmVbJ2NsYXNzJ10gPT09IHBhcmFtWydjbGFzcyddKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ucmVtb3ZlR3JpZExpbmVzID0gZnVuY3Rpb24gKHBhcmFtcywgZm9yWCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgdG9SZW1vdmUgPSAkJC5nZXRHcmlkRmlsdGVyVG9SZW1vdmUocGFyYW1zKSxcbiAgICAgICAgICAgIHRvU2hvdyA9IGZ1bmN0aW9uIHRvU2hvdyhsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRvUmVtb3ZlKGxpbmUpO1xuICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3NMaW5lcyA9IGZvclggPyBDTEFTUy54Z3JpZExpbmVzIDogQ0xBU1MueWdyaWRMaW5lcyxcbiAgICAgICAgICAgIGNsYXNzTGluZSA9IGZvclggPyBDTEFTUy54Z3JpZExpbmUgOiBDTEFTUy55Z3JpZExpbmU7XG4gICAgICAgICQkLm1haW4uc2VsZWN0KCcuJyArIGNsYXNzTGluZXMpLnNlbGVjdEFsbCgnLicgKyBjbGFzc0xpbmUpLmZpbHRlcih0b1JlbW92ZSkudHJhbnNpdGlvbigpLmR1cmF0aW9uKGNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKS5zdHlsZSgnb3BhY2l0eScsIDApLnJlbW92ZSgpO1xuICAgICAgICBpZiAoZm9yWCkge1xuICAgICAgICAgICAgY29uZmlnLmdyaWRfeF9saW5lcyA9IGNvbmZpZy5ncmlkX3hfbGluZXMuZmlsdGVyKHRvU2hvdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuZ3JpZF95X2xpbmVzID0gY29uZmlnLmdyaWRfeV9saW5lcy5maWx0ZXIodG9TaG93KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5pbml0RXZlbnRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICAkJC5tYWluLnNlbGVjdCgnLicgKyBDTEFTUy5jaGFydCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuZXZlbnRSZWN0cykuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDApO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ucmVkcmF3RXZlbnRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgZXZlbnRSZWN0VXBkYXRlLFxuICAgICAgICAgICAgbWF4RGF0YUNvdW50VGFyZ2V0LFxuICAgICAgICAgICAgaXNNdWx0aXBsZVggPSAkJC5pc011bHRpcGxlWCgpO1xuXG4gICAgICAgIC8vIHJlY3RzIGZvciBtb3VzZW92ZXJcbiAgICAgICAgdmFyIGV2ZW50UmVjdHMgPSAkJC5tYWluLnNlbGVjdCgnLicgKyBDTEFTUy5ldmVudFJlY3RzKS5zdHlsZSgnY3Vyc29yJywgY29uZmlnLnpvb21fZW5hYmxlZCA/IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAnbnMtcmVzaXplJyA6ICdldy1yZXNpemUnIDogbnVsbCkuY2xhc3NlZChDTEFTUy5ldmVudFJlY3RzTXVsdGlwbGUsIGlzTXVsdGlwbGVYKS5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdHNTaW5nbGUsICFpc011bHRpcGxlWCk7XG5cbiAgICAgICAgLy8gY2xlYXIgb2xkIHJlY3RzXG4gICAgICAgIGV2ZW50UmVjdHMuc2VsZWN0QWxsKCcuJyArIENMQVNTLmV2ZW50UmVjdCkucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gb3BlbiBhcyBwdWJsaWMgdmFyaWFibGVcbiAgICAgICAgJCQuZXZlbnRSZWN0ID0gZXZlbnRSZWN0cy5zZWxlY3RBbGwoJy4nICsgQ0xBU1MuZXZlbnRSZWN0KTtcblxuICAgICAgICBpZiAoaXNNdWx0aXBsZVgpIHtcbiAgICAgICAgICAgIGV2ZW50UmVjdFVwZGF0ZSA9ICQkLmV2ZW50UmVjdC5kYXRhKFswXSk7XG4gICAgICAgICAgICAvLyBlbnRlciA6IG9ubHkgb25lIHJlY3Qgd2lsbCBiZSBhZGRlZFxuICAgICAgICAgICAgJCQuZ2VuZXJhdGVFdmVudFJlY3RzRm9yTXVsdGlwbGVYcyhldmVudFJlY3RVcGRhdGUuZW50ZXIoKSk7XG4gICAgICAgICAgICAvLyB1cGRhdGVcbiAgICAgICAgICAgICQkLnVwZGF0ZUV2ZW50UmVjdChldmVudFJlY3RVcGRhdGUpO1xuICAgICAgICAgICAgLy8gZXhpdCA6IG5vdCBuZWVkZWQgYmVjYXVzZSBhbHdheXMgb25seSBvbmUgcmVjdCBleGlzdHNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNldCBkYXRhIGFuZCB1cGRhdGUgJCQuZXZlbnRSZWN0XG4gICAgICAgICAgICBtYXhEYXRhQ291bnRUYXJnZXQgPSAkJC5nZXRNYXhEYXRhQ291bnRUYXJnZXQoJCQuZGF0YS50YXJnZXRzKTtcbiAgICAgICAgICAgIGV2ZW50UmVjdHMuZGF0dW0obWF4RGF0YUNvdW50VGFyZ2V0ID8gbWF4RGF0YUNvdW50VGFyZ2V0LnZhbHVlcyA6IFtdKTtcbiAgICAgICAgICAgICQkLmV2ZW50UmVjdCA9IGV2ZW50UmVjdHMuc2VsZWN0QWxsKCcuJyArIENMQVNTLmV2ZW50UmVjdCk7XG4gICAgICAgICAgICBldmVudFJlY3RVcGRhdGUgPSAkJC5ldmVudFJlY3QuZGF0YShmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBlbnRlclxuICAgICAgICAgICAgJCQuZ2VuZXJhdGVFdmVudFJlY3RzRm9yU2luZ2xlWChldmVudFJlY3RVcGRhdGUuZW50ZXIoKSk7XG4gICAgICAgICAgICAvLyB1cGRhdGVcbiAgICAgICAgICAgICQkLnVwZGF0ZUV2ZW50UmVjdChldmVudFJlY3RVcGRhdGUpO1xuICAgICAgICAgICAgLy8gZXhpdFxuICAgICAgICAgICAgZXZlbnRSZWN0VXBkYXRlLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udXBkYXRlRXZlbnRSZWN0ID0gZnVuY3Rpb24gKGV2ZW50UmVjdFVwZGF0ZSkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICB3LFxuICAgICAgICAgICAgaCxcbiAgICAgICAgICAgIHJlY3RXLFxuICAgICAgICAgICAgcmVjdFg7XG5cbiAgICAgICAgLy8gc2V0IHVwZGF0ZSBzZWxlY3Rpb24gaWYgbnVsbFxuICAgICAgICBldmVudFJlY3RVcGRhdGUgPSBldmVudFJlY3RVcGRhdGUgfHwgJCQuZXZlbnRSZWN0LmRhdGEoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoJCQuaXNNdWx0aXBsZVgoKSkge1xuICAgICAgICAgICAgLy8gVE9ETzogcm90YXRlZCBub3Qgc3VwcG9ydGVkIHlldFxuICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgIHcgPSAkJC53aWR0aDtcbiAgICAgICAgICAgIGggPSAkJC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoKCQkLmlzQ3VzdG9tWCgpIHx8ICQkLmlzVGltZVNlcmllcygpKSAmJiAhJCQuaXNDYXRlZ29yaXplZCgpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgaW5kZXggZm9yIHggdGhhdCBpcyB1c2VkIGJ5IHByZXZYIGFuZCBuZXh0WFxuICAgICAgICAgICAgICAgICQkLnVwZGF0ZVhzKCk7XG5cbiAgICAgICAgICAgICAgICByZWN0VyA9IGZ1bmN0aW9uIHJlY3RXKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZYID0gJCQuZ2V0UHJldlgoZC5pbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0WCA9ICQkLmdldE5leHRYKGQuaW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIHRoaXMgaXMgYSBzaW5nbGUgZGF0YSBwb2ludCBtYWtlIHRoZSBldmVudFJlY3QgZnVsbCB3aWR0aCAob3IgaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldlggPT09IG51bGwgJiYgbmV4dFggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maWcuYXhpc19yb3RhdGVkID8gJCQuaGVpZ2h0IDogJCQud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldlggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZYID0gJCQueC5kb21haW4oKVswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRYID0gJCQueC5kb21haW4oKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCAoJCQueChuZXh0WCkgLSAkJC54KHByZXZYKSkgLyAyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlY3RYID0gZnVuY3Rpb24gcmVjdFgoZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlggPSAkJC5nZXRQcmV2WChkLmluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRYID0gJCQuZ2V0TmV4dFgoZC5pbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzWCA9ICQkLmRhdGEueHNbZC5pZF1bZC5pbmRleF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgdGhpcyBpcyBhIHNpbmdsZSBkYXRhIHBvaW50IHBvc2l0aW9uIHRoZSBldmVudFJlY3QgYXQgMFxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldlggPT09IG51bGwgJiYgbmV4dFggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZYID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2WCA9ICQkLnguZG9tYWluKClbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCQkLngodGhpc1gpICsgJCQueChwcmV2WCkpIC8gMjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWN0VyA9ICQkLmdldEV2ZW50UmVjdFdpZHRoKCk7XG4gICAgICAgICAgICAgICAgcmVjdFggPSBmdW5jdGlvbiByZWN0WChkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkJC54KGQueCkgLSByZWN0VyAvIDI7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggPSBjb25maWcuYXhpc19yb3RhdGVkID8gMCA6IHJlY3RYO1xuICAgICAgICAgICAgeSA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyByZWN0WCA6IDA7XG4gICAgICAgICAgICB3ID0gY29uZmlnLmF4aXNfcm90YXRlZCA/ICQkLndpZHRoIDogcmVjdFc7XG4gICAgICAgICAgICBoID0gY29uZmlnLmF4aXNfcm90YXRlZCA/IHJlY3RXIDogJCQuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnRSZWN0VXBkYXRlLmF0dHIoJ2NsYXNzJywgJCQuY2xhc3NFdmVudC5iaW5kKCQkKSkuYXR0cihcInhcIiwgeCkuYXR0cihcInlcIiwgeSkuYXR0cihcIndpZHRoXCIsIHcpLmF0dHIoXCJoZWlnaHRcIiwgaCk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZW5lcmF0ZUV2ZW50UmVjdHNGb3JTaW5nbGVYID0gZnVuY3Rpb24gKGV2ZW50UmVjdEVudGVyKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBkMyA9ICQkLmQzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICAgICBldmVudFJlY3RFbnRlci5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0V2ZW50LmJpbmQoJCQpKS5zdHlsZShcImN1cnNvclwiLCBjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCAmJiBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCA/IFwicG9pbnRlclwiIDogbnVsbCkub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBkLmluZGV4O1xuXG4gICAgICAgICAgICBpZiAoJCQuZHJhZ2dpbmcgfHwgJCQuZmxvd2luZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gLy8gZG8gbm90aGluZyB3aGlsZSBkcmFnZ2luZy9mbG93aW5nXG4gICAgICAgICAgICBpZiAoJCQuaGFzQXJjVHlwZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFeHBhbmQgc2hhcGVzIGZvciBzZWxlY3Rpb25cbiAgICAgICAgICAgIGlmIChjb25maWcucG9pbnRfZm9jdXNfZXhwYW5kX2VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAkJC5leHBhbmRDaXJjbGVzKGluZGV4LCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQkLmV4cGFuZEJhcnMoaW5kZXgsIG51bGwsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBDYWxsIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgICQkLm1haW4uc2VsZWN0QWxsKCcuJyArIENMQVNTLnNoYXBlICsgJy0nICsgaW5kZXgpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZGF0YV9vbm1vdXNlb3Zlci5jYWxsKCQkLmFwaSwgZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGQuaW5kZXg7XG4gICAgICAgICAgICBpZiAoISQkLmNvbmZpZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gLy8gY2hhcnQgaXMgZGVzdHJveWVkXG4gICAgICAgICAgICBpZiAoJCQuaGFzQXJjVHlwZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJCQuaGlkZVhHcmlkRm9jdXMoKTtcbiAgICAgICAgICAgICQkLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAvLyBVbmRvIGV4cGFuZGVkIHNoYXBlc1xuICAgICAgICAgICAgJCQudW5leHBhbmRDaXJjbGVzKCk7XG4gICAgICAgICAgICAkJC51bmV4cGFuZEJhcnMoKTtcbiAgICAgICAgICAgIC8vIENhbGwgZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgJCQubWFpbi5zZWxlY3RBbGwoJy4nICsgQ0xBU1Muc2hhcGUgKyAnLScgKyBpbmRleCkuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhX29ubW91c2VvdXQuY2FsbCgkJC5hcGksIGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkRGF0YSxcbiAgICAgICAgICAgICAgICBpbmRleCA9IGQuaW5kZXgsXG4gICAgICAgICAgICAgICAgZXZlbnRSZWN0ID0gJCQuc3ZnLnNlbGVjdCgnLicgKyBDTEFTUy5ldmVudFJlY3QgKyAnLScgKyBpbmRleCk7XG5cbiAgICAgICAgICAgIGlmICgkJC5kcmFnZ2luZyB8fCAkJC5mbG93aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSAvLyBkbyBub3RoaW5nIHdoaWxlIGRyYWdnaW5nL2Zsb3dpbmdcbiAgICAgICAgICAgIGlmICgkJC5oYXNBcmNUeXBlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgkJC5pc1N0ZXBUeXBlKGQpICYmICQkLmNvbmZpZy5saW5lX3N0ZXBfdHlwZSA9PT0gJ3N0ZXAtYWZ0ZXInICYmIGQzLm1vdXNlKHRoaXMpWzBdIDwgJCQueCgkJC5nZXRYVmFsdWUoZC5pZCwgaW5kZXgpKSkge1xuICAgICAgICAgICAgICAgIGluZGV4IC09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNob3cgdG9vbHRpcFxuICAgICAgICAgICAgc2VsZWN0ZWREYXRhID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkJC5hZGROYW1lKCQkLmdldFZhbHVlT25JbmRleCh0LnZhbHVlcywgaW5kZXgpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLnRvb2x0aXBfZ3JvdXBlZCkge1xuICAgICAgICAgICAgICAgICQkLnNob3dUb29sdGlwKHNlbGVjdGVkRGF0YSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgJCQuc2hvd1hHcmlkRm9jdXMoc2VsZWN0ZWREYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbmZpZy50b29sdGlwX2dyb3VwZWQgJiYgKCFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCB8fCBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQkLm1haW4uc2VsZWN0QWxsKCcuJyArIENMQVNTLnNoYXBlICsgJy0nICsgaW5kZXgpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLkVYUEFOREVELCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRSZWN0LnN0eWxlKCdjdXJzb3InLCBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCA/ICdwb2ludGVyJyA6IG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZy50b29sdGlwX2dyb3VwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgJCQuaGlkZVhHcmlkRm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgJCQuaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCQudW5leHBhbmRDaXJjbGVzKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQkLnVuZXhwYW5kQmFycyhpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJCQuaXNXaXRoaW5TaGFwZSh0aGlzLCBkKTtcbiAgICAgICAgICAgIH0pLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQgJiYgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkIHx8IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UmVjdC5zdHlsZSgnY3Vyc29yJywgJ3BvaW50ZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjb25maWcudG9vbHRpcF9ncm91cGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICQkLnNob3dUb29sdGlwKFtkXSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICQkLnNob3dYR3JpZEZvY3VzKFtkXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcucG9pbnRfZm9jdXNfZXhwYW5kX2VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQkLmV4cGFuZENpcmNsZXMoaW5kZXgsIGQuaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICQkLmV4cGFuZEJhcnMoaW5kZXgsIGQuaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5vbignY2xpY2snLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZC5pbmRleDtcbiAgICAgICAgICAgIGlmICgkJC5oYXNBcmNUeXBlKCkgfHwgISQkLnRvZ2dsZVNoYXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCQkLmNhbmNlbENsaWNrKSB7XG4gICAgICAgICAgICAgICAgJCQuY2FuY2VsQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJCQuaXNTdGVwVHlwZShkKSAmJiBjb25maWcubGluZV9zdGVwX3R5cGUgPT09ICdzdGVwLWFmdGVyJyAmJiBkMy5tb3VzZSh0aGlzKVswXSA8ICQkLngoJCQuZ2V0WFZhbHVlKGQuaWQsIGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJCQubWFpbi5zZWxlY3RBbGwoJy4nICsgQ0xBU1Muc2hhcGUgKyAnLScgKyBpbmRleCkuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCB8fCAkJC5pc1dpdGhpblNoYXBlKHRoaXMsIGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICQkLnRvZ2dsZVNoYXBlKHRoaXMsIGQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgJCQuY29uZmlnLmRhdGFfb25jbGljay5jYWxsKCQkLmFwaSwgZCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmNhbGwoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2RyYWdnYWJsZSAmJiAkJC5kcmFnID8gZDMuYmVoYXZpb3IuZHJhZygpLm9yaWdpbihPYmplY3QpLm9uKCdkcmFnJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCQuZHJhZyhkMy5tb3VzZSh0aGlzKSk7XG4gICAgICAgIH0pLm9uKCdkcmFnc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkJC5kcmFnc3RhcnQoZDMubW91c2UodGhpcykpO1xuICAgICAgICB9KS5vbignZHJhZ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQkLmRyYWdlbmQoKTtcbiAgICAgICAgfSkgOiBmdW5jdGlvbiAoKSB7fSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdlbmVyYXRlRXZlbnRSZWN0c0Zvck11bHRpcGxlWHMgPSBmdW5jdGlvbiAoZXZlbnRSZWN0RW50ZXIpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGQzID0gJCQuZDMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG5cbiAgICAgICAgZnVuY3Rpb24gbW91c2VvdXQoKSB7XG4gICAgICAgICAgICAkJC5zdmcuc2VsZWN0KCcuJyArIENMQVNTLmV2ZW50UmVjdCkuc3R5bGUoJ2N1cnNvcicsIG51bGwpO1xuICAgICAgICAgICAgJCQuaGlkZVhHcmlkRm9jdXMoKTtcbiAgICAgICAgICAgICQkLmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAkJC51bmV4cGFuZENpcmNsZXMoKTtcbiAgICAgICAgICAgICQkLnVuZXhwYW5kQmFycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnRSZWN0RW50ZXIuYXBwZW5kKCdyZWN0JykuYXR0cigneCcsIDApLmF0dHIoJ3knLCAwKS5hdHRyKCd3aWR0aCcsICQkLndpZHRoKS5hdHRyKCdoZWlnaHQnLCAkJC5oZWlnaHQpLmF0dHIoJ2NsYXNzJywgQ0xBU1MuZXZlbnRSZWN0KS5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISQkLmNvbmZpZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gLy8gY2hhcnQgaXMgZGVzdHJveWVkXG4gICAgICAgICAgICBpZiAoJCQuaGFzQXJjVHlwZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW91c2VvdXQoKTtcbiAgICAgICAgfSkub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRzVG9TaG93ID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpO1xuICAgICAgICAgICAgdmFyIG1vdXNlLCBjbG9zZXN0LCBzYW1lWERhdGEsIHNlbGVjdGVkRGF0YTtcblxuICAgICAgICAgICAgaWYgKCQkLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSAvLyBkbyBub3RoaW5nIHdoZW4gZHJhZ2dpbmdcbiAgICAgICAgICAgIGlmICgkJC5oYXNBcmNUeXBlKHRhcmdldHNUb1Nob3cpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb3VzZSA9IGQzLm1vdXNlKHRoaXMpO1xuICAgICAgICAgICAgY2xvc2VzdCA9ICQkLmZpbmRDbG9zZXN0RnJvbVRhcmdldHModGFyZ2V0c1RvU2hvdywgbW91c2UpO1xuXG4gICAgICAgICAgICBpZiAoJCQubW91c2VvdmVyICYmICghY2xvc2VzdCB8fCBjbG9zZXN0LmlkICE9PSAkJC5tb3VzZW92ZXIuaWQpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmRhdGFfb25tb3VzZW91dC5jYWxsKCQkLmFwaSwgJCQubW91c2VvdmVyKTtcbiAgICAgICAgICAgICAgICAkJC5tb3VzZW92ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2xvc2VzdCkge1xuICAgICAgICAgICAgICAgIG1vdXNlb3V0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJCQuaXNTY2F0dGVyVHlwZShjbG9zZXN0KSB8fCAhY29uZmlnLnRvb2x0aXBfZ3JvdXBlZCkge1xuICAgICAgICAgICAgICAgIHNhbWVYRGF0YSA9IFtjbG9zZXN0XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2FtZVhEYXRhID0gJCQuZmlsdGVyQnlYKHRhcmdldHNUb1Nob3csIGNsb3Nlc3QueCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNob3cgdG9vbHRpcCB3aGVuIGN1cnNvciBpcyBjbG9zZSB0byBzb21lIHBvaW50XG4gICAgICAgICAgICBzZWxlY3RlZERhdGEgPSBzYW1lWERhdGEubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkLmFkZE5hbWUoZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICQkLnNob3dUb29sdGlwKHNlbGVjdGVkRGF0YSwgdGhpcyk7XG5cbiAgICAgICAgICAgIC8vIGV4cGFuZCBwb2ludHNcbiAgICAgICAgICAgIGlmIChjb25maWcucG9pbnRfZm9jdXNfZXhwYW5kX2VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAkJC5leHBhbmRDaXJjbGVzKGNsb3Nlc3QuaW5kZXgsIGNsb3Nlc3QuaWQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJCQuZXhwYW5kQmFycyhjbG9zZXN0LmluZGV4LCBjbG9zZXN0LmlkLCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gU2hvdyB4Z3JpZCBmb2N1cyBsaW5lXG4gICAgICAgICAgICAkJC5zaG93WEdyaWRGb2N1cyhzZWxlY3RlZERhdGEpO1xuXG4gICAgICAgICAgICAvLyBTaG93IGN1cnNvciBhcyBwb2ludGVyIGlmIHBvaW50IGlzIGNsb3NlIHRvIG1vdXNlIHBvc2l0aW9uXG4gICAgICAgICAgICBpZiAoJCQuaXNCYXJUeXBlKGNsb3Nlc3QuaWQpIHx8ICQkLmRpc3QoY2xvc2VzdCwgbW91c2UpIDwgY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5KSB7XG4gICAgICAgICAgICAgICAgJCQuc3ZnLnNlbGVjdCgnLicgKyBDTEFTUy5ldmVudFJlY3QpLnN0eWxlKCdjdXJzb3InLCAncG9pbnRlcicpO1xuICAgICAgICAgICAgICAgIGlmICghJCQubW91c2VvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhX29ubW91c2VvdmVyLmNhbGwoJCQuYXBpLCBjbG9zZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgJCQubW91c2VvdmVyID0gY2xvc2VzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRzVG9TaG93ID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpO1xuICAgICAgICAgICAgdmFyIG1vdXNlLCBjbG9zZXN0O1xuICAgICAgICAgICAgaWYgKCQkLmhhc0FyY1R5cGUodGFyZ2V0c1RvU2hvdykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vdXNlID0gZDMubW91c2UodGhpcyk7XG4gICAgICAgICAgICBjbG9zZXN0ID0gJCQuZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyh0YXJnZXRzVG9TaG93LCBtb3VzZSk7XG4gICAgICAgICAgICBpZiAoIWNsb3Nlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZWxlY3QgaWYgc2VsZWN0aW9uIGVuYWJsZWRcbiAgICAgICAgICAgIGlmICgkJC5pc0JhclR5cGUoY2xvc2VzdC5pZCkgfHwgJCQuZGlzdChjbG9zZXN0LCBtb3VzZSkgPCBjb25maWcucG9pbnRfc2Vuc2l0aXZpdHkpIHtcbiAgICAgICAgICAgICAgICAkJC5tYWluLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5zaGFwZXMgKyAkJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChjbG9zZXN0LmlkKSkuc2VsZWN0QWxsKCcuJyArIENMQVNTLnNoYXBlICsgJy0nICsgY2xvc2VzdC5pbmRleCkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCB8fCAkJC5pc1dpdGhpblNoYXBlKHRoaXMsIGNsb3Nlc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkJC50b2dnbGVTaGFwZSh0aGlzLCBjbG9zZXN0LCBjbG9zZXN0LmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQkLmNvbmZpZy5kYXRhX29uY2xpY2suY2FsbCgkJC5hcGksIGNsb3Nlc3QsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhbGwoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2RyYWdnYWJsZSAmJiAkJC5kcmFnID8gZDMuYmVoYXZpb3IuZHJhZygpLm9yaWdpbihPYmplY3QpLm9uKCdkcmFnJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCQuZHJhZyhkMy5tb3VzZSh0aGlzKSk7XG4gICAgICAgIH0pLm9uKCdkcmFnc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkJC5kcmFnc3RhcnQoZDMubW91c2UodGhpcykpO1xuICAgICAgICB9KS5vbignZHJhZ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQkLmRyYWdlbmQoKTtcbiAgICAgICAgfSkgOiBmdW5jdGlvbiAoKSB7fSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKHR5cGUsIGluZGV4LCBtb3VzZSkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgc2VsZWN0b3IgPSAnLicgKyBDTEFTUy5ldmVudFJlY3QgKyAoISQkLmlzTXVsdGlwbGVYKCkgPyAnLScgKyBpbmRleCA6ICcnKSxcbiAgICAgICAgICAgIGV2ZW50UmVjdCA9ICQkLm1haW4uc2VsZWN0KHNlbGVjdG9yKS5ub2RlKCksXG4gICAgICAgICAgICBib3ggPSBldmVudFJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICB4ID0gYm94LmxlZnQgKyAobW91c2UgPyBtb3VzZVswXSA6IDApLFxuICAgICAgICAgICAgeSA9IGJveC50b3AgKyAobW91c2UgPyBtb3VzZVsxXSA6IDApLFxuICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xuXG4gICAgICAgIGV2ZW50LmluaXRNb3VzZUV2ZW50KHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgeCwgeSwgeCwgeSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICBldmVudFJlY3QuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmluaXRMZWdlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgICQkLmxlZ2VuZEl0ZW1UZXh0Qm94ID0ge307XG4gICAgICAgICQkLmxlZ2VuZEhhc1JlbmRlcmVkID0gZmFsc2U7XG4gICAgICAgICQkLmxlZ2VuZCA9ICQkLnN2Zy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKCdsZWdlbmQnKSk7XG4gICAgICAgIGlmICghJCQuY29uZmlnLmxlZ2VuZF9zaG93KSB7XG4gICAgICAgICAgICAkJC5sZWdlbmQuc3R5bGUoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XG4gICAgICAgICAgICAkJC5oaWRkZW5MZWdlbmRJZHMgPSAkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1FTU86IGNhbGwgaGVyZSB0byB1cGRhdGUgbGVnZW5kIGJveCBhbmQgdHJhbmxhdGUgZm9yIGFsbFxuICAgICAgICAvLyBNRU1POiB0cmFuc2xhdGUgd2lsbCBiZSB1cGF0ZWQgYnkgdGhpcywgc28gdHJhbnNmb3JtIG5vdCBuZWVkZWQgaW4gdXBkYXRlTGVnZW5kKClcbiAgICAgICAgJCQudXBkYXRlTGVnZW5kV2l0aERlZmF1bHRzKCk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi51cGRhdGVMZWdlbmRXaXRoRGVmYXVsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgICQkLnVwZGF0ZUxlZ2VuZCgkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpLCB7IHdpdGhUcmFuc2Zvcm06IGZhbHNlLCB3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybTogZmFsc2UsIHdpdGhUcmFuc2l0aW9uOiBmYWxzZSB9KTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnVwZGF0ZVNpemVGb3JMZWdlbmQgPSBmdW5jdGlvbiAobGVnZW5kSGVpZ2h0LCBsZWdlbmRXaWR0aCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgaW5zZXRMZWdlbmRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHRvcDogJCQuaXNMZWdlbmRUb3AgPyAkJC5nZXRDdXJyZW50UGFkZGluZ1RvcCgpICsgY29uZmlnLmxlZ2VuZF9pbnNldF95ICsgNS41IDogJCQuY3VycmVudEhlaWdodCAtIGxlZ2VuZEhlaWdodCAtICQkLmdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCkgLSBjb25maWcubGVnZW5kX2luc2V0X3ksXG4gICAgICAgICAgICBsZWZ0OiAkJC5pc0xlZ2VuZExlZnQgPyAkJC5nZXRDdXJyZW50UGFkZGluZ0xlZnQoKSArIGNvbmZpZy5sZWdlbmRfaW5zZXRfeCArIDAuNSA6ICQkLmN1cnJlbnRXaWR0aCAtIGxlZ2VuZFdpZHRoIC0gJCQuZ2V0Q3VycmVudFBhZGRpbmdSaWdodCgpIC0gY29uZmlnLmxlZ2VuZF9pbnNldF94ICsgMC41XG4gICAgICAgIH07XG5cbiAgICAgICAgJCQubWFyZ2luMyA9IHtcbiAgICAgICAgICAgIHRvcDogJCQuaXNMZWdlbmRSaWdodCA/IDAgOiAkJC5pc0xlZ2VuZEluc2V0ID8gaW5zZXRMZWdlbmRQb3NpdGlvbi50b3AgOiAkJC5jdXJyZW50SGVpZ2h0IC0gbGVnZW5kSGVpZ2h0LFxuICAgICAgICAgICAgcmlnaHQ6IE5hTixcbiAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgIGxlZnQ6ICQkLmlzTGVnZW5kUmlnaHQgPyAkJC5jdXJyZW50V2lkdGggLSBsZWdlbmRXaWR0aCA6ICQkLmlzTGVnZW5kSW5zZXQgPyBpbnNldExlZ2VuZFBvc2l0aW9uLmxlZnQgOiAwXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi50cmFuc2Zvcm1MZWdlbmQgPSBmdW5jdGlvbiAod2l0aFRyYW5zaXRpb24pIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgKHdpdGhUcmFuc2l0aW9uID8gJCQubGVnZW5kLnRyYW5zaXRpb24oKSA6ICQkLmxlZ2VuZCkuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoJ2xlZ2VuZCcpKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnVwZGF0ZUxlZ2VuZFN0ZXAgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICB0aGlzLmxlZ2VuZFN0ZXAgPSBzdGVwO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udXBkYXRlTGVnZW5kSXRlbVdpZHRoID0gZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgdGhpcy5sZWdlbmRJdGVtV2lkdGggPSB3O1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udXBkYXRlTGVnZW5kSXRlbUhlaWdodCA9IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHRoaXMubGVnZW5kSXRlbUhlaWdodCA9IGg7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRMZWdlbmRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgcmV0dXJuICQkLmNvbmZpZy5sZWdlbmRfc2hvdyA/ICQkLmlzTGVnZW5kUmlnaHQgfHwgJCQuaXNMZWdlbmRJbnNldCA/ICQkLmxlZ2VuZEl0ZW1XaWR0aCAqICgkJC5sZWdlbmRTdGVwICsgMSkgOiAkJC5jdXJyZW50V2lkdGggOiAwO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0TGVnZW5kSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgaCA9IDA7XG4gICAgICAgIGlmICgkJC5jb25maWcubGVnZW5kX3Nob3cpIHtcbiAgICAgICAgICAgIGlmICgkJC5pc0xlZ2VuZFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaCA9ICQkLmN1cnJlbnRIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGggPSBNYXRoLm1heCgyMCwgJCQubGVnZW5kSXRlbUhlaWdodCkgKiAoJCQubGVnZW5kU3RlcCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ub3BhY2l0eUZvckxlZ2VuZCA9IGZ1bmN0aW9uIChsZWdlbmRJdGVtKSB7XG4gICAgICAgIHJldHVybiBsZWdlbmRJdGVtLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUhpZGRlbikgPyBudWxsIDogMTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLm9wYWNpdHlGb3JVbmZvY3VzZWRMZWdlbmQgPSBmdW5jdGlvbiAobGVnZW5kSXRlbSkge1xuICAgICAgICByZXR1cm4gbGVnZW5kSXRlbS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1IaWRkZW4pID8gbnVsbCA6IDAuMztcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnRvZ2dsZUZvY3VzTGVnZW5kID0gZnVuY3Rpb24gKHRhcmdldElkcywgZm9jdXMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKTtcbiAgICAgICAgJCQubGVnZW5kLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5sZWdlbmRJdGVtKS5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpID49IDA7XG4gICAgICAgIH0pLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQsIGZvY3VzKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTAwKS5zdHlsZSgnb3BhY2l0eScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gZm9jdXMgPyAkJC5vcGFjaXR5Rm9yTGVnZW5kIDogJCQub3BhY2l0eUZvclVuZm9jdXNlZExlZ2VuZDtcbiAgICAgICAgICAgIHJldHVybiBvcGFjaXR5LmNhbGwoJCQsICQkLmQzLnNlbGVjdCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ucmV2ZXJ0TGVnZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgZDMgPSAkJC5kMztcbiAgICAgICAgJCQubGVnZW5kLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5sZWdlbmRJdGVtKS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmYWxzZSkudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMCkuc3R5bGUoJ29wYWNpdHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCQub3BhY2l0eUZvckxlZ2VuZChkMy5zZWxlY3QodGhpcykpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnNob3dMZWdlbmQgPSBmdW5jdGlvbiAodGFyZ2V0SWRzKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgICAgIGlmICghY29uZmlnLmxlZ2VuZF9zaG93KSB7XG4gICAgICAgICAgICBjb25maWcubGVnZW5kX3Nob3cgPSB0cnVlO1xuICAgICAgICAgICAgJCQubGVnZW5kLnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgICAgICAgICAgIGlmICghJCQubGVnZW5kSGFzUmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICAkJC51cGRhdGVMZWdlbmRXaXRoRGVmYXVsdHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAkJC5yZW1vdmVIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKTtcbiAgICAgICAgJCQubGVnZW5kLnNlbGVjdEFsbCgkJC5zZWxlY3RvckxlZ2VuZHModGFyZ2V0SWRzKSkuc3R5bGUoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpLnRyYW5zaXRpb24oKS5zdHlsZSgnb3BhY2l0eScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAkJC5vcGFjaXR5Rm9yTGVnZW5kKCQkLmQzLnNlbGVjdCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaGlkZUxlZ2VuZCA9IGZ1bmN0aW9uICh0YXJnZXRJZHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAgICAgaWYgKGNvbmZpZy5sZWdlbmRfc2hvdyAmJiBpc0VtcHR5KHRhcmdldElkcykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5sZWdlbmRfc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgJCQubGVnZW5kLnN0eWxlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgICAgICB9XG4gICAgICAgICQkLmFkZEhpZGRlbkxlZ2VuZElkcyh0YXJnZXRJZHMpO1xuICAgICAgICAkJC5sZWdlbmQuc2VsZWN0QWxsKCQkLnNlbGVjdG9yTGVnZW5kcyh0YXJnZXRJZHMpKS5zdHlsZSgnb3BhY2l0eScsIDApLnN0eWxlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uY2xlYXJMZWdlbmRJdGVtVGV4dEJveENhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxlZ2VuZEl0ZW1UZXh0Qm94ID0ge307XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi51cGRhdGVMZWdlbmQgPSBmdW5jdGlvbiAodGFyZ2V0SWRzLCBvcHRpb25zLCB0cmFuc2l0aW9ucykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICAgICB2YXIgeEZvckxlZ2VuZCwgeEZvckxlZ2VuZFRleHQsIHhGb3JMZWdlbmRSZWN0LCB5Rm9yTGVnZW5kLCB5Rm9yTGVnZW5kVGV4dCwgeUZvckxlZ2VuZFJlY3QsIHgxRm9yTGVnZW5kVGlsZSwgeDJGb3JMZWdlbmRUaWxlLCB5Rm9yTGVnZW5kVGlsZTtcbiAgICAgICAgdmFyIHBhZGRpbmdUb3AgPSA0LFxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gMTAsXG4gICAgICAgICAgICBtYXhXaWR0aCA9IDAsXG4gICAgICAgICAgICBtYXhIZWlnaHQgPSAwLFxuICAgICAgICAgICAgcG9zTWluID0gMTAsXG4gICAgICAgICAgICB0aWxlV2lkdGggPSBjb25maWcubGVnZW5kX2l0ZW1fdGlsZV93aWR0aCArIDU7XG4gICAgICAgIHZhciBsLFxuICAgICAgICAgICAgdG90YWxMZW5ndGggPSAwLFxuICAgICAgICAgICAgb2Zmc2V0cyA9IHt9LFxuICAgICAgICAgICAgd2lkdGhzID0ge30sXG4gICAgICAgICAgICBoZWlnaHRzID0ge30sXG4gICAgICAgICAgICBtYXJnaW5zID0gWzBdLFxuICAgICAgICAgICAgc3RlcHMgPSB7fSxcbiAgICAgICAgICAgIHN0ZXAgPSAwO1xuICAgICAgICB2YXIgd2l0aFRyYW5zaXRpb24sIHdpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtO1xuICAgICAgICB2YXIgdGV4dHMsIHJlY3RzLCB0aWxlcywgYmFja2dyb3VuZDtcblxuICAgICAgICAvLyBTa2lwIGVsZW1lbnRzIHdoZW4gdGhlaXIgbmFtZSBpcyBzZXQgdG8gbnVsbFxuICAgICAgICB0YXJnZXRJZHMgPSB0YXJnZXRJZHMuZmlsdGVyKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuICFpc0RlZmluZWQoY29uZmlnLmRhdGFfbmFtZXNbaWRdKSB8fCBjb25maWcuZGF0YV9uYW1lc1tpZF0gIT09IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB3aXRoVHJhbnNpdGlvbiA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2l0aW9uXCIsIHRydWUpO1xuICAgICAgICB3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtXCIsIHRydWUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFRleHRCb3godGV4dEVsZW1lbnQsIGlkKSB7XG4gICAgICAgICAgICBpZiAoISQkLmxlZ2VuZEl0ZW1UZXh0Qm94W2lkXSkge1xuICAgICAgICAgICAgICAgICQkLmxlZ2VuZEl0ZW1UZXh0Qm94W2lkXSA9ICQkLmdldFRleHRSZWN0KHRleHRFbGVtZW50LnRleHRDb250ZW50LCBDTEFTUy5sZWdlbmRJdGVtLCB0ZXh0RWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJCQubGVnZW5kSXRlbVRleHRCb3hbaWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlUG9zaXRpb25zKHRleHRFbGVtZW50LCBpZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciByZXNldCA9IGluZGV4ID09PSAwLFxuICAgICAgICAgICAgICAgIGlzTGFzdCA9IGluZGV4ID09PSB0YXJnZXRJZHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBib3ggPSBnZXRUZXh0Qm94KHRleHRFbGVtZW50LCBpZCksXG4gICAgICAgICAgICAgICAgaXRlbVdpZHRoID0gYm94LndpZHRoICsgdGlsZVdpZHRoICsgKGlzTGFzdCAmJiAhKCQkLmlzTGVnZW5kUmlnaHQgfHwgJCQuaXNMZWdlbmRJbnNldCkgPyAwIDogcGFkZGluZ1JpZ2h0KSArIGNvbmZpZy5sZWdlbmRfcGFkZGluZyxcbiAgICAgICAgICAgICAgICBpdGVtSGVpZ2h0ID0gYm94LmhlaWdodCArIHBhZGRpbmdUb3AsXG4gICAgICAgICAgICAgICAgaXRlbUxlbmd0aCA9ICQkLmlzTGVnZW5kUmlnaHQgfHwgJCQuaXNMZWdlbmRJbnNldCA/IGl0ZW1IZWlnaHQgOiBpdGVtV2lkdGgsXG4gICAgICAgICAgICAgICAgYXJlYUxlbmd0aCA9ICQkLmlzTGVnZW5kUmlnaHQgfHwgJCQuaXNMZWdlbmRJbnNldCA/ICQkLmdldExlZ2VuZEhlaWdodCgpIDogJCQuZ2V0TGVnZW5kV2lkdGgoKSxcbiAgICAgICAgICAgICAgICBtYXJnaW4sXG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBNRU1POiBjYXJlIGFib3V0IGNvbmRpZmlvbiBvZiBzdGVwLCB0b3RhbExlbmd0aFxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVmFsdWVzKGlkLCB3aXRob3V0U3RlcCkge1xuICAgICAgICAgICAgICAgIGlmICghd2l0aG91dFN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luID0gKGFyZWFMZW5ndGggLSB0b3RhbExlbmd0aCAtIGl0ZW1MZW5ndGgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmdpbiA8IHBvc01pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luID0gKGFyZWFMZW5ndGggLSBpdGVtTGVuZ3RoKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RlcHNbaWRdID0gc3RlcDtcbiAgICAgICAgICAgICAgICBtYXJnaW5zW3N0ZXBdID0gJCQuaXNMZWdlbmRJbnNldCA/IDEwIDogbWFyZ2luO1xuICAgICAgICAgICAgICAgIG9mZnNldHNbaWRdID0gdG90YWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gaXRlbUxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgICAgICAgICAgdG90YWxMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHN0ZXAgPSAwO1xuICAgICAgICAgICAgICAgIG1heFdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29uZmlnLmxlZ2VuZF9zaG93ICYmICEkJC5pc0xlZ2VuZFRvU2hvdyhpZCkpIHtcbiAgICAgICAgICAgICAgICB3aWR0aHNbaWRdID0gaGVpZ2h0c1tpZF0gPSBzdGVwc1tpZF0gPSBvZmZzZXRzW2lkXSA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aWR0aHNbaWRdID0gaXRlbVdpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0c1tpZF0gPSBpdGVtSGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoIW1heFdpZHRoIHx8IGl0ZW1XaWR0aCA+PSBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgIG1heFdpZHRoID0gaXRlbVdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXhIZWlnaHQgfHwgaXRlbUhlaWdodCA+PSBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBpdGVtSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF4TGVuZ3RoID0gJCQuaXNMZWdlbmRSaWdodCB8fCAkJC5pc0xlZ2VuZEluc2V0ID8gbWF4SGVpZ2h0IDogbWF4V2lkdGg7XG5cbiAgICAgICAgICAgIGlmIChjb25maWcubGVnZW5kX2VxdWFsbHkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh3aWR0aHMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoc1tpZF0gPSBtYXhXaWR0aDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhoZWlnaHRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHRzW2lkXSA9IG1heEhlaWdodDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtYXJnaW4gPSAoYXJlYUxlbmd0aCAtIG1heExlbmd0aCAqIHRhcmdldElkcy5sZW5ndGgpIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAobWFyZ2luIDwgcG9zTWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgc3RlcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldElkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsdWVzKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsdWVzKGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlcyhpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJCQuaXNMZWdlbmRJbnNldCkge1xuICAgICAgICAgICAgc3RlcCA9IGNvbmZpZy5sZWdlbmRfaW5zZXRfc3RlcCA/IGNvbmZpZy5sZWdlbmRfaW5zZXRfc3RlcCA6IHRhcmdldElkcy5sZW5ndGg7XG4gICAgICAgICAgICAkJC51cGRhdGVMZWdlbmRTdGVwKHN0ZXApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCQkLmlzTGVnZW5kUmlnaHQpIHtcbiAgICAgICAgICAgIHhGb3JMZWdlbmQgPSBmdW5jdGlvbiB4Rm9yTGVnZW5kKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heFdpZHRoICogc3RlcHNbaWRdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHlGb3JMZWdlbmQgPSBmdW5jdGlvbiB5Rm9yTGVnZW5kKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmdpbnNbc3RlcHNbaWRdXSArIG9mZnNldHNbaWRdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICgkJC5pc0xlZ2VuZEluc2V0KSB7XG4gICAgICAgICAgICB4Rm9yTGVnZW5kID0gZnVuY3Rpb24geEZvckxlZ2VuZChpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXhXaWR0aCAqIHN0ZXBzW2lkXSArIDEwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHlGb3JMZWdlbmQgPSBmdW5jdGlvbiB5Rm9yTGVnZW5kKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmdpbnNbc3RlcHNbaWRdXSArIG9mZnNldHNbaWRdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhGb3JMZWdlbmQgPSBmdW5jdGlvbiB4Rm9yTGVnZW5kKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmdpbnNbc3RlcHNbaWRdXSArIG9mZnNldHNbaWRdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHlGb3JMZWdlbmQgPSBmdW5jdGlvbiB5Rm9yTGVnZW5kKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heEhlaWdodCAqIHN0ZXBzW2lkXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgeEZvckxlZ2VuZFRleHQgPSBmdW5jdGlvbiB4Rm9yTGVnZW5kVGV4dChpZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHhGb3JMZWdlbmQoaWQsIGkpICsgNCArIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX3dpZHRoO1xuICAgICAgICB9O1xuICAgICAgICB5Rm9yTGVnZW5kVGV4dCA9IGZ1bmN0aW9uIHlGb3JMZWdlbmRUZXh0KGlkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geUZvckxlZ2VuZChpZCwgaSkgKyA5O1xuICAgICAgICB9O1xuICAgICAgICB4Rm9yTGVnZW5kUmVjdCA9IGZ1bmN0aW9uIHhGb3JMZWdlbmRSZWN0KGlkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geEZvckxlZ2VuZChpZCwgaSk7XG4gICAgICAgIH07XG4gICAgICAgIHlGb3JMZWdlbmRSZWN0ID0gZnVuY3Rpb24geUZvckxlZ2VuZFJlY3QoaWQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB5Rm9yTGVnZW5kKGlkLCBpKSAtIDU7XG4gICAgICAgIH07XG4gICAgICAgIHgxRm9yTGVnZW5kVGlsZSA9IGZ1bmN0aW9uIHgxRm9yTGVnZW5kVGlsZShpZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHhGb3JMZWdlbmQoaWQsIGkpIC0gMjtcbiAgICAgICAgfTtcbiAgICAgICAgeDJGb3JMZWdlbmRUaWxlID0gZnVuY3Rpb24geDJGb3JMZWdlbmRUaWxlKGlkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geEZvckxlZ2VuZChpZCwgaSkgLSAyICsgY29uZmlnLmxlZ2VuZF9pdGVtX3RpbGVfd2lkdGg7XG4gICAgICAgIH07XG4gICAgICAgIHlGb3JMZWdlbmRUaWxlID0gZnVuY3Rpb24geUZvckxlZ2VuZFRpbGUoaWQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB5Rm9yTGVnZW5kKGlkLCBpKSArIDQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRGVmaW5lIGcgZm9yIGxlZ2VuZCBhcmVhXG4gICAgICAgIGwgPSAkJC5sZWdlbmQuc2VsZWN0QWxsKCcuJyArIENMQVNTLmxlZ2VuZEl0ZW0pLmRhdGEodGFyZ2V0SWRzKS5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJCQuZ2VuZXJhdGVDbGFzcyhDTEFTUy5sZWdlbmRJdGVtLCBpZCk7XG4gICAgICAgIH0pLnN0eWxlKCd2aXNpYmlsaXR5JywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJCQuaXNMZWdlbmRUb1Nob3coaWQpID8gJ3Zpc2libGUnIDogJ2hpZGRlbic7XG4gICAgICAgIH0pLnN0eWxlKCdjdXJzb3InLCAncG9pbnRlcicpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5sZWdlbmRfaXRlbV9vbmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmxlZ2VuZF9pdGVtX29uY2xpY2suY2FsbCgkJCwgaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoJCQuZDMuZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICQkLmFwaS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICQkLmFwaS5zaG93KGlkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkJC5hcGkudG9nZ2xlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgJCQuaXNUYXJnZXRUb1Nob3coaWQpID8gJCQuYXBpLmZvY3VzKGlkKSA6ICQkLmFwaS5yZXZlcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcubGVnZW5kX2l0ZW1fb25tb3VzZW92ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25maWcubGVnZW5kX2l0ZW1fb25tb3VzZW92ZXIuY2FsbCgkJCwgaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkJC5kMy5zZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCEkJC50cmFuc2l0aW5nICYmICQkLmlzVGFyZ2V0VG9TaG93KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAkJC5hcGkuZm9jdXMoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmxlZ2VuZF9pdGVtX29ubW91c2VvdXQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcubGVnZW5kX2l0ZW1fb25tb3VzZW91dC5jYWxsKCQkLCBpZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQkLmQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgJCQuYXBpLnJldmVydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbC5hcHBlbmQoJ3RleHQnKS50ZXh0KGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRGVmaW5lZChjb25maWcuZGF0YV9uYW1lc1tpZF0pID8gY29uZmlnLmRhdGFfbmFtZXNbaWRdIDogaWQ7XG4gICAgICAgIH0pLmVhY2goZnVuY3Rpb24gKGlkLCBpKSB7XG4gICAgICAgICAgICB1cGRhdGVQb3NpdGlvbnModGhpcywgaWQsIGkpO1xuICAgICAgICB9KS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKS5hdHRyKCd4JywgJCQuaXNMZWdlbmRSaWdodCB8fCAkJC5pc0xlZ2VuZEluc2V0ID8geEZvckxlZ2VuZFRleHQgOiAtMjAwKS5hdHRyKCd5JywgJCQuaXNMZWdlbmRSaWdodCB8fCAkJC5pc0xlZ2VuZEluc2V0ID8gLTIwMCA6IHlGb3JMZWdlbmRUZXh0KTtcbiAgICAgICAgbC5hcHBlbmQoJ3JlY3QnKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kSXRlbUV2ZW50KS5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMCkuYXR0cigneCcsICQkLmlzTGVnZW5kUmlnaHQgfHwgJCQuaXNMZWdlbmRJbnNldCA/IHhGb3JMZWdlbmRSZWN0IDogLTIwMCkuYXR0cigneScsICQkLmlzTGVnZW5kUmlnaHQgfHwgJCQuaXNMZWdlbmRJbnNldCA/IC0yMDAgOiB5Rm9yTGVnZW5kUmVjdCk7XG4gICAgICAgIGwuYXBwZW5kKCdsaW5lJykuYXR0cignY2xhc3MnLCBDTEFTUy5sZWdlbmRJdGVtVGlsZSkuc3R5bGUoJ3N0cm9rZScsICQkLmNvbG9yKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKS5hdHRyKCd4MScsICQkLmlzTGVnZW5kUmlnaHQgfHwgJCQuaXNMZWdlbmRJbnNldCA/IHgxRm9yTGVnZW5kVGlsZSA6IC0yMDApLmF0dHIoJ3kxJywgJCQuaXNMZWdlbmRSaWdodCB8fCAkJC5pc0xlZ2VuZEluc2V0ID8gLTIwMCA6IHlGb3JMZWdlbmRUaWxlKS5hdHRyKCd4MicsICQkLmlzTGVnZW5kUmlnaHQgfHwgJCQuaXNMZWdlbmRJbnNldCA/IHgyRm9yTGVnZW5kVGlsZSA6IC0yMDApLmF0dHIoJ3kyJywgJCQuaXNMZWdlbmRSaWdodCB8fCAkJC5pc0xlZ2VuZEluc2V0ID8gLTIwMCA6IHlGb3JMZWdlbmRUaWxlKS5hdHRyKCdzdHJva2Utd2lkdGgnLCBjb25maWcubGVnZW5kX2l0ZW1fdGlsZV9oZWlnaHQpO1xuXG4gICAgICAgIC8vIFNldCBiYWNrZ3JvdW5kIGZvciBpbnNldCBsZWdlbmRcbiAgICAgICAgYmFja2dyb3VuZCA9ICQkLmxlZ2VuZC5zZWxlY3QoJy4nICsgQ0xBU1MubGVnZW5kQmFja2dyb3VuZCArICcgcmVjdCcpO1xuICAgICAgICBpZiAoJCQuaXNMZWdlbmRJbnNldCAmJiBtYXhXaWR0aCA+IDAgJiYgYmFja2dyb3VuZC5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQgPSAkJC5sZWdlbmQuaW5zZXJ0KCdnJywgJy4nICsgQ0xBU1MubGVnZW5kSXRlbSkuYXR0cihcImNsYXNzXCIsIENMQVNTLmxlZ2VuZEJhY2tncm91bmQpLmFwcGVuZCgncmVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dHMgPSAkJC5sZWdlbmQuc2VsZWN0QWxsKCd0ZXh0JykuZGF0YSh0YXJnZXRJZHMpLnRleHQoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgPyBjb25maWcuZGF0YV9uYW1lc1tpZF0gOiBpZDtcbiAgICAgICAgfSkgLy8gTUVNTzogbmVlZGVkIGZvciB1cGRhdGVcbiAgICAgICAgLmVhY2goZnVuY3Rpb24gKGlkLCBpKSB7XG4gICAgICAgICAgICB1cGRhdGVQb3NpdGlvbnModGhpcywgaWQsIGkpO1xuICAgICAgICB9KTtcbiAgICAgICAgKHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpLmF0dHIoJ3gnLCB4Rm9yTGVnZW5kVGV4dCkuYXR0cigneScsIHlGb3JMZWdlbmRUZXh0KTtcblxuICAgICAgICByZWN0cyA9ICQkLmxlZ2VuZC5zZWxlY3RBbGwoJ3JlY3QuJyArIENMQVNTLmxlZ2VuZEl0ZW1FdmVudCkuZGF0YSh0YXJnZXRJZHMpO1xuICAgICAgICAod2l0aFRyYW5zaXRpb24gPyByZWN0cy50cmFuc2l0aW9uKCkgOiByZWN0cykuYXR0cignd2lkdGgnLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB3aWR0aHNbaWRdO1xuICAgICAgICB9KS5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBoZWlnaHRzW2lkXTtcbiAgICAgICAgfSkuYXR0cigneCcsIHhGb3JMZWdlbmRSZWN0KS5hdHRyKCd5JywgeUZvckxlZ2VuZFJlY3QpO1xuXG4gICAgICAgIHRpbGVzID0gJCQubGVnZW5kLnNlbGVjdEFsbCgnbGluZS4nICsgQ0xBU1MubGVnZW5kSXRlbVRpbGUpLmRhdGEodGFyZ2V0SWRzKTtcbiAgICAgICAgKHdpdGhUcmFuc2l0aW9uID8gdGlsZXMudHJhbnNpdGlvbigpIDogdGlsZXMpLnN0eWxlKCdzdHJva2UnLCAkJC5sZXZlbENvbG9yID8gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJCQubGV2ZWxDb2xvcigkJC5jYWNoZVtpZF0udmFsdWVzWzBdLnZhbHVlKTtcbiAgICAgICAgfSA6ICQkLmNvbG9yKS5hdHRyKCd4MScsIHgxRm9yTGVnZW5kVGlsZSkuYXR0cigneTEnLCB5Rm9yTGVnZW5kVGlsZSkuYXR0cigneDInLCB4MkZvckxlZ2VuZFRpbGUpLmF0dHIoJ3kyJywgeUZvckxlZ2VuZFRpbGUpO1xuXG4gICAgICAgIGlmIChiYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICAod2l0aFRyYW5zaXRpb24gPyBiYWNrZ3JvdW5kLnRyYW5zaXRpb24oKSA6IGJhY2tncm91bmQpLmF0dHIoJ2hlaWdodCcsICQkLmdldExlZ2VuZEhlaWdodCgpIC0gMTIpLmF0dHIoJ3dpZHRoJywgbWF4V2lkdGggKiAoc3RlcCArIDEpICsgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG9nZ2xlIGxlZ2VuZCBzdGF0ZVxuICAgICAgICAkJC5sZWdlbmQuc2VsZWN0QWxsKCcuJyArIENMQVNTLmxlZ2VuZEl0ZW0pLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUhpZGRlbiwgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gISQkLmlzVGFyZ2V0VG9TaG93KGlkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGFsbCB0byByZWZsZWN0IGNoYW5nZSBvZiBsZWdlbmRcbiAgICAgICAgJCQudXBkYXRlTGVnZW5kSXRlbVdpZHRoKG1heFdpZHRoKTtcbiAgICAgICAgJCQudXBkYXRlTGVnZW5kSXRlbUhlaWdodChtYXhIZWlnaHQpO1xuICAgICAgICAkJC51cGRhdGVMZWdlbmRTdGVwKHN0ZXApO1xuICAgICAgICAvLyBVcGRhdGUgc2l6ZSBhbmQgc2NhbGVcbiAgICAgICAgJCQudXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgJCQudXBkYXRlU2NhbGVzKCk7XG4gICAgICAgICQkLnVwZGF0ZVN2Z1NpemUoKTtcbiAgICAgICAgLy8gVXBkYXRlIGcgcG9zaXRpb25zXG4gICAgICAgICQkLnRyYW5zZm9ybUFsbCh3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSwgdHJhbnNpdGlvbnMpO1xuICAgICAgICAkJC5sZWdlbmRIYXNSZW5kZXJlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmluaXRSZWdpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgICQkLnJlZ2lvbiA9ICQkLm1haW4uYXBwZW5kKCdnJykuYXR0cihcImNsaXAtcGF0aFwiLCAkJC5jbGlwUGF0aCkuYXR0cihcImNsYXNzXCIsIENMQVNTLnJlZ2lvbnMpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udXBkYXRlUmVnaW9uID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG5cbiAgICAgICAgLy8gaGlkZSBpZiBhcmMgdHlwZVxuICAgICAgICAkJC5yZWdpb24uc3R5bGUoJ3Zpc2liaWxpdHknLCAkJC5oYXNBcmNUeXBlKCkgPyAnaGlkZGVuJyA6ICd2aXNpYmxlJyk7XG5cbiAgICAgICAgJCQubWFpblJlZ2lvbiA9ICQkLm1haW4uc2VsZWN0KCcuJyArIENMQVNTLnJlZ2lvbnMpLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5yZWdpb24pLmRhdGEoY29uZmlnLnJlZ2lvbnMpO1xuICAgICAgICAkJC5tYWluUmVnaW9uLmVudGVyKCkuYXBwZW5kKCdnJykuYXBwZW5kKCdyZWN0Jykuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgMCk7XG4gICAgICAgICQkLm1haW5SZWdpb24uYXR0cignY2xhc3MnLCAkJC5jbGFzc1JlZ2lvbi5iaW5kKCQkKSk7XG4gICAgICAgICQkLm1haW5SZWdpb24uZXhpdCgpLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuc3R5bGUoXCJvcGFjaXR5XCIsIDApLnJlbW92ZSgpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ucmVkcmF3UmVnaW9uID0gZnVuY3Rpb24gKHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICByZWdpb25zID0gJCQubWFpblJlZ2lvbi5zZWxlY3RBbGwoJ3JlY3QnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGRhdGEgaXMgYmluZGVkIHRvIGcgYW5kIGl0J3Mgbm90IHRyYW5zZmVycmVkIHRvIHJlY3QgKGNoaWxkIG5vZGUpIGF1dG9tYXRpY2FsbHksXG4gICAgICAgICAgICAvLyB0aGVuIGRhdGEgb2YgZWFjaCByZWN0IGhhcyB0byBiZSB1cGRhdGVkIG1hbnVhbGx5LlxuICAgICAgICAgICAgLy8gVE9ETzogdGhlcmUgc2hvdWxkIGJlIG1vcmUgZWZmaWNpZW50IHdheSB0byBzb2x2ZSB0aGlzP1xuICAgICAgICAgICAgdmFyIHBhcmVudERhdGEgPSAkJC5kMy5zZWxlY3QodGhpcy5wYXJlbnROb2RlKS5kYXR1bSgpO1xuICAgICAgICAgICAgJCQuZDMuc2VsZWN0KHRoaXMpLmRhdHVtKHBhcmVudERhdGEpO1xuICAgICAgICB9KSxcbiAgICAgICAgICAgIHggPSAkJC5yZWdpb25YLmJpbmQoJCQpLFxuICAgICAgICAgICAgeSA9ICQkLnJlZ2lvblkuYmluZCgkJCksXG4gICAgICAgICAgICB3ID0gJCQucmVnaW9uV2lkdGguYmluZCgkJCksXG4gICAgICAgICAgICBoID0gJCQucmVnaW9uSGVpZ2h0LmJpbmQoJCQpO1xuICAgICAgICByZXR1cm4gWyh3aXRoVHJhbnNpdGlvbiA/IHJlZ2lvbnMudHJhbnNpdGlvbigpIDogcmVnaW9ucykuYXR0cihcInhcIiwgeCkuYXR0cihcInlcIiwgeSkuYXR0cihcIndpZHRoXCIsIHcpLmF0dHIoXCJoZWlnaHRcIiwgaCkuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbHVlKGQub3BhY2l0eSkgPyBkLm9wYWNpdHkgOiAwLjE7XG4gICAgICAgIH0pXTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnJlZ2lvblggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgeFBvcyxcbiAgICAgICAgICAgIHlTY2FsZSA9IGQuYXhpcyA9PT0gJ3knID8gJCQueSA6ICQkLnkyO1xuICAgICAgICBpZiAoZC5heGlzID09PSAneScgfHwgZC5heGlzID09PSAneTInKSB7XG4gICAgICAgICAgICB4UG9zID0gY29uZmlnLmF4aXNfcm90YXRlZCA/ICdzdGFydCcgaW4gZCA/IHlTY2FsZShkLnN0YXJ0KSA6IDAgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeFBvcyA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAwIDogJ3N0YXJ0JyBpbiBkID8gJCQueCgkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLnBhcnNlRGF0ZShkLnN0YXJ0KSA6IGQuc3RhcnQpIDogMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geFBvcztcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnJlZ2lvblkgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgeVBvcyxcbiAgICAgICAgICAgIHlTY2FsZSA9IGQuYXhpcyA9PT0gJ3knID8gJCQueSA6ICQkLnkyO1xuICAgICAgICBpZiAoZC5heGlzID09PSAneScgfHwgZC5heGlzID09PSAneTInKSB7XG4gICAgICAgICAgICB5UG9zID0gY29uZmlnLmF4aXNfcm90YXRlZCA/IDAgOiAnZW5kJyBpbiBkID8geVNjYWxlKGQuZW5kKSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5UG9zID0gY29uZmlnLmF4aXNfcm90YXRlZCA/ICdzdGFydCcgaW4gZCA/ICQkLngoJCQuaXNUaW1lU2VyaWVzKCkgPyAkJC5wYXJzZURhdGUoZC5zdGFydCkgOiBkLnN0YXJ0KSA6IDAgOiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5UG9zO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ucmVnaW9uV2lkdGggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgc3RhcnQgPSAkJC5yZWdpb25YKGQpLFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgeVNjYWxlID0gZC5heGlzID09PSAneScgPyAkJC55IDogJCQueTI7XG4gICAgICAgIGlmIChkLmF4aXMgPT09ICd5JyB8fCBkLmF4aXMgPT09ICd5MicpIHtcbiAgICAgICAgICAgIGVuZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAnZW5kJyBpbiBkID8geVNjYWxlKGQuZW5kKSA6ICQkLndpZHRoIDogJCQud2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSBjb25maWcuYXhpc19yb3RhdGVkID8gJCQud2lkdGggOiAnZW5kJyBpbiBkID8gJCQueCgkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLnBhcnNlRGF0ZShkLmVuZCkgOiBkLmVuZCkgOiAkJC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5kIDwgc3RhcnQgPyAwIDogZW5kIC0gc3RhcnQ7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5yZWdpb25IZWlnaHQgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnJlZ2lvblkoZCksXG4gICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICB5U2NhbGUgPSBkLmF4aXMgPT09ICd5JyA/ICQkLnkgOiAkJC55MjtcbiAgICAgICAgaWYgKGQuYXhpcyA9PT0gJ3knIHx8IGQuYXhpcyA9PT0gJ3kyJykge1xuICAgICAgICAgICAgZW5kID0gY29uZmlnLmF4aXNfcm90YXRlZCA/ICQkLmhlaWdodCA6ICdzdGFydCcgaW4gZCA/IHlTY2FsZShkLnN0YXJ0KSA6ICQkLmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAnZW5kJyBpbiBkID8gJCQueCgkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLnBhcnNlRGF0ZShkLmVuZCkgOiBkLmVuZCkgOiAkJC5oZWlnaHQgOiAkJC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuZCA8IHN0YXJ0ID8gMCA6IGVuZCAtIHN0YXJ0O1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaXNSZWdpb25PblggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gIWQuYXhpcyB8fCBkLmF4aXMgPT09ICd4JztcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0U2NhbGUgPSBmdW5jdGlvbiAobWluLCBtYXgsIGZvclRpbWVzZXJpZXMpIHtcbiAgICAgICAgcmV0dXJuIChmb3JUaW1lc2VyaWVzID8gdGhpcy5kMy50aW1lLnNjYWxlKCkgOiB0aGlzLmQzLnNjYWxlLmxpbmVhcigpKS5yYW5nZShbbWluLCBtYXhdKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldFggPSBmdW5jdGlvbiAobWluLCBtYXgsIGRvbWFpbiwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBzY2FsZSA9ICQkLmdldFNjYWxlKG1pbiwgbWF4LCAkJC5pc1RpbWVTZXJpZXMoKSksXG4gICAgICAgICAgICBfc2NhbGUgPSBkb21haW4gPyBzY2FsZS5kb21haW4oZG9tYWluKSA6IHNjYWxlLFxuICAgICAgICAgICAga2V5O1xuICAgICAgICAvLyBEZWZpbmUgY3VzdG9taXplZCBzY2FsZSBpZiBjYXRlZ29yaXplZCBheGlzXG4gICAgICAgIGlmICgkJC5pc0NhdGVnb3JpemVkKCkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2NhbGUgPSBmdW5jdGlvbiBzY2FsZShkLCByYXcpIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IF9zY2FsZShkKSArIG9mZnNldChkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3ID8gdiA6IE1hdGguY2VpbCh2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKGQsIHJhdykge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gX3NjYWxlKGQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYXcgPyB2IDogTWF0aC5jZWlsKHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWZpbmUgZnVuY3Rpb25zXG4gICAgICAgIGZvciAoa2V5IGluIF9zY2FsZSkge1xuICAgICAgICAgICAgc2NhbGVba2V5XSA9IF9zY2FsZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHNjYWxlLm9yZ0RvbWFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc2NhbGUuZG9tYWluKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGRlZmluZSBjdXN0b20gZG9tYWluKCkgZm9yIGNhdGVnb3JpemVkIGF4aXNcbiAgICAgICAgaWYgKCQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xuICAgICAgICAgICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24gKGRvbWFpbikge1xuICAgICAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4gPSB0aGlzLm9yZ0RvbWFpbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2RvbWFpblswXSwgZG9tYWluWzFdICsgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9zY2FsZS5kb21haW4oZG9tYWluKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldFkgPSBmdW5jdGlvbiAobWluLCBtYXgsIGRvbWFpbikge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmdldFNjYWxlKG1pbiwgbWF4LCB0aGlzLmlzVGltZVNlcmllc1koKSk7XG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldFlTY2FsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5heGlzLmdldElkKGlkKSA9PT0gJ3kyJyA/IHRoaXMueTIgOiB0aGlzLnk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRTdWJZU2NhbGUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXhpcy5nZXRJZChpZCkgPT09ICd5MicgPyB0aGlzLnN1YlkyIDogdGhpcy5zdWJZO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udXBkYXRlU2NhbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgZm9ySW5pdCA9ICEkJC54O1xuICAgICAgICAvLyB1cGRhdGUgZWRnZXNcbiAgICAgICAgJCQueE1pbiA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAxIDogMDtcbiAgICAgICAgJCQueE1heCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAkJC5oZWlnaHQgOiAkJC53aWR0aDtcbiAgICAgICAgJCQueU1pbiA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAwIDogJCQuaGVpZ2h0O1xuICAgICAgICAkJC55TWF4ID0gY29uZmlnLmF4aXNfcm90YXRlZCA/ICQkLndpZHRoIDogMTtcbiAgICAgICAgJCQuc3ViWE1pbiA9ICQkLnhNaW47XG4gICAgICAgICQkLnN1YlhNYXggPSAkJC54TWF4O1xuICAgICAgICAkJC5zdWJZTWluID0gY29uZmlnLmF4aXNfcm90YXRlZCA/IDAgOiAkJC5oZWlnaHQyO1xuICAgICAgICAkJC5zdWJZTWF4ID0gY29uZmlnLmF4aXNfcm90YXRlZCA/ICQkLndpZHRoMiA6IDE7XG4gICAgICAgIC8vIHVwZGF0ZSBzY2FsZXNcbiAgICAgICAgJCQueCA9ICQkLmdldFgoJCQueE1pbiwgJCQueE1heCwgZm9ySW5pdCA/IHVuZGVmaW5lZCA6ICQkLngub3JnRG9tYWluKCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAkJC54QXhpcy50aWNrT2Zmc2V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICAkJC55ID0gJCQuZ2V0WSgkJC55TWluLCAkJC55TWF4LCBmb3JJbml0ID8gY29uZmlnLmF4aXNfeV9kZWZhdWx0IDogJCQueS5kb21haW4oKSk7XG4gICAgICAgICQkLnkyID0gJCQuZ2V0WSgkJC55TWluLCAkJC55TWF4LCBmb3JJbml0ID8gY29uZmlnLmF4aXNfeTJfZGVmYXVsdCA6ICQkLnkyLmRvbWFpbigpKTtcbiAgICAgICAgJCQuc3ViWCA9ICQkLmdldFgoJCQueE1pbiwgJCQueE1heCwgJCQub3JnWERvbWFpbiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkICUgMSA/IDAgOiAkJC5zdWJYQXhpcy50aWNrT2Zmc2V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICAkJC5zdWJZID0gJCQuZ2V0WSgkJC5zdWJZTWluLCAkJC5zdWJZTWF4LCBmb3JJbml0ID8gY29uZmlnLmF4aXNfeV9kZWZhdWx0IDogJCQuc3ViWS5kb21haW4oKSk7XG4gICAgICAgICQkLnN1YlkyID0gJCQuZ2V0WSgkJC5zdWJZTWluLCAkJC5zdWJZTWF4LCBmb3JJbml0ID8gY29uZmlnLmF4aXNfeTJfZGVmYXVsdCA6ICQkLnN1YlkyLmRvbWFpbigpKTtcbiAgICAgICAgLy8gdXBkYXRlIGF4ZXNcbiAgICAgICAgJCQueEF4aXNUaWNrRm9ybWF0ID0gJCQuYXhpcy5nZXRYQXhpc1RpY2tGb3JtYXQoKTtcbiAgICAgICAgJCQueEF4aXNUaWNrVmFsdWVzID0gJCQuYXhpcy5nZXRYQXhpc1RpY2tWYWx1ZXMoKTtcbiAgICAgICAgJCQueUF4aXNUaWNrVmFsdWVzID0gJCQuYXhpcy5nZXRZQXhpc1RpY2tWYWx1ZXMoKTtcbiAgICAgICAgJCQueTJBeGlzVGlja1ZhbHVlcyA9ICQkLmF4aXMuZ2V0WTJBeGlzVGlja1ZhbHVlcygpO1xuXG4gICAgICAgICQkLnhBeGlzID0gJCQuYXhpcy5nZXRYQXhpcygkJC54LCAkJC54T3JpZW50LCAkJC54QXhpc1RpY2tGb3JtYXQsICQkLnhBeGlzVGlja1ZhbHVlcywgY29uZmlnLmF4aXNfeF90aWNrX291dGVyKTtcbiAgICAgICAgJCQuc3ViWEF4aXMgPSAkJC5heGlzLmdldFhBeGlzKCQkLnN1YlgsICQkLnN1YlhPcmllbnQsICQkLnhBeGlzVGlja0Zvcm1hdCwgJCQueEF4aXNUaWNrVmFsdWVzLCBjb25maWcuYXhpc194X3RpY2tfb3V0ZXIpO1xuICAgICAgICAkJC55QXhpcyA9ICQkLmF4aXMuZ2V0WUF4aXMoJCQueSwgJCQueU9yaWVudCwgY29uZmlnLmF4aXNfeV90aWNrX2Zvcm1hdCwgJCQueUF4aXNUaWNrVmFsdWVzLCBjb25maWcuYXhpc195X3RpY2tfb3V0ZXIpO1xuICAgICAgICAkJC55MkF4aXMgPSAkJC5heGlzLmdldFlBeGlzKCQkLnkyLCAkJC55Mk9yaWVudCwgY29uZmlnLmF4aXNfeTJfdGlja19mb3JtYXQsICQkLnkyQXhpc1RpY2tWYWx1ZXMsIGNvbmZpZy5heGlzX3kyX3RpY2tfb3V0ZXIpO1xuXG4gICAgICAgIC8vIFNldCBpbml0aWFsaXplZCBzY2FsZXMgdG8gYnJ1c2ggYW5kIHpvb21cbiAgICAgICAgaWYgKCFmb3JJbml0KSB7XG4gICAgICAgICAgICBpZiAoJCQuYnJ1c2gpIHtcbiAgICAgICAgICAgICAgICAkJC5icnVzaC5zY2FsZSgkJC5zdWJYKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcuem9vbV9lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgJCQuem9vbS5zY2FsZSgkJC54KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgZm9yIGFyY1xuICAgICAgICBpZiAoJCQudXBkYXRlQXJjKSB7XG4gICAgICAgICAgICAkJC51cGRhdGVBcmMoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5zZWxlY3RQb2ludCA9IGZ1bmN0aW9uICh0YXJnZXQsIGQsIGkpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIGN4ID0gKGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAkJC5jaXJjbGVZIDogJCQuY2lyY2xlWCkuYmluZCgkJCksXG4gICAgICAgICAgICBjeSA9IChjb25maWcuYXhpc19yb3RhdGVkID8gJCQuY2lyY2xlWCA6ICQkLmNpcmNsZVkpLmJpbmQoJCQpLFxuICAgICAgICAgICAgciA9ICQkLnBvaW50U2VsZWN0Ui5iaW5kKCQkKTtcbiAgICAgICAgY29uZmlnLmRhdGFfb25zZWxlY3RlZC5jYWxsKCQkLmFwaSwgZCwgdGFyZ2V0Lm5vZGUoKSk7XG4gICAgICAgIC8vIGFkZCBzZWxlY3RlZC1jaXJjbGUgb24gbG93IGxheWVyIGdcbiAgICAgICAgJCQubWFpbi5zZWxlY3QoJy4nICsgQ0xBU1Muc2VsZWN0ZWRDaXJjbGVzICsgJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCkpLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5zZWxlY3RlZENpcmNsZSArICctJyArIGkpLmRhdGEoW2RdKS5lbnRlcigpLmFwcGVuZCgnY2lyY2xlJykuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAkJC5nZW5lcmF0ZUNsYXNzKENMQVNTLnNlbGVjdGVkQ2lyY2xlLCBpKTtcbiAgICAgICAgfSkuYXR0cihcImN4XCIsIGN4KS5hdHRyKFwiY3lcIiwgY3kpLmF0dHIoXCJzdHJva2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICQkLmNvbG9yKGQpO1xuICAgICAgICB9KS5hdHRyKFwiclwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuICQkLnBvaW50U2VsZWN0UihkKSAqIDEuNDtcbiAgICAgICAgfSkudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMCkuYXR0cihcInJcIiwgcik7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi51bnNlbGVjdFBvaW50ID0gZnVuY3Rpb24gKHRhcmdldCwgZCwgaSkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICAkJC5jb25maWcuZGF0YV9vbnVuc2VsZWN0ZWQuY2FsbCgkJC5hcGksIGQsIHRhcmdldC5ub2RlKCkpO1xuICAgICAgICAvLyByZW1vdmUgc2VsZWN0ZWQtY2lyY2xlIGZyb20gbG93IGxheWVyIGdcbiAgICAgICAgJCQubWFpbi5zZWxlY3QoJy4nICsgQ0xBU1Muc2VsZWN0ZWRDaXJjbGVzICsgJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCkpLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5zZWxlY3RlZENpcmNsZSArICctJyArIGkpLnRyYW5zaXRpb24oKS5kdXJhdGlvbigxMDApLmF0dHIoJ3InLCAwKS5yZW1vdmUoKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnRvZ2dsZVBvaW50ID0gZnVuY3Rpb24gKHNlbGVjdGVkLCB0YXJnZXQsIGQsIGkpIHtcbiAgICAgICAgc2VsZWN0ZWQgPyB0aGlzLnNlbGVjdFBvaW50KHRhcmdldCwgZCwgaSkgOiB0aGlzLnVuc2VsZWN0UG9pbnQodGFyZ2V0LCBkLCBpKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnNlbGVjdFBhdGggPSBmdW5jdGlvbiAodGFyZ2V0LCBkKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgICQkLmNvbmZpZy5kYXRhX29uc2VsZWN0ZWQuY2FsbCgkJCwgZCwgdGFyZ2V0Lm5vZGUoKSk7XG4gICAgICAgIGlmICgkJC5jb25maWcuaW50ZXJhY3Rpb25fYnJpZ2h0ZW4pIHtcbiAgICAgICAgICAgIHRhcmdldC50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTAwKS5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkJC5kMy5yZ2IoJCQuY29sb3IoZCkpLmJyaWdodGVyKDAuNzUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnVuc2VsZWN0UGF0aCA9IGZ1bmN0aW9uICh0YXJnZXQsIGQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgJCQuY29uZmlnLmRhdGFfb251bnNlbGVjdGVkLmNhbGwoJCQsIGQsIHRhcmdldC5ub2RlKCkpO1xuICAgICAgICBpZiAoJCQuY29uZmlnLmludGVyYWN0aW9uX2JyaWdodGVuKSB7XG4gICAgICAgICAgICB0YXJnZXQudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMCkuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJCQuY29sb3IoZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udG9nZ2xlUGF0aCA9IGZ1bmN0aW9uIChzZWxlY3RlZCwgdGFyZ2V0LCBkLCBpKSB7XG4gICAgICAgIHNlbGVjdGVkID8gdGhpcy5zZWxlY3RQYXRoKHRhcmdldCwgZCwgaSkgOiB0aGlzLnVuc2VsZWN0UGF0aCh0YXJnZXQsIGQsIGkpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0VG9nZ2xlID0gZnVuY3Rpb24gKHRoYXQsIGQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIHRvZ2dsZTtcbiAgICAgICAgaWYgKHRoYXQubm9kZU5hbWUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgICBpZiAoJCQuaXNTdGVwVHlwZShkKSkge1xuICAgICAgICAgICAgICAgIC8vIGNpcmNsZSBpcyBoaWRkZW4gaW4gc3RlcCBjaGFydCwgc28gdHJlYXQgYXMgd2l0aGluIHRoZSBjbGljayBhcmVhXG4gICAgICAgICAgICAgICAgdG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKCkge307IC8vIFRPRE86IGhvdyB0byBzZWxlY3Qgc3RlcCBjaGFydD9cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlID0gJCQudG9nZ2xlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhhdC5ub2RlTmFtZSA9PT0gJ3BhdGgnKSB7XG4gICAgICAgICAgICB0b2dnbGUgPSAkJC50b2dnbGVQYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2dnbGU7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi50b2dnbGVTaGFwZSA9IGZ1bmN0aW9uICh0aGF0LCBkLCBpKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBkMyA9ICQkLmQzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgc2hhcGUgPSBkMy5zZWxlY3QodGhhdCksXG4gICAgICAgICAgICBpc1NlbGVjdGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCksXG4gICAgICAgICAgICB0b2dnbGUgPSAkJC5nZXRUb2dnbGUodGhhdCwgZCkuYmluZCgkJCk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkpIHtcbiAgICAgICAgICAgIGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX211bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgJCQubWFpbi5zZWxlY3RBbGwoJy4nICsgQ0xBU1Muc2hhcGVzICsgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkID8gJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCkgOiBcIlwiKSkuc2VsZWN0QWxsKCcuJyArIENMQVNTLnNoYXBlKS5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGUoZmFsc2UsIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsIGZhbHNlKSwgZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsICFpc1NlbGVjdGVkKTtcbiAgICAgICAgICAgIHRvZ2dsZSghaXNTZWxlY3RlZCwgc2hhcGUsIGQsIGkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmluaXRCYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgICQkLm1haW4uc2VsZWN0KCcuJyArIENMQVNTLmNoYXJ0KS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydEJhcnMpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udXBkYXRlVGFyZ2V0c0ZvckJhciA9IGZ1bmN0aW9uICh0YXJnZXRzKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBtYWluQmFyVXBkYXRlLFxuICAgICAgICAgICAgbWFpbkJhckVudGVyLFxuICAgICAgICAgICAgY2xhc3NDaGFydEJhciA9ICQkLmNsYXNzQ2hhcnRCYXIuYmluZCgkJCksXG4gICAgICAgICAgICBjbGFzc0JhcnMgPSAkJC5jbGFzc0JhcnMuYmluZCgkJCksXG4gICAgICAgICAgICBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKTtcbiAgICAgICAgbWFpbkJhclVwZGF0ZSA9ICQkLm1haW4uc2VsZWN0KCcuJyArIENMQVNTLmNoYXJ0QmFycykuc2VsZWN0QWxsKCcuJyArIENMQVNTLmNoYXJ0QmFyKS5kYXRhKHRhcmdldHMpLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFzc0NoYXJ0QmFyKGQpICsgY2xhc3NGb2N1cyhkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1haW5CYXJFbnRlciA9IG1haW5CYXJVcGRhdGUuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsIGNsYXNzQ2hhcnRCYXIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICAgICAgICAvLyBCYXJzIGZvciBlYWNoIGRhdGFcbiAgICAgICAgbWFpbkJhckVudGVyLmFwcGVuZCgnZycpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc0JhcnMpLnN0eWxlKFwiY3Vyc29yXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSA/IFwicG9pbnRlclwiIDogbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi51cGRhdGVCYXIgPSBmdW5jdGlvbiAoZHVyYXRpb25Gb3JFeGl0KSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBiYXJEYXRhID0gJCQuYmFyRGF0YS5iaW5kKCQkKSxcbiAgICAgICAgICAgIGNsYXNzQmFyID0gJCQuY2xhc3NCYXIuYmluZCgkJCksXG4gICAgICAgICAgICBpbml0aWFsT3BhY2l0eSA9ICQkLmluaXRpYWxPcGFjaXR5LmJpbmQoJCQpLFxuICAgICAgICAgICAgY29sb3IgPSBmdW5jdGlvbiBjb2xvcihkKSB7XG4gICAgICAgICAgICByZXR1cm4gJCQuY29sb3IoZC5pZCk7XG4gICAgICAgIH07XG4gICAgICAgICQkLm1haW5CYXIgPSAkJC5tYWluLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5iYXJzKS5zZWxlY3RBbGwoJy4nICsgQ0xBU1MuYmFyKS5kYXRhKGJhckRhdGEpO1xuICAgICAgICAkJC5tYWluQmFyLmVudGVyKCkuYXBwZW5kKCdwYXRoJykuYXR0cihcImNsYXNzXCIsIGNsYXNzQmFyKS5zdHlsZShcInN0cm9rZVwiLCBjb2xvcikuc3R5bGUoXCJmaWxsXCIsIGNvbG9yKTtcbiAgICAgICAgJCQubWFpbkJhci5zdHlsZShcIm9wYWNpdHlcIiwgaW5pdGlhbE9wYWNpdHkpO1xuICAgICAgICAkJC5tYWluQmFyLmV4aXQoKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KS5yZW1vdmUoKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnJlZHJhd0JhciA9IGZ1bmN0aW9uIChkcmF3QmFyLCB3aXRoVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gWyh3aXRoVHJhbnNpdGlvbiA/IHRoaXMubWFpbkJhci50cmFuc2l0aW9uKE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKSkgOiB0aGlzLm1haW5CYXIpLmF0dHIoJ2QnLCBkcmF3QmFyKS5zdHlsZShcInN0cm9rZVwiLCB0aGlzLmNvbG9yKS5zdHlsZShcImZpbGxcIiwgdGhpcy5jb2xvcikuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldEJhclcgPSBmdW5jdGlvbiAoYXhpcywgYmFyVGFyZ2V0c051bSkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgdyA9IHR5cGVvZiBjb25maWcuYmFyX3dpZHRoID09PSAnbnVtYmVyJyA/IGNvbmZpZy5iYXJfd2lkdGggOiBiYXJUYXJnZXRzTnVtID8gYXhpcy50aWNrSW50ZXJ2YWwoKSAqIGNvbmZpZy5iYXJfd2lkdGhfcmF0aW8gLyBiYXJUYXJnZXRzTnVtIDogMDtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5iYXJfd2lkdGhfbWF4ICYmIHcgPiBjb25maWcuYmFyX3dpZHRoX21heCA/IGNvbmZpZy5iYXJfd2lkdGhfbWF4IDogdztcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldEJhcnMgPSBmdW5jdGlvbiAoaSwgaWQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChpZCA/ICQkLm1haW4uc2VsZWN0QWxsKCcuJyArIENMQVNTLmJhcnMgKyAkJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCkpIDogJCQubWFpbikuc2VsZWN0QWxsKCcuJyArIENMQVNTLmJhciArIChpc1ZhbHVlKGkpID8gJy0nICsgaSA6ICcnKSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5leHBhbmRCYXJzID0gZnVuY3Rpb24gKGksIGlkLCByZXNldCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICAgICQkLnVuZXhwYW5kQmFycygpO1xuICAgICAgICB9XG4gICAgICAgICQkLmdldEJhcnMoaSwgaWQpLmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQsIHRydWUpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udW5leHBhbmRCYXJzID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgJCQuZ2V0QmFycyhpKS5jbGFzc2VkKENMQVNTLkVYUEFOREVELCBmYWxzZSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZW5lcmF0ZURyYXdCYXIgPSBmdW5jdGlvbiAoYmFySW5kaWNlcywgaXNTdWIpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIGdldFBvaW50cyA9ICQkLmdlbmVyYXRlR2V0QmFyUG9pbnRzKGJhckluZGljZXMsIGlzU3ViKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAvLyA0IHBvaW50cyB0aGF0IG1ha2UgYSBiYXJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBnZXRQb2ludHMoZCwgaSk7XG5cbiAgICAgICAgICAgIC8vIHN3aXRjaCBwb2ludHMgaWYgYXhpcyBpcyByb3RhdGVkLCBub3QgYXBwbGljYWJsZSBmb3Igc3ViIGNoYXJ0XG4gICAgICAgICAgICB2YXIgaW5kZXhYID0gY29uZmlnLmF4aXNfcm90YXRlZCA/IDEgOiAwO1xuICAgICAgICAgICAgdmFyIGluZGV4WSA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAwIDogMTtcblxuICAgICAgICAgICAgdmFyIHBhdGggPSAnTSAnICsgcG9pbnRzWzBdW2luZGV4WF0gKyAnLCcgKyBwb2ludHNbMF1baW5kZXhZXSArICcgJyArICdMJyArIHBvaW50c1sxXVtpbmRleFhdICsgJywnICsgcG9pbnRzWzFdW2luZGV4WV0gKyAnICcgKyAnTCcgKyBwb2ludHNbMl1baW5kZXhYXSArICcsJyArIHBvaW50c1syXVtpbmRleFldICsgJyAnICsgJ0wnICsgcG9pbnRzWzNdW2luZGV4WF0gKyAnLCcgKyBwb2ludHNbM11baW5kZXhZXSArICcgJyArICd6JztcblxuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZW5lcmF0ZUdldEJhclBvaW50cyA9IGZ1bmN0aW9uIChiYXJJbmRpY2VzLCBpc1N1Yikge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgYXhpcyA9IGlzU3ViID8gJCQuc3ViWEF4aXMgOiAkJC54QXhpcyxcbiAgICAgICAgICAgIGJhclRhcmdldHNOdW0gPSBiYXJJbmRpY2VzLl9fbWF4X18gKyAxLFxuICAgICAgICAgICAgYmFyVyA9ICQkLmdldEJhclcoYXhpcywgYmFyVGFyZ2V0c051bSksXG4gICAgICAgICAgICBiYXJYID0gJCQuZ2V0U2hhcGVYKGJhclcsIGJhclRhcmdldHNOdW0sIGJhckluZGljZXMsICEhaXNTdWIpLFxuICAgICAgICAgICAgYmFyWSA9ICQkLmdldFNoYXBlWSghIWlzU3ViKSxcbiAgICAgICAgICAgIGJhck9mZnNldCA9ICQkLmdldFNoYXBlT2Zmc2V0KCQkLmlzQmFyVHlwZSwgYmFySW5kaWNlcywgISFpc1N1YiksXG4gICAgICAgICAgICBiYXJTcGFjZU9mZnNldCA9IGJhclcgKiAoJCQuY29uZmlnLmJhcl9zcGFjZSAvIDIpLFxuICAgICAgICAgICAgeVNjYWxlID0gaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUgOiAkJC5nZXRZU2NhbGU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgdmFyIHkwID0geVNjYWxlLmNhbGwoJCQsIGQuaWQpKDApLFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGJhck9mZnNldChkLCBpKSB8fCB5MCxcbiAgICAgICAgICAgICAgICAvLyBvZmZzZXQgaXMgZm9yIHN0YWNrZWQgYmFyIGNoYXJ0XG4gICAgICAgICAgICBwb3NYID0gYmFyWChkKSxcbiAgICAgICAgICAgICAgICBwb3NZID0gYmFyWShkKTtcbiAgICAgICAgICAgIC8vIGZpeCBwb3NZIG5vdCB0byBvdmVyZmxvdyBvcHBvc2l0ZSBxdWFkcmFudFxuICAgICAgICAgICAgaWYgKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoMCA8IGQudmFsdWUgJiYgcG9zWSA8IHkwIHx8IGQudmFsdWUgPCAwICYmIHkwIDwgcG9zWSkge1xuICAgICAgICAgICAgICAgICAgICBwb3NZID0geTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gNCBwb2ludHMgdGhhdCBtYWtlIGEgYmFyXG4gICAgICAgICAgICByZXR1cm4gW1twb3NYICsgYmFyU3BhY2VPZmZzZXQsIG9mZnNldF0sIFtwb3NYICsgYmFyU3BhY2VPZmZzZXQsIHBvc1kgLSAoeTAgLSBvZmZzZXQpXSwgW3Bvc1ggKyBiYXJXIC0gYmFyU3BhY2VPZmZzZXQsIHBvc1kgLSAoeTAgLSBvZmZzZXQpXSwgW3Bvc1ggKyBiYXJXIC0gYmFyU3BhY2VPZmZzZXQsIG9mZnNldF1dO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaXNXaXRoaW5CYXIgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgICB2YXIgbW91c2UgPSB0aGlzLmQzLm1vdXNlKHRoYXQpLFxuICAgICAgICAgICAgYm94ID0gdGhhdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIHNlZzAgPSB0aGF0LnBhdGhTZWdMaXN0LmdldEl0ZW0oMCksXG4gICAgICAgICAgICBzZWcxID0gdGhhdC5wYXRoU2VnTGlzdC5nZXRJdGVtKDEpLFxuICAgICAgICAgICAgeCA9IE1hdGgubWluKHNlZzAueCwgc2VnMS54KSxcbiAgICAgICAgICAgIHkgPSBNYXRoLm1pbihzZWcwLnksIHNlZzEueSksXG4gICAgICAgICAgICB3ID0gYm94LndpZHRoLFxuICAgICAgICAgICAgaCA9IGJveC5oZWlnaHQsXG4gICAgICAgICAgICBvZmZzZXQgPSAyLFxuICAgICAgICAgICAgc3ggPSB4IC0gb2Zmc2V0LFxuICAgICAgICAgICAgZXggPSB4ICsgdyArIG9mZnNldCxcbiAgICAgICAgICAgIHN5ID0geSArIGggKyBvZmZzZXQsXG4gICAgICAgICAgICBleSA9IHkgLSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiBzeCA8IG1vdXNlWzBdICYmIG1vdXNlWzBdIDwgZXggJiYgZXkgPCBtb3VzZVsxXSAmJiBtb3VzZVsxXSA8IHN5O1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRTaGFwZUluZGljZXMgPSBmdW5jdGlvbiAodHlwZUZpbHRlcikge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgaW5kaWNlcyA9IHt9LFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgaztcbiAgICAgICAgJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMuZmlsdGVyKHR5cGVGaWx0ZXIsICQkKSkuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGF0YV9ncm91cHNbal0uaW5kZXhPZihkLmlkKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBjb25maWcuZGF0YV9ncm91cHNbal0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5kYXRhX2dyb3Vwc1tqXVtrXSBpbiBpbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzW2QuaWRdID0gaW5kaWNlc1tjb25maWcuZGF0YV9ncm91cHNbal1ba11dO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoaW5kaWNlc1tkLmlkXSkpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2VzW2QuaWRdID0gaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaW5kaWNlcy5fX21heF9fID0gaSAtIDE7XG4gICAgICAgIHJldHVybiBpbmRpY2VzO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0U2hhcGVYID0gZnVuY3Rpb24gKG9mZnNldCwgdGFyZ2V0c051bSwgaW5kaWNlcywgaXNTdWIpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIHNjYWxlID0gaXNTdWIgPyAkJC5zdWJYIDogJCQueDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBkLmlkIGluIGluZGljZXMgPyBpbmRpY2VzW2QuaWRdIDogMDtcbiAgICAgICAgICAgIHJldHVybiBkLnggfHwgZC54ID09PSAwID8gc2NhbGUoZC54KSAtIG9mZnNldCAqICh0YXJnZXRzTnVtIC8gMiAtIGluZGV4KSA6IDA7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRTaGFwZVkgPSBmdW5jdGlvbiAoaXNTdWIpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZShkLmlkKSA6ICQkLmdldFlTY2FsZShkLmlkKTtcbiAgICAgICAgICAgIHJldHVybiBzY2FsZShkLnZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldFNoYXBlT2Zmc2V0ID0gZnVuY3Rpb24gKHR5cGVGaWx0ZXIsIGluZGljZXMsIGlzU3ViKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICB0YXJnZXRzID0gJCQub3JkZXJUYXJnZXRzKCQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzLmZpbHRlcih0eXBlRmlsdGVyLCAkJCkpKSxcbiAgICAgICAgICAgIHRhcmdldElkcyA9IHRhcmdldHMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdC5pZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUoZC5pZCkgOiAkJC5nZXRZU2NhbGUoZC5pZCksXG4gICAgICAgICAgICAgICAgeTAgPSBzY2FsZSgwKSxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB5MDtcbiAgICAgICAgICAgIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSAkJC5pc1N0ZXBUeXBlKGQpID8gJCQuY29udmVydFZhbHVlc1RvU3RlcCh0LnZhbHVlcykgOiB0LnZhbHVlcztcbiAgICAgICAgICAgICAgICBpZiAodC5pZCA9PT0gZC5pZCB8fCBpbmRpY2VzW3QuaWRdICE9PSBpbmRpY2VzW2QuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldElkcy5pbmRleE9mKHQuaWQpIDwgdGFyZ2V0SWRzLmluZGV4T2YoZC5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHggdmFsdWVzIGxpbmUgdXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXNbaV0gPT09ICd1bmRlZmluZWQnIHx8ICt2YWx1ZXNbaV0ueCAhPT0gK2QueCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCIrXCIgZm9yIHRpbWVzZXJpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdCwgdHJ5IHRvIGZpbmQgdGhlIHZhbHVlIHRoYXQgZG9lcyBsaW5lIHVwXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodiwgaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2LnggPT09IGQueCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSBpbiB2YWx1ZXMgJiYgdmFsdWVzW2ldLnZhbHVlICogZC52YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc2NhbGUodmFsdWVzW2ldLnZhbHVlKSAtIHkwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICB9O1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaXNXaXRoaW5TaGFwZSA9IGZ1bmN0aW9uICh0aGF0LCBkKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBzaGFwZSA9ICQkLmQzLnNlbGVjdCh0aGF0KSxcbiAgICAgICAgICAgIGlzV2l0aGluO1xuICAgICAgICBpZiAoISQkLmlzVGFyZ2V0VG9TaG93KGQuaWQpKSB7XG4gICAgICAgICAgICBpc1dpdGhpbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoYXQubm9kZU5hbWUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgICBpc1dpdGhpbiA9ICQkLmlzU3RlcFR5cGUoZCkgPyAkJC5pc1dpdGhpblN0ZXAodGhhdCwgJCQuZ2V0WVNjYWxlKGQuaWQpKGQudmFsdWUpKSA6ICQkLmlzV2l0aGluQ2lyY2xlKHRoYXQsICQkLnBvaW50U2VsZWN0UihkKSAqIDEuNSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhhdC5ub2RlTmFtZSA9PT0gJ3BhdGgnKSB7XG4gICAgICAgICAgICBpc1dpdGhpbiA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuYmFyKSA/ICQkLmlzV2l0aGluQmFyKHRoYXQpIDogdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNXaXRoaW47XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldEludGVycG9sYXRlID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGludGVycG9sYXRpb24gPSAkJC5pc0ludGVycG9sYXRpb25UeXBlKCQkLmNvbmZpZy5zcGxpbmVfaW50ZXJwb2xhdGlvbl90eXBlKSA/ICQkLmNvbmZpZy5zcGxpbmVfaW50ZXJwb2xhdGlvbl90eXBlIDogJ2NhcmRpbmFsJztcbiAgICAgICAgcmV0dXJuICQkLmlzU3BsaW5lVHlwZShkKSA/IGludGVycG9sYXRpb24gOiAkJC5pc1N0ZXBUeXBlKGQpID8gJCQuY29uZmlnLmxpbmVfc3RlcF90eXBlIDogXCJsaW5lYXJcIjtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaW5pdExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgICQkLm1haW4uc2VsZWN0KCcuJyArIENMQVNTLmNoYXJ0KS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydExpbmVzKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnVwZGF0ZVRhcmdldHNGb3JMaW5lID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIG1haW5MaW5lVXBkYXRlLFxuICAgICAgICAgICAgbWFpbkxpbmVFbnRlcixcbiAgICAgICAgICAgIGNsYXNzQ2hhcnRMaW5lID0gJCQuY2xhc3NDaGFydExpbmUuYmluZCgkJCksXG4gICAgICAgICAgICBjbGFzc0xpbmVzID0gJCQuY2xhc3NMaW5lcy5iaW5kKCQkKSxcbiAgICAgICAgICAgIGNsYXNzQXJlYXMgPSAkJC5jbGFzc0FyZWFzLmJpbmQoJCQpLFxuICAgICAgICAgICAgY2xhc3NDaXJjbGVzID0gJCQuY2xhc3NDaXJjbGVzLmJpbmQoJCQpLFxuICAgICAgICAgICAgY2xhc3NGb2N1cyA9ICQkLmNsYXNzRm9jdXMuYmluZCgkJCk7XG4gICAgICAgIG1haW5MaW5lVXBkYXRlID0gJCQubWFpbi5zZWxlY3QoJy4nICsgQ0xBU1MuY2hhcnRMaW5lcykuc2VsZWN0QWxsKCcuJyArIENMQVNTLmNoYXJ0TGluZSkuZGF0YSh0YXJnZXRzKS5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhc3NDaGFydExpbmUoZCkgKyBjbGFzc0ZvY3VzKGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgbWFpbkxpbmVFbnRlciA9IG1haW5MaW5lVXBkYXRlLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCBjbGFzc0NoYXJ0TGluZSkuc3R5bGUoJ29wYWNpdHknLCAwKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICAgICAgLy8gTGluZXMgZm9yIGVhY2ggZGF0YVxuICAgICAgICBtYWluTGluZUVudGVyLmFwcGVuZCgnZycpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc0xpbmVzKTtcbiAgICAgICAgLy8gQXJlYXNcbiAgICAgICAgbWFpbkxpbmVFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsIGNsYXNzQXJlYXMpO1xuICAgICAgICAvLyBDaXJjbGVzIGZvciBlYWNoIGRhdGEgcG9pbnQgb24gbGluZXNcbiAgICAgICAgbWFpbkxpbmVFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAkJC5nZW5lcmF0ZUNsYXNzKENMQVNTLnNlbGVjdGVkQ2lyY2xlcywgZC5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBtYWluTGluZUVudGVyLmFwcGVuZCgnZycpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NpcmNsZXMpLnN0eWxlKFwiY3Vyc29yXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSA/IFwicG9pbnRlclwiIDogbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFVwZGF0ZSBkYXRlIGZvciBzZWxlY3RlZCBjaXJjbGVzXG4gICAgICAgIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgJCQubWFpbi5zZWxlY3RBbGwoJy4nICsgQ0xBU1Muc2VsZWN0ZWRDaXJjbGVzICsgJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodC5pZCkpLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5zZWxlY3RlZENpcmNsZSkuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIGQudmFsdWUgPSB0LnZhbHVlc1tkLmluZGV4XS52YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTUVNTzogY2FuIG5vdCBrZWVwIHNhbWUgY29sb3IuLi5cbiAgICAgICAgLy9tYWluTGluZVVwZGF0ZS5leGl0KCkucmVtb3ZlKCk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi51cGRhdGVMaW5lID0gZnVuY3Rpb24gKGR1cmF0aW9uRm9yRXhpdCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICAkJC5tYWluTGluZSA9ICQkLm1haW4uc2VsZWN0QWxsKCcuJyArIENMQVNTLmxpbmVzKS5zZWxlY3RBbGwoJy4nICsgQ0xBU1MubGluZSkuZGF0YSgkJC5saW5lRGF0YS5iaW5kKCQkKSk7XG4gICAgICAgICQkLm1haW5MaW5lLmVudGVyKCkuYXBwZW5kKCdwYXRoJykuYXR0cignY2xhc3MnLCAkJC5jbGFzc0xpbmUuYmluZCgkJCkpLnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKTtcbiAgICAgICAgJCQubWFpbkxpbmUuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmluaXRpYWxPcGFjaXR5LmJpbmQoJCQpKS5zdHlsZSgnc2hhcGUtcmVuZGVyaW5nJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAkJC5pc1N0ZXBUeXBlKGQpID8gJ2NyaXNwRWRnZXMnIDogJyc7XG4gICAgICAgIH0pLmF0dHIoJ3RyYW5zZm9ybScsIG51bGwpO1xuICAgICAgICAkJC5tYWluTGluZS5leGl0KCkudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdCkuc3R5bGUoJ29wYWNpdHknLCAwKS5yZW1vdmUoKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnJlZHJhd0xpbmUgPSBmdW5jdGlvbiAoZHJhd0xpbmUsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBbKHdpdGhUcmFuc2l0aW9uID8gdGhpcy5tYWluTGluZS50cmFuc2l0aW9uKE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKSkgOiB0aGlzLm1haW5MaW5lKS5hdHRyKFwiZFwiLCBkcmF3TGluZSkuc3R5bGUoXCJzdHJva2VcIiwgdGhpcy5jb2xvcikuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdlbmVyYXRlRHJhd0xpbmUgPSBmdW5jdGlvbiAobGluZUluZGljZXMsIGlzU3ViKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBsaW5lID0gJCQuZDMuc3ZnLmxpbmUoKSxcbiAgICAgICAgICAgIGdldFBvaW50cyA9ICQkLmdlbmVyYXRlR2V0TGluZVBvaW50cyhsaW5lSW5kaWNlcywgaXNTdWIpLFxuICAgICAgICAgICAgeVNjYWxlR2V0dGVyID0gaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUgOiAkJC5nZXRZU2NhbGUsXG4gICAgICAgICAgICB4VmFsdWUgPSBmdW5jdGlvbiB4VmFsdWUoZCkge1xuICAgICAgICAgICAgcmV0dXJuIChpc1N1YiA/ICQkLnN1Ynh4IDogJCQueHgpLmNhbGwoJCQsIGQpO1xuICAgICAgICB9LFxuICAgICAgICAgICAgeVZhbHVlID0gZnVuY3Rpb24geVZhbHVlKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoID4gMCA/IGdldFBvaW50cyhkLCBpKVswXVsxXSA6IHlTY2FsZUdldHRlci5jYWxsKCQkLCBkLmlkKShkLnZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBsaW5lID0gY29uZmlnLmF4aXNfcm90YXRlZCA/IGxpbmUueCh5VmFsdWUpLnkoeFZhbHVlKSA6IGxpbmUueCh4VmFsdWUpLnkoeVZhbHVlKTtcbiAgICAgICAgaWYgKCFjb25maWcubGluZV9jb25uZWN0TnVsbCkge1xuICAgICAgICAgICAgbGluZSA9IGxpbmUuZGVmaW5lZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLnZhbHVlICE9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBjb25maWcubGluZV9jb25uZWN0TnVsbCA/ICQkLmZpbHRlclJlbW92ZU51bGwoZC52YWx1ZXMpIDogZC52YWx1ZXMsXG4gICAgICAgICAgICAgICAgeCA9IGlzU3ViID8gJCQueCA6ICQkLnN1YlgsXG4gICAgICAgICAgICAgICAgeSA9IHlTY2FsZUdldHRlci5jYWxsKCQkLCBkLmlkKSxcbiAgICAgICAgICAgICAgICB4MCA9IDAsXG4gICAgICAgICAgICAgICAgeTAgPSAwLFxuICAgICAgICAgICAgICAgIHBhdGg7XG4gICAgICAgICAgICBpZiAoJCQuaXNMaW5lVHlwZShkKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGF0YV9yZWdpb25zW2QuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSAkJC5saW5lV2l0aFJlZ2lvbnModmFsdWVzLCB4LCB5LCBjb25maWcuZGF0YV9yZWdpb25zW2QuaWRdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJCQuaXNTdGVwVHlwZShkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gJCQuY29udmVydFZhbHVlc1RvU3RlcCh2YWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBsaW5lLmludGVycG9sYXRlKCQkLmdldEludGVycG9sYXRlKGQpKSh2YWx1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1swXSkge1xuICAgICAgICAgICAgICAgICAgICB4MCA9IHgodmFsdWVzWzBdLngpO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHkodmFsdWVzWzBdLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0aCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcIk0gXCIgKyB5MCArIFwiIFwiICsgeDAgOiBcIk0gXCIgKyB4MCArIFwiIFwiICsgeTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0aCA/IHBhdGggOiBcIk0gMCAwXCI7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZW5lcmF0ZUdldExpbmVQb2ludHMgPSBmdW5jdGlvbiAobGluZUluZGljZXMsIGlzU3ViKSB7XG4gICAgICAgIC8vIHBhcnRpYWwgZHVwbGljYXRpb24gb2YgZ2VuZXJhdGVHZXRCYXJQb2ludHNcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIGxpbmVUYXJnZXRzTnVtID0gbGluZUluZGljZXMuX19tYXhfXyArIDEsXG4gICAgICAgICAgICB4ID0gJCQuZ2V0U2hhcGVYKDAsIGxpbmVUYXJnZXRzTnVtLCBsaW5lSW5kaWNlcywgISFpc1N1YiksXG4gICAgICAgICAgICB5ID0gJCQuZ2V0U2hhcGVZKCEhaXNTdWIpLFxuICAgICAgICAgICAgbGluZU9mZnNldCA9ICQkLmdldFNoYXBlT2Zmc2V0KCQkLmlzTGluZVR5cGUsIGxpbmVJbmRpY2VzLCAhIWlzU3ViKSxcbiAgICAgICAgICAgIHlTY2FsZSA9IGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlIDogJCQuZ2V0WVNjYWxlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHZhciB5MCA9IHlTY2FsZS5jYWxsKCQkLCBkLmlkKSgwKSxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBsaW5lT2Zmc2V0KGQsIGkpIHx8IHkwLFxuICAgICAgICAgICAgICAgIC8vIG9mZnNldCBpcyBmb3Igc3RhY2tlZCBhcmVhIGNoYXJ0XG4gICAgICAgICAgICBwb3NYID0geChkKSxcbiAgICAgICAgICAgICAgICBwb3NZID0geShkKTtcbiAgICAgICAgICAgIC8vIGZpeCBwb3NZIG5vdCB0byBvdmVyZmxvdyBvcHBvc2l0ZSBxdWFkcmFudFxuICAgICAgICAgICAgaWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoMCA8IGQudmFsdWUgJiYgcG9zWSA8IHkwIHx8IGQudmFsdWUgPCAwICYmIHkwIDwgcG9zWSkge1xuICAgICAgICAgICAgICAgICAgICBwb3NZID0geTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMSBwb2ludCB0aGF0IG1hcmtzIHRoZSBsaW5lIHBvc2l0aW9uXG4gICAgICAgICAgICByZXR1cm4gW1twb3NYLCBwb3NZIC0gKHkwIC0gb2Zmc2V0KV0sIFtwb3NYLCBwb3NZIC0gKHkwIC0gb2Zmc2V0KV0sIC8vIG5lZWRlZCBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgW3Bvc1gsIHBvc1kgLSAoeTAgLSBvZmZzZXQpXSwgLy8gbmVlZGVkIGZvciBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBbcG9zWCwgcG9zWSAtICh5MCAtIG9mZnNldCldIC8vIG5lZWRlZCBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ubGluZVdpdGhSZWdpb25zID0gZnVuY3Rpb24gKGQsIHgsIHksIF9yZWdpb25zKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBwcmV2ID0gLTEsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIHMgPSBcIk1cIixcbiAgICAgICAgICAgIHNXaXRoUmVnaW9uLFxuICAgICAgICAgICAgeHAsXG4gICAgICAgICAgICB5cCxcbiAgICAgICAgICAgIGR4LFxuICAgICAgICAgICAgZHksXG4gICAgICAgICAgICBkZCxcbiAgICAgICAgICAgIGRpZmYsXG4gICAgICAgICAgICBkaWZmeDIsXG4gICAgICAgICAgICB4T2Zmc2V0ID0gJCQuaXNDYXRlZ29yaXplZCgpID8gMC41IDogMCxcbiAgICAgICAgICAgIHhWYWx1ZSxcbiAgICAgICAgICAgIHlWYWx1ZSxcbiAgICAgICAgICAgIHJlZ2lvbnMgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBpc1dpdGhpblJlZ2lvbnMoeCwgcmVnaW9ucykge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVnaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChyZWdpb25zW2ldLnN0YXJ0IDwgeCAmJiB4IDw9IHJlZ2lvbnNbaV0uZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHN0YXJ0L2VuZCBvZiByZWdpb25zXG4gICAgICAgIGlmIChpc0RlZmluZWQoX3JlZ2lvbnMpKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX3JlZ2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZWdpb25zW2ldID0ge307XG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKF9yZWdpb25zW2ldLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICByZWdpb25zW2ldLnN0YXJ0ID0gZFswXS54O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbnNbaV0uc3RhcnQgPSAkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLnBhcnNlRGF0ZShfcmVnaW9uc1tpXS5zdGFydCkgOiBfcmVnaW9uc1tpXS5zdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKF9yZWdpb25zW2ldLmVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uc1tpXS5lbmQgPSBkW2QubGVuZ3RoIC0gMV0ueDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWdpb25zW2ldLmVuZCA9ICQkLmlzVGltZVNlcmllcygpID8gJCQucGFyc2VEYXRlKF9yZWdpb25zW2ldLmVuZCkgOiBfcmVnaW9uc1tpXS5lbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHNjYWxlc1xuICAgICAgICB4VmFsdWUgPSBjb25maWcuYXhpc19yb3RhdGVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB5KGQudmFsdWUpO1xuICAgICAgICB9IDogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB4KGQueCk7XG4gICAgICAgIH07XG4gICAgICAgIHlWYWx1ZSA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIHgoZC54KTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4geShkLnZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBEZWZpbmUgc3ZnIGdlbmVyYXRvciBmdW5jdGlvbiBmb3IgcmVnaW9uXG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlTShwb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybiAnTScgKyBwb2ludHNbMF1bMF0gKyAnICcgKyBwb2ludHNbMF1bMV0gKyAnICcgKyBwb2ludHNbMV1bMF0gKyAnICcgKyBwb2ludHNbMV1bMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCQkLmlzVGltZVNlcmllcygpKSB7XG4gICAgICAgICAgICBzV2l0aFJlZ2lvbiA9IGZ1bmN0aW9uIHNXaXRoUmVnaW9uKGQwLCBkMSwgaiwgZGlmZikge1xuICAgICAgICAgICAgICAgIHZhciB4MCA9IGQwLnguZ2V0VGltZSgpLFxuICAgICAgICAgICAgICAgICAgICB4X2RpZmYgPSBkMS54IC0gZDAueCxcbiAgICAgICAgICAgICAgICAgICAgeHYwID0gbmV3IERhdGUoeDAgKyB4X2RpZmYgKiBqKSxcbiAgICAgICAgICAgICAgICAgICAgeHYxID0gbmV3IERhdGUoeDAgKyB4X2RpZmYgKiAoaiArIGRpZmYpKSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuYXhpc19yb3RhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IFtbeSh5cChqKSksIHgoeHYwKV0sIFt5KHlwKGogKyBkaWZmKSksIHgoeHYxKV1dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IFtbeCh4djApLCB5KHlwKGopKV0sIFt4KHh2MSksIHkoeXAoaiArIGRpZmYpKV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVNKHBvaW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc1dpdGhSZWdpb24gPSBmdW5jdGlvbiBzV2l0aFJlZ2lvbihkMCwgZDEsIGosIGRpZmYpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuYXhpc19yb3RhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IFtbeSh5cChqKSwgdHJ1ZSksIHgoeHAoaikpXSwgW3koeXAoaiArIGRpZmYpLCB0cnVlKSwgeCh4cChqICsgZGlmZikpXV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gW1t4KHhwKGopLCB0cnVlKSwgeSh5cChqKSldLCBbeCh4cChqICsgZGlmZiksIHRydWUpLCB5KHlwKGogKyBkaWZmKSldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlTShwb2ludHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIC8vIERyYXcgYXMgbm9ybWFsXG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQocmVnaW9ucykgfHwgIWlzV2l0aGluUmVnaW9ucyhkW2ldLngsIHJlZ2lvbnMpKSB7XG4gICAgICAgICAgICAgICAgcyArPSBcIiBcIiArIHhWYWx1ZShkW2ldKSArIFwiIFwiICsgeVZhbHVlKGRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRHJhdyB3aXRoIHJlZ2lvbiAvLyBUT0RPOiBGaXggZm9yIGhvcml6b3RhbCBjaGFydHNcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4cCA9ICQkLmdldFNjYWxlKGRbaSAtIDFdLnggKyB4T2Zmc2V0LCBkW2ldLnggKyB4T2Zmc2V0LCAkJC5pc1RpbWVTZXJpZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIHlwID0gJCQuZ2V0U2NhbGUoZFtpIC0gMV0udmFsdWUsIGRbaV0udmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGR4ID0geChkW2ldLngpIC0geChkW2kgLSAxXS54KTtcbiAgICAgICAgICAgICAgICAgICAgZHkgPSB5KGRbaV0udmFsdWUpIC0geShkW2kgLSAxXS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGRkID0gTWF0aC5zcXJ0KE1hdGgucG93KGR4LCAyKSArIE1hdGgucG93KGR5LCAyKSk7XG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPSAyIC8gZGQ7XG4gICAgICAgICAgICAgICAgICAgIGRpZmZ4MiA9IGRpZmYgKiAyO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGRpZmY7IGogPD0gMTsgaiArPSBkaWZmeDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gc1dpdGhSZWdpb24oZFtpIC0gMV0sIGRbaV0sIGosIGRpZmYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IGRbaV0ueDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi51cGRhdGVBcmVhID0gZnVuY3Rpb24gKGR1cmF0aW9uRm9yRXhpdCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgZDMgPSAkJC5kMztcbiAgICAgICAgJCQubWFpbkFyZWEgPSAkJC5tYWluLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5hcmVhcykuc2VsZWN0QWxsKCcuJyArIENMQVNTLmFyZWEpLmRhdGEoJCQubGluZURhdGEuYmluZCgkJCkpO1xuICAgICAgICAkJC5tYWluQXJlYS5lbnRlcigpLmFwcGVuZCgncGF0aCcpLmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0FyZWEuYmluZCgkJCkpLnN0eWxlKFwiZmlsbFwiLCAkJC5jb2xvcikuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQkLm9yZ0FyZWFPcGFjaXR5ID0gK2QzLnNlbGVjdCh0aGlzKS5zdHlsZSgnb3BhY2l0eScpO3JldHVybiAwO1xuICAgICAgICB9KTtcbiAgICAgICAgJCQubWFpbkFyZWEuc3R5bGUoXCJvcGFjaXR5XCIsICQkLm9yZ0FyZWFPcGFjaXR5KTtcbiAgICAgICAgJCQubWFpbkFyZWEuZXhpdCgpLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpLnN0eWxlKCdvcGFjaXR5JywgMCkucmVtb3ZlKCk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5yZWRyYXdBcmVhID0gZnVuY3Rpb24gKGRyYXdBcmVhLCB3aXRoVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gWyh3aXRoVHJhbnNpdGlvbiA/IHRoaXMubWFpbkFyZWEudHJhbnNpdGlvbihNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkpIDogdGhpcy5tYWluQXJlYSkuYXR0cihcImRcIiwgZHJhd0FyZWEpLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmNvbG9yKS5zdHlsZShcIm9wYWNpdHlcIiwgdGhpcy5vcmdBcmVhT3BhY2l0eSldO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2VuZXJhdGVEcmF3QXJlYSA9IGZ1bmN0aW9uIChhcmVhSW5kaWNlcywgaXNTdWIpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIGFyZWEgPSAkJC5kMy5zdmcuYXJlYSgpLFxuICAgICAgICAgICAgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRBcmVhUG9pbnRzKGFyZWFJbmRpY2VzLCBpc1N1YiksXG4gICAgICAgICAgICB5U2NhbGVHZXR0ZXIgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZSA6ICQkLmdldFlTY2FsZSxcbiAgICAgICAgICAgIHhWYWx1ZSA9IGZ1bmN0aW9uIHhWYWx1ZShkKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzU3ViID8gJCQuc3VieHggOiAkJC54eCkuY2FsbCgkJCwgZCk7XG4gICAgICAgIH0sXG4gICAgICAgICAgICB2YWx1ZTAgPSBmdW5jdGlvbiB2YWx1ZTAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGggPiAwID8gZ2V0UG9pbnRzKGQsIGkpWzBdWzFdIDogeVNjYWxlR2V0dGVyLmNhbGwoJCQsIGQuaWQpKCQkLmdldEFyZWFCYXNlVmFsdWUoZC5pZCkpO1xuICAgICAgICB9LFxuICAgICAgICAgICAgdmFsdWUxID0gZnVuY3Rpb24gdmFsdWUxKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoID4gMCA/IGdldFBvaW50cyhkLCBpKVsxXVsxXSA6IHlTY2FsZUdldHRlci5jYWxsKCQkLCBkLmlkKShkLnZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBhcmVhID0gY29uZmlnLmF4aXNfcm90YXRlZCA/IGFyZWEueDAodmFsdWUwKS54MSh2YWx1ZTEpLnkoeFZhbHVlKSA6IGFyZWEueCh4VmFsdWUpLnkwKGNvbmZpZy5hcmVhX2Fib3ZlID8gMCA6IHZhbHVlMCkueTEodmFsdWUxKTtcbiAgICAgICAgaWYgKCFjb25maWcubGluZV9jb25uZWN0TnVsbCkge1xuICAgICAgICAgICAgYXJlYSA9IGFyZWEuZGVmaW5lZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLnZhbHVlICE9PSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBjb25maWcubGluZV9jb25uZWN0TnVsbCA/ICQkLmZpbHRlclJlbW92ZU51bGwoZC52YWx1ZXMpIDogZC52YWx1ZXMsXG4gICAgICAgICAgICAgICAgeDAgPSAwLFxuICAgICAgICAgICAgICAgIHkwID0gMCxcbiAgICAgICAgICAgICAgICBwYXRoO1xuICAgICAgICAgICAgaWYgKCQkLmlzQXJlYVR5cGUoZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoJCQuaXNTdGVwVHlwZShkKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSAkJC5jb252ZXJ0VmFsdWVzVG9TdGVwKHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGggPSBhcmVhLmludGVycG9sYXRlKCQkLmdldEludGVycG9sYXRlKGQpKSh2YWx1ZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHgwID0gJCQueCh2YWx1ZXNbMF0ueCk7XG4gICAgICAgICAgICAgICAgICAgIHkwID0gJCQuZ2V0WVNjYWxlKGQuaWQpKHZhbHVlc1swXS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGggPSBjb25maWcuYXhpc19yb3RhdGVkID8gXCJNIFwiICsgeTAgKyBcIiBcIiArIHgwIDogXCJNIFwiICsgeDAgKyBcIiBcIiArIHkwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdGggPyBwYXRoIDogXCJNIDAgMFwiO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0QXJlYUJhc2VWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZW5lcmF0ZUdldEFyZWFQb2ludHMgPSBmdW5jdGlvbiAoYXJlYUluZGljZXMsIGlzU3ViKSB7XG4gICAgICAgIC8vIHBhcnRpYWwgZHVwbGljYXRpb24gb2YgZ2VuZXJhdGVHZXRCYXJQb2ludHNcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIGFyZWFUYXJnZXRzTnVtID0gYXJlYUluZGljZXMuX19tYXhfXyArIDEsXG4gICAgICAgICAgICB4ID0gJCQuZ2V0U2hhcGVYKDAsIGFyZWFUYXJnZXRzTnVtLCBhcmVhSW5kaWNlcywgISFpc1N1YiksXG4gICAgICAgICAgICB5ID0gJCQuZ2V0U2hhcGVZKCEhaXNTdWIpLFxuICAgICAgICAgICAgYXJlYU9mZnNldCA9ICQkLmdldFNoYXBlT2Zmc2V0KCQkLmlzQXJlYVR5cGUsIGFyZWFJbmRpY2VzLCAhIWlzU3ViKSxcbiAgICAgICAgICAgIHlTY2FsZSA9IGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlIDogJCQuZ2V0WVNjYWxlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHZhciB5MCA9IHlTY2FsZS5jYWxsKCQkLCBkLmlkKSgwKSxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBhcmVhT2Zmc2V0KGQsIGkpIHx8IHkwLFxuICAgICAgICAgICAgICAgIC8vIG9mZnNldCBpcyBmb3Igc3RhY2tlZCBhcmVhIGNoYXJ0XG4gICAgICAgICAgICBwb3NYID0geChkKSxcbiAgICAgICAgICAgICAgICBwb3NZID0geShkKTtcbiAgICAgICAgICAgIC8vIGZpeCBwb3NZIG5vdCB0byBvdmVyZmxvdyBvcHBvc2l0ZSBxdWFkcmFudFxuICAgICAgICAgICAgaWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoMCA8IGQudmFsdWUgJiYgcG9zWSA8IHkwIHx8IGQudmFsdWUgPCAwICYmIHkwIDwgcG9zWSkge1xuICAgICAgICAgICAgICAgICAgICBwb3NZID0geTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMSBwb2ludCB0aGF0IG1hcmtzIHRoZSBhcmVhIHBvc2l0aW9uXG4gICAgICAgICAgICByZXR1cm4gW1twb3NYLCBvZmZzZXRdLCBbcG9zWCwgcG9zWSAtICh5MCAtIG9mZnNldCldLCBbcG9zWCwgcG9zWSAtICh5MCAtIG9mZnNldCldLCAvLyBuZWVkZWQgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIFtwb3NYLCBvZmZzZXRdIC8vIG5lZWRlZCBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udXBkYXRlQ2lyY2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICAkJC5tYWluQ2lyY2xlID0gJCQubWFpbi5zZWxlY3RBbGwoJy4nICsgQ0xBU1MuY2lyY2xlcykuc2VsZWN0QWxsKCcuJyArIENMQVNTLmNpcmNsZSkuZGF0YSgkJC5saW5lT3JTY2F0dGVyRGF0YS5iaW5kKCQkKSk7XG4gICAgICAgICQkLm1haW5DaXJjbGUuZW50ZXIoKS5hcHBlbmQoXCJjaXJjbGVcIikuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQ2lyY2xlLmJpbmQoJCQpKS5hdHRyKFwiclwiLCAkJC5wb2ludFIuYmluZCgkJCkpLnN0eWxlKFwiZmlsbFwiLCAkJC5jb2xvcik7XG4gICAgICAgICQkLm1haW5DaXJjbGUuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmluaXRpYWxPcGFjaXR5Rm9yQ2lyY2xlLmJpbmQoJCQpKTtcbiAgICAgICAgJCQubWFpbkNpcmNsZS5leGl0KCkucmVtb3ZlKCk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5yZWRyYXdDaXJjbGUgPSBmdW5jdGlvbiAoY3gsIGN5LCB3aXRoVHJhbnNpdGlvbikge1xuICAgICAgICB2YXIgc2VsZWN0ZWRDaXJjbGVzID0gdGhpcy5tYWluLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5zZWxlY3RlZENpcmNsZSk7XG4gICAgICAgIHJldHVybiBbKHdpdGhUcmFuc2l0aW9uID8gdGhpcy5tYWluQ2lyY2xlLnRyYW5zaXRpb24oTWF0aC5yYW5kb20oKS50b1N0cmluZygpKSA6IHRoaXMubWFpbkNpcmNsZSkuc3R5bGUoJ29wYWNpdHknLCB0aGlzLm9wYWNpdHlGb3JDaXJjbGUuYmluZCh0aGlzKSkuc3R5bGUoXCJmaWxsXCIsIHRoaXMuY29sb3IpLmF0dHIoXCJjeFwiLCBjeCkuYXR0cihcImN5XCIsIGN5KSwgKHdpdGhUcmFuc2l0aW9uID8gc2VsZWN0ZWRDaXJjbGVzLnRyYW5zaXRpb24oTWF0aC5yYW5kb20oKS50b1N0cmluZygpKSA6IHNlbGVjdGVkQ2lyY2xlcykuYXR0cihcImN4XCIsIGN4KS5hdHRyKFwiY3lcIiwgY3kpXTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmNpcmNsZVggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC54IHx8IGQueCA9PT0gMCA/IHRoaXMueChkLngpIDogbnVsbDtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnVwZGF0ZUNpcmNsZVkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBsaW5lSW5kaWNlcyxcbiAgICAgICAgICAgIGdldFBvaW50cztcbiAgICAgICAgaWYgKCQkLmNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsaW5lSW5kaWNlcyA9ICQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0xpbmVUeXBlKSwgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRMaW5lUG9pbnRzKGxpbmVJbmRpY2VzKTtcbiAgICAgICAgICAgICQkLmNpcmNsZVkgPSBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRQb2ludHMoZCwgaSlbMF1bMV07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJCQuY2lyY2xlWSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkLmdldFlTY2FsZShkLmlkKShkLnZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldENpcmNsZXMgPSBmdW5jdGlvbiAoaSwgaWQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChpZCA/ICQkLm1haW4uc2VsZWN0QWxsKCcuJyArIENMQVNTLmNpcmNsZXMgKyAkJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCkpIDogJCQubWFpbikuc2VsZWN0QWxsKCcuJyArIENMQVNTLmNpcmNsZSArIChpc1ZhbHVlKGkpID8gJy0nICsgaSA6ICcnKSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5leHBhbmRDaXJjbGVzID0gZnVuY3Rpb24gKGksIGlkLCByZXNldCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgciA9ICQkLnBvaW50RXhwYW5kZWRSLmJpbmQoJCQpO1xuICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICAgICQkLnVuZXhwYW5kQ2lyY2xlcygpO1xuICAgICAgICB9XG4gICAgICAgICQkLmdldENpcmNsZXMoaSwgaWQpLmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQsIHRydWUpLmF0dHIoJ3InLCByKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnVuZXhwYW5kQ2lyY2xlcyA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICByID0gJCQucG9pbnRSLmJpbmQoJCQpO1xuICAgICAgICAkJC5nZXRDaXJjbGVzKGkpLmZpbHRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCQuZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQpO1xuICAgICAgICB9KS5jbGFzc2VkKENMQVNTLkVYUEFOREVELCBmYWxzZSkuYXR0cigncicsIHIpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ucG9pbnRSID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAgICAgcmV0dXJuICQkLmlzU3RlcFR5cGUoZCkgPyAwIDogaXNGdW5jdGlvbihjb25maWcucG9pbnRfcikgPyBjb25maWcucG9pbnRfcihkKSA6IGNvbmZpZy5wb2ludF9yO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ucG9pbnRFeHBhbmRlZFIgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICAgICBpZiAoY29uZmlnLnBvaW50X2ZvY3VzX2V4cGFuZF9lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihjb25maWcucG9pbnRfZm9jdXNfZXhwYW5kX3IpID8gY29uZmlnLnBvaW50X2ZvY3VzX2V4cGFuZF9yKGQpIDogY29uZmlnLnBvaW50X2ZvY3VzX2V4cGFuZF9yID8gY29uZmlnLnBvaW50X2ZvY3VzX2V4cGFuZF9yIDogJCQucG9pbnRSKGQpICogMS43NTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAkJC5wb2ludFIoZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnBvaW50U2VsZWN0UiA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbmZpZy5wb2ludF9zZWxlY3RfcikgPyBjb25maWcucG9pbnRfc2VsZWN0X3IoZCkgOiBjb25maWcucG9pbnRfc2VsZWN0X3IgPyBjb25maWcucG9pbnRfc2VsZWN0X3IgOiAkJC5wb2ludFIoZCkgKiA0O1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaXNXaXRoaW5DaXJjbGUgPSBmdW5jdGlvbiAodGhhdCwgcikge1xuICAgICAgICB2YXIgZDMgPSB0aGlzLmQzLFxuICAgICAgICAgICAgbW91c2UgPSBkMy5tb3VzZSh0aGF0KSxcbiAgICAgICAgICAgIGQzX3RoaXMgPSBkMy5zZWxlY3QodGhhdCksXG4gICAgICAgICAgICBjeCA9ICtkM190aGlzLmF0dHIoXCJjeFwiKSxcbiAgICAgICAgICAgIGN5ID0gK2QzX3RoaXMuYXR0cihcImN5XCIpO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGN4IC0gbW91c2VbMF0sIDIpICsgTWF0aC5wb3coY3kgLSBtb3VzZVsxXSwgMikpIDwgcjtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmlzV2l0aGluU3RlcCA9IGZ1bmN0aW9uICh0aGF0LCB5KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh5IC0gdGhpcy5kMy5tb3VzZSh0aGF0KVsxXSkgPCAzMDtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0Q3VycmVudFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuICAgICAgICByZXR1cm4gY29uZmlnLnNpemVfd2lkdGggPyBjb25maWcuc2l6ZV93aWR0aCA6ICQkLmdldFBhcmVudFdpZHRoKCk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRDdXJyZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgaCA9IGNvbmZpZy5zaXplX2hlaWdodCA/IGNvbmZpZy5zaXplX2hlaWdodCA6ICQkLmdldFBhcmVudEhlaWdodCgpO1xuICAgICAgICByZXR1cm4gaCA+IDAgPyBoIDogMzIwIC8gKCQkLmhhc1R5cGUoJ2dhdWdlJykgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMiA6IDEpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0Q3VycmVudFBhZGRpbmdUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBwYWRkaW5nID0gaXNWYWx1ZShjb25maWcucGFkZGluZ190b3ApID8gY29uZmlnLnBhZGRpbmdfdG9wIDogMDtcbiAgICAgICAgaWYgKCQkLnRpdGxlICYmICQkLnRpdGxlLm5vZGUoKSkge1xuICAgICAgICAgICAgcGFkZGluZyArPSAkJC5nZXRUaXRsZVBhZGRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFkZGluZztcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldEN1cnJlbnRQYWRkaW5nQm90dG9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIHJldHVybiBpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX2JvdHRvbSkgPyBjb25maWcucGFkZGluZ19ib3R0b20gOiAwO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0Q3VycmVudFBhZGRpbmdMZWZ0ID0gZnVuY3Rpb24gKHdpdGhvdXRSZWNvbXB1dGUpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAgICAgaWYgKGlzVmFsdWUoY29uZmlnLnBhZGRpbmdfbGVmdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcucGFkZGluZ19sZWZ0O1xuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAhY29uZmlnLmF4aXNfeF9zaG93IHx8IGNvbmZpZy5heGlzX3hfaW5uZXIgPyAxIDogTWF0aC5tYXgoY2VpbDEwKCQkLmdldEF4aXNXaWR0aEJ5QXhpc0lkKCd4Jywgd2l0aG91dFJlY29tcHV0ZSkpLCA0MCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbmZpZy5heGlzX3lfc2hvdyB8fCBjb25maWcuYXhpc195X2lubmVyKSB7XG4gICAgICAgICAgICAvLyAmJiAhY29uZmlnLmF4aXNfcm90YXRlZFxuICAgICAgICAgICAgcmV0dXJuICQkLmF4aXMuZ2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkuaXNPdXRlciA/IDMwIDogMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjZWlsMTAoJCQuZ2V0QXhpc1dpZHRoQnlBeGlzSWQoJ3knLCB3aXRob3V0UmVjb21wdXRlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBkZWZhdWx0UGFkZGluZyA9IDEwLFxuICAgICAgICAgICAgbGVnZW5kV2lkdGhPblJpZ2h0ID0gJCQuaXNMZWdlbmRSaWdodCA/ICQkLmdldExlZ2VuZFdpZHRoKCkgKyAyMCA6IDA7XG4gICAgICAgIGlmIChpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX3JpZ2h0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5wYWRkaW5nX3JpZ2h0ICsgMTsgLy8gMSBpcyBuZWVkZWQgbm90IHRvIGhpZGUgdGljayBsaW5lXG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmF4aXNfcm90YXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRQYWRkaW5nICsgbGVnZW5kV2lkdGhPblJpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKCFjb25maWcuYXhpc195Ml9zaG93IHx8IGNvbmZpZy5heGlzX3kyX2lubmVyKSB7XG4gICAgICAgICAgICAvLyAmJiAhY29uZmlnLmF4aXNfcm90YXRlZFxuICAgICAgICAgICAgcmV0dXJuIDIgKyBsZWdlbmRXaWR0aE9uUmlnaHQgKyAoJCQuYXhpcy5nZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkuaXNPdXRlciA/IDIwIDogMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2VpbDEwKCQkLmdldEF4aXNXaWR0aEJ5QXhpc0lkKCd5MicpKSArIGxlZ2VuZFdpZHRoT25SaWdodDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRQYXJlbnRSZWN0VmFsdWUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnNlbGVjdENoYXJ0Lm5vZGUoKSxcbiAgICAgICAgICAgIHY7XG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnRhZ05hbWUgIT09ICdCT0RZJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2tleV07XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3dpZHRoJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBJRSBpbiBjZXJ0YWluIGNhc2VzIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIGNhdXNlIGFuIFwidW5zcGVjaWZpZWQgZXJyb3JcIlxuICAgICAgICAgICAgICAgICAgICB2ID0gcGFyZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldFBhcmVudFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJlbnRSZWN0VmFsdWUoJ3dpZHRoJyk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRQYXJlbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoID0gdGhpcy5zZWxlY3RDaGFydC5zdHlsZSgnaGVpZ2h0Jyk7XG4gICAgICAgIHJldHVybiBoLmluZGV4T2YoJ3B4JykgPiAwID8gK2gucmVwbGFjZSgncHgnLCAnJykgOiAwO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRTdmdMZWZ0ID0gZnVuY3Rpb24gKHdpdGhvdXRSZWNvbXB1dGUpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIGhhc0xlZnRBeGlzUmVjdCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgfHwgIWNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgIWNvbmZpZy5heGlzX3lfaW5uZXIsXG4gICAgICAgICAgICBsZWZ0QXhpc0NsYXNzID0gY29uZmlnLmF4aXNfcm90YXRlZCA/IENMQVNTLmF4aXNYIDogQ0xBU1MuYXhpc1ksXG4gICAgICAgICAgICBsZWZ0QXhpcyA9ICQkLm1haW4uc2VsZWN0KCcuJyArIGxlZnRBeGlzQ2xhc3MpLm5vZGUoKSxcbiAgICAgICAgICAgIHN2Z1JlY3QgPSBsZWZ0QXhpcyAmJiBoYXNMZWZ0QXhpc1JlY3QgPyBsZWZ0QXhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHsgcmlnaHQ6IDAgfSxcbiAgICAgICAgICAgIGNoYXJ0UmVjdCA9ICQkLnNlbGVjdENoYXJ0Lm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIGhhc0FyYyA9ICQkLmhhc0FyY1R5cGUoKSxcbiAgICAgICAgICAgIHN2Z0xlZnQgPSBzdmdSZWN0LnJpZ2h0IC0gY2hhcnRSZWN0LmxlZnQgLSAoaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCh3aXRob3V0UmVjb21wdXRlKSk7XG4gICAgICAgIHJldHVybiBzdmdMZWZ0ID4gMCA/IHN2Z0xlZnQgOiAwO1xuICAgIH07XG5cbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRBeGlzV2lkdGhCeUF4aXNJZCA9IGZ1bmN0aW9uIChpZCwgd2l0aG91dFJlY29tcHV0ZSkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgcG9zaXRpb24gPSAkJC5heGlzLmdldExhYmVsUG9zaXRpb25CeUlkKGlkKTtcbiAgICAgICAgcmV0dXJuICQkLmF4aXMuZ2V0TWF4VGlja1dpZHRoKGlkLCB3aXRob3V0UmVjb21wdXRlKSArIChwb3NpdGlvbi5pc0lubmVyID8gMjAgOiA0MCk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRIb3Jpem9udGFsQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChheGlzSWQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIGggPSAzMDtcbiAgICAgICAgaWYgKGF4aXNJZCA9PT0gJ3gnICYmICFjb25maWcuYXhpc194X3Nob3cpIHtcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzSWQgPT09ICd4JyAmJiBjb25maWcuYXhpc194X2hlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5heGlzX3hfaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzSWQgPT09ICd5JyAmJiAhY29uZmlnLmF4aXNfeV9zaG93KSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLmxlZ2VuZF9zaG93ICYmICEkJC5pc0xlZ2VuZFJpZ2h0ICYmICEkJC5pc0xlZ2VuZEluc2V0ID8gMTAgOiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzSWQgPT09ICd5MicgJiYgIWNvbmZpZy5heGlzX3kyX3Nob3cpIHtcbiAgICAgICAgICAgIHJldHVybiAkJC5yb3RhdGVkX3BhZGRpbmdfdG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSB4IGF4aXMgaGVpZ2h0IHdoZW4gdGljayByb3RhdGVkXG4gICAgICAgIGlmIChheGlzSWQgPT09ICd4JyAmJiAhY29uZmlnLmF4aXNfcm90YXRlZCAmJiBjb25maWcuYXhpc194X3RpY2tfcm90YXRlKSB7XG4gICAgICAgICAgICBoID0gMzAgKyAkJC5heGlzLmdldE1heFRpY2tXaWR0aChheGlzSWQpICogTWF0aC5jb3MoTWF0aC5QSSAqICg5MCAtIGNvbmZpZy5heGlzX3hfdGlja19yb3RhdGUpIC8gMTgwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgeSBheGlzIGhlaWdodCB3aGVuIHRpY2sgcm90YXRlZFxuICAgICAgICBpZiAoYXhpc0lkID09PSAneScgJiYgY29uZmlnLmF4aXNfcm90YXRlZCAmJiBjb25maWcuYXhpc195X3RpY2tfcm90YXRlKSB7XG4gICAgICAgICAgICBoID0gMzAgKyAkJC5heGlzLmdldE1heFRpY2tXaWR0aChheGlzSWQpICogTWF0aC5jb3MoTWF0aC5QSSAqICg5MCAtIGNvbmZpZy5heGlzX3lfdGlja19yb3RhdGUpIC8gMTgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaCArICgkJC5heGlzLmdldExhYmVsUG9zaXRpb25CeUlkKGF4aXNJZCkuaXNJbm5lciA/IDAgOiAxMCkgKyAoYXhpc0lkID09PSAneTInID8gLTEwIDogMCk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldEV2ZW50UmVjdFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgdGhpcy54QXhpcy50aWNrSW50ZXJ2YWwoKSk7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmluaXRCcnVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGQzID0gJCQuZDM7XG4gICAgICAgICQkLmJydXNoID0gZDMuc3ZnLmJydXNoKCkub24oXCJicnVzaFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkJC5yZWRyYXdGb3JCcnVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgJCQuYnJ1c2gudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCQkLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAkJC5jb250ZXh0LnNlbGVjdCgnLicgKyBDTEFTUy5icnVzaCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAkJC5icnVzaC5zY2FsZSA9IGZ1bmN0aW9uIChzY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQgPyB0aGlzLnkoc2NhbGUpIDogdGhpcy54KHNjYWxlKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmluaXRTdWJjaGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIGNvbnRleHQgPSAkJC5jb250ZXh0ID0gJCQuc3ZnLmFwcGVuZChcImdcIikuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoJ2NvbnRleHQnKSksXG4gICAgICAgICAgICB2aXNpYmlsaXR5ID0gY29uZmlnLnN1YmNoYXJ0X3Nob3cgPyAndmlzaWJsZScgOiAnaGlkZGVuJztcblxuICAgICAgICBjb250ZXh0LnN0eWxlKCd2aXNpYmlsaXR5JywgdmlzaWJpbGl0eSk7XG5cbiAgICAgICAgLy8gRGVmaW5lIGcgZm9yIGNoYXJ0IGFyZWFcbiAgICAgICAgY29udGV4dC5hcHBlbmQoJ2cnKS5hdHRyKFwiY2xpcC1wYXRoXCIsICQkLmNsaXBQYXRoRm9yU3ViY2hhcnQpLmF0dHIoJ2NsYXNzJywgQ0xBU1MuY2hhcnQpO1xuXG4gICAgICAgIC8vIERlZmluZSBnIGZvciBiYXIgY2hhcnQgYXJlYVxuICAgICAgICBjb250ZXh0LnNlbGVjdCgnLicgKyBDTEFTUy5jaGFydCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRCYXJzKTtcblxuICAgICAgICAvLyBEZWZpbmUgZyBmb3IgbGluZSBjaGFydCBhcmVhXG4gICAgICAgIGNvbnRleHQuc2VsZWN0KCcuJyArIENMQVNTLmNoYXJ0KS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydExpbmVzKTtcblxuICAgICAgICAvLyBBZGQgZXh0ZW50IHJlY3QgZm9yIEJydXNoXG4gICAgICAgIGNvbnRleHQuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xpcC1wYXRoXCIsICQkLmNsaXBQYXRoKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuYnJ1c2gpLmNhbGwoJCQuYnJ1c2gpO1xuXG4gICAgICAgIC8vIEFUVEVOVElPTjogVGhpcyBtdXN0IGJlIGNhbGxlZCBBRlRFUiBjaGFydCBhZGRlZFxuICAgICAgICAvLyBBZGQgQXhpc1xuICAgICAgICAkJC5heGVzLnN1YnggPSBjb250ZXh0LmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIENMQVNTLmF4aXNYKS5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZSgnc3VieCcpKS5hdHRyKFwiY2xpcC1wYXRoXCIsIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcIlwiIDogJCQuY2xpcFBhdGhGb3JYQXhpcykuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZy5zdWJjaGFydF9heGlzX3hfc2hvdyA/IHZpc2liaWxpdHkgOiAnaGlkZGVuJyk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi51cGRhdGVUYXJnZXRzRm9yU3ViY2hhcnQgPSBmdW5jdGlvbiAodGFyZ2V0cykge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29udGV4dCA9ICQkLmNvbnRleHQsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBjb250ZXh0TGluZUVudGVyLFxuICAgICAgICAgICAgY29udGV4dExpbmVVcGRhdGUsXG4gICAgICAgICAgICBjb250ZXh0QmFyRW50ZXIsXG4gICAgICAgICAgICBjb250ZXh0QmFyVXBkYXRlLFxuICAgICAgICAgICAgY2xhc3NDaGFydEJhciA9ICQkLmNsYXNzQ2hhcnRCYXIuYmluZCgkJCksXG4gICAgICAgICAgICBjbGFzc0JhcnMgPSAkJC5jbGFzc0JhcnMuYmluZCgkJCksXG4gICAgICAgICAgICBjbGFzc0NoYXJ0TGluZSA9ICQkLmNsYXNzQ2hhcnRMaW5lLmJpbmQoJCQpLFxuICAgICAgICAgICAgY2xhc3NMaW5lcyA9ICQkLmNsYXNzTGluZXMuYmluZCgkJCksXG4gICAgICAgICAgICBjbGFzc0FyZWFzID0gJCQuY2xhc3NBcmVhcy5iaW5kKCQkKTtcblxuICAgICAgICBpZiAoY29uZmlnLnN1YmNoYXJ0X3Nob3cpIHtcbiAgICAgICAgICAgIC8vLS0gQmFyIC0tLy9cbiAgICAgICAgICAgIGNvbnRleHRCYXJVcGRhdGUgPSBjb250ZXh0LnNlbGVjdCgnLicgKyBDTEFTUy5jaGFydEJhcnMpLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5jaGFydEJhcikuZGF0YSh0YXJnZXRzKS5hdHRyKCdjbGFzcycsIGNsYXNzQ2hhcnRCYXIpO1xuICAgICAgICAgICAgY29udGV4dEJhckVudGVyID0gY29udGV4dEJhclVwZGF0ZS5lbnRlcigpLmFwcGVuZCgnZycpLnN0eWxlKCdvcGFjaXR5JywgMCkuYXR0cignY2xhc3MnLCBjbGFzc0NoYXJ0QmFyKTtcbiAgICAgICAgICAgIC8vIEJhcnMgZm9yIGVhY2ggZGF0YVxuICAgICAgICAgICAgY29udGV4dEJhckVudGVyLmFwcGVuZCgnZycpLmF0dHIoXCJjbGFzc1wiLCBjbGFzc0JhcnMpO1xuXG4gICAgICAgICAgICAvLy0tIExpbmUgLS0vL1xuICAgICAgICAgICAgY29udGV4dExpbmVVcGRhdGUgPSBjb250ZXh0LnNlbGVjdCgnLicgKyBDTEFTUy5jaGFydExpbmVzKS5zZWxlY3RBbGwoJy4nICsgQ0xBU1MuY2hhcnRMaW5lKS5kYXRhKHRhcmdldHMpLmF0dHIoJ2NsYXNzJywgY2xhc3NDaGFydExpbmUpO1xuICAgICAgICAgICAgY29udGV4dExpbmVFbnRlciA9IGNvbnRleHRMaW5lVXBkYXRlLmVudGVyKCkuYXBwZW5kKCdnJykuc3R5bGUoJ29wYWNpdHknLCAwKS5hdHRyKCdjbGFzcycsIGNsYXNzQ2hhcnRMaW5lKTtcbiAgICAgICAgICAgIC8vIExpbmVzIGZvciBlYWNoIGRhdGFcbiAgICAgICAgICAgIGNvbnRleHRMaW5lRW50ZXIuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgY2xhc3NMaW5lcyk7XG4gICAgICAgICAgICAvLyBBcmVhXG4gICAgICAgICAgICBjb250ZXh0TGluZUVudGVyLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGNsYXNzQXJlYXMpO1xuXG4gICAgICAgICAgICAvLy0tIEJydXNoIC0tLy9cbiAgICAgICAgICAgIGNvbnRleHQuc2VsZWN0QWxsKCcuJyArIENMQVNTLmJydXNoICsgJyByZWN0JykuYXR0cihjb25maWcuYXhpc19yb3RhdGVkID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/ICQkLndpZHRoMiA6ICQkLmhlaWdodDIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi51cGRhdGVCYXJGb3JTdWJjaGFydCA9IGZ1bmN0aW9uIChkdXJhdGlvbkZvckV4aXQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgJCQuY29udGV4dEJhciA9ICQkLmNvbnRleHQuc2VsZWN0QWxsKCcuJyArIENMQVNTLmJhcnMpLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5iYXIpLmRhdGEoJCQuYmFyRGF0YS5iaW5kKCQkKSk7XG4gICAgICAgICQkLmNvbnRleHRCYXIuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKS5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NCYXIuYmluZCgkJCkpLnN0eWxlKFwic3Ryb2tlXCIsICdub25lJykuc3R5bGUoXCJmaWxsXCIsICQkLmNvbG9yKTtcbiAgICAgICAgJCQuY29udGV4dEJhci5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpO1xuICAgICAgICAkJC5jb250ZXh0QmFyLmV4aXQoKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KS5zdHlsZSgnb3BhY2l0eScsIDApLnJlbW92ZSgpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ucmVkcmF3QmFyRm9yU3ViY2hhcnQgPSBmdW5jdGlvbiAoZHJhd0Jhck9uU3ViLCB3aXRoVHJhbnNpdGlvbiwgZHVyYXRpb24pIHtcbiAgICAgICAgKHdpdGhUcmFuc2l0aW9uID8gdGhpcy5jb250ZXh0QmFyLnRyYW5zaXRpb24oTWF0aC5yYW5kb20oKS50b1N0cmluZygpKS5kdXJhdGlvbihkdXJhdGlvbikgOiB0aGlzLmNvbnRleHRCYXIpLmF0dHIoJ2QnLCBkcmF3QmFyT25TdWIpLnN0eWxlKCdvcGFjaXR5JywgMSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi51cGRhdGVMaW5lRm9yU3ViY2hhcnQgPSBmdW5jdGlvbiAoZHVyYXRpb25Gb3JFeGl0KSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgICQkLmNvbnRleHRMaW5lID0gJCQuY29udGV4dC5zZWxlY3RBbGwoJy4nICsgQ0xBU1MubGluZXMpLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5saW5lKS5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcbiAgICAgICAgJCQuY29udGV4dExpbmUuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdjbGFzcycsICQkLmNsYXNzTGluZS5iaW5kKCQkKSkuc3R5bGUoJ3N0cm9rZScsICQkLmNvbG9yKTtcbiAgICAgICAgJCQuY29udGV4dExpbmUuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmluaXRpYWxPcGFjaXR5LmJpbmQoJCQpKTtcbiAgICAgICAgJCQuY29udGV4dExpbmUuZXhpdCgpLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpLnN0eWxlKCdvcGFjaXR5JywgMCkucmVtb3ZlKCk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5yZWRyYXdMaW5lRm9yU3ViY2hhcnQgPSBmdW5jdGlvbiAoZHJhd0xpbmVPblN1Yiwgd2l0aFRyYW5zaXRpb24sIGR1cmF0aW9uKSB7XG4gICAgICAgICh3aXRoVHJhbnNpdGlvbiA/IHRoaXMuY29udGV4dExpbmUudHJhbnNpdGlvbihNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkpLmR1cmF0aW9uKGR1cmF0aW9uKSA6IHRoaXMuY29udGV4dExpbmUpLmF0dHIoXCJkXCIsIGRyYXdMaW5lT25TdWIpLnN0eWxlKCdvcGFjaXR5JywgMSk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi51cGRhdGVBcmVhRm9yU3ViY2hhcnQgPSBmdW5jdGlvbiAoZHVyYXRpb25Gb3JFeGl0KSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBkMyA9ICQkLmQzO1xuICAgICAgICAkJC5jb250ZXh0QXJlYSA9ICQkLmNvbnRleHQuc2VsZWN0QWxsKCcuJyArIENMQVNTLmFyZWFzKS5zZWxlY3RBbGwoJy4nICsgQ0xBU1MuYXJlYSkuZGF0YSgkJC5saW5lRGF0YS5iaW5kKCQkKSk7XG4gICAgICAgICQkLmNvbnRleHRBcmVhLmVudGVyKCkuYXBwZW5kKCdwYXRoJykuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJlYS5iaW5kKCQkKSkuc3R5bGUoXCJmaWxsXCIsICQkLmNvbG9yKS5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCQub3JnQXJlYU9wYWNpdHkgPSArZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdvcGFjaXR5Jyk7cmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgICAgICAkJC5jb250ZXh0QXJlYS5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgICAgICQkLmNvbnRleHRBcmVhLmV4aXQoKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KS5zdHlsZSgnb3BhY2l0eScsIDApLnJlbW92ZSgpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ucmVkcmF3QXJlYUZvclN1YmNoYXJ0ID0gZnVuY3Rpb24gKGRyYXdBcmVhT25TdWIsIHdpdGhUcmFuc2l0aW9uLCBkdXJhdGlvbikge1xuICAgICAgICAod2l0aFRyYW5zaXRpb24gPyB0aGlzLmNvbnRleHRBcmVhLnRyYW5zaXRpb24oTWF0aC5yYW5kb20oKS50b1N0cmluZygpKS5kdXJhdGlvbihkdXJhdGlvbikgOiB0aGlzLmNvbnRleHRBcmVhKS5hdHRyKFwiZFwiLCBkcmF3QXJlYU9uU3ViKS5zdHlsZShcImZpbGxcIiwgdGhpcy5jb2xvcikuc3R5bGUoXCJvcGFjaXR5XCIsIHRoaXMub3JnQXJlYU9wYWNpdHkpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ucmVkcmF3U3ViY2hhcnQgPSBmdW5jdGlvbiAod2l0aFN1YmNoYXJ0LCB0cmFuc2l0aW9ucywgZHVyYXRpb24sIGR1cmF0aW9uRm9yRXhpdCwgYXJlYUluZGljZXMsIGJhckluZGljZXMsIGxpbmVJbmRpY2VzKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBkMyA9ICQkLmQzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgZHJhd0FyZWFPblN1YixcbiAgICAgICAgICAgIGRyYXdCYXJPblN1YixcbiAgICAgICAgICAgIGRyYXdMaW5lT25TdWI7XG5cbiAgICAgICAgJCQuY29udGV4dC5zdHlsZSgndmlzaWJpbGl0eScsIGNvbmZpZy5zdWJjaGFydF9zaG93ID8gJ3Zpc2libGUnIDogJ2hpZGRlbicpO1xuXG4gICAgICAgIC8vIHN1YmNoYXJ0XG4gICAgICAgIGlmIChjb25maWcuc3ViY2hhcnRfc2hvdykge1xuICAgICAgICAgICAgLy8gcmVmbGVjdCBtYWluIGNoYXJ0IHRvIGV4dGVudCBvbiBzdWJjaGFydCBpZiB6b29tZWRcbiAgICAgICAgICAgIGlmIChkMy5ldmVudCAmJiBkMy5ldmVudC50eXBlID09PSAnem9vbScpIHtcbiAgICAgICAgICAgICAgICAkJC5icnVzaC5leHRlbnQoJCQueC5vcmdEb21haW4oKSkudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1cGRhdGUgc3ViY2hhcnQgZWxlbWVudHMgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAod2l0aFN1YmNoYXJ0KSB7XG5cbiAgICAgICAgICAgICAgICAvLyBleHRlbnQgcmVjdFxuICAgICAgICAgICAgICAgIGlmICghJCQuYnJ1c2guZW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAkJC5icnVzaC5leHRlbnQoJCQueC5vcmdEb21haW4oKSkudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNldHVwIGRyYXdlciAtIE1FTU86IHRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgYXhpcyB1cGRhdGVkXG4gICAgICAgICAgICAgICAgZHJhd0FyZWFPblN1YiA9ICQkLmdlbmVyYXRlRHJhd0FyZWEoYXJlYUluZGljZXMsIHRydWUpO1xuICAgICAgICAgICAgICAgIGRyYXdCYXJPblN1YiA9ICQkLmdlbmVyYXRlRHJhd0JhcihiYXJJbmRpY2VzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkcmF3TGluZU9uU3ViID0gJCQuZ2VuZXJhdGVEcmF3TGluZShsaW5lSW5kaWNlcywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAkJC51cGRhdGVCYXJGb3JTdWJjaGFydChkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgJCQudXBkYXRlTGluZUZvclN1YmNoYXJ0KGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAkJC51cGRhdGVBcmVhRm9yU3ViY2hhcnQoZHVyYXRpb24pO1xuXG4gICAgICAgICAgICAgICAgJCQucmVkcmF3QmFyRm9yU3ViY2hhcnQoZHJhd0Jhck9uU3ViLCBkdXJhdGlvbiwgZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICQkLnJlZHJhd0xpbmVGb3JTdWJjaGFydChkcmF3TGluZU9uU3ViLCBkdXJhdGlvbiwgZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICQkLnJlZHJhd0FyZWFGb3JTdWJjaGFydChkcmF3QXJlYU9uU3ViLCBkdXJhdGlvbiwgZHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5yZWRyYXdGb3JCcnVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIHggPSAkJC54O1xuICAgICAgICAkJC5yZWRyYXcoe1xuICAgICAgICAgICAgd2l0aFRyYW5zaXRpb246IGZhbHNlLFxuICAgICAgICAgICAgd2l0aFk6ICQkLmNvbmZpZy56b29tX3Jlc2NhbGUsXG4gICAgICAgICAgICB3aXRoU3ViY2hhcnQ6IGZhbHNlLFxuICAgICAgICAgICAgd2l0aFVwZGF0ZVhEb21haW46IHRydWUsXG4gICAgICAgICAgICB3aXRoRGltZW5zaW9uOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgJCQuY29uZmlnLnN1YmNoYXJ0X29uYnJ1c2guY2FsbCgkJC5hcGksIHgub3JnRG9tYWluKCkpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4udHJhbnNmb3JtQ29udGV4dCA9IGZ1bmN0aW9uICh3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIHN1YlhBeGlzO1xuICAgICAgICBpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1N1YlgpIHtcbiAgICAgICAgICAgIHN1YlhBeGlzID0gdHJhbnNpdGlvbnMuYXhpc1N1Ylg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJYQXhpcyA9ICQkLmNvbnRleHQuc2VsZWN0KCcuJyArIENMQVNTLmF4aXNYKTtcbiAgICAgICAgICAgIGlmICh3aXRoVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIHN1YlhBeGlzID0gc3ViWEF4aXMudHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICQkLmNvbnRleHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoJ2NvbnRleHQnKSk7XG4gICAgICAgIHN1YlhBeGlzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKCdzdWJ4JykpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0RGVmYXVsdEV4dGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIGV4dGVudCA9IGlzRnVuY3Rpb24oY29uZmlnLmF4aXNfeF9leHRlbnQpID8gY29uZmlnLmF4aXNfeF9leHRlbnQoJCQuZ2V0WERvbWFpbigkJC5kYXRhLnRhcmdldHMpKSA6IGNvbmZpZy5heGlzX3hfZXh0ZW50O1xuICAgICAgICBpZiAoJCQuaXNUaW1lU2VyaWVzKCkpIHtcbiAgICAgICAgICAgIGV4dGVudCA9IFskJC5wYXJzZURhdGUoZXh0ZW50WzBdKSwgJCQucGFyc2VEYXRlKGV4dGVudFsxXSldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlbnQ7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmluaXRUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICAkJC5tYWluLnNlbGVjdCgnLicgKyBDTEFTUy5jaGFydCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRUZXh0cyk7XG4gICAgICAgICQkLm1haW5UZXh0ID0gJCQuZDMuc2VsZWN0QWxsKFtdKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnVwZGF0ZVRhcmdldHNGb3JUZXh0ID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIG1haW5UZXh0VXBkYXRlLFxuICAgICAgICAgICAgbWFpblRleHRFbnRlcixcbiAgICAgICAgICAgIGNsYXNzQ2hhcnRUZXh0ID0gJCQuY2xhc3NDaGFydFRleHQuYmluZCgkJCksXG4gICAgICAgICAgICBjbGFzc1RleHRzID0gJCQuY2xhc3NUZXh0cy5iaW5kKCQkKSxcbiAgICAgICAgICAgIGNsYXNzRm9jdXMgPSAkJC5jbGFzc0ZvY3VzLmJpbmQoJCQpO1xuICAgICAgICBtYWluVGV4dFVwZGF0ZSA9ICQkLm1haW4uc2VsZWN0KCcuJyArIENMQVNTLmNoYXJ0VGV4dHMpLnNlbGVjdEFsbCgnLicgKyBDTEFTUy5jaGFydFRleHQpLmRhdGEodGFyZ2V0cykuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzQ2hhcnRUZXh0KGQpICsgY2xhc3NGb2N1cyhkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1haW5UZXh0RW50ZXIgPSBtYWluVGV4dFVwZGF0ZS5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgY2xhc3NDaGFydFRleHQpLnN0eWxlKCdvcGFjaXR5JywgMCkuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG4gICAgICAgIG1haW5UZXh0RW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCBjbGFzc1RleHRzKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnVwZGF0ZVRleHQgPSBmdW5jdGlvbiAoZHVyYXRpb25Gb3JFeGl0KSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBiYXJPckxpbmVEYXRhID0gJCQuYmFyT3JMaW5lRGF0YS5iaW5kKCQkKSxcbiAgICAgICAgICAgIGNsYXNzVGV4dCA9ICQkLmNsYXNzVGV4dC5iaW5kKCQkKTtcbiAgICAgICAgJCQubWFpblRleHQgPSAkJC5tYWluLnNlbGVjdEFsbCgnLicgKyBDTEFTUy50ZXh0cykuc2VsZWN0QWxsKCcuJyArIENMQVNTLnRleHQpLmRhdGEoYmFyT3JMaW5lRGF0YSk7XG4gICAgICAgICQkLm1haW5UZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JykuYXR0cihcImNsYXNzXCIsIGNsYXNzVGV4dCkuYXR0cigndGV4dC1hbmNob3InLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBkLnZhbHVlIDwgMCA/ICdlbmQnIDogJ3N0YXJ0JyA6ICdtaWRkbGUnO1xuICAgICAgICB9KS5zdHlsZShcInN0cm9rZVwiLCAnbm9uZScpLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuICQkLmNvbG9yKGQpO1xuICAgICAgICB9KS5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCAwKTtcbiAgICAgICAgJCQubWFpblRleHQudGV4dChmdW5jdGlvbiAoZCwgaSwgaikge1xuICAgICAgICAgICAgcmV0dXJuICQkLmRhdGFMYWJlbEZvcm1hdChkLmlkKShkLnZhbHVlLCBkLmlkLCBpLCBqKTtcbiAgICAgICAgfSk7XG4gICAgICAgICQkLm1haW5UZXh0LmV4aXQoKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KS5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMCkucmVtb3ZlKCk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5yZWRyYXdUZXh0ID0gZnVuY3Rpb24gKHhGb3JUZXh0LCB5Rm9yVGV4dCwgZm9yRmxvdywgd2l0aFRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFsod2l0aFRyYW5zaXRpb24gPyB0aGlzLm1haW5UZXh0LnRyYW5zaXRpb24oKSA6IHRoaXMubWFpblRleHQpLmF0dHIoJ3gnLCB4Rm9yVGV4dCkuYXR0cigneScsIHlGb3JUZXh0KS5zdHlsZShcImZpbGxcIiwgdGhpcy5jb2xvcikuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgZm9yRmxvdyA/IDAgOiB0aGlzLm9wYWNpdHlGb3JUZXh0LmJpbmQodGhpcykpXTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldFRleHRSZWN0ID0gZnVuY3Rpb24gKHRleHQsIGNscywgZWxlbWVudCkge1xuICAgICAgICB2YXIgZHVtbXkgPSB0aGlzLmQzLnNlbGVjdCgnYm9keScpLmFwcGVuZCgnZGl2JykuY2xhc3NlZCgnYzMnLCB0cnVlKSxcbiAgICAgICAgICAgIHN2ZyA9IGR1bW15LmFwcGVuZChcInN2Z1wiKS5zdHlsZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKS5zdHlsZSgncG9zaXRpb24nLCAnZml4ZWQnKS5zdHlsZSgndG9wJywgMCkuc3R5bGUoJ2xlZnQnLCAwKSxcbiAgICAgICAgICAgIGZvbnQgPSB0aGlzLmQzLnNlbGVjdChlbGVtZW50KS5zdHlsZSgnZm9udCcpLFxuICAgICAgICAgICAgcmVjdDtcbiAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLmR1bW15JykuZGF0YShbdGV4dF0pLmVudGVyKCkuYXBwZW5kKCd0ZXh0JykuY2xhc3NlZChjbHMgPyBjbHMgOiBcIlwiLCB0cnVlKS5zdHlsZSgnZm9udCcsIGZvbnQpLnRleHQodGV4dCkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGR1bW15LnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdlbmVyYXRlWFlGb3JUZXh0ID0gZnVuY3Rpb24gKGFyZWFJbmRpY2VzLCBiYXJJbmRpY2VzLCBsaW5lSW5kaWNlcywgZm9yWCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgZ2V0QXJlYVBvaW50cyA9ICQkLmdlbmVyYXRlR2V0QXJlYVBvaW50cyhhcmVhSW5kaWNlcywgZmFsc2UpLFxuICAgICAgICAgICAgZ2V0QmFyUG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRCYXJQb2ludHMoYmFySW5kaWNlcywgZmFsc2UpLFxuICAgICAgICAgICAgZ2V0TGluZVBvaW50cyA9ICQkLmdlbmVyYXRlR2V0TGluZVBvaW50cyhsaW5lSW5kaWNlcywgZmFsc2UpLFxuICAgICAgICAgICAgZ2V0dGVyID0gZm9yWCA/ICQkLmdldFhGb3JUZXh0IDogJCQuZ2V0WUZvclRleHQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgdmFyIGdldFBvaW50cyA9ICQkLmlzQXJlYVR5cGUoZCkgPyBnZXRBcmVhUG9pbnRzIDogJCQuaXNCYXJUeXBlKGQpID8gZ2V0QmFyUG9pbnRzIDogZ2V0TGluZVBvaW50cztcbiAgICAgICAgICAgIHJldHVybiBnZXR0ZXIuY2FsbCgkJCwgZ2V0UG9pbnRzKGQsIGkpLCBkLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmdldFhGb3JUZXh0ID0gZnVuY3Rpb24gKHBvaW50cywgZCwgdGV4dEVsZW1lbnQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGJveCA9IHRleHRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgeFBvcyxcbiAgICAgICAgICAgIHBhZGRpbmc7XG4gICAgICAgIGlmICgkJC5jb25maWcuYXhpc19yb3RhdGVkKSB7XG4gICAgICAgICAgICBwYWRkaW5nID0gJCQuaXNCYXJUeXBlKGQpID8gNCA6IDY7XG4gICAgICAgICAgICB4UG9zID0gcG9pbnRzWzJdWzFdICsgcGFkZGluZyAqIChkLnZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4UG9zID0gJCQuaGFzVHlwZSgnYmFyJykgPyAocG9pbnRzWzJdWzBdICsgcG9pbnRzWzBdWzBdKSAvIDIgOiBwb2ludHNbMF1bMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2hvdyBsYWJlbHMgcmVnYXJkbGVzcyBvZiB0aGUgZG9tYWluIGlmIHZhbHVlIGlzIG51bGxcbiAgICAgICAgaWYgKGQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh4UG9zID4gJCQud2lkdGgpIHtcbiAgICAgICAgICAgICAgICB4UG9zID0gJCQud2lkdGggLSBib3gud2lkdGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHhQb3MgPCAwKSB7XG4gICAgICAgICAgICAgICAgeFBvcyA9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhQb3M7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRZRm9yVGV4dCA9IGZ1bmN0aW9uIChwb2ludHMsIGQsIHRleHRFbGVtZW50KSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBib3ggPSB0ZXh0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIHlQb3M7XG4gICAgICAgIGlmICgkJC5jb25maWcuYXhpc19yb3RhdGVkKSB7XG4gICAgICAgICAgICB5UG9zID0gKHBvaW50c1swXVswXSArIHBvaW50c1syXVswXSArIGJveC5oZWlnaHQgKiAwLjYpIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlQb3MgPSBwb2ludHNbMl1bMV07XG4gICAgICAgICAgICBpZiAoZC52YWx1ZSA8IDAgfHwgZC52YWx1ZSA9PT0gMCAmJiAhJCQuaGFzUG9zaXRpdmVWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHlQb3MgKz0gYm94LmhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoJCQuaXNCYXJUeXBlKGQpICYmICQkLmlzU2FmYXJpKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeVBvcyAtPSAzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoISQkLmlzQmFyVHlwZShkKSAmJiAkJC5pc0Nocm9tZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlQb3MgKz0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHlQb3MgKz0gJCQuaXNCYXJUeXBlKGQpID8gLTMgOiAtNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzaG93IGxhYmVscyByZWdhcmRsZXNzIG9mIHRoZSBkb21haW4gaWYgdmFsdWUgaXMgbnVsbFxuICAgICAgICBpZiAoZC52YWx1ZSA9PT0gbnVsbCAmJiAhJCQuY29uZmlnLmF4aXNfcm90YXRlZCkge1xuICAgICAgICAgICAgaWYgKHlQb3MgPCBib3guaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgeVBvcyA9IGJveC5oZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHlQb3MgPiB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIHlQb3MgPSB0aGlzLmhlaWdodCAtIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHlQb3M7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmluaXRUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgJCQudGl0bGUgPSAkJC5zdmcuYXBwZW5kKFwidGV4dFwiKS50ZXh0KCQkLmNvbmZpZy50aXRsZV90ZXh0KS5hdHRyKFwiY2xhc3NcIiwgJCQuQ0xBU1MudGl0bGUpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ucmVkcmF3VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXM7XG4gICAgICAgICQkLnRpdGxlLmF0dHIoXCJ4XCIsICQkLnhGb3JUaXRsZS5iaW5kKCQkKSkuYXR0cihcInlcIiwgJCQueUZvclRpdGxlLmJpbmQoJCQpKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnhGb3JUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZyxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gY29uZmlnLnRpdGxlX3Bvc2l0aW9uIHx8ICdsZWZ0JyxcbiAgICAgICAgICAgIHg7XG4gICAgICAgIGlmIChwb3NpdGlvbi5pbmRleE9mKCdyaWdodCcpID49IDApIHtcbiAgICAgICAgICAgIHggPSAkJC5jdXJyZW50V2lkdGggLSAkJC5nZXRUZXh0UmVjdCgkJC50aXRsZS5ub2RlKCkudGV4dENvbnRlbnQsICQkLkNMQVNTLnRpdGxlLCAkJC50aXRsZS5ub2RlKCkpLndpZHRoIC0gY29uZmlnLnRpdGxlX3BhZGRpbmcucmlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24uaW5kZXhPZignY2VudGVyJykgPj0gMCkge1xuICAgICAgICAgICAgeCA9ICgkJC5jdXJyZW50V2lkdGggLSAkJC5nZXRUZXh0UmVjdCgkJC50aXRsZS5ub2RlKCkudGV4dENvbnRlbnQsICQkLkNMQVNTLnRpdGxlLCAkJC50aXRsZS5ub2RlKCkpLndpZHRoKSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBsZWZ0XG4gICAgICAgICAgICB4ID0gY29uZmlnLnRpdGxlX3BhZGRpbmcubGVmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnlGb3JUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcztcbiAgICAgICAgcmV0dXJuICQkLmNvbmZpZy50aXRsZV9wYWRkaW5nLnRvcCArICQkLmdldFRleHRSZWN0KCQkLnRpdGxlLm5vZGUoKS50ZXh0Q29udGVudCwgJCQuQ0xBU1MudGl0bGUsICQkLnRpdGxlLm5vZGUoKSkuaGVpZ2h0O1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0VGl0bGVQYWRkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gJCQueUZvclRpdGxlKCkgKyAkJC5jb25maWcudGl0bGVfcGFkZGluZy5ib3R0b207XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmluaXRUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgJCQudG9vbHRpcCA9ICQkLnNlbGVjdENoYXJ0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKS5hcHBlbmQoXCJkaXZcIikuYXR0cignY2xhc3MnLCBDTEFTUy50b29sdGlwQ29udGFpbmVyKS5zdHlsZShcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIikuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIikuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgLy8gU2hvdyB0b29sdGlwIGlmIG5lZWRlZFxuICAgICAgICBpZiAoY29uZmlnLnRvb2x0aXBfaW5pdF9zaG93KSB7XG4gICAgICAgICAgICBpZiAoJCQuaXNUaW1lU2VyaWVzKCkgJiYgaXNTdHJpbmcoY29uZmlnLnRvb2x0aXBfaW5pdF94KSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy50b29sdGlwX2luaXRfeCA9ICQkLnBhcnNlRGF0ZShjb25maWcudG9vbHRpcF9pbml0X3gpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzW2ldLnggLSBjb25maWcudG9vbHRpcF9pbml0X3ggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbmZpZy50b29sdGlwX2luaXRfeCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkJC50b29sdGlwLmh0bWwoY29uZmlnLnRvb2x0aXBfY29udGVudHMuY2FsbCgkJCwgJCQuZGF0YS50YXJnZXRzLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkJC5hZGROYW1lKGQudmFsdWVzW2NvbmZpZy50b29sdGlwX2luaXRfeF0pO1xuICAgICAgICAgICAgfSksICQkLmF4aXMuZ2V0WEF4aXNUaWNrRm9ybWF0KCksICQkLmdldFlGb3JtYXQoJCQuaGFzQXJjVHlwZSgpKSwgJCQuY29sb3IpKTtcbiAgICAgICAgICAgICQkLnRvb2x0aXAuc3R5bGUoXCJ0b3BcIiwgY29uZmlnLnRvb2x0aXBfaW5pdF9wb3NpdGlvbi50b3ApLnN0eWxlKFwibGVmdFwiLCBjb25maWcudG9vbHRpcF9pbml0X3Bvc2l0aW9uLmxlZnQpLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRUb29sdGlwU29ydEZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnO1xuXG4gICAgICAgIGlmIChjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoID09PSAwIHx8IGNvbmZpZy50b29sdGlwX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGlmIGRhdGEgYXJlIG5vdCBncm91cGVkIG9yIGlmIGFuIG9yZGVyIGlzIHNwZWNpZmllZFxuICAgICAgICAgICAgLy8gZm9yIHRoZSB0b29sdGlwIHZhbHVlcyB3ZSBzb3J0IHRoZW0gYnkgdGhlaXIgdmFsdWVzXG5cbiAgICAgICAgICAgIHZhciBvcmRlciA9IGNvbmZpZy50b29sdGlwX29yZGVyO1xuICAgICAgICAgICAgaWYgKG9yZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcmRlciA9IGNvbmZpZy5kYXRhX29yZGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsdWVPZiA9IGZ1bmN0aW9uIHZhbHVlT2Yob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiA/IG9iai52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBpZiBkYXRhIGFyZSBub3QgZ3JvdXBlZCwgd2Ugc29ydCB0aGVtIGJ5IHRoZWlyIHZhbHVlXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcob3JkZXIpICYmIG9yZGVyLnRvTG93ZXJDYXNlKCkgPT09ICdhc2MnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZU9mKGEpIC0gdmFsdWVPZihiKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyhvcmRlcikgJiYgb3JkZXIudG9Mb3dlckNhc2UoKSA9PT0gJ2Rlc2MnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZU9mKGIpIC0gdmFsdWVPZihhKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKG9yZGVyKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZ1bmN0aW9uIGlzIGZyb20gZGF0YV9vcmRlciB3ZSBuZWVkXG4gICAgICAgICAgICAgICAgLy8gdG8gd3JhcCB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gaW4gb3JkZXIgdG8gZm9ybWF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIHNvcnRlZCB2YWx1ZSB0byB0aGUgZXhwZWN0ZWQgZm9ybWF0XG5cbiAgICAgICAgICAgICAgICB2YXIgc29ydEZ1bmN0aW9uID0gb3JkZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnRvb2x0aXBfb3JkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzb3J0RnVuY3Rpb24gPSBmdW5jdGlvbiBzb3J0RnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yZGVyKGEgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBbYV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gOiBudWxsLCBiID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBiLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogW2JdXG4gICAgICAgICAgICAgICAgICAgICAgICB9IDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRGdW5jdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShvcmRlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yZGVyLmluZGV4T2YoYS5pZCkgLSBvcmRlci5pbmRleE9mKGIuaWQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBkYXRhIGFyZSBncm91cGVkLCB3ZSBmb2xsb3cgdGhlIG9yZGVyIG9mIGdyb3VwZWQgdGFyZ2V0c1xuICAgICAgICAgICAgdmFyIGlkcyA9ICQkLm9yZGVyVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpLmlkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGlmIGl0IHdhcyBlaXRoZXIgYXNjIG9yIGRlc2Mgd2UgbmVlZCB0byBpbnZlcnQgdGhlIG9yZGVyXG4gICAgICAgICAgICAvLyByZXR1cm5lZCBieSBvcmRlclRhcmdldHNcbiAgICAgICAgICAgIGlmICgkJC5pc09yZGVyQXNjKCkgfHwgJCQuaXNPcmRlckRlc2MoKSkge1xuICAgICAgICAgICAgICAgIGlkcyA9IGlkcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZHMuaW5kZXhPZihhLmlkKSAtIGlkcy5pbmRleE9mKGIuaWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uZ2V0VG9vbHRpcENvbnRlbnQgPSBmdW5jdGlvbiAoZCwgZGVmYXVsdFRpdGxlRm9ybWF0LCBkZWZhdWx0VmFsdWVGb3JtYXQsIGNvbG9yKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICB0aXRsZUZvcm1hdCA9IGNvbmZpZy50b29sdGlwX2Zvcm1hdF90aXRsZSB8fCBkZWZhdWx0VGl0bGVGb3JtYXQsXG4gICAgICAgICAgICBuYW1lRm9ybWF0ID0gY29uZmlnLnRvb2x0aXBfZm9ybWF0X25hbWUgfHwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9LFxuICAgICAgICAgICAgdmFsdWVGb3JtYXQgPSBjb25maWcudG9vbHRpcF9mb3JtYXRfdmFsdWUgfHwgZGVmYXVsdFZhbHVlRm9ybWF0LFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGJnY29sb3I7XG5cbiAgICAgICAgdmFyIHRvb2x0aXBTb3J0RnVuY3Rpb24gPSB0aGlzLmdldFRvb2x0aXBTb3J0RnVuY3Rpb24oKTtcbiAgICAgICAgaWYgKHRvb2x0aXBTb3J0RnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGQuc29ydCh0b29sdGlwU29ydEZ1bmN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIShkW2ldICYmIChkW2ldLnZhbHVlIHx8IGRbaV0udmFsdWUgPT09IDApKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IHNhbml0aXNlKHRpdGxlRm9ybWF0ID8gdGl0bGVGb3JtYXQoZFtpXS54KSA6IGRbaV0ueCk7XG4gICAgICAgICAgICAgICAgdGV4dCA9IFwiPHRhYmxlIGNsYXNzPSdcIiArICQkLkNMQVNTLnRvb2x0aXAgKyBcIic+XCIgKyAodGl0bGUgfHwgdGl0bGUgPT09IDAgPyBcIjx0cj48dGggY29sc3Bhbj0nMic+XCIgKyB0aXRsZSArIFwiPC90aD48L3RyPlwiIDogXCJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gc2FuaXRpc2UodmFsdWVGb3JtYXQoZFtpXS52YWx1ZSwgZFtpXS5yYXRpbywgZFtpXS5pZCwgZFtpXS5pbmRleCwgZCkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGVsZW1lbnRzIHdoZW4gdGhlaXIgbmFtZSBpcyBzZXQgdG8gbnVsbFxuICAgICAgICAgICAgICAgIGlmIChkW2ldLm5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5hbWUgPSBzYW5pdGlzZShuYW1lRm9ybWF0KGRbaV0ubmFtZSwgZFtpXS5yYXRpbywgZFtpXS5pZCwgZFtpXS5pbmRleCkpO1xuICAgICAgICAgICAgICAgIGJnY29sb3IgPSAkJC5sZXZlbENvbG9yID8gJCQubGV2ZWxDb2xvcihkW2ldLnZhbHVlKSA6IGNvbG9yKGRbaV0uaWQpO1xuXG4gICAgICAgICAgICAgICAgdGV4dCArPSBcIjx0ciBjbGFzcz0nXCIgKyAkJC5DTEFTUy50b29sdGlwTmFtZSArIFwiLVwiICsgJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZFtpXS5pZCkgKyBcIic+XCI7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBcIjx0ZCBjbGFzcz0nbmFtZSc+PHNwYW4gc3R5bGU9J2JhY2tncm91bmQtY29sb3I6XCIgKyBiZ2NvbG9yICsgXCInPjwvc3Bhbj5cIiArIG5hbWUgKyBcIjwvdGQ+XCI7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBcIjx0ZCBjbGFzcz0ndmFsdWUnPlwiICsgdmFsdWUgKyBcIjwvdGQ+XCI7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBcIjwvdHI+XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQgKyBcIjwvdGFibGU+XCI7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi50b29sdGlwUG9zaXRpb24gPSBmdW5jdGlvbiAoZGF0YVRvU2hvdywgdFdpZHRoLCB0SGVpZ2h0LCBlbGVtZW50KSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWcsXG4gICAgICAgICAgICBkMyA9ICQkLmQzO1xuICAgICAgICB2YXIgc3ZnTGVmdCwgdG9vbHRpcExlZnQsIHRvb2x0aXBSaWdodCwgdG9vbHRpcFRvcCwgY2hhcnRSaWdodDtcbiAgICAgICAgdmFyIGZvckFyYyA9ICQkLmhhc0FyY1R5cGUoKSxcbiAgICAgICAgICAgIG1vdXNlID0gZDMubW91c2UoZWxlbWVudCk7XG4gICAgICAgIC8vIERldGVybWluIHRvb2x0aXAgcG9zaXRpb25cbiAgICAgICAgaWYgKGZvckFyYykge1xuICAgICAgICAgICAgdG9vbHRpcExlZnQgPSAoJCQud2lkdGggLSAoJCQuaXNMZWdlbmRSaWdodCA/ICQkLmdldExlZ2VuZFdpZHRoKCkgOiAwKSkgLyAyICsgbW91c2VbMF07XG4gICAgICAgICAgICB0b29sdGlwVG9wID0gKCQkLmhhc1R5cGUoJ2dhdWdlJykgPyAkJC5oZWlnaHQgOiAkJC5oZWlnaHQgLyAyKSArIG1vdXNlWzFdICsgMjA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdmdMZWZ0ID0gJCQuZ2V0U3ZnTGVmdCh0cnVlKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuYXhpc19yb3RhdGVkKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcExlZnQgPSBzdmdMZWZ0ICsgbW91c2VbMF0gKyAxMDA7XG4gICAgICAgICAgICAgICAgdG9vbHRpcFJpZ2h0ID0gdG9vbHRpcExlZnQgKyB0V2lkdGg7XG4gICAgICAgICAgICAgICAgY2hhcnRSaWdodCA9ICQkLmN1cnJlbnRXaWR0aCAtICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQoKTtcbiAgICAgICAgICAgICAgICB0b29sdGlwVG9wID0gJCQueChkYXRhVG9TaG93WzBdLngpICsgMjA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBMZWZ0ID0gc3ZnTGVmdCArICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCh0cnVlKSArICQkLngoZGF0YVRvU2hvd1swXS54KSArIDIwO1xuICAgICAgICAgICAgICAgIHRvb2x0aXBSaWdodCA9IHRvb2x0aXBMZWZ0ICsgdFdpZHRoO1xuICAgICAgICAgICAgICAgIGNoYXJ0UmlnaHQgPSBzdmdMZWZ0ICsgJCQuY3VycmVudFdpZHRoIC0gJCQuZ2V0Q3VycmVudFBhZGRpbmdSaWdodCgpO1xuICAgICAgICAgICAgICAgIHRvb2x0aXBUb3AgPSBtb3VzZVsxXSArIDE1O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9vbHRpcFJpZ2h0ID4gY2hhcnRSaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIDIwIGlzIG5lZWRlZCBmb3IgRmlyZWZveCB0byBrZWVwIHRvb2x0aXAgd2lkdGhcbiAgICAgICAgICAgICAgICB0b29sdGlwTGVmdCAtPSB0b29sdGlwUmlnaHQgLSBjaGFydFJpZ2h0ICsgMjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9vbHRpcFRvcCArIHRIZWlnaHQgPiAkJC5jdXJyZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcFRvcCAtPSB0SGVpZ2h0ICsgMzA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvb2x0aXBUb3AgPCAwKSB7XG4gICAgICAgICAgICB0b29sdGlwVG9wID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0b3A6IHRvb2x0aXBUb3AsIGxlZnQ6IHRvb2x0aXBMZWZ0IH07XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5zaG93VG9vbHRpcCA9IGZ1bmN0aW9uIChzZWxlY3RlZERhdGEsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyICQkID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9ICQkLmNvbmZpZztcbiAgICAgICAgdmFyIHRXaWR0aCwgdEhlaWdodCwgcG9zaXRpb247XG4gICAgICAgIHZhciBmb3JBcmMgPSAkJC5oYXNBcmNUeXBlKCksXG4gICAgICAgICAgICBkYXRhVG9TaG93ID0gc2VsZWN0ZWREYXRhLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQgJiYgaXNWYWx1ZShkLnZhbHVlKTtcbiAgICAgICAgfSksXG4gICAgICAgICAgICBwb3NpdGlvbkZ1bmN0aW9uID0gY29uZmlnLnRvb2x0aXBfcG9zaXRpb24gfHwgYzNfY2hhcnRfaW50ZXJuYWxfZm4udG9vbHRpcFBvc2l0aW9uO1xuICAgICAgICBpZiAoZGF0YVRvU2hvdy5sZW5ndGggPT09IDAgfHwgIWNvbmZpZy50b29sdGlwX3Nob3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAkJC50b29sdGlwLmh0bWwoY29uZmlnLnRvb2x0aXBfY29udGVudHMuY2FsbCgkJCwgc2VsZWN0ZWREYXRhLCAkJC5heGlzLmdldFhBeGlzVGlja0Zvcm1hdCgpLCAkJC5nZXRZRm9ybWF0KGZvckFyYyksICQkLmNvbG9yKSkuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cbiAgICAgICAgLy8gR2V0IHRvb2x0aXAgZGltZW5zaW9uc1xuICAgICAgICB0V2lkdGggPSAkJC50b29sdGlwLnByb3BlcnR5KCdvZmZzZXRXaWR0aCcpO1xuICAgICAgICB0SGVpZ2h0ID0gJCQudG9vbHRpcC5wcm9wZXJ0eSgnb2Zmc2V0SGVpZ2h0Jyk7XG5cbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbkZ1bmN0aW9uLmNhbGwodGhpcywgZGF0YVRvU2hvdywgdFdpZHRoLCB0SGVpZ2h0LCBlbGVtZW50KTtcbiAgICAgICAgLy8gU2V0IHRvb2x0aXBcbiAgICAgICAgJCQudG9vbHRpcC5zdHlsZShcInRvcFwiLCBwb3NpdGlvbi50b3AgKyBcInB4XCIpLnN0eWxlKFwibGVmdFwiLCBwb3NpdGlvbi5sZWZ0ICsgJ3B4Jyk7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5oaWRlVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnNldFRhcmdldFR5cGUgPSBmdW5jdGlvbiAodGFyZ2V0SWRzLCB0eXBlKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSAkJC5jb25maWc7XG4gICAgICAgICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICQkLndpdGhvdXRGYWRlSW5baWRdID0gdHlwZSA9PT0gY29uZmlnLmRhdGFfdHlwZXNbaWRdO1xuICAgICAgICAgICAgY29uZmlnLmRhdGFfdHlwZXNbaWRdID0gdHlwZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGFyZ2V0SWRzKSB7XG4gICAgICAgICAgICBjb25maWcuZGF0YV90eXBlID0gdHlwZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaGFzVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCB0YXJnZXRzKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICB0eXBlcyA9ICQkLmNvbmZpZy5kYXRhX3R5cGVzLFxuICAgICAgICAgICAgaGFzID0gZmFsc2U7XG4gICAgICAgIHRhcmdldHMgPSB0YXJnZXRzIHx8ICQkLmRhdGEudGFyZ2V0cztcbiAgICAgICAgaWYgKHRhcmdldHMgJiYgdGFyZ2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0eXBlc1t0YXJnZXQuaWRdO1xuICAgICAgICAgICAgICAgIGlmICh0ICYmIHQuaW5kZXhPZih0eXBlKSA+PSAwIHx8ICF0ICYmIHR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgICAgICAgICBoYXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5rZXlzKHR5cGVzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlc1tpZF0gPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhcyA9ICQkLmNvbmZpZy5kYXRhX3R5cGUgPT09IHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhcztcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmhhc0FyY1R5cGUgPSBmdW5jdGlvbiAodGFyZ2V0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNUeXBlKCdwaWUnLCB0YXJnZXRzKSB8fCB0aGlzLmhhc1R5cGUoJ2RvbnV0JywgdGFyZ2V0cykgfHwgdGhpcy5oYXNUeXBlKCdnYXVnZScsIHRhcmdldHMpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaXNMaW5lVHlwZSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIGlkID0gaXNTdHJpbmcoZCkgPyBkIDogZC5pZDtcbiAgICAgICAgcmV0dXJuICFjb25maWcuZGF0YV90eXBlc1tpZF0gfHwgWydsaW5lJywgJ3NwbGluZScsICdhcmVhJywgJ2FyZWEtc3BsaW5lJywgJ3N0ZXAnLCAnYXJlYS1zdGVwJ10uaW5kZXhPZihjb25maWcuZGF0YV90eXBlc1tpZF0pID49IDA7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5pc1N0ZXBUeXBlID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIGlkID0gaXNTdHJpbmcoZCkgPyBkIDogZC5pZDtcbiAgICAgICAgcmV0dXJuIFsnc3RlcCcsICdhcmVhLXN0ZXAnXS5pbmRleE9mKHRoaXMuY29uZmlnLmRhdGFfdHlwZXNbaWRdKSA+PSAwO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaXNTcGxpbmVUeXBlID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIGlkID0gaXNTdHJpbmcoZCkgPyBkIDogZC5pZDtcbiAgICAgICAgcmV0dXJuIFsnc3BsaW5lJywgJ2FyZWEtc3BsaW5lJ10uaW5kZXhPZih0aGlzLmNvbmZpZy5kYXRhX3R5cGVzW2lkXSkgPj0gMDtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmlzQXJlYVR5cGUgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgaWQgPSBpc1N0cmluZyhkKSA/IGQgOiBkLmlkO1xuICAgICAgICByZXR1cm4gWydhcmVhJywgJ2FyZWEtc3BsaW5lJywgJ2FyZWEtc3RlcCddLmluZGV4T2YodGhpcy5jb25maWcuZGF0YV90eXBlc1tpZF0pID49IDA7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5pc0JhclR5cGUgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgaWQgPSBpc1N0cmluZyhkKSA/IGQgOiBkLmlkO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuZGF0YV90eXBlc1tpZF0gPT09ICdiYXInO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaXNTY2F0dGVyVHlwZSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBpZCA9IGlzU3RyaW5nKGQpID8gZCA6IGQuaWQ7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhX3R5cGVzW2lkXSA9PT0gJ3NjYXR0ZXInO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaXNQaWVUeXBlID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIGlkID0gaXNTdHJpbmcoZCkgPyBkIDogZC5pZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGFfdHlwZXNbaWRdID09PSAncGllJztcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmlzR2F1Z2VUeXBlID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIGlkID0gaXNTdHJpbmcoZCkgPyBkIDogZC5pZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGFfdHlwZXNbaWRdID09PSAnZ2F1Z2UnO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaXNEb251dFR5cGUgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgaWQgPSBpc1N0cmluZyhkKSA/IGQgOiBkLmlkO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuZGF0YV90eXBlc1tpZF0gPT09ICdkb251dCc7XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5pc0FyY1R5cGUgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1BpZVR5cGUoZCkgfHwgdGhpcy5pc0RvbnV0VHlwZShkKSB8fCB0aGlzLmlzR2F1Z2VUeXBlKGQpO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4ubGluZURhdGEgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0xpbmVUeXBlKGQpID8gW2RdIDogW107XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5hcmNEYXRhID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBcmNUeXBlKGQuZGF0YSkgPyBbZF0gOiBbXTtcbiAgICB9O1xuICAgIC8qIG5vdCB1c2VkXG4gICAgIGZ1bmN0aW9uIHNjYXR0ZXJEYXRhKGQpIHtcbiAgICAgcmV0dXJuIGlzU2NhdHRlclR5cGUoZCkgPyBkLnZhbHVlcyA6IFtdO1xuICAgICB9XG4gICAgICovXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uYmFyRGF0YSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQmFyVHlwZShkKSA/IGQudmFsdWVzIDogW107XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5saW5lT3JTY2F0dGVyRGF0YSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTGluZVR5cGUoZCkgfHwgdGhpcy5pc1NjYXR0ZXJUeXBlKGQpID8gZC52YWx1ZXMgOiBbXTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmJhck9yTGluZURhdGEgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0JhclR5cGUoZCkgfHwgdGhpcy5pc0xpbmVUeXBlKGQpID8gZC52YWx1ZXMgOiBbXTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmlzSW50ZXJwb2xhdGlvblR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gWydsaW5lYXInLCAnbGluZWFyLWNsb3NlZCcsICdiYXNpcycsICdiYXNpcy1vcGVuJywgJ2Jhc2lzLWNsb3NlZCcsICdidW5kbGUnLCAnY2FyZGluYWwnLCAnY2FyZGluYWwtb3BlbicsICdjYXJkaW5hbC1jbG9zZWQnLCAnbW9ub3RvbmUnXS5pbmRleE9mKHR5cGUpID49IDA7XG4gICAgfTtcblxuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLmlzU2FmYXJpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgICAgcmV0dXJuIHVhLmluZGV4T2YoJ1NhZmFyaScpID49IDAgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPCAwO1xuICAgIH07XG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaXNDaHJvbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgICByZXR1cm4gdWEuaW5kZXhPZignQ2hyb21lJykgPj0gMDtcbiAgICB9O1xuXG4gICAgYzNfY2hhcnRfaW50ZXJuYWxfZm4uaW5pdFpvb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBkMyA9ICQkLmQzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgc3RhcnRFdmVudDtcblxuICAgICAgICAkJC56b29tID0gZDMuYmVoYXZpb3Iuem9vbSgpLm9uKFwiem9vbXN0YXJ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN0YXJ0RXZlbnQgPSBkMy5ldmVudC5zb3VyY2VFdmVudDtcbiAgICAgICAgICAgICQkLnpvb20uYWx0RG9tYWluID0gZDMuZXZlbnQuc291cmNlRXZlbnQuYWx0S2V5ID8gJCQueC5vcmdEb21haW4oKSA6IG51bGw7XG4gICAgICAgICAgICBjb25maWcuem9vbV9vbnpvb21zdGFydC5jYWxsKCQkLmFwaSwgZDMuZXZlbnQuc291cmNlRXZlbnQpO1xuICAgICAgICB9KS5vbihcInpvb21cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCQucmVkcmF3Rm9yWm9vbS5jYWxsKCQkKTtcbiAgICAgICAgfSkub24oJ3pvb21lbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBkMy5ldmVudC5zb3VyY2VFdmVudDtcbiAgICAgICAgICAgIC8vIGlmIGNsaWNrLCBkbyBub3RoaW5nLiBvdGhlcndpc2UsIGNsaWNrIGludGVyYWN0aW9uIHdpbGwgYmUgY2FuY2VsZWQuXG4gICAgICAgICAgICBpZiAoZXZlbnQgJiYgc3RhcnRFdmVudC5jbGllbnRYID09PSBldmVudC5jbGllbnRYICYmIHN0YXJ0RXZlbnQuY2xpZW50WSA9PT0gZXZlbnQuY2xpZW50WSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQkLnJlZHJhd0V2ZW50UmVjdCgpO1xuICAgICAgICAgICAgJCQudXBkYXRlWm9vbSgpO1xuICAgICAgICAgICAgY29uZmlnLnpvb21fb256b29tZW5kLmNhbGwoJCQuYXBpLCAkJC54Lm9yZ0RvbWFpbigpKTtcbiAgICAgICAgfSk7XG4gICAgICAgICQkLnpvb20uc2NhbGUgPSBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuYXhpc19yb3RhdGVkID8gdGhpcy55KHNjYWxlKSA6IHRoaXMueChzY2FsZSk7XG4gICAgICAgIH07XG4gICAgICAgICQkLnpvb20ub3JnU2NhbGVFeHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gY29uZmlnLnpvb21fZXh0ZW50ID8gY29uZmlnLnpvb21fZXh0ZW50IDogWzEsIDEwXTtcbiAgICAgICAgICAgIHJldHVybiBbZXh0ZW50WzBdLCBNYXRoLm1heCgkJC5nZXRNYXhEYXRhQ291bnQoKSAvIGV4dGVudFsxXSwgZXh0ZW50WzFdKV07XG4gICAgICAgIH07XG4gICAgICAgICQkLnpvb20udXBkYXRlU2NhbGVFeHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmF0aW8gPSBkaWZmRG9tYWluKCQkLngub3JnRG9tYWluKCkpIC8gZGlmZkRvbWFpbigkJC5nZXRab29tRG9tYWluKCkpLFxuICAgICAgICAgICAgICAgIGV4dGVudCA9IHRoaXMub3JnU2NhbGVFeHRlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVFeHRlbnQoW2V4dGVudFswXSAqIHJhdGlvLCBleHRlbnRbMV0gKiByYXRpb10pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi5nZXRab29tRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgZDMgPSAkJC5kMyxcbiAgICAgICAgICAgIG1pbiA9IGQzLm1pbihbJCQub3JnWERvbWFpblswXSwgY29uZmlnLnpvb21feF9taW5dKSxcbiAgICAgICAgICAgIG1heCA9IGQzLm1heChbJCQub3JnWERvbWFpblsxXSwgY29uZmlnLnpvb21feF9tYXhdKTtcbiAgICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgfTtcbiAgICBjM19jaGFydF9pbnRlcm5hbF9mbi51cGRhdGVab29tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJCQgPSB0aGlzLFxuICAgICAgICAgICAgeiA9ICQkLmNvbmZpZy56b29tX2VuYWJsZWQgPyAkJC56b29tIDogZnVuY3Rpb24gKCkge307XG4gICAgICAgICQkLm1haW4uc2VsZWN0KCcuJyArIENMQVNTLnpvb21SZWN0KS5jYWxsKHopLm9uKFwiZGJsY2xpY2suem9vbVwiLCBudWxsKTtcbiAgICAgICAgJCQubWFpbi5zZWxlY3RBbGwoJy4nICsgQ0xBU1MuZXZlbnRSZWN0KS5jYWxsKHopLm9uKFwiZGJsY2xpY2suem9vbVwiLCBudWxsKTtcbiAgICB9O1xuICAgIGMzX2NoYXJ0X2ludGVybmFsX2ZuLnJlZHJhd0Zvclpvb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkJCA9IHRoaXMsXG4gICAgICAgICAgICBkMyA9ICQkLmQzLFxuICAgICAgICAgICAgY29uZmlnID0gJCQuY29uZmlnLFxuICAgICAgICAgICAgem9vbSA9ICQkLnpvb20sXG4gICAgICAgICAgICB4ID0gJCQueDtcbiAgICAgICAgaWYgKCFjb25maWcuem9vbV9lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScgJiYgem9vbS5hbHREb21haW4pIHtcbiAgICAgICAgICAgIHguZG9tYWluKHpvb20uYWx0RG9tYWluKTtcbiAgICAgICAgICAgIHpvb20uc2NhbGUoeCkudXBkYXRlU2NhbGVFeHRlbnQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJCQuaXNDYXRlZ29yaXplZCgpICYmIHgub3JnRG9tYWluKClbMF0gPT09ICQkLm9yZ1hEb21haW5bMF0pIHtcbiAgICAgICAgICAgIHguZG9tYWluKFskJC5vcmdYRG9tYWluWzBdIC0gMWUtMTAsIHgub3JnRG9tYWluKClbMV1dKTtcbiAgICAgICAgfVxuICAgICAgICAkJC5yZWRyYXcoe1xuICAgICAgICAgICAgd2l0aFRyYW5zaXRpb246IGZhbHNlLFxuICAgICAgICAgICAgd2l0aFk6IGNvbmZpZy56b29tX3Jlc2NhbGUsXG4gICAgICAgICAgICB3aXRoU3ViY2hhcnQ6IGZhbHNlLFxuICAgICAgICAgICAgd2l0aEV2ZW50UmVjdDogZmFsc2UsXG4gICAgICAgICAgICB3aXRoRGltZW5zaW9uOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50LnR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgICAgICAkJC5jYW5jZWxDbGljayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLnpvb21fb256b29tLmNhbGwoJCQuYXBpLCB4Lm9yZ0RvbWFpbigpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGMzO1xuXG59KSkpO1xuIiwiIWZ1bmN0aW9uKCkge1xuICB2YXIgZDMgPSB7XG4gICAgdmVyc2lvbjogXCIzLjUuMTdcIlxuICB9O1xuICB2YXIgZDNfYXJyYXlTbGljZSA9IFtdLnNsaWNlLCBkM19hcnJheSA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICByZXR1cm4gZDNfYXJyYXlTbGljZS5jYWxsKGxpc3QpO1xuICB9O1xuICB2YXIgZDNfZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50O1xuICBmdW5jdGlvbiBkM19kb2N1bWVudEVsZW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIChub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZS5kb2N1bWVudCB8fCBub2RlKS5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfd2luZG93KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiAobm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCBub2RlLmRvY3VtZW50ICYmIG5vZGUgfHwgbm9kZS5kZWZhdWx0Vmlldyk7XG4gIH1cbiAgaWYgKGQzX2RvY3VtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGQzX2FycmF5KGQzX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jaGlsZE5vZGVzKVswXS5ub2RlVHlwZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkM19hcnJheSA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICAgICAgdmFyIGkgPSBsaXN0Lmxlbmd0aCwgYXJyYXkgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgIHdoaWxlIChpLS0pIGFycmF5W2ldID0gbGlzdFtpXTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaWYgKCFEYXRlLm5vdykgRGF0ZS5ub3cgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gK25ldyBEYXRlKCk7XG4gIH07XG4gIGlmIChkM19kb2N1bWVudCkge1xuICAgIHRyeSB7XG4gICAgICBkM19kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpLnN0eWxlLnNldFByb3BlcnR5KFwib3BhY2l0eVwiLCAwLCBcIlwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdmFyIGQzX2VsZW1lbnRfcHJvdG90eXBlID0gdGhpcy5FbGVtZW50LnByb3RvdHlwZSwgZDNfZWxlbWVudF9zZXRBdHRyaWJ1dGUgPSBkM19lbGVtZW50X3Byb3RvdHlwZS5zZXRBdHRyaWJ1dGUsIGQzX2VsZW1lbnRfc2V0QXR0cmlidXRlTlMgPSBkM19lbGVtZW50X3Byb3RvdHlwZS5zZXRBdHRyaWJ1dGVOUywgZDNfc3R5bGVfcHJvdG90eXBlID0gdGhpcy5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZSwgZDNfc3R5bGVfc2V0UHJvcGVydHkgPSBkM19zdHlsZV9wcm90b3R5cGUuc2V0UHJvcGVydHk7XG4gICAgICBkM19lbGVtZW50X3Byb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICBkM19lbGVtZW50X3NldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlICsgXCJcIik7XG4gICAgICB9O1xuICAgICAgZDNfZWxlbWVudF9wcm90b3R5cGUuc2V0QXR0cmlidXRlTlMgPSBmdW5jdGlvbihzcGFjZSwgbG9jYWwsIHZhbHVlKSB7XG4gICAgICAgIGQzX2VsZW1lbnRfc2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBzcGFjZSwgbG9jYWwsIHZhbHVlICsgXCJcIik7XG4gICAgICB9O1xuICAgICAgZDNfc3R5bGVfcHJvdG90eXBlLnNldFByb3BlcnR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gICAgICAgIGQzX3N0eWxlX3NldFByb3BlcnR5LmNhbGwodGhpcywgbmFtZSwgdmFsdWUgKyBcIlwiLCBwcmlvcml0eSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBkMy5hc2NlbmRpbmcgPSBkM19hc2NlbmRpbmc7XG4gIGZ1bmN0aW9uIGQzX2FzY2VuZGluZyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xuICB9XG4gIGQzLmRlc2NlbmRpbmcgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xuICB9O1xuICBkMy5taW4gPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBpID0gLTEsIG4gPSBhcnJheS5sZW5ndGgsIGEsIGI7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBiID49IGIpIHtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGEgPiBiKSBhID0gYjtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwgJiYgYSA+IGIpIGEgPSBiO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcbiAgZDMubWF4ID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gYXJyYXkubGVuZ3RoLCBhLCBiO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBiID4gYSkgYSA9IGI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkgIT0gbnVsbCAmJiBiID49IGIpIHtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSAhPSBudWxsICYmIGIgPiBhKSBhID0gYjtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG4gIGQzLmV4dGVudCA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IGFycmF5Lmxlbmd0aCwgYSwgYiwgYztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYyA9IGI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhID4gYikgYSA9IGI7XG4gICAgICAgIGlmIChjIDwgYikgYyA9IGI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkgIT0gbnVsbCAmJiBiID49IGIpIHtcbiAgICAgICAgYSA9IGMgPSBiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYSA+IGIpIGEgPSBiO1xuICAgICAgICBpZiAoYyA8IGIpIGMgPSBiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gWyBhLCBjIF07XG4gIH07XG4gIGZ1bmN0aW9uIGQzX251bWJlcih4KSB7XG4gICAgcmV0dXJuIHggPT09IG51bGwgPyBOYU4gOiAreDtcbiAgfVxuICBmdW5jdGlvbiBkM19udW1lcmljKHgpIHtcbiAgICByZXR1cm4gIWlzTmFOKHgpO1xuICB9XG4gIGQzLnN1bSA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIHMgPSAwLCBuID0gYXJyYXkubGVuZ3RoLCBhLCBpID0gLTE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gK2FycmF5W2ldKSkgcyArPSBhO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGQzX251bWVyaWMoYSA9ICtmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkpIHMgKz0gYTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH07XG4gIGQzLm1lYW4gPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBzID0gMCwgbiA9IGFycmF5Lmxlbmd0aCwgYSwgaSA9IC0xLCBqID0gbjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChkM19udW1lcmljKGEgPSBkM19udW1iZXIoYXJyYXlbaV0pKSkgcyArPSBhOyBlbHNlIC0tajtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChkM19udW1lcmljKGEgPSBkM19udW1iZXIoZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpKSkgcyArPSBhOyBlbHNlIC0tajtcbiAgICB9XG4gICAgaWYgKGopIHJldHVybiBzIC8gajtcbiAgfTtcbiAgZDMucXVhbnRpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIHApIHtcbiAgICB2YXIgSCA9ICh2YWx1ZXMubGVuZ3RoIC0gMSkgKiBwICsgMSwgaCA9IE1hdGguZmxvb3IoSCksIHYgPSArdmFsdWVzW2ggLSAxXSwgZSA9IEggLSBoO1xuICAgIHJldHVybiBlID8gdiArIGUgKiAodmFsdWVzW2hdIC0gdikgOiB2O1xuICB9O1xuICBkMy5tZWRpYW4gPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBudW1iZXJzID0gW10sIG4gPSBhcnJheS5sZW5ndGgsIGEsIGkgPSAtMTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChkM19udW1lcmljKGEgPSBkM19udW1iZXIoYXJyYXlbaV0pKSkgbnVtYmVycy5wdXNoKGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGQzX251bWVyaWMoYSA9IGQzX251bWJlcihmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkpKSBudW1iZXJzLnB1c2goYSk7XG4gICAgfVxuICAgIGlmIChudW1iZXJzLmxlbmd0aCkgcmV0dXJuIGQzLnF1YW50aWxlKG51bWJlcnMuc29ydChkM19hc2NlbmRpbmcpLCAuNSk7XG4gIH07XG4gIGQzLnZhcmlhbmNlID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aCwgbSA9IDAsIGEsIGQsIHMgPSAwLCBpID0gLTEsIGogPSAwO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGFycmF5W2ldKSkpIHtcbiAgICAgICAgICBkID0gYSAtIG07XG4gICAgICAgICAgbSArPSBkIC8gKytqO1xuICAgICAgICAgIHMgKz0gZCAqIChhIC0gbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKGQzX251bWVyaWMoYSA9IGQzX251bWJlcihmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkpKSB7XG4gICAgICAgICAgZCA9IGEgLSBtO1xuICAgICAgICAgIG0gKz0gZCAvICsrajtcbiAgICAgICAgICBzICs9IGQgKiAoYSAtIG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChqID4gMSkgcmV0dXJuIHMgLyAoaiAtIDEpO1xuICB9O1xuICBkMy5kZXZpYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IGQzLnZhcmlhbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHYgPyBNYXRoLnNxcnQodikgOiB2O1xuICB9O1xuICBmdW5jdGlvbiBkM19iaXNlY3Rvcihjb21wYXJlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIGxvID0gMDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSBoaSA9IGEubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPCAwKSBsbyA9IG1pZCArIDE7IGVsc2UgaGkgPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgfSxcbiAgICAgIHJpZ2h0OiBmdW5jdGlvbihhLCB4LCBsbywgaGkpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBsbyA9IDA7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgNCkgaGkgPSBhLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpID4gMCkgaGkgPSBtaWQ7IGVsc2UgbG8gPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsbztcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHZhciBkM19iaXNlY3QgPSBkM19iaXNlY3RvcihkM19hc2NlbmRpbmcpO1xuICBkMy5iaXNlY3RMZWZ0ID0gZDNfYmlzZWN0LmxlZnQ7XG4gIGQzLmJpc2VjdCA9IGQzLmJpc2VjdFJpZ2h0ID0gZDNfYmlzZWN0LnJpZ2h0O1xuICBkMy5iaXNlY3RvciA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gZDNfYmlzZWN0b3IoZi5sZW5ndGggPT09IDEgPyBmdW5jdGlvbihkLCB4KSB7XG4gICAgICByZXR1cm4gZDNfYXNjZW5kaW5nKGYoZCksIHgpO1xuICAgIH0gOiBmKTtcbiAgfTtcbiAgZDMuc2h1ZmZsZSA9IGZ1bmN0aW9uKGFycmF5LCBpMCwgaTEpIHtcbiAgICBpZiAoKG0gPSBhcmd1bWVudHMubGVuZ3RoKSA8IDMpIHtcbiAgICAgIGkxID0gYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKG0gPCAyKSBpMCA9IDA7XG4gICAgfVxuICAgIHZhciBtID0gaTEgLSBpMCwgdCwgaTtcbiAgICB3aGlsZSAobSkge1xuICAgICAgaSA9IE1hdGgucmFuZG9tKCkgKiBtLS0gfCAwO1xuICAgICAgdCA9IGFycmF5W20gKyBpMF0sIGFycmF5W20gKyBpMF0gPSBhcnJheVtpICsgaTBdLCBhcnJheVtpICsgaTBdID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xuICBkMy5wZXJtdXRlID0gZnVuY3Rpb24oYXJyYXksIGluZGV4ZXMpIHtcbiAgICB2YXIgaSA9IGluZGV4ZXMubGVuZ3RoLCBwZXJtdXRlcyA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKSBwZXJtdXRlc1tpXSA9IGFycmF5W2luZGV4ZXNbaV1dO1xuICAgIHJldHVybiBwZXJtdXRlcztcbiAgfTtcbiAgZDMucGFpcnMgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBpID0gMCwgbiA9IGFycmF5Lmxlbmd0aCAtIDEsIHAwLCBwMSA9IGFycmF5WzBdLCBwYWlycyA9IG5ldyBBcnJheShuIDwgMCA/IDAgOiBuKTtcbiAgICB3aGlsZSAoaSA8IG4pIHBhaXJzW2ldID0gWyBwMCA9IHAxLCBwMSA9IGFycmF5WysraV0gXTtcbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG4gIGQzLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgIGlmICghKG4gPSBtYXRyaXgubGVuZ3RoKSkgcmV0dXJuIFtdO1xuICAgIGZvciAodmFyIGkgPSAtMSwgbSA9IGQzLm1pbihtYXRyaXgsIGQzX3RyYW5zcG9zZUxlbmd0aCksIHRyYW5zcG9zZSA9IG5ldyBBcnJheShtKTsgKytpIDwgbTsgKSB7XG4gICAgICBmb3IgKHZhciBqID0gLTEsIG4sIHJvdyA9IHRyYW5zcG9zZVtpXSA9IG5ldyBBcnJheShuKTsgKytqIDwgbjsgKSB7XG4gICAgICAgIHJvd1tqXSA9IG1hdHJpeFtqXVtpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zcG9zZTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdHJhbnNwb3NlTGVuZ3RoKGQpIHtcbiAgICByZXR1cm4gZC5sZW5ndGg7XG4gIH1cbiAgZDMuemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnRyYW5zcG9zZShhcmd1bWVudHMpO1xuICB9O1xuICBkMy5rZXlzID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWFwKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcbiAgZDMudmFsdWVzID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBtYXApIHZhbHVlcy5wdXNoKG1hcFtrZXldKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuICBkMy5lbnRyaWVzID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWFwKSBlbnRyaWVzLnB1c2goe1xuICAgICAga2V5OiBrZXksXG4gICAgICB2YWx1ZTogbWFwW2tleV1cbiAgICB9KTtcbiAgICByZXR1cm4gZW50cmllcztcbiAgfTtcbiAgZDMubWVyZ2UgPSBmdW5jdGlvbihhcnJheXMpIHtcbiAgICB2YXIgbiA9IGFycmF5cy5sZW5ndGgsIG0sIGkgPSAtMSwgaiA9IDAsIG1lcmdlZCwgYXJyYXk7XG4gICAgd2hpbGUgKCsraSA8IG4pIGogKz0gYXJyYXlzW2ldLmxlbmd0aDtcbiAgICBtZXJnZWQgPSBuZXcgQXJyYXkoaik7XG4gICAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgICBhcnJheSA9IGFycmF5c1tuXTtcbiAgICAgIG0gPSBhcnJheS5sZW5ndGg7XG4gICAgICB3aGlsZSAoLS1tID49IDApIHtcbiAgICAgICAgbWVyZ2VkWy0tal0gPSBhcnJheVttXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfTtcbiAgdmFyIGFicyA9IE1hdGguYWJzO1xuICBkMy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICBzdGVwID0gMTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKChzdG9wIC0gc3RhcnQpIC8gc3RlcCA9PT0gSW5maW5pdHkpIHRocm93IG5ldyBFcnJvcihcImluZmluaXRlIHJhbmdlXCIpO1xuICAgIHZhciByYW5nZSA9IFtdLCBrID0gZDNfcmFuZ2VfaW50ZWdlclNjYWxlKGFicyhzdGVwKSksIGkgPSAtMSwgajtcbiAgICBzdGFydCAqPSBrLCBzdG9wICo9IGssIHN0ZXAgKj0gaztcbiAgICBpZiAoc3RlcCA8IDApIHdoaWxlICgoaiA9IHN0YXJ0ICsgc3RlcCAqICsraSkgPiBzdG9wKSByYW5nZS5wdXNoKGogLyBrKTsgZWxzZSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpIDwgc3RvcCkgcmFuZ2UucHVzaChqIC8gayk7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuICBmdW5jdGlvbiBkM19yYW5nZV9pbnRlZ2VyU2NhbGUoeCkge1xuICAgIHZhciBrID0gMTtcbiAgICB3aGlsZSAoeCAqIGsgJSAxKSBrICo9IDEwO1xuICAgIHJldHVybiBrO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2NsYXNzKGN0b3IsIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHByb3BlcnRpZXNba2V5XSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBkMy5tYXAgPSBmdW5jdGlvbihvYmplY3QsIGYpIHtcbiAgICB2YXIgbWFwID0gbmV3IGQzX01hcCgpO1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBkM19NYXApIHtcbiAgICAgIG9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gb2JqZWN0Lmxlbmd0aCwgbztcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB3aGlsZSAoKytpIDwgbikgbWFwLnNldChpLCBvYmplY3RbaV0pOyBlbHNlIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KGYuY2FsbChvYmplY3QsIG8gPSBvYmplY3RbaV0sIGkpLCBvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkgbWFwLnNldChrZXksIG9iamVjdFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfTWFwKCkge1xuICAgIHRoaXMuXyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgdmFyIGQzX21hcF9wcm90byA9IFwiX19wcm90b19fXCIsIGQzX21hcF96ZXJvID0gXCJcXHgwMFwiO1xuICBkM19jbGFzcyhkM19NYXAsIHtcbiAgICBoYXM6IGQzX21hcF9oYXMsXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9bZDNfbWFwX2VzY2FwZShrZXkpXTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX1tkM19tYXBfZXNjYXBlKGtleSldID0gdmFsdWU7XG4gICAgfSxcbiAgICByZW1vdmU6IGQzX21hcF9yZW1vdmUsXG4gICAga2V5czogZDNfbWFwX2tleXMsXG4gICAgdmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIHZhbHVlcy5wdXNoKHRoaXMuX1trZXldKTtcbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfSxcbiAgICBlbnRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSBlbnRyaWVzLnB1c2goe1xuICAgICAgICBrZXk6IGQzX21hcF91bmVzY2FwZShrZXkpLFxuICAgICAgICB2YWx1ZTogdGhpcy5fW2tleV1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgfSxcbiAgICBzaXplOiBkM19tYXBfc2l6ZSxcbiAgICBlbXB0eTogZDNfbWFwX2VtcHR5LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGYpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIGYuY2FsbCh0aGlzLCBkM19tYXBfdW5lc2NhcGUoa2V5KSwgdGhpcy5fW2tleV0pO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIGQzX21hcF9lc2NhcGUoa2V5KSB7XG4gICAgcmV0dXJuIChrZXkgKz0gXCJcIikgPT09IGQzX21hcF9wcm90byB8fCBrZXlbMF0gPT09IGQzX21hcF96ZXJvID8gZDNfbWFwX3plcm8gKyBrZXkgOiBrZXk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX3VuZXNjYXBlKGtleSkge1xuICAgIHJldHVybiAoa2V5ICs9IFwiXCIpWzBdID09PSBkM19tYXBfemVybyA/IGtleS5zbGljZSgxKSA6IGtleTtcbiAgfVxuICBmdW5jdGlvbiBkM19tYXBfaGFzKGtleSkge1xuICAgIHJldHVybiBkM19tYXBfZXNjYXBlKGtleSkgaW4gdGhpcy5fO1xuICB9XG4gIGZ1bmN0aW9uIGQzX21hcF9yZW1vdmUoa2V5KSB7XG4gICAgcmV0dXJuIChrZXkgPSBkM19tYXBfZXNjYXBlKGtleSkpIGluIHRoaXMuXyAmJiBkZWxldGUgdGhpcy5fW2tleV07XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX2tleXMoKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSBrZXlzLnB1c2goZDNfbWFwX3VuZXNjYXBlKGtleSkpO1xuICAgIHJldHVybiBrZXlzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX21hcF9zaXplKCkge1xuICAgIHZhciBzaXplID0gMDtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSArK3NpemU7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX2VtcHR5KCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkMy5uZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5lc3QgPSB7fSwga2V5cyA9IFtdLCBzb3J0S2V5cyA9IFtdLCBzb3J0VmFsdWVzLCByb2xsdXA7XG4gICAgZnVuY3Rpb24gbWFwKG1hcFR5cGUsIGFycmF5LCBkZXB0aCkge1xuICAgICAgaWYgKGRlcHRoID49IGtleXMubGVuZ3RoKSByZXR1cm4gcm9sbHVwID8gcm9sbHVwLmNhbGwobmVzdCwgYXJyYXkpIDogc29ydFZhbHVlcyA/IGFycmF5LnNvcnQoc29ydFZhbHVlcykgOiBhcnJheTtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBhcnJheS5sZW5ndGgsIGtleSA9IGtleXNbZGVwdGgrK10sIGtleVZhbHVlLCBvYmplY3QsIHNldHRlciwgdmFsdWVzQnlLZXkgPSBuZXcgZDNfTWFwKCksIHZhbHVlcztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgPSB2YWx1ZXNCeUtleS5nZXQoa2V5VmFsdWUgPSBrZXkob2JqZWN0ID0gYXJyYXlbaV0pKSkge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKG9iamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVzQnlLZXkuc2V0KGtleVZhbHVlLCBbIG9iamVjdCBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1hcFR5cGUpIHtcbiAgICAgICAgb2JqZWN0ID0gbWFwVHlwZSgpO1xuICAgICAgICBzZXR0ZXIgPSBmdW5jdGlvbihrZXlWYWx1ZSwgdmFsdWVzKSB7XG4gICAgICAgICAgb2JqZWN0LnNldChrZXlWYWx1ZSwgbWFwKG1hcFR5cGUsIHZhbHVlcywgZGVwdGgpKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdCA9IHt9O1xuICAgICAgICBzZXR0ZXIgPSBmdW5jdGlvbihrZXlWYWx1ZSwgdmFsdWVzKSB7XG4gICAgICAgICAgb2JqZWN0W2tleVZhbHVlXSA9IG1hcChtYXBUeXBlLCB2YWx1ZXMsIGRlcHRoKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhbHVlc0J5S2V5LmZvckVhY2goc2V0dGVyKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVudHJpZXMobWFwLCBkZXB0aCkge1xuICAgICAgaWYgKGRlcHRoID49IGtleXMubGVuZ3RoKSByZXR1cm4gbWFwO1xuICAgICAgdmFyIGFycmF5ID0gW10sIHNvcnRLZXkgPSBzb3J0S2V5c1tkZXB0aCsrXTtcbiAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKGtleSwga2V5TWFwKSB7XG4gICAgICAgIGFycmF5LnB1c2goe1xuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIHZhbHVlczogZW50cmllcyhrZXlNYXAsIGRlcHRoKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvcnRLZXkgPyBhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRLZXkoYS5rZXksIGIua2V5KTtcbiAgICAgIH0pIDogYXJyYXk7XG4gICAgfVxuICAgIG5lc3QubWFwID0gZnVuY3Rpb24oYXJyYXksIG1hcFR5cGUpIHtcbiAgICAgIHJldHVybiBtYXAobWFwVHlwZSwgYXJyYXksIDApO1xuICAgIH07XG4gICAgbmVzdC5lbnRyaWVzID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgIHJldHVybiBlbnRyaWVzKG1hcChkMy5tYXAsIGFycmF5LCAwKSwgMCk7XG4gICAgfTtcbiAgICBuZXN0LmtleSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgIGtleXMucHVzaChkKTtcbiAgICAgIHJldHVybiBuZXN0O1xuICAgIH07XG4gICAgbmVzdC5zb3J0S2V5cyA9IGZ1bmN0aW9uKG9yZGVyKSB7XG4gICAgICBzb3J0S2V5c1trZXlzLmxlbmd0aCAtIDFdID0gb3JkZXI7XG4gICAgICByZXR1cm4gbmVzdDtcbiAgICB9O1xuICAgIG5lc3Quc29ydFZhbHVlcyA9IGZ1bmN0aW9uKG9yZGVyKSB7XG4gICAgICBzb3J0VmFsdWVzID0gb3JkZXI7XG4gICAgICByZXR1cm4gbmVzdDtcbiAgICB9O1xuICAgIG5lc3Qucm9sbHVwID0gZnVuY3Rpb24oZikge1xuICAgICAgcm9sbHVwID0gZjtcbiAgICAgIHJldHVybiBuZXN0O1xuICAgIH07XG4gICAgcmV0dXJuIG5lc3Q7XG4gIH07XG4gIGQzLnNldCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHNldCA9IG5ldyBkM19TZXQoKTtcbiAgICBpZiAoYXJyYXkpIGZvciAodmFyIGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoOyBpIDwgbjsgKytpKSBzZXQuYWRkKGFycmF5W2ldKTtcbiAgICByZXR1cm4gc2V0O1xuICB9O1xuICBmdW5jdGlvbiBkM19TZXQoKSB7XG4gICAgdGhpcy5fID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBkM19jbGFzcyhkM19TZXQsIHtcbiAgICBoYXM6IGQzX21hcF9oYXMsXG4gICAgYWRkOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHRoaXMuX1tkM19tYXBfZXNjYXBlKGtleSArPSBcIlwiKV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9LFxuICAgIHJlbW92ZTogZDNfbWFwX3JlbW92ZSxcbiAgICB2YWx1ZXM6IGQzX21hcF9rZXlzLFxuICAgIHNpemU6IGQzX21hcF9zaXplLFxuICAgIGVtcHR5OiBkM19tYXBfZW1wdHksXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oZikge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgZi5jYWxsKHRoaXMsIGQzX21hcF91bmVzY2FwZShrZXkpKTtcbiAgICB9XG4gIH0pO1xuICBkMy5iZWhhdmlvciA9IHt9O1xuICBmdW5jdGlvbiBkM19pZGVudGl0eShkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH1cbiAgZDMucmViaW5kID0gZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgICB2YXIgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBtZXRob2Q7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRhcmdldFttZXRob2QgPSBhcmd1bWVudHNbaV1dID0gZDNfcmViaW5kKHRhcmdldCwgc291cmNlLCBzb3VyY2VbbWV0aG9kXSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfcmViaW5kKHRhcmdldCwgc291cmNlLCBtZXRob2QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsdWUgPSBtZXRob2QuYXBwbHkoc291cmNlLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBzb3VyY2UgPyB0YXJnZXQgOiB2YWx1ZTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3ZlbmRvclN5bWJvbChvYmplY3QsIG5hbWUpIHtcbiAgICBpZiAobmFtZSBpbiBvYmplY3QpIHJldHVybiBuYW1lO1xuICAgIG5hbWUgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGQzX3ZlbmRvclByZWZpeGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIHByZWZpeE5hbWUgPSBkM192ZW5kb3JQcmVmaXhlc1tpXSArIG5hbWU7XG4gICAgICBpZiAocHJlZml4TmFtZSBpbiBvYmplY3QpIHJldHVybiBwcmVmaXhOYW1lO1xuICAgIH1cbiAgfVxuICB2YXIgZDNfdmVuZG9yUHJlZml4ZXMgPSBbIFwid2Via2l0XCIsIFwibXNcIiwgXCJtb3pcIiwgXCJNb3pcIiwgXCJvXCIsIFwiT1wiIF07XG4gIGZ1bmN0aW9uIGQzX25vb3AoKSB7fVxuICBkMy5kaXNwYXRjaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkaXNwYXRjaCA9IG5ldyBkM19kaXNwYXRjaCgpLCBpID0gLTEsIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBkaXNwYXRjaFthcmd1bWVudHNbaV1dID0gZDNfZGlzcGF0Y2hfZXZlbnQoZGlzcGF0Y2gpO1xuICAgIHJldHVybiBkaXNwYXRjaDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZGlzcGF0Y2goKSB7fVxuICBkM19kaXNwYXRjaC5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciBpID0gdHlwZS5pbmRleE9mKFwiLlwiKSwgbmFtZSA9IFwiXCI7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgbmFtZSA9IHR5cGUuc2xpY2UoaSArIDEpO1xuICAgICAgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSk7XG4gICAgfVxuICAgIGlmICh0eXBlKSByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB0aGlzW3R5cGVdLm9uKG5hbWUpIDogdGhpc1t0eXBlXS5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSBmb3IgKHR5cGUgaW4gdGhpcykge1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhpc1t0eXBlXS5vbihuYW1lLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZGlzcGF0Y2hfZXZlbnQoZGlzcGF0Y2gpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gW10sIGxpc3RlbmVyQnlOYW1lID0gbmV3IGQzX01hcCgpO1xuICAgIGZ1bmN0aW9uIGV2ZW50KCkge1xuICAgICAgdmFyIHogPSBsaXN0ZW5lcnMsIGkgPSAtMSwgbiA9IHoubGVuZ3RoLCBsO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChsID0geltpXS5vbikgbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoO1xuICAgIH1cbiAgICBldmVudC5vbiA9IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbCA9IGxpc3RlbmVyQnlOYW1lLmdldChuYW1lKSwgaTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIGwgJiYgbC5vbjtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIGwub24gPSBudWxsO1xuICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoMCwgaSA9IGxpc3RlbmVycy5pbmRleE9mKGwpKS5jb25jYXQobGlzdGVuZXJzLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgIGxpc3RlbmVyQnlOYW1lLnJlbW92ZShuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaXN0ZW5lcikgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXJCeU5hbWUuc2V0KG5hbWUsIHtcbiAgICAgICAgb246IGxpc3RlbmVyXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2g7XG4gICAgfTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgZDMuZXZlbnQgPSBudWxsO1xuICBmdW5jdGlvbiBkM19ldmVudFByZXZlbnREZWZhdWx0KCkge1xuICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZXZlbnRTb3VyY2UoKSB7XG4gICAgdmFyIGUgPSBkMy5ldmVudCwgcztcbiAgICB3aGlsZSAocyA9IGUuc291cmNlRXZlbnQpIGUgPSBzO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2V2ZW50RGlzcGF0Y2godGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoID0gbmV3IGQzX2Rpc3BhdGNoKCksIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgZGlzcGF0Y2hbYXJndW1lbnRzW2ldXSA9IGQzX2Rpc3BhdGNoX2V2ZW50KGRpc3BhdGNoKTtcbiAgICBkaXNwYXRjaC5vZiA9IGZ1bmN0aW9uKHRoaXosIGFyZ3VtZW50eikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUxKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGUwID0gZTEuc291cmNlRXZlbnQgPSBkMy5ldmVudDtcbiAgICAgICAgICBlMS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgZDMuZXZlbnQgPSBlMTtcbiAgICAgICAgICBkaXNwYXRjaFtlMS50eXBlXS5hcHBseSh0aGl6LCBhcmd1bWVudHopO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGQzLmV2ZW50ID0gZTA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gZGlzcGF0Y2g7XG4gIH1cbiAgZDMucmVxdW90ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKGQzX3JlcXVvdGVfcmUsIFwiXFxcXCQmXCIpO1xuICB9O1xuICB2YXIgZDNfcmVxdW90ZV9yZSA9IC9bXFxcXFxcXlxcJFxcKlxcK1xcP1xcfFxcW1xcXVxcKFxcKVxcLlxce1xcfV0vZztcbiAgdmFyIGQzX3N1YmNsYXNzID0ge30uX19wcm90b19fID8gZnVuY3Rpb24ob2JqZWN0LCBwcm90b3R5cGUpIHtcbiAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlO1xuICB9IDogZnVuY3Rpb24ob2JqZWN0LCBwcm90b3R5cGUpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBwcm90b3R5cGUpIG9iamVjdFtwcm9wZXJ0eV0gPSBwcm90b3R5cGVbcHJvcGVydHldO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb24oZ3JvdXBzKSB7XG4gICAgZDNfc3ViY2xhc3MoZ3JvdXBzLCBkM19zZWxlY3Rpb25Qcm90b3R5cGUpO1xuICAgIHJldHVybiBncm91cHM7XG4gIH1cbiAgdmFyIGQzX3NlbGVjdCA9IGZ1bmN0aW9uKHMsIG4pIHtcbiAgICByZXR1cm4gbi5xdWVyeVNlbGVjdG9yKHMpO1xuICB9LCBkM19zZWxlY3RBbGwgPSBmdW5jdGlvbihzLCBuKSB7XG4gICAgcmV0dXJuIG4ucXVlcnlTZWxlY3RvckFsbChzKTtcbiAgfSwgZDNfc2VsZWN0TWF0Y2hlcyA9IGZ1bmN0aW9uKG4sIHMpIHtcbiAgICB2YXIgZDNfc2VsZWN0TWF0Y2hlciA9IG4ubWF0Y2hlcyB8fCBuW2QzX3ZlbmRvclN5bWJvbChuLCBcIm1hdGNoZXNTZWxlY3RvclwiKV07XG4gICAgZDNfc2VsZWN0TWF0Y2hlcyA9IGZ1bmN0aW9uKG4sIHMpIHtcbiAgICAgIHJldHVybiBkM19zZWxlY3RNYXRjaGVyLmNhbGwobiwgcyk7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfc2VsZWN0TWF0Y2hlcyhuLCBzKTtcbiAgfTtcbiAgaWYgKHR5cGVvZiBTaXp6bGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGQzX3NlbGVjdCA9IGZ1bmN0aW9uKHMsIG4pIHtcbiAgICAgIHJldHVybiBTaXp6bGUocywgbilbMF0gfHwgbnVsbDtcbiAgICB9O1xuICAgIGQzX3NlbGVjdEFsbCA9IFNpenpsZTtcbiAgICBkM19zZWxlY3RNYXRjaGVzID0gU2l6emxlLm1hdGNoZXNTZWxlY3RvcjtcbiAgfVxuICBkMy5zZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuc2VsZWN0KGQzX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gIH07XG4gIHZhciBkM19zZWxlY3Rpb25Qcm90b3R5cGUgPSBkMy5zZWxlY3Rpb24ucHJvdG90eXBlID0gW107XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIHN1Ym5vZGUsIGdyb3VwLCBub2RlO1xuICAgIHNlbGVjdG9yID0gZDNfc2VsZWN0aW9uX3NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIHN1Ymdyb3VwLnBhcmVudE5vZGUgPSAoZ3JvdXAgPSB0aGlzW2pdKS5wYXJlbnROb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IC0xLCBuID0gZ3JvdXAubGVuZ3RoOyArK2kgPCBuOyApIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2goc3Vibm9kZSA9IHNlbGVjdG9yLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpO1xuICAgICAgICAgIGlmIChzdWJub2RlICYmIFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM19zZWxlY3Rpb24oc3ViZ3JvdXBzKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX3NlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiID8gc2VsZWN0b3IgOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zZWxlY3Qoc2VsZWN0b3IsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnNlbGVjdEFsbCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgdmFyIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgbm9kZTtcbiAgICBzZWxlY3RvciA9IGQzX3NlbGVjdGlvbl9zZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBkM19hcnJheShzZWxlY3Rvci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKSk7XG4gICAgICAgICAgc3ViZ3JvdXAucGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbihzdWJncm91cHMpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fc2VsZWN0b3JBbGwoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgPyBzZWxlY3RvciA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NlbGVjdEFsbChzZWxlY3RvciwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfbnNYaHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuICB2YXIgZDNfbnNQcmVmaXggPSB7XG4gICAgc3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgeGh0bWw6IGQzX25zWGh0bWwsXG4gICAgeGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgIHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG4gIH07XG4gIGQzLm5zID0ge1xuICAgIHByZWZpeDogZDNfbnNQcmVmaXgsXG4gICAgcXVhbGlmeTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGkgPSBuYW1lLmluZGV4T2YoXCI6XCIpLCBwcmVmaXggPSBuYW1lO1xuICAgICAgaWYgKGkgPj0gMCAmJiAocHJlZml4ID0gbmFtZS5zbGljZSgwLCBpKSkgIT09IFwieG1sbnNcIikgbmFtZSA9IG5hbWUuc2xpY2UoaSArIDEpO1xuICAgICAgcmV0dXJuIGQzX25zUHJlZml4Lmhhc093blByb3BlcnR5KHByZWZpeCkgPyB7XG4gICAgICAgIHNwYWNlOiBkM19uc1ByZWZpeFtwcmVmaXhdLFxuICAgICAgICBsb2NhbDogbmFtZVxuICAgICAgfSA6IG5hbWU7XG4gICAgfVxuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuYXR0ciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICAgICAgbmFtZSA9IGQzLm5zLnF1YWxpZnkobmFtZSk7XG4gICAgICAgIHJldHVybiBuYW1lLmxvY2FsID8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKSA6IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgfVxuICAgICAgZm9yICh2YWx1ZSBpbiBuYW1lKSB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX2F0dHIodmFsdWUsIG5hbWVbdmFsdWVdKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fYXR0cihuYW1lLCB2YWx1ZSkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fYXR0cihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBkMy5ucy5xdWFsaWZ5KG5hbWUpO1xuICAgIGZ1bmN0aW9uIGF0dHJOdWxsKCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJOdWxsTlMoKSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyQ29uc3RhbnQoKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJGdW5jdGlvbigpIHtcbiAgICAgIHZhciB4ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh4ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpOyBlbHNlIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyRnVuY3Rpb25OUygpIHtcbiAgICAgIHZhciB4ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh4ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCk7IGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsLCB4KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBuYW1lLmxvY2FsID8gYXR0ck51bGxOUyA6IGF0dHJOdWxsIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24gOiBuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfY29sbGFwc2Uocykge1xuICAgIHJldHVybiBzLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuY2xhc3NlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKSwgbiA9IChuYW1lID0gZDNfc2VsZWN0aW9uX2NsYXNzZXMobmFtZSkpLmxlbmd0aCwgaSA9IC0xO1xuICAgICAgICBpZiAodmFsdWUgPSBub2RlLmNsYXNzTGlzdCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIXZhbHVlLmNvbnRhaW5zKG5hbWVbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWQzX3NlbGVjdGlvbl9jbGFzc2VkUmUobmFtZVtpXSkudGVzdCh2YWx1ZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFsdWUgaW4gbmFtZSkgdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9jbGFzc2VkKHZhbHVlLCBuYW1lW3ZhbHVlXSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX2NsYXNzZWQobmFtZSwgdmFsdWUpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2NsYXNzZWRSZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpefFxcXFxzKylcIiArIGQzLnJlcXVvdGUobmFtZSkgKyBcIig/OlxcXFxzK3wkKVwiLCBcImdcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2NsYXNzZXMobmFtZSkge1xuICAgIHJldHVybiAobmFtZSArIFwiXCIpLnRyaW0oKS5zcGxpdCgvXnxcXHMrLyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2NsYXNzZWQobmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gZDNfc2VsZWN0aW9uX2NsYXNzZXMobmFtZSkubWFwKGQzX3NlbGVjdGlvbl9jbGFzc2VkTmFtZSk7XG4gICAgdmFyIG4gPSBuYW1lLmxlbmd0aDtcbiAgICBmdW5jdGlvbiBjbGFzc2VkQ29uc3RhbnQoKSB7XG4gICAgICB2YXIgaSA9IC0xO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIG5hbWVbaV0odGhpcywgdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGFzc2VkRnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IC0xLCB4ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBuYW1lW2ldKHRoaXMsIHgpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjbGFzc2VkRnVuY3Rpb24gOiBjbGFzc2VkQ29uc3RhbnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2NsYXNzZWROYW1lKG5hbWUpIHtcbiAgICB2YXIgcmUgPSBkM19zZWxlY3Rpb25fY2xhc3NlZFJlKG5hbWUpO1xuICAgIHJldHVybiBmdW5jdGlvbihub2RlLCB2YWx1ZSkge1xuICAgICAgaWYgKGMgPSBub2RlLmNsYXNzTGlzdCkgcmV0dXJuIHZhbHVlID8gYy5hZGQobmFtZSkgOiBjLnJlbW92ZShuYW1lKTtcbiAgICAgIHZhciBjID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGlmICghcmUudGVzdChjKSkgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBkM19jb2xsYXBzZShjICsgXCIgXCIgKyBuYW1lKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGQzX2NvbGxhcHNlKGMucmVwbGFjZShyZSwgXCIgXCIpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc3R5bGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKG4gPCAzKSB7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKG4gPCAyKSB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIGZvciAocHJpb3JpdHkgaW4gbmFtZSkgdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9zdHlsZShwcmlvcml0eSwgbmFtZVtwcmlvcml0eV0sIHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCAyKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG4gICAgICAgIHJldHVybiBkM193aW5kb3cobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICAgICAgfVxuICAgICAgcHJpb3JpdHkgPSBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9zdHlsZShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX3N0eWxlKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICAgIGZ1bmN0aW9uIHN0eWxlTnVsbCgpIHtcbiAgICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQoKSB7XG4gICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlLCBwcmlvcml0eSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoeCA9PSBudWxsKSB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpOyBlbHNlIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgeCwgcHJpb3JpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHN0eWxlTnVsbCA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gc3R5bGVGdW5jdGlvbiA6IHN0eWxlQ29uc3RhbnQ7XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnByb3BlcnR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHRoaXMubm9kZSgpW25hbWVdO1xuICAgICAgZm9yICh2YWx1ZSBpbiBuYW1lKSB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX3Byb3BlcnR5KHZhbHVlLCBuYW1lW3ZhbHVlXSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX3Byb3BlcnR5KG5hbWUsIHZhbHVlKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9wcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5TnVsbCgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KCkge1xuICAgICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eUZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHggPT0gbnVsbCkgZGVsZXRlIHRoaXNbbmFtZV07IGVsc2UgdGhpc1tuYW1lXSA9IHg7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gcHJvcGVydHlOdWxsIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBwcm9wZXJ0eUZ1bmN0aW9uIDogcHJvcGVydHlDb25zdGFudDtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmVhY2godHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMudGV4dENvbnRlbnQgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgICB9IDogdmFsdWUgPT0gbnVsbCA/IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgIH0pIDogdGhpcy5ub2RlKCkudGV4dENvbnRlbnQ7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuZWFjaCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5pbm5lckhUTUwgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgICB9IDogdmFsdWUgPT0gbnVsbCA/IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgfSkgOiB0aGlzLm5vZGUoKS5pbm5lckhUTUw7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgbmFtZSA9IGQzX3NlbGVjdGlvbl9jcmVhdG9yKG5hbWUpO1xuICAgIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKG5hbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9jcmVhdG9yKG5hbWUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQsIG5hbWVzcGFjZSA9IHRoaXMubmFtZXNwYWNlVVJJO1xuICAgICAgcmV0dXJuIG5hbWVzcGFjZSA9PT0gZDNfbnNYaHRtbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBkM19uc1hodG1sID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIG5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVOUygpIHtcbiAgICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiAobmFtZSA9IGQzLm5zLnF1YWxpZnkobmFtZSkpLmxvY2FsID8gY3JlYXRlTlMgOiBjcmVhdGU7XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKG5hbWUsIGJlZm9yZSkge1xuICAgIG5hbWUgPSBkM19zZWxlY3Rpb25fY3JlYXRvcihuYW1lKTtcbiAgICBiZWZvcmUgPSBkM19zZWxlY3Rpb25fc2VsZWN0b3IoYmVmb3JlKTtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUobmFtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBiZWZvcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCBudWxsKTtcbiAgICB9KTtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uUmVtb3ZlKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uUmVtb3ZlKCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHZhciBpID0gLTEsIG4gPSB0aGlzLmxlbmd0aCwgZ3JvdXAsIG5vZGU7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBBcnJheShuID0gKGdyb3VwID0gdGhpc1swXSkubGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICB2YWx1ZVtpXSA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmluZChncm91cCwgZ3JvdXBEYXRhKSB7XG4gICAgICB2YXIgaSwgbiA9IGdyb3VwLmxlbmd0aCwgbSA9IGdyb3VwRGF0YS5sZW5ndGgsIG4wID0gTWF0aC5taW4obiwgbSksIHVwZGF0ZU5vZGVzID0gbmV3IEFycmF5KG0pLCBlbnRlck5vZGVzID0gbmV3IEFycmF5KG0pLCBleGl0Tm9kZXMgPSBuZXcgQXJyYXkobiksIG5vZGUsIG5vZGVEYXRhO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgbm9kZUJ5S2V5VmFsdWUgPSBuZXcgZDNfTWFwKCksIGtleVZhbHVlcyA9IG5ldyBBcnJheShuKSwga2V5VmFsdWU7XG4gICAgICAgIGZvciAoaSA9IC0xOyArK2kgPCBuOyApIHtcbiAgICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgICBpZiAobm9kZUJ5S2V5VmFsdWUuaGFzKGtleVZhbHVlID0ga2V5LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSkpKSB7XG4gICAgICAgICAgICAgIGV4aXROb2Rlc1tpXSA9IG5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlQnlLZXlWYWx1ZS5zZXQoa2V5VmFsdWUsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5VmFsdWVzW2ldID0ga2V5VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IC0xOyArK2kgPCBtOyApIHtcbiAgICAgICAgICBpZiAoIShub2RlID0gbm9kZUJ5S2V5VmFsdWUuZ2V0KGtleVZhbHVlID0ga2V5LmNhbGwoZ3JvdXBEYXRhLCBub2RlRGF0YSA9IGdyb3VwRGF0YVtpXSwgaSkpKSkge1xuICAgICAgICAgICAgZW50ZXJOb2Rlc1tpXSA9IGQzX3NlbGVjdGlvbl9kYXRhTm9kZShub2RlRGF0YSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB1cGRhdGVOb2Rlc1tpXSA9IG5vZGU7XG4gICAgICAgICAgICBub2RlLl9fZGF0YV9fID0gbm9kZURhdGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGVCeUtleVZhbHVlLnNldChrZXlWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gLTE7ICsraSA8IG47ICkge1xuICAgICAgICAgIGlmIChpIGluIGtleVZhbHVlcyAmJiBub2RlQnlLZXlWYWx1ZS5nZXQoa2V5VmFsdWVzW2ldKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgZXhpdE5vZGVzW2ldID0gZ3JvdXBbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAtMTsgKytpIDwgbjA7ICkge1xuICAgICAgICAgIG5vZGUgPSBncm91cFtpXTtcbiAgICAgICAgICBub2RlRGF0YSA9IGdyb3VwRGF0YVtpXTtcbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5fX2RhdGFfXyA9IG5vZGVEYXRhO1xuICAgICAgICAgICAgdXBkYXRlTm9kZXNbaV0gPSBub2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnRlck5vZGVzW2ldID0gZDNfc2VsZWN0aW9uX2RhdGFOb2RlKG5vZGVEYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7aSA8IG07ICsraSkge1xuICAgICAgICAgIGVudGVyTm9kZXNbaV0gPSBkM19zZWxlY3Rpb25fZGF0YU5vZGUoZ3JvdXBEYXRhW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDtpIDwgbjsgKytpKSB7XG4gICAgICAgICAgZXhpdE5vZGVzW2ldID0gZ3JvdXBbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVudGVyTm9kZXMudXBkYXRlID0gdXBkYXRlTm9kZXM7XG4gICAgICBlbnRlck5vZGVzLnBhcmVudE5vZGUgPSB1cGRhdGVOb2Rlcy5wYXJlbnROb2RlID0gZXhpdE5vZGVzLnBhcmVudE5vZGUgPSBncm91cC5wYXJlbnROb2RlO1xuICAgICAgZW50ZXIucHVzaChlbnRlck5vZGVzKTtcbiAgICAgIHVwZGF0ZS5wdXNoKHVwZGF0ZU5vZGVzKTtcbiAgICAgIGV4aXQucHVzaChleGl0Tm9kZXMpO1xuICAgIH1cbiAgICB2YXIgZW50ZXIgPSBkM19zZWxlY3Rpb25fZW50ZXIoW10pLCB1cGRhdGUgPSBkM19zZWxlY3Rpb24oW10pLCBleGl0ID0gZDNfc2VsZWN0aW9uKFtdKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGJpbmQoZ3JvdXAgPSB0aGlzW2ldLCB2YWx1ZS5jYWxsKGdyb3VwLCBncm91cC5wYXJlbnROb2RlLl9fZGF0YV9fLCBpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGJpbmQoZ3JvdXAgPSB0aGlzW2ldLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZS5lbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudGVyO1xuICAgIH07XG4gICAgdXBkYXRlLmV4aXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleGl0O1xuICAgIH07XG4gICAgcmV0dXJuIHVwZGF0ZTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2RhdGFOb2RlKGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX19kYXRhX186IGRhdGFcbiAgICB9O1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5kYXR1bSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgdmFsdWUpIDogdGhpcy5wcm9wZXJ0eShcIl9fZGF0YV9fXCIpO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgdmFyIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgZ3JvdXAsIG5vZGU7XG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgIT09IFwiZnVuY3Rpb25cIikgZmlsdGVyID0gZDNfc2VsZWN0aW9uX2ZpbHRlcihmaWx0ZXIpO1xuICAgIGZvciAodmFyIGogPSAwLCBtID0gdGhpcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgc3ViZ3JvdXAucGFyZW50Tm9kZSA9IChncm91cCA9IHRoaXNbal0pLnBhcmVudE5vZGU7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgZmlsdGVyLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM19zZWxlY3Rpb24oc3ViZ3JvdXBzKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2ZpbHRlcihzZWxlY3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zZWxlY3RNYXRjaGVzKHRoaXMsIHNlbGVjdG9yKTtcbiAgICB9O1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5vcmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IGdyb3VwLmxlbmd0aCAtIDEsIG5leHQgPSBncm91cFtpXSwgbm9kZTsgLS1pID49IDA7ICkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgaWYgKG5leHQgJiYgbmV4dCAhPT0gbm9kZS5uZXh0U2libGluZykgbmV4dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBuZXh0KTtcbiAgICAgICAgICBuZXh0ID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihjb21wYXJhdG9yKSB7XG4gICAgY29tcGFyYXRvciA9IGQzX3NlbGVjdGlvbl9zb3J0Q29tcGFyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHRoaXNbal0uc29ydChjb21wYXJhdG9yKTtcbiAgICByZXR1cm4gdGhpcy5vcmRlcigpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fc29ydENvbXBhcmF0b3IoY29tcGFyYXRvcikge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgY29tcGFyYXRvciA9IGQzX2FzY2VuZGluZztcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgJiYgYiA/IGNvbXBhcmF0b3IoYS5fX2RhdGFfXywgYi5fX2RhdGFfXykgOiAhYSAtICFiO1xuICAgIH07XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCBmdW5jdGlvbihub2RlLCBpLCBqKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopO1xuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fZWFjaChncm91cHMsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2sobm9kZSwgaSwgaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncm91cHM7XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBhcmdzID0gZDNfYXJyYXkoYXJndW1lbnRzKTtcbiAgICBjYWxsYmFjay5hcHBseShhcmdzWzBdID0gdGhpcywgYXJncyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5ub2RlKCk7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaiA9IDAsIG0gPSB0aGlzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGdyb3VwW2ldO1xuICAgICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gMDtcbiAgICBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICsrbjtcbiAgICB9KTtcbiAgICByZXR1cm4gbjtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2VudGVyKHNlbGVjdGlvbikge1xuICAgIGQzX3N1YmNsYXNzKHNlbGVjdGlvbiwgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlKTtcbiAgICByZXR1cm4gc2VsZWN0aW9uO1xuICB9XG4gIHZhciBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUgPSBbXTtcbiAgZDMuc2VsZWN0aW9uLmVudGVyID0gZDNfc2VsZWN0aW9uX2VudGVyO1xuICBkMy5zZWxlY3Rpb24uZW50ZXIucHJvdG90eXBlID0gZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlO1xuICBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuYXBwZW5kID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLmFwcGVuZDtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLmVtcHR5ID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLmVtcHR5O1xuICBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUubm9kZSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5ub2RlO1xuICBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuY2FsbCA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5jYWxsO1xuICBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuc2l6ZSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5zaXplO1xuICBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBzdWJub2RlLCB1cGdyb3VwLCBncm91cCwgbm9kZTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICB1cGdyb3VwID0gKGdyb3VwID0gdGhpc1tqXSkudXBkYXRlO1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBzdWJncm91cC5wYXJlbnROb2RlID0gZ3JvdXAucGFyZW50Tm9kZTtcbiAgICAgIGZvciAodmFyIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjsgKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKHVwZ3JvdXBbaV0gPSBzdWJub2RlID0gc2VsZWN0b3IuY2FsbChncm91cC5wYXJlbnROb2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSk7XG4gICAgICAgICAgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKHN1Ymdyb3Vwcyk7XG4gIH07XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihuYW1lLCBiZWZvcmUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIGJlZm9yZSA9IGQzX3NlbGVjdGlvbl9lbnRlckluc2VydEJlZm9yZSh0aGlzKTtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uUHJvdG90eXBlLmluc2VydC5jYWxsKHRoaXMsIG5hbWUsIGJlZm9yZSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9lbnRlckluc2VydEJlZm9yZShlbnRlcikge1xuICAgIHZhciBpMCwgajA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGQsIGksIGopIHtcbiAgICAgIHZhciBncm91cCA9IGVudGVyW2pdLnVwZGF0ZSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTtcbiAgICAgIGlmIChqICE9IGowKSBqMCA9IGosIGkwID0gMDtcbiAgICAgIGlmIChpID49IGkwKSBpMCA9IGkgKyAxO1xuICAgICAgd2hpbGUgKCEobm9kZSA9IGdyb3VwW2kwXSkgJiYgKytpMCA8IG4pIDtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gIH1cbiAgZDMuc2VsZWN0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBncm91cDtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGdyb3VwID0gWyBkM19zZWxlY3Qobm9kZSwgZDNfZG9jdW1lbnQpIF07XG4gICAgICBncm91cC5wYXJlbnROb2RlID0gZDNfZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cCA9IFsgbm9kZSBdO1xuICAgICAgZ3JvdXAucGFyZW50Tm9kZSA9IGQzX2RvY3VtZW50RWxlbWVudChub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbihbIGdyb3VwIF0pO1xuICB9O1xuICBkMy5zZWxlY3RBbGwgPSBmdW5jdGlvbihub2Rlcykge1xuICAgIHZhciBncm91cDtcbiAgICBpZiAodHlwZW9mIG5vZGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBncm91cCA9IGQzX2FycmF5KGQzX3NlbGVjdEFsbChub2RlcywgZDNfZG9jdW1lbnQpKTtcbiAgICAgIGdyb3VwLnBhcmVudE5vZGUgPSBkM19kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwID0gZDNfYXJyYXkobm9kZXMpO1xuICAgICAgZ3JvdXAucGFyZW50Tm9kZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkM19zZWxlY3Rpb24oWyBncm91cCBdKTtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKG4gPCAzKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKG4gPCAyKSBsaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNhcHR1cmUgaW4gdHlwZSkgdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9vbihjYXB0dXJlLCB0eXBlW2NhcHR1cmVdLCBsaXN0ZW5lcikpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgMikgcmV0dXJuIChuID0gdGhpcy5ub2RlKClbXCJfX29uXCIgKyB0eXBlXSkgJiYgbi5fO1xuICAgICAgY2FwdHVyZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9vbih0eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fb24odHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpIHtcbiAgICB2YXIgbmFtZSA9IFwiX19vblwiICsgdHlwZSwgaSA9IHR5cGUuaW5kZXhPZihcIi5cIiksIHdyYXAgPSBkM19zZWxlY3Rpb25fb25MaXN0ZW5lcjtcbiAgICBpZiAoaSA+IDApIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGkpO1xuICAgIHZhciBmaWx0ZXIgPSBkM19zZWxlY3Rpb25fb25GaWx0ZXJzLmdldCh0eXBlKTtcbiAgICBpZiAoZmlsdGVyKSB0eXBlID0gZmlsdGVyLCB3cmFwID0gZDNfc2VsZWN0aW9uX29uRmlsdGVyO1xuICAgIGZ1bmN0aW9uIG9uUmVtb3ZlKCkge1xuICAgICAgdmFyIGwgPSB0aGlzW25hbWVdO1xuICAgICAgaWYgKGwpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGwsIGwuJCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkFkZCgpIHtcbiAgICAgIHZhciBsID0gd3JhcChsaXN0ZW5lciwgZDNfYXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICBvblJlbW92ZS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXNbbmFtZV0gPSBsLCBsLiQgPSBjYXB0dXJlKTtcbiAgICAgIGwuXyA9IGxpc3RlbmVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGwoKSB7XG4gICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiXl9fb24oW14uXSspXCIgKyBkMy5yZXF1b3RlKHR5cGUpICsgXCIkXCIpLCBtYXRjaDtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICBpZiAobWF0Y2ggPSBuYW1lLm1hdGNoKHJlKSkge1xuICAgICAgICAgIHZhciBsID0gdGhpc1tuYW1lXTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIobWF0Y2hbMV0sIGwsIGwuJCk7XG4gICAgICAgICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGkgPyBsaXN0ZW5lciA/IG9uQWRkIDogb25SZW1vdmUgOiBsaXN0ZW5lciA/IGQzX25vb3AgOiByZW1vdmVBbGw7XG4gIH1cbiAgdmFyIGQzX3NlbGVjdGlvbl9vbkZpbHRlcnMgPSBkMy5tYXAoe1xuICAgIG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG4gICAgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwiXG4gIH0pO1xuICBpZiAoZDNfZG9jdW1lbnQpIHtcbiAgICBkM19zZWxlY3Rpb25fb25GaWx0ZXJzLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgaWYgKFwib25cIiArIGsgaW4gZDNfZG9jdW1lbnQpIGQzX3NlbGVjdGlvbl9vbkZpbHRlcnMucmVtb3ZlKGspO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9vbkxpc3RlbmVyKGxpc3RlbmVyLCBhcmd1bWVudHopIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIG8gPSBkMy5ldmVudDtcbiAgICAgIGQzLmV2ZW50ID0gZTtcbiAgICAgIGFyZ3VtZW50elswXSA9IHRoaXMuX19kYXRhX187XG4gICAgICB0cnkge1xuICAgICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHopO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZDMuZXZlbnQgPSBvO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX29uRmlsdGVyKGxpc3RlbmVyLCBhcmd1bWVudHopIHtcbiAgICB2YXIgbCA9IGQzX3NlbGVjdGlvbl9vbkxpc3RlbmVyKGxpc3RlbmVyLCBhcmd1bWVudHopO1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcywgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldDtcbiAgICAgIGlmICghcmVsYXRlZCB8fCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIShyZWxhdGVkLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRhcmdldCkgJiA4KSkge1xuICAgICAgICBsLmNhbGwodGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHZhciBkM19ldmVudF9kcmFnU2VsZWN0LCBkM19ldmVudF9kcmFnSWQgPSAwO1xuICBmdW5jdGlvbiBkM19ldmVudF9kcmFnU3VwcHJlc3Mobm9kZSkge1xuICAgIHZhciBuYW1lID0gXCIuZHJhZ3N1cHByZXNzLVwiICsgKytkM19ldmVudF9kcmFnSWQsIGNsaWNrID0gXCJjbGlja1wiICsgbmFtZSwgdyA9IGQzLnNlbGVjdChkM193aW5kb3cobm9kZSkpLm9uKFwidG91Y2htb3ZlXCIgKyBuYW1lLCBkM19ldmVudFByZXZlbnREZWZhdWx0KS5vbihcImRyYWdzdGFydFwiICsgbmFtZSwgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCkub24oXCJzZWxlY3RzdGFydFwiICsgbmFtZSwgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCk7XG4gICAgaWYgKGQzX2V2ZW50X2RyYWdTZWxlY3QgPT0gbnVsbCkge1xuICAgICAgZDNfZXZlbnRfZHJhZ1NlbGVjdCA9IFwib25zZWxlY3RzdGFydFwiIGluIG5vZGUgPyBmYWxzZSA6IGQzX3ZlbmRvclN5bWJvbChub2RlLnN0eWxlLCBcInVzZXJTZWxlY3RcIik7XG4gICAgfVxuICAgIGlmIChkM19ldmVudF9kcmFnU2VsZWN0KSB7XG4gICAgICB2YXIgc3R5bGUgPSBkM19kb2N1bWVudEVsZW1lbnQobm9kZSkuc3R5bGUsIHNlbGVjdCA9IHN0eWxlW2QzX2V2ZW50X2RyYWdTZWxlY3RdO1xuICAgICAgc3R5bGVbZDNfZXZlbnRfZHJhZ1NlbGVjdF0gPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN1cHByZXNzQ2xpY2spIHtcbiAgICAgIHcub24obmFtZSwgbnVsbCk7XG4gICAgICBpZiAoZDNfZXZlbnRfZHJhZ1NlbGVjdCkgc3R5bGVbZDNfZXZlbnRfZHJhZ1NlbGVjdF0gPSBzZWxlY3Q7XG4gICAgICBpZiAoc3VwcHJlc3NDbGljaykge1xuICAgICAgICB2YXIgb2ZmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdy5vbihjbGljaywgbnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIHcub24oY2xpY2ssIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBvZmYoKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHNldFRpbWVvdXQob2ZmLCAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGQzLm1vdXNlID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGQzX21vdXNlUG9pbnQoY29udGFpbmVyLCBkM19ldmVudFNvdXJjZSgpKTtcbiAgfTtcbiAgdmFyIGQzX21vdXNlX2J1ZzQ0MDgzID0gdGhpcy5uYXZpZ2F0b3IgJiYgL1dlYktpdC8udGVzdCh0aGlzLm5hdmlnYXRvci51c2VyQWdlbnQpID8gLTEgOiAwO1xuICBmdW5jdGlvbiBkM19tb3VzZVBvaW50KGNvbnRhaW5lciwgZSkge1xuICAgIGlmIChlLmNoYW5nZWRUb3VjaGVzKSBlID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICB2YXIgc3ZnID0gY29udGFpbmVyLm93bmVyU1ZHRWxlbWVudCB8fCBjb250YWluZXI7XG4gICAgaWYgKHN2Zy5jcmVhdGVTVkdQb2ludCkge1xuICAgICAgdmFyIHBvaW50ID0gc3ZnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICBpZiAoZDNfbW91c2VfYnVnNDQwODMgPCAwKSB7XG4gICAgICAgIHZhciB3aW5kb3cgPSBkM193aW5kb3coY29udGFpbmVyKTtcbiAgICAgICAgaWYgKHdpbmRvdy5zY3JvbGxYIHx8IHdpbmRvdy5zY3JvbGxZKSB7XG4gICAgICAgICAgc3ZnID0gZDMuc2VsZWN0KFwiYm9keVwiKS5hcHBlbmQoXCJzdmdcIikuc3R5bGUoe1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIlxuICAgICAgICAgIH0sIFwiaW1wb3J0YW50XCIpO1xuICAgICAgICAgIHZhciBjdG0gPSBzdmdbMF1bMF0uZ2V0U2NyZWVuQ1RNKCk7XG4gICAgICAgICAgZDNfbW91c2VfYnVnNDQwODMgPSAhKGN0bS5mIHx8IGN0bS5lKTtcbiAgICAgICAgICBzdmcucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkM19tb3VzZV9idWc0NDA4MykgcG9pbnQueCA9IGUucGFnZVgsIHBvaW50LnkgPSBlLnBhZ2VZOyBlbHNlIHBvaW50LnggPSBlLmNsaWVudFgsIFxuICAgICAgcG9pbnQueSA9IGUuY2xpZW50WTtcbiAgICAgIHBvaW50ID0gcG9pbnQubWF0cml4VHJhbnNmb3JtKGNvbnRhaW5lci5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgICAgcmV0dXJuIFsgcG9pbnQueCwgcG9pbnQueSBdO1xuICAgIH1cbiAgICB2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gWyBlLmNsaWVudFggLSByZWN0LmxlZnQgLSBjb250YWluZXIuY2xpZW50TGVmdCwgZS5jbGllbnRZIC0gcmVjdC50b3AgLSBjb250YWluZXIuY2xpZW50VG9wIF07XG4gIH1cbiAgZDMudG91Y2ggPSBmdW5jdGlvbihjb250YWluZXIsIHRvdWNoZXMsIGlkZW50aWZpZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIGlkZW50aWZpZXIgPSB0b3VjaGVzLCB0b3VjaGVzID0gZDNfZXZlbnRTb3VyY2UoKS5jaGFuZ2VkVG91Y2hlcztcbiAgICBpZiAodG91Y2hlcykgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzLmxlbmd0aCwgdG91Y2g7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgodG91Y2ggPSB0b3VjaGVzW2ldKS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBkM19tb3VzZVBvaW50KGNvbnRhaW5lciwgdG91Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZDMuYmVoYXZpb3IuZHJhZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBldmVudCA9IGQzX2V2ZW50RGlzcGF0Y2goZHJhZywgXCJkcmFnXCIsIFwiZHJhZ3N0YXJ0XCIsIFwiZHJhZ2VuZFwiKSwgb3JpZ2luID0gbnVsbCwgbW91c2Vkb3duID0gZHJhZ3N0YXJ0KGQzX25vb3AsIGQzLm1vdXNlLCBkM193aW5kb3csIFwibW91c2Vtb3ZlXCIsIFwibW91c2V1cFwiKSwgdG91Y2hzdGFydCA9IGRyYWdzdGFydChkM19iZWhhdmlvcl9kcmFnVG91Y2hJZCwgZDMudG91Y2gsIGQzX2lkZW50aXR5LCBcInRvdWNobW92ZVwiLCBcInRvdWNoZW5kXCIpO1xuICAgIGZ1bmN0aW9uIGRyYWcoKSB7XG4gICAgICB0aGlzLm9uKFwibW91c2Vkb3duLmRyYWdcIiwgbW91c2Vkb3duKS5vbihcInRvdWNoc3RhcnQuZHJhZ1wiLCB0b3VjaHN0YXJ0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZHJhZ3N0YXJ0KGlkLCBwb3NpdGlvbiwgc3ViamVjdCwgbW92ZSwgZW5kKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcywgdGFyZ2V0ID0gZDMuZXZlbnQudGFyZ2V0LmNvcnJlc3BvbmRpbmdFbGVtZW50IHx8IGQzLmV2ZW50LnRhcmdldCwgcGFyZW50ID0gdGhhdC5wYXJlbnROb2RlLCBkaXNwYXRjaCA9IGV2ZW50Lm9mKHRoYXQsIGFyZ3VtZW50cyksIGRyYWdnZWQgPSAwLCBkcmFnSWQgPSBpZCgpLCBkcmFnTmFtZSA9IFwiLmRyYWdcIiArIChkcmFnSWQgPT0gbnVsbCA/IFwiXCIgOiBcIi1cIiArIGRyYWdJZCksIGRyYWdPZmZzZXQsIGRyYWdTdWJqZWN0ID0gZDMuc2VsZWN0KHN1YmplY3QodGFyZ2V0KSkub24obW92ZSArIGRyYWdOYW1lLCBtb3ZlZCkub24oZW5kICsgZHJhZ05hbWUsIGVuZGVkKSwgZHJhZ1Jlc3RvcmUgPSBkM19ldmVudF9kcmFnU3VwcHJlc3ModGFyZ2V0KSwgcG9zaXRpb24wID0gcG9zaXRpb24ocGFyZW50LCBkcmFnSWQpO1xuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgZHJhZ09mZnNldCA9IG9yaWdpbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICAgICAgICAgIGRyYWdPZmZzZXQgPSBbIGRyYWdPZmZzZXQueCAtIHBvc2l0aW9uMFswXSwgZHJhZ09mZnNldC55IC0gcG9zaXRpb24wWzFdIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHJhZ09mZnNldCA9IFsgMCwgMCBdO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBcImRyYWdzdGFydFwiXG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBtb3ZlZCgpIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb24xID0gcG9zaXRpb24ocGFyZW50LCBkcmFnSWQpLCBkeCwgZHk7XG4gICAgICAgICAgaWYgKCFwb3NpdGlvbjEpIHJldHVybjtcbiAgICAgICAgICBkeCA9IHBvc2l0aW9uMVswXSAtIHBvc2l0aW9uMFswXTtcbiAgICAgICAgICBkeSA9IHBvc2l0aW9uMVsxXSAtIHBvc2l0aW9uMFsxXTtcbiAgICAgICAgICBkcmFnZ2VkIHw9IGR4IHwgZHk7XG4gICAgICAgICAgcG9zaXRpb24wID0gcG9zaXRpb24xO1xuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZHJhZ1wiLFxuICAgICAgICAgICAgeDogcG9zaXRpb24xWzBdICsgZHJhZ09mZnNldFswXSxcbiAgICAgICAgICAgIHk6IHBvc2l0aW9uMVsxXSArIGRyYWdPZmZzZXRbMV0sXG4gICAgICAgICAgICBkeDogZHgsXG4gICAgICAgICAgICBkeTogZHlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlbmRlZCgpIHtcbiAgICAgICAgICBpZiAoIXBvc2l0aW9uKHBhcmVudCwgZHJhZ0lkKSkgcmV0dXJuO1xuICAgICAgICAgIGRyYWdTdWJqZWN0Lm9uKG1vdmUgKyBkcmFnTmFtZSwgbnVsbCkub24oZW5kICsgZHJhZ05hbWUsIG51bGwpO1xuICAgICAgICAgIGRyYWdSZXN0b3JlKGRyYWdnZWQpO1xuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZHJhZ2VuZFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGRyYWcub3JpZ2luID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JpZ2luO1xuICAgICAgb3JpZ2luID0geDtcbiAgICAgIHJldHVybiBkcmFnO1xuICAgIH07XG4gICAgcmV0dXJuIGQzLnJlYmluZChkcmFnLCBldmVudCwgXCJvblwiKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfYmVoYXZpb3JfZHJhZ1RvdWNoSWQoKSB7XG4gICAgcmV0dXJuIGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmlkZW50aWZpZXI7XG4gIH1cbiAgZDMudG91Y2hlcyA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgdG91Y2hlcykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgdG91Y2hlcyA9IGQzX2V2ZW50U291cmNlKCkudG91Y2hlcztcbiAgICByZXR1cm4gdG91Y2hlcyA/IGQzX2FycmF5KHRvdWNoZXMpLm1hcChmdW5jdGlvbih0b3VjaCkge1xuICAgICAgdmFyIHBvaW50ID0gZDNfbW91c2VQb2ludChjb250YWluZXIsIHRvdWNoKTtcbiAgICAgIHBvaW50LmlkZW50aWZpZXIgPSB0b3VjaC5pZGVudGlmaWVyO1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH0pIDogW107XG4gIH07XG4gIHZhciDOtSA9IDFlLTYsIM61MiA9IM61ICogzrUsIM+AID0gTWF0aC5QSSwgz4QgPSAyICogz4AsIM+EzrUgPSDPhCAtIM61LCBoYWxmz4AgPSDPgCAvIDIsIGQzX3JhZGlhbnMgPSDPgCAvIDE4MCwgZDNfZGVncmVlcyA9IDE4MCAvIM+AO1xuICBmdW5jdGlvbiBkM19zZ24oeCkge1xuICAgIHJldHVybiB4ID4gMCA/IDEgOiB4IDwgMCA/IC0xIDogMDtcbiAgfVxuICBmdW5jdGlvbiBkM19jcm9zczJkKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGJbMF0gLSBhWzBdKSAqIChjWzFdIC0gYVsxXSkgLSAoYlsxXSAtIGFbMV0pICogKGNbMF0gLSBhWzBdKTtcbiAgfVxuICBmdW5jdGlvbiBkM19hY29zKHgpIHtcbiAgICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gz4AgOiBNYXRoLmFjb3MoeCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfYXNpbih4KSB7XG4gICAgcmV0dXJuIHggPiAxID8gaGFsZs+AIDogeCA8IC0xID8gLWhhbGbPgCA6IE1hdGguYXNpbih4KTtcbiAgfVxuICBmdW5jdGlvbiBkM19zaW5oKHgpIHtcbiAgICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpIC0gMSAvIHgpIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBkM19jb3NoKHgpIHtcbiAgICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpICsgMSAvIHgpIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBkM190YW5oKHgpIHtcbiAgICByZXR1cm4gKCh4ID0gTWF0aC5leHAoMiAqIHgpKSAtIDEpIC8gKHggKyAxKTtcbiAgfVxuICBmdW5jdGlvbiBkM19oYXZlcnNpbih4KSB7XG4gICAgcmV0dXJuICh4ID0gTWF0aC5zaW4oeCAvIDIpKSAqIHg7XG4gIH1cbiAgdmFyIM+BID0gTWF0aC5TUVJUMiwgz4EyID0gMiwgz4E0ID0gNDtcbiAgZDMuaW50ZXJwb2xhdGVab29tID0gZnVuY3Rpb24ocDAsIHAxKSB7XG4gICAgdmFyIHV4MCA9IHAwWzBdLCB1eTAgPSBwMFsxXSwgdzAgPSBwMFsyXSwgdXgxID0gcDFbMF0sIHV5MSA9IHAxWzFdLCB3MSA9IHAxWzJdLCBkeCA9IHV4MSAtIHV4MCwgZHkgPSB1eTEgLSB1eTAsIGQyID0gZHggKiBkeCArIGR5ICogZHksIGksIFM7XG4gICAgaWYgKGQyIDwgzrUyKSB7XG4gICAgICBTID0gTWF0aC5sb2codzEgLyB3MCkgLyDPgTtcbiAgICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBbIHV4MCArIHQgKiBkeCwgdXkwICsgdCAqIGR5LCB3MCAqIE1hdGguZXhwKM+BICogdCAqIFMpIF07XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZDEgPSBNYXRoLnNxcnQoZDIpLCBiMCA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIM+BNCAqIGQyKSAvICgyICogdzAgKiDPgTIgKiBkMSksIGIxID0gKHcxICogdzEgLSB3MCAqIHcwIC0gz4E0ICogZDIpIC8gKDIgKiB3MSAqIM+BMiAqIGQxKSwgcjAgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjAgKiBiMCArIDEpIC0gYjApLCByMSA9IE1hdGgubG9nKE1hdGguc3FydChiMSAqIGIxICsgMSkgLSBiMSk7XG4gICAgICBTID0gKHIxIC0gcjApIC8gz4E7XG4gICAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcyA9IHQgKiBTLCBjb3NocjAgPSBkM19jb3NoKHIwKSwgdSA9IHcwIC8gKM+BMiAqIGQxKSAqIChjb3NocjAgKiBkM190YW5oKM+BICogcyArIHIwKSAtIGQzX3NpbmgocjApKTtcbiAgICAgICAgcmV0dXJuIFsgdXgwICsgdSAqIGR4LCB1eTAgKyB1ICogZHksIHcwICogY29zaHIwIC8gZDNfY29zaCjPgSAqIHMgKyByMCkgXTtcbiAgICAgIH07XG4gICAgfVxuICAgIGkuZHVyYXRpb24gPSBTICogMWUzO1xuICAgIHJldHVybiBpO1xuICB9O1xuICBkMy5iZWhhdmlvci56b29tID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZpZXcgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIGs6IDFcbiAgICB9LCB0cmFuc2xhdGUwLCBjZW50ZXIwLCBjZW50ZXIsIHNpemUgPSBbIDk2MCwgNTAwIF0sIHNjYWxlRXh0ZW50ID0gZDNfYmVoYXZpb3Jfem9vbUluZmluaXR5LCBkdXJhdGlvbiA9IDI1MCwgem9vbWluZyA9IDAsIG1vdXNlZG93biA9IFwibW91c2Vkb3duLnpvb21cIiwgbW91c2Vtb3ZlID0gXCJtb3VzZW1vdmUuem9vbVwiLCBtb3VzZXVwID0gXCJtb3VzZXVwLnpvb21cIiwgbW91c2V3aGVlbFRpbWVyLCB0b3VjaHN0YXJ0ID0gXCJ0b3VjaHN0YXJ0Lnpvb21cIiwgdG91Y2h0aW1lLCBldmVudCA9IGQzX2V2ZW50RGlzcGF0Y2goem9vbSwgXCJ6b29tc3RhcnRcIiwgXCJ6b29tXCIsIFwiem9vbWVuZFwiKSwgeDAsIHgxLCB5MCwgeTE7XG4gICAgaWYgKCFkM19iZWhhdmlvcl96b29tV2hlZWwpIHtcbiAgICAgIGQzX2JlaGF2aW9yX3pvb21XaGVlbCA9IFwib253aGVlbFwiIGluIGQzX2RvY3VtZW50ID8gKGQzX2JlaGF2aW9yX3pvb21EZWx0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gLWQzLmV2ZW50LmRlbHRhWSAqIChkMy5ldmVudC5kZWx0YU1vZGUgPyAxMjAgOiAxKTtcbiAgICAgIH0sIFwid2hlZWxcIikgOiBcIm9ubW91c2V3aGVlbFwiIGluIGQzX2RvY3VtZW50ID8gKGQzX2JlaGF2aW9yX3pvb21EZWx0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZDMuZXZlbnQud2hlZWxEZWx0YTtcbiAgICAgIH0sIFwibW91c2V3aGVlbFwiKSA6IChkM19iZWhhdmlvcl96b29tRGVsdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIC1kMy5ldmVudC5kZXRhaWw7XG4gICAgICB9LCBcIk1vek1vdXNlUGl4ZWxTY3JvbGxcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHpvb20oZykge1xuICAgICAgZy5vbihtb3VzZWRvd24sIG1vdXNlZG93bmVkKS5vbihkM19iZWhhdmlvcl96b29tV2hlZWwgKyBcIi56b29tXCIsIG1vdXNld2hlZWxlZCkub24oXCJkYmxjbGljay56b29tXCIsIGRibGNsaWNrZWQpLm9uKHRvdWNoc3RhcnQsIHRvdWNoc3RhcnRlZCk7XG4gICAgfVxuICAgIHpvb20uZXZlbnQgPSBmdW5jdGlvbihnKSB7XG4gICAgICBnLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaXNwYXRjaCA9IGV2ZW50Lm9mKHRoaXMsIGFyZ3VtZW50cyksIHZpZXcxID0gdmlldztcbiAgICAgICAgaWYgKGQzX3RyYW5zaXRpb25Jbmhlcml0SWQpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmVhY2goXCJzdGFydC56b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmlldyA9IHRoaXMuX19jaGFydF9fIHx8IHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgazogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHpvb21zdGFydGVkKGRpc3BhdGNoKTtcbiAgICAgICAgICB9KS50d2VlbihcInpvb206em9vbVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IHNpemVbMF0sIGR5ID0gc2l6ZVsxXSwgY3ggPSBjZW50ZXIwID8gY2VudGVyMFswXSA6IGR4IC8gMiwgY3kgPSBjZW50ZXIwID8gY2VudGVyMFsxXSA6IGR5IC8gMiwgaSA9IGQzLmludGVycG9sYXRlWm9vbShbIChjeCAtIHZpZXcueCkgLyB2aWV3LmssIChjeSAtIHZpZXcueSkgLyB2aWV3LmssIGR4IC8gdmlldy5rIF0sIFsgKGN4IC0gdmlldzEueCkgLyB2aWV3MS5rLCAoY3kgLSB2aWV3MS55KSAvIHZpZXcxLmssIGR4IC8gdmlldzEuayBdKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgIHZhciBsID0gaSh0KSwgayA9IGR4IC8gbFsyXTtcbiAgICAgICAgICAgICAgdGhpcy5fX2NoYXJ0X18gPSB2aWV3ID0ge1xuICAgICAgICAgICAgICAgIHg6IGN4IC0gbFswXSAqIGssXG4gICAgICAgICAgICAgICAgeTogY3kgLSBsWzFdICogayxcbiAgICAgICAgICAgICAgICBrOiBrXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHpvb21lZChkaXNwYXRjaCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLmVhY2goXCJpbnRlcnJ1cHQuem9vbVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHpvb21lbmRlZChkaXNwYXRjaCk7XG4gICAgICAgICAgfSkuZWFjaChcImVuZC56b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgem9vbWVuZGVkKGRpc3BhdGNoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fY2hhcnRfXyA9IHZpZXc7XG4gICAgICAgICAgem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpO1xuICAgICAgICAgIHpvb21lZChkaXNwYXRjaCk7XG4gICAgICAgICAgem9vbWVuZGVkKGRpc3BhdGNoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB6b29tLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgdmlldy54LCB2aWV3LnkgXTtcbiAgICAgIHZpZXcgPSB7XG4gICAgICAgIHg6ICtfWzBdLFxuICAgICAgICB5OiArX1sxXSxcbiAgICAgICAgazogdmlldy5rXG4gICAgICB9O1xuICAgICAgcmVzY2FsZSgpO1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmlldy5rO1xuICAgICAgdmlldyA9IHtcbiAgICAgICAgeDogdmlldy54LFxuICAgICAgICB5OiB2aWV3LnksXG4gICAgICAgIGs6IG51bGxcbiAgICAgIH07XG4gICAgICBzY2FsZVRvKCtfKTtcbiAgICAgIHJlc2NhbGUoKTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS5zY2FsZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNjYWxlRXh0ZW50O1xuICAgICAgc2NhbGVFeHRlbnQgPSBfID09IG51bGwgPyBkM19iZWhhdmlvcl96b29tSW5maW5pdHkgOiBbICtfWzBdLCArX1sxXSBdO1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNlbnRlcjtcbiAgICAgIGNlbnRlciA9IF8gJiYgWyArX1swXSwgK19bMV0gXTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS5zaXplID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSBfICYmIFsgK19bMF0sICtfWzFdIF07XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20uZHVyYXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkdXJhdGlvbjtcbiAgICAgIGR1cmF0aW9uID0gK187XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20ueCA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxO1xuICAgICAgeDEgPSB6O1xuICAgICAgeDAgPSB6LmNvcHkoKTtcbiAgICAgIHZpZXcgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIGs6IDFcbiAgICAgIH07XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20ueSA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHkxO1xuICAgICAgeTEgPSB6O1xuICAgICAgeTAgPSB6LmNvcHkoKTtcbiAgICAgIHZpZXcgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIGs6IDFcbiAgICAgIH07XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxvY2F0aW9uKHApIHtcbiAgICAgIHJldHVybiBbIChwWzBdIC0gdmlldy54KSAvIHZpZXcuaywgKHBbMV0gLSB2aWV3LnkpIC8gdmlldy5rIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50KGwpIHtcbiAgICAgIHJldHVybiBbIGxbMF0gKiB2aWV3LmsgKyB2aWV3LngsIGxbMV0gKiB2aWV3LmsgKyB2aWV3LnkgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGVUbyhzKSB7XG4gICAgICB2aWV3LmsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIHMpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlVG8ocCwgbCkge1xuICAgICAgbCA9IHBvaW50KGwpO1xuICAgICAgdmlldy54ICs9IHBbMF0gLSBsWzBdO1xuICAgICAgdmlldy55ICs9IHBbMV0gLSBsWzFdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6b29tVG8odGhhdCwgcCwgbCwgaykge1xuICAgICAgdGhhdC5fX2NoYXJ0X18gPSB7XG4gICAgICAgIHg6IHZpZXcueCxcbiAgICAgICAgeTogdmlldy55LFxuICAgICAgICBrOiB2aWV3LmtcbiAgICAgIH07XG4gICAgICBzY2FsZVRvKE1hdGgucG93KDIsIGspKTtcbiAgICAgIHRyYW5zbGF0ZVRvKGNlbnRlcjAgPSBwLCBsKTtcbiAgICAgIHRoYXQgPSBkMy5zZWxlY3QodGhhdCk7XG4gICAgICBpZiAoZHVyYXRpb24gPiAwKSB0aGF0ID0gdGhhdC50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgdGhhdC5jYWxsKHpvb20uZXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgICAgaWYgKHgxKSB4MS5kb21haW4oeDAucmFuZ2UoKS5tYXAoZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gKHggLSB2aWV3LngpIC8gdmlldy5rO1xuICAgICAgfSkubWFwKHgwLmludmVydCkpO1xuICAgICAgaWYgKHkxKSB5MS5kb21haW4oeTAucmFuZ2UoKS5tYXAoZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gKHkgLSB2aWV3LnkpIC8gdmlldy5rO1xuICAgICAgfSkubWFwKHkwLmludmVydCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6b29tc3RhcnRlZChkaXNwYXRjaCkge1xuICAgICAgaWYgKCF6b29taW5nKyspIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogXCJ6b29tc3RhcnRcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHpvb21lZChkaXNwYXRjaCkge1xuICAgICAgcmVzY2FsZSgpO1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcInpvb21cIixcbiAgICAgICAgc2NhbGU6IHZpZXcuayxcbiAgICAgICAgdHJhbnNsYXRlOiBbIHZpZXcueCwgdmlldy55IF1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6b29tZW5kZWQoZGlzcGF0Y2gpIHtcbiAgICAgIGlmICghLS16b29taW5nKSBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFwiem9vbWVuZFwiXG4gICAgICB9KSwgY2VudGVyMCA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdXNlZG93bmVkKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLCBkaXNwYXRjaCA9IGV2ZW50Lm9mKHRoYXQsIGFyZ3VtZW50cyksIGRyYWdnZWQgPSAwLCBzdWJqZWN0ID0gZDMuc2VsZWN0KGQzX3dpbmRvdyh0aGF0KSkub24obW91c2Vtb3ZlLCBtb3ZlZCkub24obW91c2V1cCwgZW5kZWQpLCBsb2NhdGlvbjAgPSBsb2NhdGlvbihkMy5tb3VzZSh0aGF0KSksIGRyYWdSZXN0b3JlID0gZDNfZXZlbnRfZHJhZ1N1cHByZXNzKHRoYXQpO1xuICAgICAgZDNfc2VsZWN0aW9uX2ludGVycnVwdC5jYWxsKHRoYXQpO1xuICAgICAgem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpO1xuICAgICAgZnVuY3Rpb24gbW92ZWQoKSB7XG4gICAgICAgIGRyYWdnZWQgPSAxO1xuICAgICAgICB0cmFuc2xhdGVUbyhkMy5tb3VzZSh0aGF0KSwgbG9jYXRpb24wKTtcbiAgICAgICAgem9vbWVkKGRpc3BhdGNoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVuZGVkKCkge1xuICAgICAgICBzdWJqZWN0Lm9uKG1vdXNlbW92ZSwgbnVsbCkub24obW91c2V1cCwgbnVsbCk7XG4gICAgICAgIGRyYWdSZXN0b3JlKGRyYWdnZWQpO1xuICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b3VjaHN0YXJ0ZWQoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsIGRpc3BhdGNoID0gZXZlbnQub2YodGhhdCwgYXJndW1lbnRzKSwgbG9jYXRpb25zMCA9IHt9LCBkaXN0YW5jZTAgPSAwLCBzY2FsZTAsIHpvb21OYW1lID0gXCIuem9vbS1cIiArIGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmlkZW50aWZpZXIsIHRvdWNobW92ZSA9IFwidG91Y2htb3ZlXCIgKyB6b29tTmFtZSwgdG91Y2hlbmQgPSBcInRvdWNoZW5kXCIgKyB6b29tTmFtZSwgdGFyZ2V0cyA9IFtdLCBzdWJqZWN0ID0gZDMuc2VsZWN0KHRoYXQpLCBkcmFnUmVzdG9yZSA9IGQzX2V2ZW50X2RyYWdTdXBwcmVzcyh0aGF0KTtcbiAgICAgIHN0YXJ0ZWQoKTtcbiAgICAgIHpvb21zdGFydGVkKGRpc3BhdGNoKTtcbiAgICAgIHN1YmplY3Qub24obW91c2Vkb3duLCBudWxsKS5vbih0b3VjaHN0YXJ0LCBzdGFydGVkKTtcbiAgICAgIGZ1bmN0aW9uIHJlbG9jYXRlKCkge1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGQzLnRvdWNoZXModGhhdCk7XG4gICAgICAgIHNjYWxlMCA9IHZpZXcuaztcbiAgICAgICAgdG91Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICBpZiAodC5pZGVudGlmaWVyIGluIGxvY2F0aW9uczApIGxvY2F0aW9uczBbdC5pZGVudGlmaWVyXSA9IGxvY2F0aW9uKHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRvdWNoZXM7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzdGFydGVkKCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZDMuZXZlbnQudGFyZ2V0O1xuICAgICAgICBkMy5zZWxlY3QodGFyZ2V0KS5vbih0b3VjaG1vdmUsIG1vdmVkKS5vbih0b3VjaGVuZCwgZW5kZWQpO1xuICAgICAgICB0YXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBkMy5ldmVudC5jaGFuZ2VkVG91Y2hlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjaGFuZ2VkLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGxvY2F0aW9uczBbY2hhbmdlZFtpXS5pZGVudGlmaWVyXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdWNoZXMgPSByZWxvY2F0ZSgpLCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAodG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBpZiAobm93IC0gdG91Y2h0aW1lIDwgNTAwKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRvdWNoZXNbMF07XG4gICAgICAgICAgICB6b29tVG8odGhhdCwgcCwgbG9jYXRpb25zMFtwLmlkZW50aWZpZXJdLCBNYXRoLmZsb29yKE1hdGgubG9nKHZpZXcuaykgLyBNYXRoLkxOMikgKyAxKTtcbiAgICAgICAgICAgIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG91Y2h0aW1lID0gbm93O1xuICAgICAgICB9IGVsc2UgaWYgKHRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHZhciBwID0gdG91Y2hlc1swXSwgcSA9IHRvdWNoZXNbMV0sIGR4ID0gcFswXSAtIHFbMF0sIGR5ID0gcFsxXSAtIHFbMV07XG4gICAgICAgICAgZGlzdGFuY2UwID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1vdmVkKCkge1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGQzLnRvdWNoZXModGhhdCksIHAwLCBsMCwgcDEsIGwxO1xuICAgICAgICBkM19zZWxlY3Rpb25faW50ZXJydXB0LmNhbGwodGhhdCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcy5sZW5ndGg7IGkgPCBuOyArK2ksIGwxID0gbnVsbCkge1xuICAgICAgICAgIHAxID0gdG91Y2hlc1tpXTtcbiAgICAgICAgICBpZiAobDEgPSBsb2NhdGlvbnMwW3AxLmlkZW50aWZpZXJdKSB7XG4gICAgICAgICAgICBpZiAobDApIGJyZWFrO1xuICAgICAgICAgICAgcDAgPSBwMSwgbDAgPSBsMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGwxKSB7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlMSA9IChkaXN0YW5jZTEgPSBwMVswXSAtIHAwWzBdKSAqIGRpc3RhbmNlMSArIChkaXN0YW5jZTEgPSBwMVsxXSAtIHAwWzFdKSAqIGRpc3RhbmNlMSwgc2NhbGUxID0gZGlzdGFuY2UwICYmIE1hdGguc3FydChkaXN0YW5jZTEgLyBkaXN0YW5jZTApO1xuICAgICAgICAgIHAwID0gWyAocDBbMF0gKyBwMVswXSkgLyAyLCAocDBbMV0gKyBwMVsxXSkgLyAyIF07XG4gICAgICAgICAgbDAgPSBbIChsMFswXSArIGwxWzBdKSAvIDIsIChsMFsxXSArIGwxWzFdKSAvIDIgXTtcbiAgICAgICAgICBzY2FsZVRvKHNjYWxlMSAqIHNjYWxlMCk7XG4gICAgICAgIH1cbiAgICAgICAgdG91Y2h0aW1lID0gbnVsbDtcbiAgICAgICAgdHJhbnNsYXRlVG8ocDAsIGwwKTtcbiAgICAgICAgem9vbWVkKGRpc3BhdGNoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVuZGVkKCkge1xuICAgICAgICBpZiAoZDMuZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgY2hhbmdlZCA9IGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY2hhbmdlZC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhdGlvbnMwW2NoYW5nZWRbaV0uaWRlbnRpZmllcl07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGlkZW50aWZpZXIgaW4gbG9jYXRpb25zMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgcmVsb2NhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZDMuc2VsZWN0QWxsKHRhcmdldHMpLm9uKHpvb21OYW1lLCBudWxsKTtcbiAgICAgICAgc3ViamVjdC5vbihtb3VzZWRvd24sIG1vdXNlZG93bmVkKS5vbih0b3VjaHN0YXJ0LCB0b3VjaHN0YXJ0ZWQpO1xuICAgICAgICBkcmFnUmVzdG9yZSgpO1xuICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VzZXdoZWVsZWQoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2ggPSBldmVudC5vZih0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKG1vdXNld2hlZWxUaW1lcikgY2xlYXJUaW1lb3V0KG1vdXNld2hlZWxUaW1lcik7IGVsc2UgZDNfc2VsZWN0aW9uX2ludGVycnVwdC5jYWxsKHRoaXMpLCBcbiAgICAgIHRyYW5zbGF0ZTAgPSBsb2NhdGlvbihjZW50ZXIwID0gY2VudGVyIHx8IGQzLm1vdXNlKHRoaXMpKSwgem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpO1xuICAgICAgbW91c2V3aGVlbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgbW91c2V3aGVlbFRpbWVyID0gbnVsbDtcbiAgICAgICAgem9vbWVuZGVkKGRpc3BhdGNoKTtcbiAgICAgIH0sIDUwKTtcbiAgICAgIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNjYWxlVG8oTWF0aC5wb3coMiwgZDNfYmVoYXZpb3Jfem9vbURlbHRhKCkgKiAuMDAyKSAqIHZpZXcuayk7XG4gICAgICB0cmFuc2xhdGVUbyhjZW50ZXIwLCB0cmFuc2xhdGUwKTtcbiAgICAgIHpvb21lZChkaXNwYXRjaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRibGNsaWNrZWQoKSB7XG4gICAgICB2YXIgcCA9IGQzLm1vdXNlKHRoaXMpLCBrID0gTWF0aC5sb2codmlldy5rKSAvIE1hdGguTE4yO1xuICAgICAgem9vbVRvKHRoaXMsIHAsIGxvY2F0aW9uKHApLCBkMy5ldmVudC5zaGlmdEtleSA/IE1hdGguY2VpbChrKSAtIDEgOiBNYXRoLmZsb29yKGspICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBkMy5yZWJpbmQoem9vbSwgZXZlbnQsIFwib25cIik7XG4gIH07XG4gIHZhciBkM19iZWhhdmlvcl96b29tSW5maW5pdHkgPSBbIDAsIEluZmluaXR5IF0sIGQzX2JlaGF2aW9yX3pvb21EZWx0YSwgZDNfYmVoYXZpb3Jfem9vbVdoZWVsO1xuICBkMy5jb2xvciA9IGQzX2NvbG9yO1xuICBmdW5jdGlvbiBkM19jb2xvcigpIHt9XG4gIGQzX2NvbG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJnYigpICsgXCJcIjtcbiAgfTtcbiAgZDMuaHNsID0gZDNfaHNsO1xuICBmdW5jdGlvbiBkM19oc2woaCwgcywgbCkge1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgZDNfaHNsID8gdm9pZCAodGhpcy5oID0gK2gsIHRoaXMucyA9ICtzLCB0aGlzLmwgPSArbCkgOiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGggaW5zdGFuY2VvZiBkM19oc2wgPyBuZXcgZDNfaHNsKGguaCwgaC5zLCBoLmwpIDogZDNfcmdiX3BhcnNlKFwiXCIgKyBoLCBkM19yZ2JfaHNsLCBkM19oc2wpIDogbmV3IGQzX2hzbChoLCBzLCBsKTtcbiAgfVxuICB2YXIgZDNfaHNsUHJvdG90eXBlID0gZDNfaHNsLnByb3RvdHlwZSA9IG5ldyBkM19jb2xvcigpO1xuICBkM19oc2xQcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IE1hdGgucG93KC43LCBhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpO1xuICAgIHJldHVybiBuZXcgZDNfaHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgLyBrKTtcbiAgfTtcbiAgZDNfaHNsUHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gTWF0aC5wb3coLjcsIGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSk7XG4gICAgcmV0dXJuIG5ldyBkM19oc2wodGhpcy5oLCB0aGlzLnMsIGsgKiB0aGlzLmwpO1xuICB9O1xuICBkM19oc2xQcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2hzbF9yZ2IodGhpcy5oLCB0aGlzLnMsIHRoaXMubCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2hzbF9yZ2IoaCwgcywgbCkge1xuICAgIHZhciBtMSwgbTI7XG4gICAgaCA9IGlzTmFOKGgpID8gMCA6IChoICU9IDM2MCkgPCAwID8gaCArIDM2MCA6IGg7XG4gICAgcyA9IGlzTmFOKHMpID8gMCA6IHMgPCAwID8gMCA6IHMgPiAxID8gMSA6IHM7XG4gICAgbCA9IGwgPCAwID8gMCA6IGwgPiAxID8gMSA6IGw7XG4gICAgbTIgPSBsIDw9IC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgIG0xID0gMiAqIGwgLSBtMjtcbiAgICBmdW5jdGlvbiB2KGgpIHtcbiAgICAgIGlmIChoID4gMzYwKSBoIC09IDM2MDsgZWxzZSBpZiAoaCA8IDApIGggKz0gMzYwO1xuICAgICAgaWYgKGggPCA2MCkgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAvIDYwO1xuICAgICAgaWYgKGggPCAxODApIHJldHVybiBtMjtcbiAgICAgIGlmIChoIDwgMjQwKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMjQwIC0gaCkgLyA2MDtcbiAgICAgIHJldHVybiBtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdnYoaCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodihoKSAqIDI1NSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgZDNfcmdiKHZ2KGggKyAxMjApLCB2dihoKSwgdnYoaCAtIDEyMCkpO1xuICB9XG4gIGQzLmhjbCA9IGQzX2hjbDtcbiAgZnVuY3Rpb24gZDNfaGNsKGgsIGMsIGwpIHtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGQzX2hjbCA/IHZvaWQgKHRoaXMuaCA9ICtoLCB0aGlzLmMgPSArYywgdGhpcy5sID0gK2wpIDogYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBoIGluc3RhbmNlb2YgZDNfaGNsID8gbmV3IGQzX2hjbChoLmgsIGguYywgaC5sKSA6IGggaW5zdGFuY2VvZiBkM19sYWIgPyBkM19sYWJfaGNsKGgubCwgaC5hLCBoLmIpIDogZDNfbGFiX2hjbCgoaCA9IGQzX3JnYl9sYWIoKGggPSBkMy5yZ2IoaCkpLnIsIGguZywgaC5iKSkubCwgaC5hLCBoLmIpIDogbmV3IGQzX2hjbChoLCBjLCBsKTtcbiAgfVxuICB2YXIgZDNfaGNsUHJvdG90eXBlID0gZDNfaGNsLnByb3RvdHlwZSA9IG5ldyBkM19jb2xvcigpO1xuICBkM19oY2xQcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBkM19oY2wodGhpcy5oLCB0aGlzLmMsIE1hdGgubWluKDEwMCwgdGhpcy5sICsgZDNfbGFiX0sgKiAoYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKSkpO1xuICB9O1xuICBkM19oY2xQcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgZDNfaGNsKHRoaXMuaCwgdGhpcy5jLCBNYXRoLm1heCgwLCB0aGlzLmwgLSBkM19sYWJfSyAqIChhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpKSk7XG4gIH07XG4gIGQzX2hjbFByb3RvdHlwZS5yZ2IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfaGNsX2xhYih0aGlzLmgsIHRoaXMuYywgdGhpcy5sKS5yZ2IoKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfaGNsX2xhYihoLCBjLCBsKSB7XG4gICAgaWYgKGlzTmFOKGgpKSBoID0gMDtcbiAgICBpZiAoaXNOYU4oYykpIGMgPSAwO1xuICAgIHJldHVybiBuZXcgZDNfbGFiKGwsIE1hdGguY29zKGggKj0gZDNfcmFkaWFucykgKiBjLCBNYXRoLnNpbihoKSAqIGMpO1xuICB9XG4gIGQzLmxhYiA9IGQzX2xhYjtcbiAgZnVuY3Rpb24gZDNfbGFiKGwsIGEsIGIpIHtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGQzX2xhYiA/IHZvaWQgKHRoaXMubCA9ICtsLCB0aGlzLmEgPSArYSwgdGhpcy5iID0gK2IpIDogYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBsIGluc3RhbmNlb2YgZDNfbGFiID8gbmV3IGQzX2xhYihsLmwsIGwuYSwgbC5iKSA6IGwgaW5zdGFuY2VvZiBkM19oY2wgPyBkM19oY2xfbGFiKGwuaCwgbC5jLCBsLmwpIDogZDNfcmdiX2xhYigobCA9IGQzX3JnYihsKSkuciwgbC5nLCBsLmIpIDogbmV3IGQzX2xhYihsLCBhLCBiKTtcbiAgfVxuICB2YXIgZDNfbGFiX0sgPSAxODtcbiAgdmFyIGQzX2xhYl9YID0gLjk1MDQ3LCBkM19sYWJfWSA9IDEsIGQzX2xhYl9aID0gMS4wODg4MztcbiAgdmFyIGQzX2xhYlByb3RvdHlwZSA9IGQzX2xhYi5wcm90b3R5cGUgPSBuZXcgZDNfY29sb3IoKTtcbiAgZDNfbGFiUHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgZDNfbGFiKE1hdGgubWluKDEwMCwgdGhpcy5sICsgZDNfbGFiX0sgKiAoYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKSksIHRoaXMuYSwgdGhpcy5iKTtcbiAgfTtcbiAgZDNfbGFiUHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IGQzX2xhYihNYXRoLm1heCgwLCB0aGlzLmwgLSBkM19sYWJfSyAqIChhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpKSwgdGhpcy5hLCB0aGlzLmIpO1xuICB9O1xuICBkM19sYWJQcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2xhYl9yZ2IodGhpcy5sLCB0aGlzLmEsIHRoaXMuYik7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xhYl9yZ2IobCwgYSwgYikge1xuICAgIHZhciB5ID0gKGwgKyAxNikgLyAxMTYsIHggPSB5ICsgYSAvIDUwMCwgeiA9IHkgLSBiIC8gMjAwO1xuICAgIHggPSBkM19sYWJfeHl6KHgpICogZDNfbGFiX1g7XG4gICAgeSA9IGQzX2xhYl94eXooeSkgKiBkM19sYWJfWTtcbiAgICB6ID0gZDNfbGFiX3h5eih6KSAqIGQzX2xhYl9aO1xuICAgIHJldHVybiBuZXcgZDNfcmdiKGQzX3h5el9yZ2IoMy4yNDA0NTQyICogeCAtIDEuNTM3MTM4NSAqIHkgLSAuNDk4NTMxNCAqIHopLCBkM194eXpfcmdiKC0uOTY5MjY2ICogeCArIDEuODc2MDEwOCAqIHkgKyAuMDQxNTU2ICogeiksIGQzX3h5el9yZ2IoLjA1NTY0MzQgKiB4IC0gLjIwNDAyNTkgKiB5ICsgMS4wNTcyMjUyICogeikpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xhYl9oY2wobCwgYSwgYikge1xuICAgIHJldHVybiBsID4gMCA/IG5ldyBkM19oY2woTWF0aC5hdGFuMihiLCBhKSAqIGQzX2RlZ3JlZXMsIE1hdGguc3FydChhICogYSArIGIgKiBiKSwgbCkgOiBuZXcgZDNfaGNsKE5hTiwgTmFOLCBsKTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYWJfeHl6KHgpIHtcbiAgICByZXR1cm4geCA+IC4yMDY4OTMwMzQgPyB4ICogeCAqIHggOiAoeCAtIDQgLyAyOSkgLyA3Ljc4NzAzNztcbiAgfVxuICBmdW5jdGlvbiBkM194eXpfbGFiKHgpIHtcbiAgICByZXR1cm4geCA+IC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxIC8gMykgOiA3Ljc4NzAzNyAqIHggKyA0IC8gMjk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfeHl6X3JnYihyKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoMjU1ICogKHIgPD0gLjAwMzA0ID8gMTIuOTIgKiByIDogMS4wNTUgKiBNYXRoLnBvdyhyLCAxIC8gMi40KSAtIC4wNTUpKTtcbiAgfVxuICBkMy5yZ2IgPSBkM19yZ2I7XG4gIGZ1bmN0aW9uIGQzX3JnYihyLCBnLCBiKSB7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBkM19yZ2IgPyB2b2lkICh0aGlzLnIgPSB+fnIsIHRoaXMuZyA9IH5+ZywgdGhpcy5iID0gfn5iKSA6IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gciBpbnN0YW5jZW9mIGQzX3JnYiA/IG5ldyBkM19yZ2Ioci5yLCByLmcsIHIuYikgOiBkM19yZ2JfcGFyc2UoXCJcIiArIHIsIGQzX3JnYiwgZDNfaHNsX3JnYikgOiBuZXcgZDNfcmdiKHIsIGcsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYk51bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgZDNfcmdiKHZhbHVlID4+IDE2LCB2YWx1ZSA+PiA4ICYgMjU1LCB2YWx1ZSAmIDI1NSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfcmdiU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIGQzX3JnYk51bWJlcih2YWx1ZSkgKyBcIlwiO1xuICB9XG4gIHZhciBkM19yZ2JQcm90b3R5cGUgPSBkM19yZ2IucHJvdG90eXBlID0gbmV3IGQzX2NvbG9yKCk7XG4gIGQzX3JnYlByb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gTWF0aC5wb3coLjcsIGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSk7XG4gICAgdmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmIsIGkgPSAzMDtcbiAgICBpZiAoIXIgJiYgIWcgJiYgIWIpIHJldHVybiBuZXcgZDNfcmdiKGksIGksIGkpO1xuICAgIGlmIChyICYmIHIgPCBpKSByID0gaTtcbiAgICBpZiAoZyAmJiBnIDwgaSkgZyA9IGk7XG4gICAgaWYgKGIgJiYgYiA8IGkpIGIgPSBpO1xuICAgIHJldHVybiBuZXcgZDNfcmdiKE1hdGgubWluKDI1NSwgciAvIGspLCBNYXRoLm1pbigyNTUsIGcgLyBrKSwgTWF0aC5taW4oMjU1LCBiIC8gaykpO1xuICB9O1xuICBkM19yZ2JQcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBNYXRoLnBvdyguNywgYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKTtcbiAgICByZXR1cm4gbmV3IGQzX3JnYihrICogdGhpcy5yLCBrICogdGhpcy5nLCBrICogdGhpcy5iKTtcbiAgfTtcbiAgZDNfcmdiUHJvdG90eXBlLmhzbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19yZ2JfaHNsKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICB9O1xuICBkM19yZ2JQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCIjXCIgKyBkM19yZ2JfaGV4KHRoaXMucikgKyBkM19yZ2JfaGV4KHRoaXMuZykgKyBkM19yZ2JfaGV4KHRoaXMuYik7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3JnYl9oZXgodikge1xuICAgIHJldHVybiB2IDwgMTYgPyBcIjBcIiArIE1hdGgubWF4KDAsIHYpLnRvU3RyaW5nKDE2KSA6IE1hdGgubWluKDI1NSwgdikudG9TdHJpbmcoMTYpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYl9wYXJzZShmb3JtYXQsIHJnYiwgaHNsKSB7XG4gICAgdmFyIHIgPSAwLCBnID0gMCwgYiA9IDAsIG0xLCBtMiwgY29sb3I7XG4gICAgbTEgPSAvKFthLXpdKylcXCgoLiopXFwpLy5leGVjKGZvcm1hdCA9IGZvcm1hdC50b0xvd2VyQ2FzZSgpKTtcbiAgICBpZiAobTEpIHtcbiAgICAgIG0yID0gbTFbMl0uc3BsaXQoXCIsXCIpO1xuICAgICAgc3dpdGNoIChtMVsxXSkge1xuICAgICAgIGNhc2UgXCJoc2xcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBoc2wocGFyc2VGbG9hdChtMlswXSksIHBhcnNlRmxvYXQobTJbMV0pIC8gMTAwLCBwYXJzZUZsb2F0KG0yWzJdKSAvIDEwMCk7XG4gICAgICAgIH1cblxuICAgICAgIGNhc2UgXCJyZ2JcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiByZ2IoZDNfcmdiX3BhcnNlTnVtYmVyKG0yWzBdKSwgZDNfcmdiX3BhcnNlTnVtYmVyKG0yWzFdKSwgZDNfcmdiX3BhcnNlTnVtYmVyKG0yWzJdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbG9yID0gZDNfcmdiX25hbWVzLmdldChmb3JtYXQpKSB7XG4gICAgICByZXR1cm4gcmdiKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ICE9IG51bGwgJiYgZm9ybWF0LmNoYXJBdCgwKSA9PT0gXCIjXCIgJiYgIWlzTmFOKGNvbG9yID0gcGFyc2VJbnQoZm9ybWF0LnNsaWNlKDEpLCAxNikpKSB7XG4gICAgICBpZiAoZm9ybWF0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICByID0gKGNvbG9yICYgMzg0MCkgPj4gNDtcbiAgICAgICAgciA9IHIgPj4gNCB8IHI7XG4gICAgICAgIGcgPSBjb2xvciAmIDI0MDtcbiAgICAgICAgZyA9IGcgPj4gNCB8IGc7XG4gICAgICAgIGIgPSBjb2xvciAmIDE1O1xuICAgICAgICBiID0gYiA8PCA0IHwgYjtcbiAgICAgIH0gZWxzZSBpZiAoZm9ybWF0Lmxlbmd0aCA9PT0gNykge1xuICAgICAgICByID0gKGNvbG9yICYgMTY3MTE2ODApID4+IDE2O1xuICAgICAgICBnID0gKGNvbG9yICYgNjUyODApID4+IDg7XG4gICAgICAgIGIgPSBjb2xvciAmIDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJnYihyLCBnLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JfaHNsKHIsIGcsIGIpIHtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociAvPSAyNTUsIGcgLz0gMjU1LCBiIC89IDI1NSksIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLCBkID0gbWF4IC0gbWluLCBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyO1xuICAgIGlmIChkKSB7XG4gICAgICBzID0gbCA8IC41ID8gZCAvIChtYXggKyBtaW4pIDogZCAvICgyIC0gbWF4IC0gbWluKTtcbiAgICAgIGlmIChyID09IG1heCkgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOyBlbHNlIGlmIChnID09IG1heCkgaCA9IChiIC0gcikgLyBkICsgMjsgZWxzZSBoID0gKHIgLSBnKSAvIGQgKyA0O1xuICAgICAgaCAqPSA2MDtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IE5hTjtcbiAgICAgIHMgPSBsID4gMCAmJiBsIDwgMSA/IDAgOiBoO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGQzX2hzbChoLCBzLCBsKTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JfbGFiKHIsIGcsIGIpIHtcbiAgICByID0gZDNfcmdiX3h5eihyKTtcbiAgICBnID0gZDNfcmdiX3h5eihnKTtcbiAgICBiID0gZDNfcmdiX3h5eihiKTtcbiAgICB2YXIgeCA9IGQzX3h5el9sYWIoKC40MTI0NTY0ICogciArIC4zNTc1NzYxICogZyArIC4xODA0Mzc1ICogYikgLyBkM19sYWJfWCksIHkgPSBkM194eXpfbGFiKCguMjEyNjcyOSAqIHIgKyAuNzE1MTUyMiAqIGcgKyAuMDcyMTc1ICogYikgLyBkM19sYWJfWSksIHogPSBkM194eXpfbGFiKCguMDE5MzMzOSAqIHIgKyAuMTE5MTkyICogZyArIC45NTAzMDQxICogYikgLyBkM19sYWJfWik7XG4gICAgcmV0dXJuIGQzX2xhYigxMTYgKiB5IC0gMTYsIDUwMCAqICh4IC0geSksIDIwMCAqICh5IC0geikpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYl94eXoocikge1xuICAgIHJldHVybiAociAvPSAyNTUpIDw9IC4wNDA0NSA/IHIgLyAxMi45MiA6IE1hdGgucG93KChyICsgLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JfcGFyc2VOdW1iZXIoYykge1xuICAgIHZhciBmID0gcGFyc2VGbG9hdChjKTtcbiAgICByZXR1cm4gYy5jaGFyQXQoYy5sZW5ndGggLSAxKSA9PT0gXCIlXCIgPyBNYXRoLnJvdW5kKGYgKiAyLjU1KSA6IGY7XG4gIH1cbiAgdmFyIGQzX3JnYl9uYW1lcyA9IGQzLm1hcCh7XG4gICAgYWxpY2VibHVlOiAxNTc5MjM4MyxcbiAgICBhbnRpcXVld2hpdGU6IDE2NDQ0Mzc1LFxuICAgIGFxdWE6IDY1NTM1LFxuICAgIGFxdWFtYXJpbmU6IDgzODg1NjQsXG4gICAgYXp1cmU6IDE1Nzk0MTc1LFxuICAgIGJlaWdlOiAxNjExOTI2MCxcbiAgICBiaXNxdWU6IDE2NzcwMjQ0LFxuICAgIGJsYWNrOiAwLFxuICAgIGJsYW5jaGVkYWxtb25kOiAxNjc3MjA0NSxcbiAgICBibHVlOiAyNTUsXG4gICAgYmx1ZXZpb2xldDogOTA1NTIwMixcbiAgICBicm93bjogMTA4MjQyMzQsXG4gICAgYnVybHl3b29kOiAxNDU5NjIzMSxcbiAgICBjYWRldGJsdWU6IDYyNjY1MjgsXG4gICAgY2hhcnRyZXVzZTogODM4ODM1MixcbiAgICBjaG9jb2xhdGU6IDEzNzg5NDcwLFxuICAgIGNvcmFsOiAxNjc0NDI3MixcbiAgICBjb3JuZmxvd2VyYmx1ZTogNjU5MTk4MSxcbiAgICBjb3Juc2lsazogMTY3NzUzODgsXG4gICAgY3JpbXNvbjogMTQ0MjMxMDAsXG4gICAgY3lhbjogNjU1MzUsXG4gICAgZGFya2JsdWU6IDEzOSxcbiAgICBkYXJrY3lhbjogMzU3MjMsXG4gICAgZGFya2dvbGRlbnJvZDogMTIwOTI5MzksXG4gICAgZGFya2dyYXk6IDExMTE5MDE3LFxuICAgIGRhcmtncmVlbjogMjU2MDAsXG4gICAgZGFya2dyZXk6IDExMTE5MDE3LFxuICAgIGRhcmtraGFraTogMTI0MzMyNTksXG4gICAgZGFya21hZ2VudGE6IDkxMDk2NDMsXG4gICAgZGFya29saXZlZ3JlZW46IDU1OTc5OTksXG4gICAgZGFya29yYW5nZTogMTY3NDc1MjAsXG4gICAgZGFya29yY2hpZDogMTAwNDAwMTIsXG4gICAgZGFya3JlZDogOTEwOTUwNCxcbiAgICBkYXJrc2FsbW9uOiAxNTMwODQxMCxcbiAgICBkYXJrc2VhZ3JlZW46IDk0MTk5MTksXG4gICAgZGFya3NsYXRlYmx1ZTogNDczNDM0NyxcbiAgICBkYXJrc2xhdGVncmF5OiAzMTAwNDk1LFxuICAgIGRhcmtzbGF0ZWdyZXk6IDMxMDA0OTUsXG4gICAgZGFya3R1cnF1b2lzZTogNTI5NDUsXG4gICAgZGFya3Zpb2xldDogOTY5OTUzOSxcbiAgICBkZWVwcGluazogMTY3MTY5NDcsXG4gICAgZGVlcHNreWJsdWU6IDQ5MTUxLFxuICAgIGRpbWdyYXk6IDY5MDgyNjUsXG4gICAgZGltZ3JleTogNjkwODI2NSxcbiAgICBkb2RnZXJibHVlOiAyMDAzMTk5LFxuICAgIGZpcmVicmljazogMTE2NzQxNDYsXG4gICAgZmxvcmFsd2hpdGU6IDE2Nzc1OTIwLFxuICAgIGZvcmVzdGdyZWVuOiAyMjYzODQyLFxuICAgIGZ1Y2hzaWE6IDE2NzExOTM1LFxuICAgIGdhaW5zYm9ybzogMTQ0NzQ0NjAsXG4gICAgZ2hvc3R3aGl0ZTogMTYzMTY2NzEsXG4gICAgZ29sZDogMTY3NjY3MjAsXG4gICAgZ29sZGVucm9kOiAxNDMyOTEyMCxcbiAgICBncmF5OiA4NDIxNTA0LFxuICAgIGdyZWVuOiAzMjc2OCxcbiAgICBncmVlbnllbGxvdzogMTE0MDMwNTUsXG4gICAgZ3JleTogODQyMTUwNCxcbiAgICBob25leWRldzogMTU3OTQxNjAsXG4gICAgaG90cGluazogMTY3Mzg3NDAsXG4gICAgaW5kaWFucmVkOiAxMzQ1ODUyNCxcbiAgICBpbmRpZ286IDQ5MTUzMzAsXG4gICAgaXZvcnk6IDE2Nzc3MjAwLFxuICAgIGtoYWtpOiAxNTc4NzY2MCxcbiAgICBsYXZlbmRlcjogMTUxMzI0MTAsXG4gICAgbGF2ZW5kZXJibHVzaDogMTY3NzMzNjUsXG4gICAgbGF3bmdyZWVuOiA4MTkwOTc2LFxuICAgIGxlbW9uY2hpZmZvbjogMTY3NzU4ODUsXG4gICAgbGlnaHRibHVlOiAxMTM5MzI1NCxcbiAgICBsaWdodGNvcmFsOiAxNTc2MTUzNixcbiAgICBsaWdodGN5YW46IDE0NzQ1NTk5LFxuICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAxNjQ0ODIxMCxcbiAgICBsaWdodGdyYXk6IDEzODgyMzIzLFxuICAgIGxpZ2h0Z3JlZW46IDk0OTgyNTYsXG4gICAgbGlnaHRncmV5OiAxMzg4MjMyMyxcbiAgICBsaWdodHBpbms6IDE2NzU4NDY1LFxuICAgIGxpZ2h0c2FsbW9uOiAxNjc1Mjc2MixcbiAgICBsaWdodHNlYWdyZWVuOiAyMTQyODkwLFxuICAgIGxpZ2h0c2t5Ymx1ZTogODkwMDM0NixcbiAgICBsaWdodHNsYXRlZ3JheTogNzgzMzc1MyxcbiAgICBsaWdodHNsYXRlZ3JleTogNzgzMzc1MyxcbiAgICBsaWdodHN0ZWVsYmx1ZTogMTE1ODQ3MzQsXG4gICAgbGlnaHR5ZWxsb3c6IDE2Nzc3MTg0LFxuICAgIGxpbWU6IDY1MjgwLFxuICAgIGxpbWVncmVlbjogMzMyOTMzMCxcbiAgICBsaW5lbjogMTY0NDU2NzAsXG4gICAgbWFnZW50YTogMTY3MTE5MzUsXG4gICAgbWFyb29uOiA4Mzg4NjA4LFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6IDY3MzczMjIsXG4gICAgbWVkaXVtYmx1ZTogMjA1LFxuICAgIG1lZGl1bW9yY2hpZDogMTIyMTE2NjcsXG4gICAgbWVkaXVtcHVycGxlOiA5NjYyNjgzLFxuICAgIG1lZGl1bXNlYWdyZWVuOiAzOTc4MDk3LFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogODA4Nzc5MCxcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogNjQxNTQsXG4gICAgbWVkaXVtdHVycXVvaXNlOiA0NzcyMzAwLFxuICAgIG1lZGl1bXZpb2xldHJlZDogMTMwNDcxNzMsXG4gICAgbWlkbmlnaHRibHVlOiAxNjQ0OTEyLFxuICAgIG1pbnRjcmVhbTogMTYxMjE4NTAsXG4gICAgbWlzdHlyb3NlOiAxNjc3MDI3MyxcbiAgICBtb2NjYXNpbjogMTY3NzAyMjksXG4gICAgbmF2YWpvd2hpdGU6IDE2NzY4Njg1LFxuICAgIG5hdnk6IDEyOCxcbiAgICBvbGRsYWNlOiAxNjY0MzU1OCxcbiAgICBvbGl2ZTogODQyMTM3NixcbiAgICBvbGl2ZWRyYWI6IDcwNDg3MzksXG4gICAgb3JhbmdlOiAxNjc1MzkyMCxcbiAgICBvcmFuZ2VyZWQ6IDE2NzI5MzQ0LFxuICAgIG9yY2hpZDogMTQzMTU3MzQsXG4gICAgcGFsZWdvbGRlbnJvZDogMTU2NTcxMzAsXG4gICAgcGFsZWdyZWVuOiAxMDAyNTg4MCxcbiAgICBwYWxldHVycXVvaXNlOiAxMTUyOTk2NixcbiAgICBwYWxldmlvbGV0cmVkOiAxNDM4MTIwMyxcbiAgICBwYXBheWF3aGlwOiAxNjc3MzA3NyxcbiAgICBwZWFjaHB1ZmY6IDE2NzY3NjczLFxuICAgIHBlcnU6IDEzNDY4OTkxLFxuICAgIHBpbms6IDE2NzYxMDM1LFxuICAgIHBsdW06IDE0NTI0NjM3LFxuICAgIHBvd2RlcmJsdWU6IDExNTkxOTEwLFxuICAgIHB1cnBsZTogODM4ODczNixcbiAgICByZWJlY2NhcHVycGxlOiA2Njk3ODgxLFxuICAgIHJlZDogMTY3MTE2ODAsXG4gICAgcm9zeWJyb3duOiAxMjM1NzUxOSxcbiAgICByb3lhbGJsdWU6IDQyODY5NDUsXG4gICAgc2FkZGxlYnJvd246IDkxMjcxODcsXG4gICAgc2FsbW9uOiAxNjQxNjg4MixcbiAgICBzYW5keWJyb3duOiAxNjAzMjg2NCxcbiAgICBzZWFncmVlbjogMzA1MDMyNyxcbiAgICBzZWFzaGVsbDogMTY3NzQ2MzgsXG4gICAgc2llbm5hOiAxMDUwNjc5NyxcbiAgICBzaWx2ZXI6IDEyNjMyMjU2LFxuICAgIHNreWJsdWU6IDg5MDAzMzEsXG4gICAgc2xhdGVibHVlOiA2OTcwMDYxLFxuICAgIHNsYXRlZ3JheTogNzM3Mjk0NCxcbiAgICBzbGF0ZWdyZXk6IDczNzI5NDQsXG4gICAgc25vdzogMTY3NzU5MzAsXG4gICAgc3ByaW5nZ3JlZW46IDY1NDA3LFxuICAgIHN0ZWVsYmx1ZTogNDYyMDk4MCxcbiAgICB0YW46IDEzODA4NzgwLFxuICAgIHRlYWw6IDMyODk2LFxuICAgIHRoaXN0bGU6IDE0MjA0ODg4LFxuICAgIHRvbWF0bzogMTY3MzcwOTUsXG4gICAgdHVycXVvaXNlOiA0MjUxODU2LFxuICAgIHZpb2xldDogMTU2MzEwODYsXG4gICAgd2hlYXQ6IDE2MTEzMzMxLFxuICAgIHdoaXRlOiAxNjc3NzIxNSxcbiAgICB3aGl0ZXNtb2tlOiAxNjExOTI4NSxcbiAgICB5ZWxsb3c6IDE2Nzc2OTYwLFxuICAgIHllbGxvd2dyZWVuOiAxMDE0NTA3NFxuICB9KTtcbiAgZDNfcmdiX25hbWVzLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGQzX3JnYl9uYW1lcy5zZXQoa2V5LCBkM19yZ2JOdW1iZXIodmFsdWUpKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGQzX2Z1bmN0b3Iodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiID8gdiA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfTtcbiAgfVxuICBkMy5mdW5jdG9yID0gZDNfZnVuY3RvcjtcbiAgZDMueGhyID0gZDNfeGhyVHlwZShkM19pZGVudGl0eSk7XG4gIGZ1bmN0aW9uIGQzX3hoclR5cGUocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odXJsLCBtaW1lVHlwZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBtaW1lVHlwZSA9PT0gXCJmdW5jdGlvblwiKSBjYWxsYmFjayA9IG1pbWVUeXBlLCBcbiAgICAgIG1pbWVUeXBlID0gbnVsbDtcbiAgICAgIHJldHVybiBkM194aHIodXJsLCBtaW1lVHlwZSwgcmVzcG9uc2UsIGNhbGxiYWNrKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3hocih1cmwsIG1pbWVUeXBlLCByZXNwb25zZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgeGhyID0ge30sIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goXCJiZWZvcmVzZW5kXCIsIFwicHJvZ3Jlc3NcIiwgXCJsb2FkXCIsIFwiZXJyb3JcIiksIGhlYWRlcnMgPSB7fSwgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLCByZXNwb25zZVR5cGUgPSBudWxsO1xuICAgIGlmICh0aGlzLlhEb21haW5SZXF1ZXN0ICYmICEoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiByZXF1ZXN0KSAmJiAvXihodHRwKHMpPzopP1xcL1xcLy8udGVzdCh1cmwpKSByZXF1ZXN0ID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgXCJvbmxvYWRcIiBpbiByZXF1ZXN0ID8gcmVxdWVzdC5vbmxvYWQgPSByZXF1ZXN0Lm9uZXJyb3IgPSByZXNwb25kIDogcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlcXVlc3QucmVhZHlTdGF0ZSA+IDMgJiYgcmVzcG9uZCgpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVzcG9uZCgpIHtcbiAgICAgIHZhciBzdGF0dXMgPSByZXF1ZXN0LnN0YXR1cywgcmVzdWx0O1xuICAgICAgaWYgKCFzdGF0dXMgJiYgZDNfeGhySGFzUmVzcG9uc2UocmVxdWVzdCkgfHwgc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSByZXNwb25zZS5jYWxsKHhociwgcmVxdWVzdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkaXNwYXRjaC5lcnJvci5jYWxsKHhociwgZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoLmxvYWQuY2FsbCh4aHIsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwYXRjaC5lcnJvci5jYWxsKHhociwgcmVxdWVzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgbyA9IGQzLmV2ZW50O1xuICAgICAgZDMuZXZlbnQgPSBldmVudDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRpc3BhdGNoLnByb2dyZXNzLmNhbGwoeGhyLCByZXF1ZXN0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGQzLmV2ZW50ID0gbztcbiAgICAgIH1cbiAgICB9O1xuICAgIHhoci5oZWFkZXIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgbmFtZSA9IChuYW1lICsgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIGhlYWRlcnNbbmFtZV07XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkgZGVsZXRlIGhlYWRlcnNbbmFtZV07IGVsc2UgaGVhZGVyc1tuYW1lXSA9IHZhbHVlICsgXCJcIjtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICB4aHIubWltZVR5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWltZVR5cGU7XG4gICAgICBtaW1lVHlwZSA9IHZhbHVlID09IG51bGwgPyBudWxsIDogdmFsdWUgKyBcIlwiO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmVzcG9uc2VUeXBlO1xuICAgICAgcmVzcG9uc2VUeXBlID0gdmFsdWU7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgeGhyLnJlc3BvbnNlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3BvbnNlID0gdmFsdWU7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgWyBcImdldFwiLCBcInBvc3RcIiBdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICB4aHJbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geGhyLnNlbmQuYXBwbHkoeGhyLCBbIG1ldGhvZCBdLmNvbmNhdChkM19hcnJheShhcmd1bWVudHMpKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHhoci5zZW5kID0gZnVuY3Rpb24obWV0aG9kLCBkYXRhLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGRhdGEgPT09IFwiZnVuY3Rpb25cIikgY2FsbGJhY2sgPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgICAgIHJlcXVlc3Qub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgICBpZiAobWltZVR5cGUgIT0gbnVsbCAmJiAhKFwiYWNjZXB0XCIgaW4gaGVhZGVycykpIGhlYWRlcnNbXCJhY2NlcHRcIl0gPSBtaW1lVHlwZSArIFwiLCovKlwiO1xuICAgICAgaWYgKHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcikgZm9yICh2YXIgbmFtZSBpbiBoZWFkZXJzKSByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICBpZiAobWltZVR5cGUgIT0gbnVsbCAmJiByZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUpIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZShtaW1lVHlwZSk7XG4gICAgICBpZiAocmVzcG9uc2VUeXBlICE9IG51bGwpIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHhoci5vbihcImVycm9yXCIsIGNhbGxiYWNrKS5vbihcImxvYWRcIiwgZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXF1ZXN0KTtcbiAgICAgIH0pO1xuICAgICAgZGlzcGF0Y2guYmVmb3Jlc2VuZC5jYWxsKHhociwgcmVxdWVzdCk7XG4gICAgICByZXF1ZXN0LnNlbmQoZGF0YSA9PSBudWxsID8gbnVsbCA6IGRhdGEpO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIHhoci5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIGQzLnJlYmluZCh4aHIsIGRpc3BhdGNoLCBcIm9uXCIpO1xuICAgIHJldHVybiBjYWxsYmFjayA9PSBudWxsID8geGhyIDogeGhyLmdldChkM194aHJfZml4Q2FsbGJhY2soY2FsbGJhY2spKTtcbiAgfVxuICBmdW5jdGlvbiBkM194aHJfZml4Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICByZXR1cm4gY2FsbGJhY2subGVuZ3RoID09PSAxID8gZnVuY3Rpb24oZXJyb3IsIHJlcXVlc3QpIHtcbiAgICAgIGNhbGxiYWNrKGVycm9yID09IG51bGwgPyByZXF1ZXN0IDogbnVsbCk7XG4gICAgfSA6IGNhbGxiYWNrO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3hockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHtcbiAgICB2YXIgdHlwZSA9IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICAgIHJldHVybiB0eXBlICYmIHR5cGUgIT09IFwidGV4dFwiID8gcmVxdWVzdC5yZXNwb25zZSA6IHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICB9XG4gIGQzLmRzdiA9IGZ1bmN0aW9uKGRlbGltaXRlciwgbWltZVR5cGUpIHtcbiAgICB2YXIgcmVGb3JtYXQgPSBuZXcgUmVnRXhwKCdbXCInICsgZGVsaW1pdGVyICsgXCJcXG5dXCIpLCBkZWxpbWl0ZXJDb2RlID0gZGVsaW1pdGVyLmNoYXJDb2RlQXQoMCk7XG4gICAgZnVuY3Rpb24gZHN2KHVybCwgcm93LCBjYWxsYmFjaykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBjYWxsYmFjayA9IHJvdywgcm93ID0gbnVsbDtcbiAgICAgIHZhciB4aHIgPSBkM194aHIodXJsLCBtaW1lVHlwZSwgcm93ID09IG51bGwgPyByZXNwb25zZSA6IHR5cGVkUmVzcG9uc2Uocm93KSwgY2FsbGJhY2spO1xuICAgICAgeGhyLnJvdyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB4aHIucmVzcG9uc2UoKHJvdyA9IF8pID09IG51bGwgPyByZXNwb25zZSA6IHR5cGVkUmVzcG9uc2UoXykpIDogcm93O1xuICAgICAgfTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlKHJlcXVlc3QpIHtcbiAgICAgIHJldHVybiBkc3YucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0eXBlZFJlc3BvbnNlKGYpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBkc3YucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQsIGYpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZHN2LnBhcnNlID0gZnVuY3Rpb24odGV4dCwgZikge1xuICAgICAgdmFyIG87XG4gICAgICByZXR1cm4gZHN2LnBhcnNlUm93cyh0ZXh0LCBmdW5jdGlvbihyb3csIGkpIHtcbiAgICAgICAgaWYgKG8pIHJldHVybiBvKHJvdywgaSAtIDEpO1xuICAgICAgICB2YXIgYSA9IG5ldyBGdW5jdGlvbihcImRcIiwgXCJyZXR1cm4ge1wiICsgcm93Lm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgXCI6IGRbXCIgKyBpICsgXCJdXCI7XG4gICAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xuICAgICAgICBvID0gZiA/IGZ1bmN0aW9uKHJvdywgaSkge1xuICAgICAgICAgIHJldHVybiBmKGEocm93KSwgaSk7XG4gICAgICAgIH0gOiBhO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBkc3YucGFyc2VSb3dzID0gZnVuY3Rpb24odGV4dCwgZikge1xuICAgICAgdmFyIEVPTCA9IHt9LCBFT0YgPSB7fSwgcm93cyA9IFtdLCBOID0gdGV4dC5sZW5ndGgsIEkgPSAwLCBuID0gMCwgdCwgZW9sO1xuICAgICAgZnVuY3Rpb24gdG9rZW4oKSB7XG4gICAgICAgIGlmIChJID49IE4pIHJldHVybiBFT0Y7XG4gICAgICAgIGlmIChlb2wpIHJldHVybiBlb2wgPSBmYWxzZSwgRU9MO1xuICAgICAgICB2YXIgaiA9IEk7XG4gICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaikgPT09IDM0KSB7XG4gICAgICAgICAgdmFyIGkgPSBqO1xuICAgICAgICAgIHdoaWxlIChpKysgPCBOKSB7XG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSAzNCkge1xuICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMzQpIGJyZWFrO1xuICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIEkgPSBpICsgMjtcbiAgICAgICAgICB2YXIgYyA9IHRleHQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgaWYgKGMgPT09IDEzKSB7XG4gICAgICAgICAgICBlb2wgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpICsgMikgPT09IDEwKSArK0k7XG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAxMCkge1xuICAgICAgICAgICAgZW9sID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiArIDEsIGkpLnJlcGxhY2UoL1wiXCIvZywgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKEkgPCBOKSB7XG4gICAgICAgICAgdmFyIGMgPSB0ZXh0LmNoYXJDb2RlQXQoSSsrKSwgayA9IDE7XG4gICAgICAgICAgaWYgKGMgPT09IDEwKSBlb2wgPSB0cnVlOyBlbHNlIGlmIChjID09PSAxMykge1xuICAgICAgICAgICAgZW9sID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IDEwKSArK0ksICsraztcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgIT09IGRlbGltaXRlckNvZGUpIGNvbnRpbnVlO1xuICAgICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGosIEkgLSBrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgodCA9IHRva2VuKCkpICE9PSBFT0YpIHtcbiAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgd2hpbGUgKHQgIT09IEVPTCAmJiB0ICE9PSBFT0YpIHtcbiAgICAgICAgICBhLnB1c2godCk7XG4gICAgICAgICAgdCA9IHRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYgJiYgKGEgPSBmKGEsIG4rKykpID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICByb3dzLnB1c2goYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93cztcbiAgICB9O1xuICAgIGRzdi5mb3JtYXQgPSBmdW5jdGlvbihyb3dzKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyb3dzWzBdKSkgcmV0dXJuIGRzdi5mb3JtYXRSb3dzKHJvd3MpO1xuICAgICAgdmFyIGZpZWxkU2V0ID0gbmV3IGQzX1NldCgpLCBmaWVsZHMgPSBbXTtcbiAgICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgZm9yICh2YXIgZmllbGQgaW4gcm93KSB7XG4gICAgICAgICAgaWYgKCFmaWVsZFNldC5oYXMoZmllbGQpKSB7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChmaWVsZFNldC5hZGQoZmllbGQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFsgZmllbGRzLm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpIF0uY29uY2F0KHJvd3MubWFwKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICByZXR1cm4gZmllbGRzLm1hcChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShyb3dbZmllbGRdKTtcbiAgICAgICAgfSkuam9pbihkZWxpbWl0ZXIpO1xuICAgICAgfSkpLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICBkc3YuZm9ybWF0Um93cyA9IGZ1bmN0aW9uKHJvd3MpIHtcbiAgICAgIHJldHVybiByb3dzLm1hcChmb3JtYXRSb3cpLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBmb3JtYXRSb3cocm93KSB7XG4gICAgICByZXR1cm4gcm93Lm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh0ZXh0KSB7XG4gICAgICByZXR1cm4gcmVGb3JtYXQudGVzdCh0ZXh0KSA/ICdcIicgKyB0ZXh0LnJlcGxhY2UoL1xcXCIvZywgJ1wiXCInKSArICdcIicgOiB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gZHN2O1xuICB9O1xuICBkMy5jc3YgPSBkMy5kc3YoXCIsXCIsIFwidGV4dC9jc3ZcIik7XG4gIGQzLnRzdiA9IGQzLmRzdihcIlx0XCIsIFwidGV4dC90YWItc2VwYXJhdGVkLXZhbHVlc1wiKTtcbiAgdmFyIGQzX3RpbWVyX3F1ZXVlSGVhZCwgZDNfdGltZXJfcXVldWVUYWlsLCBkM190aW1lcl9pbnRlcnZhbCwgZDNfdGltZXJfdGltZW91dCwgZDNfdGltZXJfZnJhbWUgPSB0aGlzW2QzX3ZlbmRvclN5bWJvbCh0aGlzLCBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiKV0gfHwgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxNyk7XG4gIH07XG4gIGQzLnRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgZDNfdGltZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdGltZXIoY2FsbGJhY2ssIGRlbGF5LCB0aGVuKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChuIDwgMikgZGVsYXkgPSAwO1xuICAgIGlmIChuIDwgMykgdGhlbiA9IERhdGUubm93KCk7XG4gICAgdmFyIHRpbWUgPSB0aGVuICsgZGVsYXksIHRpbWVyID0ge1xuICAgICAgYzogY2FsbGJhY2ssXG4gICAgICB0OiB0aW1lLFxuICAgICAgbjogbnVsbFxuICAgIH07XG4gICAgaWYgKGQzX3RpbWVyX3F1ZXVlVGFpbCkgZDNfdGltZXJfcXVldWVUYWlsLm4gPSB0aW1lcjsgZWxzZSBkM190aW1lcl9xdWV1ZUhlYWQgPSB0aW1lcjtcbiAgICBkM190aW1lcl9xdWV1ZVRhaWwgPSB0aW1lcjtcbiAgICBpZiAoIWQzX3RpbWVyX2ludGVydmFsKSB7XG4gICAgICBkM190aW1lcl90aW1lb3V0ID0gY2xlYXJUaW1lb3V0KGQzX3RpbWVyX3RpbWVvdXQpO1xuICAgICAgZDNfdGltZXJfaW50ZXJ2YWwgPSAxO1xuICAgICAgZDNfdGltZXJfZnJhbWUoZDNfdGltZXJfc3RlcCk7XG4gICAgfVxuICAgIHJldHVybiB0aW1lcjtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lcl9zdGVwKCkge1xuICAgIHZhciBub3cgPSBkM190aW1lcl9tYXJrKCksIGRlbGF5ID0gZDNfdGltZXJfc3dlZXAoKSAtIG5vdztcbiAgICBpZiAoZGVsYXkgPiAyNCkge1xuICAgICAgaWYgKGlzRmluaXRlKGRlbGF5KSkge1xuICAgICAgICBjbGVhclRpbWVvdXQoZDNfdGltZXJfdGltZW91dCk7XG4gICAgICAgIGQzX3RpbWVyX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGQzX3RpbWVyX3N0ZXAsIGRlbGF5KTtcbiAgICAgIH1cbiAgICAgIGQzX3RpbWVyX2ludGVydmFsID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZDNfdGltZXJfaW50ZXJ2YWwgPSAxO1xuICAgICAgZDNfdGltZXJfZnJhbWUoZDNfdGltZXJfc3RlcCk7XG4gICAgfVxuICB9XG4gIGQzLnRpbWVyLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgZDNfdGltZXJfbWFyaygpO1xuICAgIGQzX3RpbWVyX3N3ZWVwKCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RpbWVyX21hcmsoKSB7XG4gICAgdmFyIG5vdyA9IERhdGUubm93KCksIHRpbWVyID0gZDNfdGltZXJfcXVldWVIZWFkO1xuICAgIHdoaWxlICh0aW1lcikge1xuICAgICAgaWYgKG5vdyA+PSB0aW1lci50ICYmIHRpbWVyLmMobm93IC0gdGltZXIudCkpIHRpbWVyLmMgPSBudWxsO1xuICAgICAgdGltZXIgPSB0aW1lci5uO1xuICAgIH1cbiAgICByZXR1cm4gbm93O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVyX3N3ZWVwKCkge1xuICAgIHZhciB0MCwgdDEgPSBkM190aW1lcl9xdWV1ZUhlYWQsIHRpbWUgPSBJbmZpbml0eTtcbiAgICB3aGlsZSAodDEpIHtcbiAgICAgIGlmICh0MS5jKSB7XG4gICAgICAgIGlmICh0MS50IDwgdGltZSkgdGltZSA9IHQxLnQ7XG4gICAgICAgIHQxID0gKHQwID0gdDEpLm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0MSA9IHQwID8gdDAubiA9IHQxLm4gOiBkM190aW1lcl9xdWV1ZUhlYWQgPSB0MS5uO1xuICAgICAgfVxuICAgIH1cbiAgICBkM190aW1lcl9xdWV1ZVRhaWwgPSB0MDtcbiAgICByZXR1cm4gdGltZTtcbiAgfVxuICBmdW5jdGlvbiBkM19mb3JtYXRfcHJlY2lzaW9uKHgsIHApIHtcbiAgICByZXR1cm4gcCAtICh4ID8gTWF0aC5jZWlsKE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwKSA6IDEpO1xuICB9XG4gIGQzLnJvdW5kID0gZnVuY3Rpb24oeCwgbikge1xuICAgIHJldHVybiBuID8gTWF0aC5yb3VuZCh4ICogKG4gPSBNYXRoLnBvdygxMCwgbikpKSAvIG4gOiBNYXRoLnJvdW5kKHgpO1xuICB9O1xuICB2YXIgZDNfZm9ybWF0UHJlZml4ZXMgPSBbIFwieVwiLCBcInpcIiwgXCJhXCIsIFwiZlwiLCBcInBcIiwgXCJuXCIsIFwiwrVcIiwgXCJtXCIsIFwiXCIsIFwia1wiLCBcIk1cIiwgXCJHXCIsIFwiVFwiLCBcIlBcIiwgXCJFXCIsIFwiWlwiLCBcIllcIiBdLm1hcChkM19mb3JtYXRQcmVmaXgpO1xuICBkMy5mb3JtYXRQcmVmaXggPSBmdW5jdGlvbih2YWx1ZSwgcHJlY2lzaW9uKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIGlmICh2YWx1ZSA9ICt2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgKj0gLTE7XG4gICAgICBpZiAocHJlY2lzaW9uKSB2YWx1ZSA9IGQzLnJvdW5kKHZhbHVlLCBkM19mb3JtYXRfcHJlY2lzaW9uKHZhbHVlLCBwcmVjaXNpb24pKTtcbiAgICAgIGkgPSAxICsgTWF0aC5mbG9vcigxZS0xMiArIE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4xMCk7XG4gICAgICBpID0gTWF0aC5tYXgoLTI0LCBNYXRoLm1pbigyNCwgTWF0aC5mbG9vcigoaSAtIDEpIC8gMykgKiAzKSk7XG4gICAgfVxuICAgIHJldHVybiBkM19mb3JtYXRQcmVmaXhlc1s4ICsgaSAvIDNdO1xuICB9O1xuICBmdW5jdGlvbiBkM19mb3JtYXRQcmVmaXgoZCwgaSkge1xuICAgIHZhciBrID0gTWF0aC5wb3coMTAsIGFicyg4IC0gaSkgKiAzKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGU6IGkgPiA4ID8gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZCAvIGs7XG4gICAgICB9IDogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZCAqIGs7XG4gICAgICB9LFxuICAgICAgc3ltYm9sOiBkXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19sb2NhbGVfbnVtYmVyRm9ybWF0KGxvY2FsZSkge1xuICAgIHZhciBsb2NhbGVfZGVjaW1hbCA9IGxvY2FsZS5kZWNpbWFsLCBsb2NhbGVfdGhvdXNhbmRzID0gbG9jYWxlLnRob3VzYW5kcywgbG9jYWxlX2dyb3VwaW5nID0gbG9jYWxlLmdyb3VwaW5nLCBsb2NhbGVfY3VycmVuY3kgPSBsb2NhbGUuY3VycmVuY3ksIGZvcm1hdEdyb3VwID0gbG9jYWxlX2dyb3VwaW5nICYmIGxvY2FsZV90aG91c2FuZHMgPyBmdW5jdGlvbih2YWx1ZSwgd2lkdGgpIHtcbiAgICAgIHZhciBpID0gdmFsdWUubGVuZ3RoLCB0ID0gW10sIGogPSAwLCBnID0gbG9jYWxlX2dyb3VwaW5nWzBdLCBsZW5ndGggPSAwO1xuICAgICAgd2hpbGUgKGkgPiAwICYmIGcgPiAwKSB7XG4gICAgICAgIGlmIChsZW5ndGggKyBnICsgMSA+IHdpZHRoKSBnID0gTWF0aC5tYXgoMSwgd2lkdGggLSBsZW5ndGgpO1xuICAgICAgICB0LnB1c2godmFsdWUuc3Vic3RyaW5nKGkgLT0gZywgaSArIGcpKTtcbiAgICAgICAgaWYgKChsZW5ndGggKz0gZyArIDEpID4gd2lkdGgpIGJyZWFrO1xuICAgICAgICBnID0gbG9jYWxlX2dyb3VwaW5nW2ogPSAoaiArIDEpICUgbG9jYWxlX2dyb3VwaW5nLmxlbmd0aF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdC5yZXZlcnNlKCkuam9pbihsb2NhbGVfdGhvdXNhbmRzKTtcbiAgICB9IDogZDNfaWRlbnRpdHk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIG1hdGNoID0gZDNfZm9ybWF0X3JlLmV4ZWMoc3BlY2lmaWVyKSwgZmlsbCA9IG1hdGNoWzFdIHx8IFwiIFwiLCBhbGlnbiA9IG1hdGNoWzJdIHx8IFwiPlwiLCBzaWduID0gbWF0Y2hbM10gfHwgXCItXCIsIHN5bWJvbCA9IG1hdGNoWzRdIHx8IFwiXCIsIHpmaWxsID0gbWF0Y2hbNV0sIHdpZHRoID0gK21hdGNoWzZdLCBjb21tYSA9IG1hdGNoWzddLCBwcmVjaXNpb24gPSBtYXRjaFs4XSwgdHlwZSA9IG1hdGNoWzldLCBzY2FsZSA9IDEsIHByZWZpeCA9IFwiXCIsIHN1ZmZpeCA9IFwiXCIsIGludGVnZXIgPSBmYWxzZSwgZXhwb25lbnQgPSB0cnVlO1xuICAgICAgaWYgKHByZWNpc2lvbikgcHJlY2lzaW9uID0gK3ByZWNpc2lvbi5zdWJzdHJpbmcoMSk7XG4gICAgICBpZiAoemZpbGwgfHwgZmlsbCA9PT0gXCIwXCIgJiYgYWxpZ24gPT09IFwiPVwiKSB7XG4gICAgICAgIHpmaWxsID0gZmlsbCA9IFwiMFwiO1xuICAgICAgICBhbGlnbiA9IFwiPVwiO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgY2FzZSBcIm5cIjpcbiAgICAgICAgY29tbWEgPSB0cnVlO1xuICAgICAgICB0eXBlID0gXCJnXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgc2NhbGUgPSAxMDA7XG4gICAgICAgIHN1ZmZpeCA9IFwiJVwiO1xuICAgICAgICB0eXBlID0gXCJmXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcInBcIjpcbiAgICAgICAgc2NhbGUgPSAxMDA7XG4gICAgICAgIHN1ZmZpeCA9IFwiJVwiO1xuICAgICAgICB0eXBlID0gXCJyXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcImJcIjpcbiAgICAgICBjYXNlIFwib1wiOlxuICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgaWYgKHN5bWJvbCA9PT0gXCIjXCIpIHByZWZpeCA9IFwiMFwiICsgdHlwZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgZXhwb25lbnQgPSBmYWxzZTtcblxuICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgIGludGVnZXIgPSB0cnVlO1xuICAgICAgICBwcmVjaXNpb24gPSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgIHNjYWxlID0gLTE7XG4gICAgICAgIHR5cGUgPSBcInJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3ltYm9sID09PSBcIiRcIikgcHJlZml4ID0gbG9jYWxlX2N1cnJlbmN5WzBdLCBzdWZmaXggPSBsb2NhbGVfY3VycmVuY3lbMV07XG4gICAgICBpZiAodHlwZSA9PSBcInJcIiAmJiAhcHJlY2lzaW9uKSB0eXBlID0gXCJnXCI7XG4gICAgICBpZiAocHJlY2lzaW9uICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJnXCIpIHByZWNpc2lvbiA9IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCBwcmVjaXNpb24pKTsgZWxzZSBpZiAodHlwZSA9PSBcImVcIiB8fCB0eXBlID09IFwiZlwiKSBwcmVjaXNpb24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgcHJlY2lzaW9uKSk7XG4gICAgICB9XG4gICAgICB0eXBlID0gZDNfZm9ybWF0X3R5cGVzLmdldCh0eXBlKSB8fCBkM19mb3JtYXRfdHlwZURlZmF1bHQ7XG4gICAgICB2YXIgemNvbW1hID0gemZpbGwgJiYgY29tbWE7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGZ1bGxTdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIGlmIChpbnRlZ2VyICYmIHZhbHVlICUgMSkgcmV0dXJuIFwiXCI7XG4gICAgICAgIHZhciBuZWdhdGl2ZSA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gKHZhbHVlID0gLXZhbHVlLCBcIi1cIikgOiBzaWduID09PSBcIi1cIiA/IFwiXCIgOiBzaWduO1xuICAgICAgICBpZiAoc2NhbGUgPCAwKSB7XG4gICAgICAgICAgdmFyIHVuaXQgPSBkMy5mb3JtYXRQcmVmaXgodmFsdWUsIHByZWNpc2lvbik7XG4gICAgICAgICAgdmFsdWUgPSB1bml0LnNjYWxlKHZhbHVlKTtcbiAgICAgICAgICBmdWxsU3VmZml4ID0gdW5pdC5zeW1ib2wgKyBzdWZmaXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgKj0gc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB0eXBlKHZhbHVlLCBwcmVjaXNpb24pO1xuICAgICAgICB2YXIgaSA9IHZhbHVlLmxhc3RJbmRleE9mKFwiLlwiKSwgYmVmb3JlLCBhZnRlcjtcbiAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgdmFyIGogPSBleHBvbmVudCA/IHZhbHVlLmxhc3RJbmRleE9mKFwiZVwiKSA6IC0xO1xuICAgICAgICAgIGlmIChqIDwgMCkgYmVmb3JlID0gdmFsdWUsIGFmdGVyID0gXCJcIjsgZWxzZSBiZWZvcmUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgaiksIGFmdGVyID0gdmFsdWUuc3Vic3RyaW5nKGopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJlZm9yZSA9IHZhbHVlLnN1YnN0cmluZygwLCBpKTtcbiAgICAgICAgICBhZnRlciA9IGxvY2FsZV9kZWNpbWFsICsgdmFsdWUuc3Vic3RyaW5nKGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXpmaWxsICYmIGNvbW1hKSBiZWZvcmUgPSBmb3JtYXRHcm91cChiZWZvcmUsIEluZmluaXR5KTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHByZWZpeC5sZW5ndGggKyBiZWZvcmUubGVuZ3RoICsgYWZ0ZXIubGVuZ3RoICsgKHpjb21tYSA/IDAgOiBuZWdhdGl2ZS5sZW5ndGgpLCBwYWRkaW5nID0gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkobGVuZ3RoID0gd2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpIDogXCJcIjtcbiAgICAgICAgaWYgKHpjb21tYSkgYmVmb3JlID0gZm9ybWF0R3JvdXAocGFkZGluZyArIGJlZm9yZSwgcGFkZGluZy5sZW5ndGggPyB3aWR0aCAtIGFmdGVyLmxlbmd0aCA6IEluZmluaXR5KTtcbiAgICAgICAgbmVnYXRpdmUgKz0gcHJlZml4O1xuICAgICAgICB2YWx1ZSA9IGJlZm9yZSArIGFmdGVyO1xuICAgICAgICByZXR1cm4gKGFsaWduID09PSBcIjxcIiA/IG5lZ2F0aXZlICsgdmFsdWUgKyBwYWRkaW5nIDogYWxpZ24gPT09IFwiPlwiID8gcGFkZGluZyArIG5lZ2F0aXZlICsgdmFsdWUgOiBhbGlnbiA9PT0gXCJeXCIgPyBwYWRkaW5nLnN1YnN0cmluZygwLCBsZW5ndGggPj49IDEpICsgbmVnYXRpdmUgKyB2YWx1ZSArIHBhZGRpbmcuc3Vic3RyaW5nKGxlbmd0aCkgOiBuZWdhdGl2ZSArICh6Y29tbWEgPyB2YWx1ZSA6IHBhZGRpbmcgKyB2YWx1ZSkpICsgZnVsbFN1ZmZpeDtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfZm9ybWF0X3JlID0gLyg/OihbXntdKT8oWzw+PV5dKSk/KFsrXFwtIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuLT9cXGQrKT8oW2EteiVdKT8vaTtcbiAgdmFyIGQzX2Zvcm1hdF90eXBlcyA9IGQzLm1hcCh7XG4gICAgYjogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHgudG9TdHJpbmcoMik7XG4gICAgfSxcbiAgICBjOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh4KTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnRvU3RyaW5nKDgpO1xuICAgIH0sXG4gICAgeDogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHgudG9TdHJpbmcoMTYpO1xuICAgIH0sXG4gICAgWDogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHgudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSxcbiAgICBnOiBmdW5jdGlvbih4LCBwKSB7XG4gICAgICByZXR1cm4geC50b1ByZWNpc2lvbihwKTtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uKHgsIHApIHtcbiAgICAgIHJldHVybiB4LnRvRXhwb25lbnRpYWwocCk7XG4gICAgfSxcbiAgICBmOiBmdW5jdGlvbih4LCBwKSB7XG4gICAgICByZXR1cm4geC50b0ZpeGVkKHApO1xuICAgIH0sXG4gICAgcjogZnVuY3Rpb24oeCwgcCkge1xuICAgICAgcmV0dXJuICh4ID0gZDMucm91bmQoeCwgZDNfZm9ybWF0X3ByZWNpc2lvbih4LCBwKSkpLnRvRml4ZWQoTWF0aC5tYXgoMCwgTWF0aC5taW4oMjAsIGQzX2Zvcm1hdF9wcmVjaXNpb24oeCAqICgxICsgMWUtMTUpLCBwKSkpKTtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBkM19mb3JtYXRfdHlwZURlZmF1bHQoeCkge1xuICAgIHJldHVybiB4ICsgXCJcIjtcbiAgfVxuICB2YXIgZDNfdGltZSA9IGQzLnRpbWUgPSB7fSwgZDNfZGF0ZSA9IERhdGU7XG4gIGZ1bmN0aW9uIGQzX2RhdGVfdXRjKCkge1xuICAgIHRoaXMuXyA9IG5ldyBEYXRlKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gRGF0ZS5VVEMuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGFyZ3VtZW50c1swXSk7XG4gIH1cbiAgZDNfZGF0ZV91dGMucHJvdG90eXBlID0ge1xuICAgIGdldERhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENEYXRlKCk7XG4gICAgfSxcbiAgICBnZXREYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENEYXkoKTtcbiAgICB9LFxuICAgIGdldEZ1bGxZZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDRnVsbFllYXIoKTtcbiAgICB9LFxuICAgIGdldEhvdXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDSG91cnMoKTtcbiAgICB9LFxuICAgIGdldE1pbGxpc2Vjb25kczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgIH0sXG4gICAgZ2V0TWludXRlczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ01pbnV0ZXMoKTtcbiAgICB9LFxuICAgIGdldE1vbnRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDTW9udGgoKTtcbiAgICB9LFxuICAgIGdldFNlY29uZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENTZWNvbmRzKCk7XG4gICAgfSxcbiAgICBnZXRUaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VGltZSgpO1xuICAgIH0sXG4gICAgZ2V0VGltZXpvbmVPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8udmFsdWVPZigpO1xuICAgIH0sXG4gICAgc2V0RGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENEYXRlLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldERheTogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENEYXkuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0RnVsbFllYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDRnVsbFllYXIuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0SG91cnM6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDSG91cnMuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0TWlsbGlzZWNvbmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ01pbGxpc2Vjb25kcy5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRNaW51dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ01pbnV0ZXMuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0TW9udGg6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDTW9udGguYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0U2Vjb25kczogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENTZWNvbmRzLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VGltZS5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuICB2YXIgZDNfdGltZV9wcm90b3R5cGUgPSBEYXRlLnByb3RvdHlwZTtcbiAgZnVuY3Rpb24gZDNfdGltZV9pbnRlcnZhbChsb2NhbCwgc3RlcCwgbnVtYmVyKSB7XG4gICAgZnVuY3Rpb24gcm91bmQoZGF0ZSkge1xuICAgICAgdmFyIGQwID0gbG9jYWwoZGF0ZSksIGQxID0gb2Zmc2V0KGQwLCAxKTtcbiAgICAgIHJldHVybiBkYXRlIC0gZDAgPCBkMSAtIGRhdGUgPyBkMCA6IGQxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZWlsKGRhdGUpIHtcbiAgICAgIHN0ZXAoZGF0ZSA9IGxvY2FsKG5ldyBkM19kYXRlKGRhdGUgLSAxKSksIDEpO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9mZnNldChkYXRlLCBrKSB7XG4gICAgICBzdGVwKGRhdGUgPSBuZXcgZDNfZGF0ZSgrZGF0ZSksIGspO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhbmdlKHQwLCB0MSwgZHQpIHtcbiAgICAgIHZhciB0aW1lID0gY2VpbCh0MCksIHRpbWVzID0gW107XG4gICAgICBpZiAoZHQgPiAxKSB7XG4gICAgICAgIHdoaWxlICh0aW1lIDwgdDEpIHtcbiAgICAgICAgICBpZiAoIShudW1iZXIodGltZSkgJSBkdCkpIHRpbWVzLnB1c2gobmV3IERhdGUoK3RpbWUpKTtcbiAgICAgICAgICBzdGVwKHRpbWUsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAodGltZSA8IHQxKSB0aW1lcy5wdXNoKG5ldyBEYXRlKCt0aW1lKSksIHN0ZXAodGltZSwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGltZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhbmdlX3V0Yyh0MCwgdDEsIGR0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBkM19kYXRlID0gZDNfZGF0ZV91dGM7XG4gICAgICAgIHZhciB1dGMgPSBuZXcgZDNfZGF0ZV91dGMoKTtcbiAgICAgICAgdXRjLl8gPSB0MDtcbiAgICAgICAgcmV0dXJuIHJhbmdlKHV0YywgdDEsIGR0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGQzX2RhdGUgPSBEYXRlO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2NhbC5mbG9vciA9IGxvY2FsO1xuICAgIGxvY2FsLnJvdW5kID0gcm91bmQ7XG4gICAgbG9jYWwuY2VpbCA9IGNlaWw7XG4gICAgbG9jYWwub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIGxvY2FsLnJhbmdlID0gcmFuZ2U7XG4gICAgdmFyIHV0YyA9IGxvY2FsLnV0YyA9IGQzX3RpbWVfaW50ZXJ2YWxfdXRjKGxvY2FsKTtcbiAgICB1dGMuZmxvb3IgPSB1dGM7XG4gICAgdXRjLnJvdW5kID0gZDNfdGltZV9pbnRlcnZhbF91dGMocm91bmQpO1xuICAgIHV0Yy5jZWlsID0gZDNfdGltZV9pbnRlcnZhbF91dGMoY2VpbCk7XG4gICAgdXRjLm9mZnNldCA9IGQzX3RpbWVfaW50ZXJ2YWxfdXRjKG9mZnNldCk7XG4gICAgdXRjLnJhbmdlID0gcmFuZ2VfdXRjO1xuICAgIHJldHVybiBsb2NhbDtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2ludGVydmFsX3V0YyhtZXRob2QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0ZSwgaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZDNfZGF0ZSA9IGQzX2RhdGVfdXRjO1xuICAgICAgICB2YXIgdXRjID0gbmV3IGQzX2RhdGVfdXRjKCk7XG4gICAgICAgIHV0Yy5fID0gZGF0ZTtcbiAgICAgICAgcmV0dXJuIG1ldGhvZCh1dGMsIGspLl87XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkM19kYXRlID0gRGF0ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGQzX3RpbWUueWVhciA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUgPSBkM190aW1lLmRheShkYXRlKTtcbiAgICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICAgIHJldHVybiBkYXRlO1xuICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIG9mZnNldCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICB9KTtcbiAgZDNfdGltZS55ZWFycyA9IGQzX3RpbWUueWVhci5yYW5nZTtcbiAgZDNfdGltZS55ZWFycy51dGMgPSBkM190aW1lLnllYXIudXRjLnJhbmdlO1xuICBkM190aW1lLmRheSA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciBkYXkgPSBuZXcgZDNfZGF0ZSgyZTMsIDApO1xuICAgIGRheS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpO1xuICAgIHJldHVybiBkYXk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIG9mZnNldCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXREYXRlKCkgLSAxO1xuICB9KTtcbiAgZDNfdGltZS5kYXlzID0gZDNfdGltZS5kYXkucmFuZ2U7XG4gIGQzX3RpbWUuZGF5cy51dGMgPSBkM190aW1lLmRheS51dGMucmFuZ2U7XG4gIGQzX3RpbWUuZGF5T2ZZZWFyID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciB5ZWFyID0gZDNfdGltZS55ZWFyKGRhdGUpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKChkYXRlIC0geWVhciAtIChkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgLSB5ZWFyLmdldFRpbWV6b25lT2Zmc2V0KCkpICogNmU0KSAvIDg2NGU1KTtcbiAgfTtcbiAgWyBcInN1bmRheVwiLCBcIm1vbmRheVwiLCBcInR1ZXNkYXlcIiwgXCJ3ZWRuZXNkYXlcIiwgXCJ0aHVyc2RheVwiLCBcImZyaWRheVwiLCBcInNhdHVyZGF5XCIgXS5mb3JFYWNoKGZ1bmN0aW9uKGRheSwgaSkge1xuICAgIGkgPSA3IC0gaTtcbiAgICB2YXIgaW50ZXJ2YWwgPSBkM190aW1lW2RheV0gPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIChkYXRlID0gZDNfdGltZS5kYXkoZGF0ZSkpLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSAoZGF0ZS5nZXREYXkoKSArIGkpICUgNyk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIE1hdGguZmxvb3Iob2Zmc2V0KSAqIDcpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBkYXkgPSBkM190aW1lLnllYXIoZGF0ZSkuZ2V0RGF5KCk7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcigoZDNfdGltZS5kYXlPZlllYXIoZGF0ZSkgKyAoZGF5ICsgaSkgJSA3KSAvIDcpIC0gKGRheSAhPT0gaSk7XG4gICAgfSk7XG4gICAgZDNfdGltZVtkYXkgKyBcInNcIl0gPSBpbnRlcnZhbC5yYW5nZTtcbiAgICBkM190aW1lW2RheSArIFwic1wiXS51dGMgPSBpbnRlcnZhbC51dGMucmFuZ2U7XG4gICAgZDNfdGltZVtkYXkgKyBcIk9mWWVhclwiXSA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBkYXkgPSBkM190aW1lLnllYXIoZGF0ZSkuZ2V0RGF5KCk7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcigoZDNfdGltZS5kYXlPZlllYXIoZGF0ZSkgKyAoZGF5ICsgaSkgJSA3KSAvIDcpO1xuICAgIH07XG4gIH0pO1xuICBkM190aW1lLndlZWsgPSBkM190aW1lLnN1bmRheTtcbiAgZDNfdGltZS53ZWVrcyA9IGQzX3RpbWUuc3VuZGF5LnJhbmdlO1xuICBkM190aW1lLndlZWtzLnV0YyA9IGQzX3RpbWUuc3VuZGF5LnV0Yy5yYW5nZTtcbiAgZDNfdGltZS53ZWVrT2ZZZWFyID0gZDNfdGltZS5zdW5kYXlPZlllYXI7XG4gIGZ1bmN0aW9uIGQzX2xvY2FsZV90aW1lRm9ybWF0KGxvY2FsZSkge1xuICAgIHZhciBsb2NhbGVfZGF0ZVRpbWUgPSBsb2NhbGUuZGF0ZVRpbWUsIGxvY2FsZV9kYXRlID0gbG9jYWxlLmRhdGUsIGxvY2FsZV90aW1lID0gbG9jYWxlLnRpbWUsIGxvY2FsZV9wZXJpb2RzID0gbG9jYWxlLnBlcmlvZHMsIGxvY2FsZV9kYXlzID0gbG9jYWxlLmRheXMsIGxvY2FsZV9zaG9ydERheXMgPSBsb2NhbGUuc2hvcnREYXlzLCBsb2NhbGVfbW9udGhzID0gbG9jYWxlLm1vbnRocywgbG9jYWxlX3Nob3J0TW9udGhzID0gbG9jYWxlLnNob3J0TW9udGhzO1xuICAgIGZ1bmN0aW9uIGQzX3RpbWVfZm9ybWF0KHRlbXBsYXRlKSB7XG4gICAgICB2YXIgbiA9IHRlbXBsYXRlLmxlbmd0aDtcbiAgICAgIGZ1bmN0aW9uIGZvcm1hdChkYXRlKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSBbXSwgaSA9IC0xLCBqID0gMCwgYywgcCwgZjtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBpZiAodGVtcGxhdGUuY2hhckNvZGVBdChpKSA9PT0gMzcpIHtcbiAgICAgICAgICAgIHN0cmluZy5wdXNoKHRlbXBsYXRlLnNsaWNlKGosIGkpKTtcbiAgICAgICAgICAgIGlmICgocCA9IGQzX3RpbWVfZm9ybWF0UGFkc1tjID0gdGVtcGxhdGUuY2hhckF0KCsraSldKSAhPSBudWxsKSBjID0gdGVtcGxhdGUuY2hhckF0KCsraSk7XG4gICAgICAgICAgICBpZiAoZiA9IGQzX3RpbWVfZm9ybWF0c1tjXSkgYyA9IGYoZGF0ZSwgcCA9PSBudWxsID8gYyA9PT0gXCJlXCIgPyBcIiBcIiA6IFwiMFwiIDogcCk7XG4gICAgICAgICAgICBzdHJpbmcucHVzaChjKTtcbiAgICAgICAgICAgIGogPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyaW5nLnB1c2godGVtcGxhdGUuc2xpY2UoaiwgaSkpO1xuICAgICAgICByZXR1cm4gc3RyaW5nLmpvaW4oXCJcIik7XG4gICAgICB9XG4gICAgICBmb3JtYXQucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdmFyIGQgPSB7XG4gICAgICAgICAgeTogMTkwMCxcbiAgICAgICAgICBtOiAwLFxuICAgICAgICAgIGQ6IDEsXG4gICAgICAgICAgSDogMCxcbiAgICAgICAgICBNOiAwLFxuICAgICAgICAgIFM6IDAsXG4gICAgICAgICAgTDogMCxcbiAgICAgICAgICBaOiBudWxsXG4gICAgICAgIH0sIGkgPSBkM190aW1lX3BhcnNlKGQsIHRlbXBsYXRlLCBzdHJpbmcsIDApO1xuICAgICAgICBpZiAoaSAhPSBzdHJpbmcubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKFwicFwiIGluIGQpIGQuSCA9IGQuSCAlIDEyICsgZC5wICogMTI7XG4gICAgICAgIHZhciBsb2NhbFogPSBkLlogIT0gbnVsbCAmJiBkM19kYXRlICE9PSBkM19kYXRlX3V0YywgZGF0ZSA9IG5ldyAobG9jYWxaID8gZDNfZGF0ZV91dGMgOiBkM19kYXRlKSgpO1xuICAgICAgICBpZiAoXCJqXCIgaW4gZCkgZGF0ZS5zZXRGdWxsWWVhcihkLnksIDAsIGQuaik7IGVsc2UgaWYgKFwiV1wiIGluIGQgfHwgXCJVXCIgaW4gZCkge1xuICAgICAgICAgIGlmICghKFwid1wiIGluIGQpKSBkLncgPSBcIldcIiBpbiBkID8gMSA6IDA7XG4gICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcihkLnksIDAsIDEpO1xuICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoZC55LCAwLCBcIldcIiBpbiBkID8gKGQudyArIDYpICUgNyArIGQuVyAqIDcgLSAoZGF0ZS5nZXREYXkoKSArIDUpICUgNyA6IGQudyArIGQuVSAqIDcgLSAoZGF0ZS5nZXREYXkoKSArIDYpICUgNyk7XG4gICAgICAgIH0gZWxzZSBkYXRlLnNldEZ1bGxZZWFyKGQueSwgZC5tLCBkLmQpO1xuICAgICAgICBkYXRlLnNldEhvdXJzKGQuSCArIChkLlogLyAxMDAgfCAwKSwgZC5NICsgZC5aICUgMTAwLCBkLlMsIGQuTCk7XG4gICAgICAgIHJldHVybiBsb2NhbFogPyBkYXRlLl8gOiBkYXRlO1xuICAgICAgfTtcbiAgICAgIGZvcm1hdC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZShkYXRlLCB0ZW1wbGF0ZSwgc3RyaW5nLCBqKSB7XG4gICAgICB2YXIgYywgcCwgdCwgaSA9IDAsIG4gPSB0ZW1wbGF0ZS5sZW5ndGgsIG0gPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICAgIGlmIChqID49IG0pIHJldHVybiAtMTtcbiAgICAgICAgYyA9IHRlbXBsYXRlLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgaWYgKGMgPT09IDM3KSB7XG4gICAgICAgICAgdCA9IHRlbXBsYXRlLmNoYXJBdChpKyspO1xuICAgICAgICAgIHAgPSBkM190aW1lX3BhcnNlcnNbdCBpbiBkM190aW1lX2Zvcm1hdFBhZHMgPyB0ZW1wbGF0ZS5jaGFyQXQoaSsrKSA6IHRdO1xuICAgICAgICAgIGlmICghcCB8fCAoaiA9IHAoZGF0ZSwgc3RyaW5nLCBqKSkgPCAwKSByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoYyAhPSBzdHJpbmcuY2hhckNvZGVBdChqKyspKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gajtcbiAgICB9XG4gICAgZDNfdGltZV9mb3JtYXQudXRjID0gZnVuY3Rpb24odGVtcGxhdGUpIHtcbiAgICAgIHZhciBsb2NhbCA9IGQzX3RpbWVfZm9ybWF0KHRlbXBsYXRlKTtcbiAgICAgIGZ1bmN0aW9uIGZvcm1hdChkYXRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZDNfZGF0ZSA9IGQzX2RhdGVfdXRjO1xuICAgICAgICAgIHZhciB1dGMgPSBuZXcgZDNfZGF0ZSgpO1xuICAgICAgICAgIHV0Yy5fID0gZGF0ZTtcbiAgICAgICAgICByZXR1cm4gbG9jYWwodXRjKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBkM19kYXRlID0gRGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9ybWF0LnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZDNfZGF0ZSA9IGQzX2RhdGVfdXRjO1xuICAgICAgICAgIHZhciBkYXRlID0gbG9jYWwucGFyc2Uoc3RyaW5nKTtcbiAgICAgICAgICByZXR1cm4gZGF0ZSAmJiBkYXRlLl87XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZDNfZGF0ZSA9IERhdGU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3JtYXQudG9TdHJpbmcgPSBsb2NhbC50b1N0cmluZztcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfTtcbiAgICBkM190aW1lX2Zvcm1hdC5tdWx0aSA9IGQzX3RpbWVfZm9ybWF0LnV0Yy5tdWx0aSA9IGQzX3RpbWVfZm9ybWF0TXVsdGk7XG4gICAgdmFyIGQzX3RpbWVfcGVyaW9kTG9va3VwID0gZDMubWFwKCksIGQzX3RpbWVfZGF5UmUgPSBkM190aW1lX2Zvcm1hdFJlKGxvY2FsZV9kYXlzKSwgZDNfdGltZV9kYXlMb29rdXAgPSBkM190aW1lX2Zvcm1hdExvb2t1cChsb2NhbGVfZGF5cyksIGQzX3RpbWVfZGF5QWJicmV2UmUgPSBkM190aW1lX2Zvcm1hdFJlKGxvY2FsZV9zaG9ydERheXMpLCBkM190aW1lX2RheUFiYnJldkxvb2t1cCA9IGQzX3RpbWVfZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydERheXMpLCBkM190aW1lX21vbnRoUmUgPSBkM190aW1lX2Zvcm1hdFJlKGxvY2FsZV9tb250aHMpLCBkM190aW1lX21vbnRoTG9va3VwID0gZDNfdGltZV9mb3JtYXRMb29rdXAobG9jYWxlX21vbnRocyksIGQzX3RpbWVfbW9udGhBYmJyZXZSZSA9IGQzX3RpbWVfZm9ybWF0UmUobG9jYWxlX3Nob3J0TW9udGhzKSwgZDNfdGltZV9tb250aEFiYnJldkxvb2t1cCA9IGQzX3RpbWVfZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydE1vbnRocyk7XG4gICAgbG9jYWxlX3BlcmlvZHMuZm9yRWFjaChmdW5jdGlvbihwLCBpKSB7XG4gICAgICBkM190aW1lX3BlcmlvZExvb2t1cC5zZXQocC50b0xvd2VyQ2FzZSgpLCBpKTtcbiAgICB9KTtcbiAgICB2YXIgZDNfdGltZV9mb3JtYXRzID0ge1xuICAgICAgYTogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlX3Nob3J0RGF5c1tkLmdldERheSgpXTtcbiAgICAgIH0sXG4gICAgICBBOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVfZGF5c1tkLmdldERheSgpXTtcbiAgICAgIH0sXG4gICAgICBiOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRNb250aCgpXTtcbiAgICAgIH0sXG4gICAgICBCOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0TW9udGgoKV07XG4gICAgICB9LFxuICAgICAgYzogZDNfdGltZV9mb3JtYXQobG9jYWxlX2RhdGVUaW1lKSxcbiAgICAgIGQ6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0RGF0ZSgpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBlOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldERhdGUoKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgSDogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRIb3VycygpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBJOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldEhvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG4gICAgICB9LFxuICAgICAgajogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoMSArIGQzX3RpbWUuZGF5T2ZZZWFyKGQpLCBwLCAzKTtcbiAgICAgIH0sXG4gICAgICBMOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldE1pbGxpc2Vjb25kcygpLCBwLCAzKTtcbiAgICAgIH0sXG4gICAgICBtOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldE1vbnRoKCkgKyAxLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBNOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldE1pbnV0ZXMoKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgcDogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldEhvdXJzKCkgPj0gMTIpXTtcbiAgICAgIH0sXG4gICAgICBTOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldFNlY29uZHMoKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgVTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZDNfdGltZS5zdW5kYXlPZlllYXIoZCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIHc6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0RGF5KCk7XG4gICAgICB9LFxuICAgICAgVzogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZDNfdGltZS5tb25kYXlPZlllYXIoZCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIHg6IGQzX3RpbWVfZm9ybWF0KGxvY2FsZV9kYXRlKSxcbiAgICAgIFg6IGQzX3RpbWVfZm9ybWF0KGxvY2FsZV90aW1lKSxcbiAgICAgIHk6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG4gICAgICB9LFxuICAgICAgWTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRGdWxsWWVhcigpICUgMWU0LCBwLCA0KTtcbiAgICAgIH0sXG4gICAgICBaOiBkM190aW1lX3pvbmUsXG4gICAgICBcIiVcIjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIiVcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBkM190aW1lX3BhcnNlcnMgPSB7XG4gICAgICBhOiBkM190aW1lX3BhcnNlV2Vla2RheUFiYnJldixcbiAgICAgIEE6IGQzX3RpbWVfcGFyc2VXZWVrZGF5LFxuICAgICAgYjogZDNfdGltZV9wYXJzZU1vbnRoQWJicmV2LFxuICAgICAgQjogZDNfdGltZV9wYXJzZU1vbnRoLFxuICAgICAgYzogZDNfdGltZV9wYXJzZUxvY2FsZUZ1bGwsXG4gICAgICBkOiBkM190aW1lX3BhcnNlRGF5LFxuICAgICAgZTogZDNfdGltZV9wYXJzZURheSxcbiAgICAgIEg6IGQzX3RpbWVfcGFyc2VIb3VyMjQsXG4gICAgICBJOiBkM190aW1lX3BhcnNlSG91cjI0LFxuICAgICAgajogZDNfdGltZV9wYXJzZURheU9mWWVhcixcbiAgICAgIEw6IGQzX3RpbWVfcGFyc2VNaWxsaXNlY29uZHMsXG4gICAgICBtOiBkM190aW1lX3BhcnNlTW9udGhOdW1iZXIsXG4gICAgICBNOiBkM190aW1lX3BhcnNlTWludXRlcyxcbiAgICAgIHA6IGQzX3RpbWVfcGFyc2VBbVBtLFxuICAgICAgUzogZDNfdGltZV9wYXJzZVNlY29uZHMsXG4gICAgICBVOiBkM190aW1lX3BhcnNlV2Vla051bWJlclN1bmRheSxcbiAgICAgIHc6IGQzX3RpbWVfcGFyc2VXZWVrZGF5TnVtYmVyLFxuICAgICAgVzogZDNfdGltZV9wYXJzZVdlZWtOdW1iZXJNb25kYXksXG4gICAgICB4OiBkM190aW1lX3BhcnNlTG9jYWxlRGF0ZSxcbiAgICAgIFg6IGQzX3RpbWVfcGFyc2VMb2NhbGVUaW1lLFxuICAgICAgeTogZDNfdGltZV9wYXJzZVllYXIsXG4gICAgICBZOiBkM190aW1lX3BhcnNlRnVsbFllYXIsXG4gICAgICBaOiBkM190aW1lX3BhcnNlWm9uZSxcbiAgICAgIFwiJVwiOiBkM190aW1lX3BhcnNlTGl0ZXJhbFBlcmNlbnRcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrZGF5QWJicmV2KGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgZDNfdGltZV9kYXlBYmJyZXZSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG4gPSBkM190aW1lX2RheUFiYnJldlJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGRhdGUudyA9IGQzX3RpbWVfZGF5QWJicmV2TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrZGF5KGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgZDNfdGltZV9kYXlSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG4gPSBkM190aW1lX2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGRhdGUudyA9IGQzX3RpbWVfZGF5TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VNb250aEFiYnJldihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIGQzX3RpbWVfbW9udGhBYmJyZXZSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG4gPSBkM190aW1lX21vbnRoQWJicmV2UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZGF0ZS5tID0gZDNfdGltZV9tb250aEFiYnJldkxvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTW9udGgoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICBkM190aW1lX21vbnRoUmUubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBuID0gZDNfdGltZV9tb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGRhdGUubSA9IGQzX3RpbWVfbW9udGhMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUxvY2FsZUZ1bGwoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICByZXR1cm4gZDNfdGltZV9wYXJzZShkYXRlLCBkM190aW1lX2Zvcm1hdHMuYy50b1N0cmluZygpLCBzdHJpbmcsIGkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTG9jYWxlRGF0ZShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBkM190aW1lX3BhcnNlKGRhdGUsIGQzX3RpbWVfZm9ybWF0cy54LnRvU3RyaW5nKCksIHN0cmluZywgaSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VMb2NhbGVUaW1lKGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIGQzX3RpbWVfcGFyc2UoZGF0ZSwgZDNfdGltZV9mb3JtYXRzLlgudG9TdHJpbmcoKSwgc3RyaW5nLCBpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUFtUG0oZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICB2YXIgbiA9IGQzX3RpbWVfcGVyaW9kTG9va3VwLmdldChzdHJpbmcuc2xpY2UoaSwgaSArPSAyKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIHJldHVybiBuID09IG51bGwgPyAtMSA6IChkYXRlLnAgPSBuLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0O1xuICB9XG4gIHZhciBkM190aW1lX2Zvcm1hdFBhZHMgPSB7XG4gICAgXCItXCI6IFwiXCIsXG4gICAgXzogXCIgXCIsXG4gICAgXCIwXCI6IFwiMFwiXG4gIH0sIGQzX3RpbWVfbnVtYmVyUmUgPSAvXlxccypcXGQrLywgZDNfdGltZV9wZXJjZW50UmUgPSAvXiUvO1xuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdFBhZCh2YWx1ZSwgZmlsbCwgd2lkdGgpIHtcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/IFwiLVwiIDogXCJcIiwgc3RyaW5nID0gKHNpZ24gPyAtdmFsdWUgOiB2YWx1ZSkgKyBcIlwiLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgIHJldHVybiBzaWduICsgKGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSArIHN0cmluZyA6IHN0cmluZyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9mb3JtYXRSZShuYW1lcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgbmFtZXMubWFwKGQzLnJlcXVvdGUpLmpvaW4oXCJ8XCIpICsgXCIpXCIsIFwiaVwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdExvb2t1cChuYW1lcykge1xuICAgIHZhciBtYXAgPSBuZXcgZDNfTWFwKCksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgbWFwLnNldChuYW1lc1tpXS50b0xvd2VyQ2FzZSgpLCBpKTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrZGF5TnVtYmVyKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLncgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrTnVtYmVyU3VuZGF5KGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGRhdGUuVSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVdlZWtOdW1iZXJNb25kYXkoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5XID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlRnVsbFllYXIoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNCkpO1xuICAgIHJldHVybiBuID8gKGRhdGUueSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVllYXIoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGRhdGUueSA9IGQzX3RpbWVfZXhwYW5kWWVhcigrblswXSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlWm9uZShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gL15bKy1dXFxkezR9JC8udGVzdChzdHJpbmcgPSBzdHJpbmcuc2xpY2UoaSwgaSArIDUpKSA/IChkYXRlLlogPSAtc3RyaW5nLCBcbiAgICBpICsgNSkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2V4cGFuZFllYXIoZCkge1xuICAgIHJldHVybiBkICsgKGQgPiA2OCA/IDE5MDAgOiAyZTMpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VNb250aE51bWJlcihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5tID0gblswXSAtIDEsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlRGF5KGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VEYXlPZlllYXIoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICAgIHJldHVybiBuID8gKGRhdGUuaiA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUhvdXIyNChkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5IID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTWludXRlcyhkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5NID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlU2Vjb25kcyhkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5TID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTWlsbGlzZWNvbmRzKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLkwgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfem9uZShkKSB7XG4gICAgdmFyIHogPSBkLmdldFRpbWV6b25lT2Zmc2V0KCksIHpzID0geiA+IDAgPyBcIi1cIiA6IFwiK1wiLCB6aCA9IGFicyh6KSAvIDYwIHwgMCwgem0gPSBhYnMoeikgJSA2MDtcbiAgICByZXR1cm4genMgKyBkM190aW1lX2Zvcm1hdFBhZCh6aCwgXCIwXCIsIDIpICsgZDNfdGltZV9mb3JtYXRQYWQoem0sIFwiMFwiLCAyKTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTGl0ZXJhbFBlcmNlbnQoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9wZXJjZW50UmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfcGVyY2VudFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gICAgcmV0dXJuIG4gPyBpICsgblswXS5sZW5ndGggOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdE11bHRpKGZvcm1hdHMpIHtcbiAgICB2YXIgbiA9IGZvcm1hdHMubGVuZ3RoLCBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IG4pIGZvcm1hdHNbaV1bMF0gPSB0aGlzKGZvcm1hdHNbaV1bMF0pO1xuICAgIHJldHVybiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgaSA9IDAsIGYgPSBmb3JtYXRzW2ldO1xuICAgICAgd2hpbGUgKCFmWzFdKGRhdGUpKSBmID0gZm9ybWF0c1srK2ldO1xuICAgICAgcmV0dXJuIGZbMF0oZGF0ZSk7XG4gICAgfTtcbiAgfVxuICBkMy5sb2NhbGUgPSBmdW5jdGlvbihsb2NhbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbnVtYmVyRm9ybWF0OiBkM19sb2NhbGVfbnVtYmVyRm9ybWF0KGxvY2FsZSksXG4gICAgICB0aW1lRm9ybWF0OiBkM19sb2NhbGVfdGltZUZvcm1hdChsb2NhbGUpXG4gICAgfTtcbiAgfTtcbiAgdmFyIGQzX2xvY2FsZV9lblVTID0gZDMubG9jYWxlKHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbIDMgXSxcbiAgICBjdXJyZW5jeTogWyBcIiRcIiwgXCJcIiBdLFxuICAgIGRhdGVUaW1lOiBcIiVhICViICVlICVYICVZXCIsXG4gICAgZGF0ZTogXCIlbS8lZC8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbIFwiQU1cIiwgXCJQTVwiIF0sXG4gICAgZGF5czogWyBcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCIgXSxcbiAgICBzaG9ydERheXM6IFsgXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiBdLFxuICAgIG1vbnRoczogWyBcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCIgXSxcbiAgICBzaG9ydE1vbnRoczogWyBcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiIF1cbiAgfSk7XG4gIGQzLmZvcm1hdCA9IGQzX2xvY2FsZV9lblVTLm51bWJlckZvcm1hdDtcbiAgZDMuZ2VvID0ge307XG4gIGZ1bmN0aW9uIGQzX2FkZGVyKCkge31cbiAgZDNfYWRkZXIucHJvdG90eXBlID0ge1xuICAgIHM6IDAsXG4gICAgdDogMCxcbiAgICBhZGQ6IGZ1bmN0aW9uKHkpIHtcbiAgICAgIGQzX2FkZGVyU3VtKHksIHRoaXMudCwgZDNfYWRkZXJUZW1wKTtcbiAgICAgIGQzX2FkZGVyU3VtKGQzX2FkZGVyVGVtcC5zLCB0aGlzLnMsIHRoaXMpO1xuICAgICAgaWYgKHRoaXMucykgdGhpcy50ICs9IGQzX2FkZGVyVGVtcC50OyBlbHNlIHRoaXMucyA9IGQzX2FkZGVyVGVtcC50O1xuICAgIH0sXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zID0gdGhpcy50ID0gMDtcbiAgICB9LFxuICAgIHZhbHVlT2Y6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucztcbiAgICB9XG4gIH07XG4gIHZhciBkM19hZGRlclRlbXAgPSBuZXcgZDNfYWRkZXIoKTtcbiAgZnVuY3Rpb24gZDNfYWRkZXJTdW0oYSwgYiwgbykge1xuICAgIHZhciB4ID0gby5zID0gYSArIGIsIGJ2ID0geCAtIGEsIGF2ID0geCAtIGJ2O1xuICAgIG8udCA9IGEgLSBhdiArIChiIC0gYnYpO1xuICB9XG4gIGQzLmdlby5zdHJlYW0gPSBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgaWYgKG9iamVjdCAmJiBkM19nZW9fc3RyZWFtT2JqZWN0VHlwZS5oYXNPd25Qcm9wZXJ0eShvYmplY3QudHlwZSkpIHtcbiAgICAgIGQzX2dlb19zdHJlYW1PYmplY3RUeXBlW29iamVjdC50eXBlXShvYmplY3QsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5KG9iamVjdCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3N0cmVhbUdlb21ldHJ5KGdlb21ldHJ5LCBsaXN0ZW5lcikge1xuICAgIGlmIChnZW9tZXRyeSAmJiBkM19nZW9fc3RyZWFtR2VvbWV0cnlUeXBlLmhhc093blByb3BlcnR5KGdlb21ldHJ5LnR5cGUpKSB7XG4gICAgICBkM19nZW9fc3RyZWFtR2VvbWV0cnlUeXBlW2dlb21ldHJ5LnR5cGVdKGdlb21ldHJ5LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG4gIHZhciBkM19nZW9fc3RyZWFtT2JqZWN0VHlwZSA9IHtcbiAgICBGZWF0dXJlOiBmdW5jdGlvbihmZWF0dXJlLCBsaXN0ZW5lcikge1xuICAgICAgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5KGZlYXR1cmUuZ2VvbWV0cnksIGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIEZlYXR1cmVDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgZmVhdHVyZXMgPSBvYmplY3QuZmVhdHVyZXMsIGkgPSAtMSwgbiA9IGZlYXR1cmVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtR2VvbWV0cnkoZmVhdHVyZXNbaV0uZ2VvbWV0cnksIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG4gIHZhciBkM19nZW9fc3RyZWFtR2VvbWV0cnlUeXBlID0ge1xuICAgIFNwaGVyZTogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIuc3BoZXJlKCk7XG4gICAgfSxcbiAgICBQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0LmNvb3JkaW5hdGVzO1xuICAgICAgbGlzdGVuZXIucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gICAgfSxcbiAgICBNdWx0aVBvaW50OiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBvYmplY3QgPSBjb29yZGluYXRlc1tpXSwgbGlzdGVuZXIucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gICAgfSxcbiAgICBMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICBkM19nZW9fc3RyZWFtTGluZShvYmplY3QuY29vcmRpbmF0ZXMsIGxpc3RlbmVyLCAwKTtcbiAgICB9LFxuICAgIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgZDNfZ2VvX3N0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIGxpc3RlbmVyLCAwKTtcbiAgICB9LFxuICAgIFBvbHlnb246IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIGQzX2dlb19zdHJlYW1Qb2x5Z29uKG9iamVjdC5jb29yZGluYXRlcywgbGlzdGVuZXIpO1xuICAgIH0sXG4gICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtUG9seWdvbihjb29yZGluYXRlc1tpXSwgbGlzdGVuZXIpO1xuICAgIH0sXG4gICAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgZ2VvbWV0cmllcyA9IG9iamVjdC5nZW9tZXRyaWVzLCBpID0gLTEsIG4gPSBnZW9tZXRyaWVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cmllc1tpXSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3N0cmVhbUxpbmUoY29vcmRpbmF0ZXMsIGxpc3RlbmVyLCBjbG9zZWQpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gY2xvc2VkLCBjb29yZGluYXRlO1xuICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgIHdoaWxlICgrK2kgPCBuKSBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV0sIGxpc3RlbmVyLnBvaW50KGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0sIGNvb3JkaW5hdGVbMl0pO1xuICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fc3RyZWFtUG9seWdvbihjb29yZGluYXRlcywgbGlzdGVuZXIpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpO1xuICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgbGlzdGVuZXIsIDEpO1xuICAgIGxpc3RlbmVyLnBvbHlnb25FbmQoKTtcbiAgfVxuICBkMy5nZW8uYXJlYSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGQzX2dlb19hcmVhU3VtID0gMDtcbiAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgZDNfZ2VvX2FyZWEpO1xuICAgIHJldHVybiBkM19nZW9fYXJlYVN1bTtcbiAgfTtcbiAgdmFyIGQzX2dlb19hcmVhU3VtLCBkM19nZW9fYXJlYVJpbmdTdW0gPSBuZXcgZDNfYWRkZXIoKTtcbiAgdmFyIGQzX2dlb19hcmVhID0ge1xuICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fYXJlYVN1bSArPSA0ICogz4A7XG4gICAgfSxcbiAgICBwb2ludDogZDNfbm9vcCxcbiAgICBsaW5lU3RhcnQ6IGQzX25vb3AsXG4gICAgbGluZUVuZDogZDNfbm9vcCxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2FyZWFSaW5nU3VtLnJlc2V0KCk7XG4gICAgICBkM19nZW9fYXJlYS5saW5lU3RhcnQgPSBkM19nZW9fYXJlYVJpbmdTdGFydDtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZWEgPSAyICogZDNfZ2VvX2FyZWFSaW5nU3VtO1xuICAgICAgZDNfZ2VvX2FyZWFTdW0gKz0gYXJlYSA8IDAgPyA0ICogz4AgKyBhcmVhIDogYXJlYTtcbiAgICAgIGQzX2dlb19hcmVhLmxpbmVTdGFydCA9IGQzX2dlb19hcmVhLmxpbmVFbmQgPSBkM19nZW9fYXJlYS5wb2ludCA9IGQzX25vb3A7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fYXJlYVJpbmdTdGFydCgpIHtcbiAgICB2YXIgzrswMCwgz4YwMCwgzrswLCBjb3PPhjAsIHNpbs+GMDtcbiAgICBkM19nZW9fYXJlYS5wb2ludCA9IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgZDNfZ2VvX2FyZWEucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICDOuzAgPSAozrswMCA9IM67KSAqIGQzX3JhZGlhbnMsIGNvc8+GMCA9IE1hdGguY29zKM+GID0gKM+GMDAgPSDPhikgKiBkM19yYWRpYW5zIC8gMiArIM+AIC8gNCksIFxuICAgICAgc2luz4YwID0gTWF0aC5zaW4oz4YpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KM67LCDPhikge1xuICAgICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICAgIM+GID0gz4YgKiBkM19yYWRpYW5zIC8gMiArIM+AIC8gNDtcbiAgICAgIHZhciBkzrsgPSDOuyAtIM67MCwgc2TOuyA9IGTOuyA+PSAwID8gMSA6IC0xLCBhZM67ID0gc2TOuyAqIGTOuywgY29zz4YgPSBNYXRoLmNvcyjPhiksIHNpbs+GID0gTWF0aC5zaW4oz4YpLCBrID0gc2luz4YwICogc2luz4YsIHUgPSBjb3PPhjAgKiBjb3PPhiArIGsgKiBNYXRoLmNvcyhhZM67KSwgdiA9IGsgKiBzZM67ICogTWF0aC5zaW4oYWTOuyk7XG4gICAgICBkM19nZW9fYXJlYVJpbmdTdW0uYWRkKE1hdGguYXRhbjIodiwgdSkpO1xuICAgICAgzrswID0gzrssIGNvc8+GMCA9IGNvc8+GLCBzaW7PhjAgPSBzaW7PhjtcbiAgICB9XG4gICAgZDNfZ2VvX2FyZWEubGluZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbmV4dFBvaW50KM67MDAsIM+GMDApO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhbihzcGhlcmljYWwpIHtcbiAgICB2YXIgzrsgPSBzcGhlcmljYWxbMF0sIM+GID0gc3BoZXJpY2FsWzFdLCBjb3PPhiA9IE1hdGguY29zKM+GKTtcbiAgICByZXR1cm4gWyBjb3PPhiAqIE1hdGguY29zKM67KSwgY29zz4YgKiBNYXRoLnNpbijOuyksIE1hdGguc2luKM+GKSBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jYXJ0ZXNpYW5Eb3QoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKGEsIGIpIHtcbiAgICByZXR1cm4gWyBhWzFdICogYlsyXSAtIGFbMl0gKiBiWzFdLCBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdLCBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdIF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhbkFkZChhLCBiKSB7XG4gICAgYVswXSArPSBiWzBdO1xuICAgIGFbMV0gKz0gYlsxXTtcbiAgICBhWzJdICs9IGJbMl07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhblNjYWxlKHZlY3Rvciwgaykge1xuICAgIHJldHVybiBbIHZlY3RvclswXSAqIGssIHZlY3RvclsxXSAqIGssIHZlY3RvclsyXSAqIGsgXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2FydGVzaWFuTm9ybWFsaXplKGQpIHtcbiAgICB2YXIgbCA9IE1hdGguc3FydChkWzBdICogZFswXSArIGRbMV0gKiBkWzFdICsgZFsyXSAqIGRbMl0pO1xuICAgIGRbMF0gLz0gbDtcbiAgICBkWzFdIC89IGw7XG4gICAgZFsyXSAvPSBsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19zcGhlcmljYWwoY2FydGVzaWFuKSB7XG4gICAgcmV0dXJuIFsgTWF0aC5hdGFuMihjYXJ0ZXNpYW5bMV0sIGNhcnRlc2lhblswXSksIGQzX2FzaW4oY2FydGVzaWFuWzJdKSBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19zcGhlcmljYWxFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGFicyhhWzBdIC0gYlswXSkgPCDOtSAmJiBhYnMoYVsxXSAtIGJbMV0pIDwgzrU7XG4gIH1cbiAgZDMuZ2VvLmJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciDOuzAsIM+GMCwgzrsxLCDPhjEsIM67XywgzrtfXywgz4ZfXywgcDAsIGTOu1N1bSwgcmFuZ2VzLCByYW5nZTtcbiAgICB2YXIgYm91bmQgPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBib3VuZC5wb2ludCA9IHJpbmdQb2ludDtcbiAgICAgICAgYm91bmQubGluZVN0YXJ0ID0gcmluZ1N0YXJ0O1xuICAgICAgICBib3VuZC5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgICAgZM67U3VtID0gMDtcbiAgICAgICAgZDNfZ2VvX2FyZWEucG9seWdvblN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGQzX2dlb19hcmVhLnBvbHlnb25FbmQoKTtcbiAgICAgICAgYm91bmQucG9pbnQgPSBwb2ludDtcbiAgICAgICAgYm91bmQubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBib3VuZC5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgaWYgKGQzX2dlb19hcmVhUmluZ1N1bSA8IDApIM67MCA9IC0ozrsxID0gMTgwKSwgz4YwID0gLSjPhjEgPSA5MCk7IGVsc2UgaWYgKGTOu1N1bSA+IM61KSDPhjEgPSA5MDsgZWxzZSBpZiAoZM67U3VtIDwgLc61KSDPhjAgPSAtOTA7XG4gICAgICAgIHJhbmdlWzBdID0gzrswLCByYW5nZVsxXSA9IM67MTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBvaW50KM67LCDPhikge1xuICAgICAgcmFuZ2VzLnB1c2gocmFuZ2UgPSBbIM67MCA9IM67LCDOuzEgPSDOuyBdKTtcbiAgICAgIGlmICjPhiA8IM+GMCkgz4YwID0gz4Y7XG4gICAgICBpZiAoz4YgPiDPhjEpIM+GMSA9IM+GO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lUG9pbnQozrssIM+GKSB7XG4gICAgICB2YXIgcCA9IGQzX2dlb19jYXJ0ZXNpYW4oWyDOuyAqIGQzX3JhZGlhbnMsIM+GICogZDNfcmFkaWFucyBdKTtcbiAgICAgIGlmIChwMCkge1xuICAgICAgICB2YXIgbm9ybWFsID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKHAwLCBwKSwgZXF1YXRvcmlhbCA9IFsgbm9ybWFsWzFdLCAtbm9ybWFsWzBdLCAwIF0sIGluZmxlY3Rpb24gPSBkM19nZW9fY2FydGVzaWFuQ3Jvc3MoZXF1YXRvcmlhbCwgbm9ybWFsKTtcbiAgICAgICAgZDNfZ2VvX2NhcnRlc2lhbk5vcm1hbGl6ZShpbmZsZWN0aW9uKTtcbiAgICAgICAgaW5mbGVjdGlvbiA9IGQzX2dlb19zcGhlcmljYWwoaW5mbGVjdGlvbik7XG4gICAgICAgIHZhciBkzrsgPSDOuyAtIM67XywgcyA9IGTOuyA+IDAgPyAxIDogLTEsIM67aSA9IGluZmxlY3Rpb25bMF0gKiBkM19kZWdyZWVzICogcywgYW50aW1lcmlkaWFuID0gYWJzKGTOuykgPiAxODA7XG4gICAgICAgIGlmIChhbnRpbWVyaWRpYW4gXiAocyAqIM67XyA8IM67aSAmJiDOu2kgPCBzICogzrspKSB7XG4gICAgICAgICAgdmFyIM+GaSA9IGluZmxlY3Rpb25bMV0gKiBkM19kZWdyZWVzO1xuICAgICAgICAgIGlmICjPhmkgPiDPhjEpIM+GMSA9IM+GaTtcbiAgICAgICAgfSBlbHNlIGlmICjOu2kgPSAozrtpICsgMzYwKSAlIDM2MCAtIDE4MCwgYW50aW1lcmlkaWFuIF4gKHMgKiDOu18gPCDOu2kgJiYgzrtpIDwgcyAqIM67KSkge1xuICAgICAgICAgIHZhciDPhmkgPSAtaW5mbGVjdGlvblsxXSAqIGQzX2RlZ3JlZXM7XG4gICAgICAgICAgaWYgKM+GaSA8IM+GMCkgz4YwID0gz4ZpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICjPhiA8IM+GMCkgz4YwID0gz4Y7XG4gICAgICAgICAgaWYgKM+GID4gz4YxKSDPhjEgPSDPhjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW50aW1lcmlkaWFuKSB7XG4gICAgICAgICAgaWYgKM67IDwgzrtfKSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUozrswLCDOuykgPiBhbmdsZSjOuzAsIM67MSkpIM67MSA9IM67O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUozrssIM67MSkgPiBhbmdsZSjOuzAsIM67MSkpIM67MCA9IM67O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAozrsxID49IM67MCkge1xuICAgICAgICAgICAgaWYgKM67IDwgzrswKSDOuzAgPSDOuztcbiAgICAgICAgICAgIGlmICjOuyA+IM67MSkgzrsxID0gzrs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICjOuyA+IM67Xykge1xuICAgICAgICAgICAgICBpZiAoYW5nbGUozrswLCDOuykgPiBhbmdsZSjOuzAsIM67MSkpIM67MSA9IM67O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGFuZ2xlKM67LCDOuzEpID4gYW5nbGUozrswLCDOuzEpKSDOuzAgPSDOuztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50KM67LCDPhik7XG4gICAgICB9XG4gICAgICBwMCA9IHAsIM67XyA9IM67O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICBib3VuZC5wb2ludCA9IGxpbmVQb2ludDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIHJhbmdlWzBdID0gzrswLCByYW5nZVsxXSA9IM67MTtcbiAgICAgIGJvdW5kLnBvaW50ID0gcG9pbnQ7XG4gICAgICBwMCA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJpbmdQb2ludCjOuywgz4YpIHtcbiAgICAgIGlmIChwMCkge1xuICAgICAgICB2YXIgZM67ID0gzrsgLSDOu187XG4gICAgICAgIGTOu1N1bSArPSBhYnMoZM67KSA+IDE4MCA/IGTOuyArIChkzrsgPiAwID8gMzYwIDogLTM2MCkgOiBkzrs7XG4gICAgICB9IGVsc2UgzrtfXyA9IM67LCDPhl9fID0gz4Y7XG4gICAgICBkM19nZW9fYXJlYS5wb2ludCjOuywgz4YpO1xuICAgICAgbGluZVBvaW50KM67LCDPhik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgIGQzX2dlb19hcmVhLmxpbmVTdGFydCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgcmluZ1BvaW50KM67X18sIM+GX18pO1xuICAgICAgZDNfZ2VvX2FyZWEubGluZUVuZCgpO1xuICAgICAgaWYgKGFicyhkzrtTdW0pID4gzrUpIM67MCA9IC0ozrsxID0gMTgwKTtcbiAgICAgIHJhbmdlWzBdID0gzrswLCByYW5nZVsxXSA9IM67MTtcbiAgICAgIHAwID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW5nbGUozrswLCDOuzEpIHtcbiAgICAgIHJldHVybiAozrsxIC09IM67MCkgPCAwID8gzrsxICsgMzYwIDogzrsxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlUmFuZ2VzKGEsIGIpIHtcbiAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2l0aGluUmFuZ2UoeCwgcmFuZ2UpIHtcbiAgICAgIHJldHVybiByYW5nZVswXSA8PSByYW5nZVsxXSA/IHJhbmdlWzBdIDw9IHggJiYgeCA8PSByYW5nZVsxXSA6IHggPCByYW5nZVswXSB8fCByYW5nZVsxXSA8IHg7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICDPhjEgPSDOuzEgPSAtKM67MCA9IM+GMCA9IEluZmluaXR5KTtcbiAgICAgIHJhbmdlcyA9IFtdO1xuICAgICAgZDMuZ2VvLnN0cmVhbShmZWF0dXJlLCBib3VuZCk7XG4gICAgICB2YXIgbiA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICBpZiAobikge1xuICAgICAgICByYW5nZXMuc29ydChjb21wYXJlUmFuZ2VzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGEgPSByYW5nZXNbMF0sIGIsIG1lcmdlZCA9IFsgYSBdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgYiA9IHJhbmdlc1tpXTtcbiAgICAgICAgICBpZiAod2l0aGluUmFuZ2UoYlswXSwgYSkgfHwgd2l0aGluUmFuZ2UoYlsxXSwgYSkpIHtcbiAgICAgICAgICAgIGlmIChhbmdsZShhWzBdLCBiWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKSBhWzFdID0gYlsxXTtcbiAgICAgICAgICAgIGlmIChhbmdsZShiWzBdLCBhWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKSBhWzBdID0gYlswXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2goYSA9IGIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYmVzdCA9IC1JbmZpbml0eSwgZM67O1xuICAgICAgICBmb3IgKHZhciBuID0gbWVyZ2VkLmxlbmd0aCAtIDEsIGkgPSAwLCBhID0gbWVyZ2VkW25dLCBiOyBpIDw9IG47IGEgPSBiLCArK2kpIHtcbiAgICAgICAgICBiID0gbWVyZ2VkW2ldO1xuICAgICAgICAgIGlmICgoZM67ID0gYW5nbGUoYVsxXSwgYlswXSkpID4gYmVzdCkgYmVzdCA9IGTOuywgzrswID0gYlswXSwgzrsxID0gYVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmFuZ2VzID0gcmFuZ2UgPSBudWxsO1xuICAgICAgcmV0dXJuIM67MCA9PT0gSW5maW5pdHkgfHwgz4YwID09PSBJbmZpbml0eSA/IFsgWyBOYU4sIE5hTiBdLCBbIE5hTiwgTmFOIF0gXSA6IFsgWyDOuzAsIM+GMCBdLCBbIM67MSwgz4YxIF0gXTtcbiAgICB9O1xuICB9KCk7XG4gIGQzLmdlby5jZW50cm9pZCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGQzX2dlb19jZW50cm9pZFcwID0gZDNfZ2VvX2NlbnRyb2lkVzEgPSBkM19nZW9fY2VudHJvaWRYMCA9IGQzX2dlb19jZW50cm9pZFkwID0gZDNfZ2VvX2NlbnRyb2lkWjAgPSBkM19nZW9fY2VudHJvaWRYMSA9IGQzX2dlb19jZW50cm9pZFkxID0gZDNfZ2VvX2NlbnRyb2lkWjEgPSBkM19nZW9fY2VudHJvaWRYMiA9IGQzX2dlb19jZW50cm9pZFkyID0gZDNfZ2VvX2NlbnRyb2lkWjIgPSAwO1xuICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBkM19nZW9fY2VudHJvaWQpO1xuICAgIHZhciB4ID0gZDNfZ2VvX2NlbnRyb2lkWDIsIHkgPSBkM19nZW9fY2VudHJvaWRZMiwgeiA9IGQzX2dlb19jZW50cm9pZFoyLCBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICAgIGlmIChtIDwgzrUyKSB7XG4gICAgICB4ID0gZDNfZ2VvX2NlbnRyb2lkWDEsIHkgPSBkM19nZW9fY2VudHJvaWRZMSwgeiA9IGQzX2dlb19jZW50cm9pZFoxO1xuICAgICAgaWYgKGQzX2dlb19jZW50cm9pZFcxIDwgzrUpIHggPSBkM19nZW9fY2VudHJvaWRYMCwgeSA9IGQzX2dlb19jZW50cm9pZFkwLCB6ID0gZDNfZ2VvX2NlbnRyb2lkWjA7XG4gICAgICBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICAgICAgaWYgKG0gPCDOtTIpIHJldHVybiBbIE5hTiwgTmFOIF07XG4gICAgfVxuICAgIHJldHVybiBbIE1hdGguYXRhbjIoeSwgeCkgKiBkM19kZWdyZWVzLCBkM19hc2luKHogLyBNYXRoLnNxcnQobSkpICogZDNfZGVncmVlcyBdO1xuICB9O1xuICB2YXIgZDNfZ2VvX2NlbnRyb2lkVzAsIGQzX2dlb19jZW50cm9pZFcxLCBkM19nZW9fY2VudHJvaWRYMCwgZDNfZ2VvX2NlbnRyb2lkWTAsIGQzX2dlb19jZW50cm9pZFowLCBkM19nZW9fY2VudHJvaWRYMSwgZDNfZ2VvX2NlbnRyb2lkWTEsIGQzX2dlb19jZW50cm9pZFoxLCBkM19nZW9fY2VudHJvaWRYMiwgZDNfZ2VvX2NlbnRyb2lkWTIsIGQzX2dlb19jZW50cm9pZFoyO1xuICB2YXIgZDNfZ2VvX2NlbnRyb2lkID0ge1xuICAgIHNwaGVyZTogZDNfbm9vcCxcbiAgICBwb2ludDogZDNfZ2VvX2NlbnRyb2lkUG9pbnQsXG4gICAgbGluZVN0YXJ0OiBkM19nZW9fY2VudHJvaWRMaW5lU3RhcnQsXG4gICAgbGluZUVuZDogZDNfZ2VvX2NlbnRyb2lkTGluZUVuZCxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLmxpbmVTdGFydCA9IGQzX2dlb19jZW50cm9pZFJpbmdTdGFydDtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLmxpbmVTdGFydCA9IGQzX2dlb19jZW50cm9pZExpbmVTdGFydDtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZFBvaW50KM67LCDPhikge1xuICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YgKj0gZDNfcmFkaWFucyk7XG4gICAgZDNfZ2VvX2NlbnRyb2lkUG9pbnRYWVooY29zz4YgKiBNYXRoLmNvcyjOuyksIGNvc8+GICogTWF0aC5zaW4ozrspLCBNYXRoLnNpbijPhikpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgsIHksIHopIHtcbiAgICArK2QzX2dlb19jZW50cm9pZFcwO1xuICAgIGQzX2dlb19jZW50cm9pZFgwICs9ICh4IC0gZDNfZ2VvX2NlbnRyb2lkWDApIC8gZDNfZ2VvX2NlbnRyb2lkVzA7XG4gICAgZDNfZ2VvX2NlbnRyb2lkWTAgKz0gKHkgLSBkM19nZW9fY2VudHJvaWRZMCkgLyBkM19nZW9fY2VudHJvaWRXMDtcbiAgICBkM19nZW9fY2VudHJvaWRaMCArPSAoeiAtIGQzX2dlb19jZW50cm9pZFowKSAvIGQzX2dlb19jZW50cm9pZFcwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZExpbmVTdGFydCgpIHtcbiAgICB2YXIgeDAsIHkwLCB6MDtcbiAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiAqPSBkM19yYWRpYW5zKTtcbiAgICAgIHgwID0gY29zz4YgKiBNYXRoLmNvcyjOuyk7XG4gICAgICB5MCA9IGNvc8+GICogTWF0aC5zaW4ozrspO1xuICAgICAgejAgPSBNYXRoLnNpbijPhik7XG4gICAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICBkM19nZW9fY2VudHJvaWRQb2ludFhZWih4MCwgeTAsIHowKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCjOuywgz4YpIHtcbiAgICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiAqPSBkM19yYWRpYW5zKSwgeCA9IGNvc8+GICogTWF0aC5jb3MozrspLCB5ID0gY29zz4YgKiBNYXRoLnNpbijOuyksIHogPSBNYXRoLnNpbijPhiksIHcgPSBNYXRoLmF0YW4yKE1hdGguc3FydCgodyA9IHkwICogeiAtIHowICogeSkgKiB3ICsgKHcgPSB6MCAqIHggLSB4MCAqIHopICogdyArICh3ID0geDAgKiB5IC0geTAgKiB4KSAqIHcpLCB4MCAqIHggKyB5MCAqIHkgKyB6MCAqIHopO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkVzEgKz0gdztcbiAgICAgIGQzX2dlb19jZW50cm9pZFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgwLCB5MCwgejApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2VudHJvaWRMaW5lRW5kKCkge1xuICAgIGQzX2dlb19jZW50cm9pZC5wb2ludCA9IGQzX2dlb19jZW50cm9pZFBvaW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZFJpbmdTdGFydCgpIHtcbiAgICB2YXIgzrswMCwgz4YwMCwgeDAsIHkwLCB6MDtcbiAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIM67MDAgPSDOuywgz4YwMCA9IM+GO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLnBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GICo9IGQzX3JhZGlhbnMpO1xuICAgICAgeDAgPSBjb3PPhiAqIE1hdGguY29zKM67KTtcbiAgICAgIHkwID0gY29zz4YgKiBNYXRoLnNpbijOuyk7XG4gICAgICB6MCA9IE1hdGguc2luKM+GKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgwLCB5MCwgejApO1xuICAgIH07XG4gICAgZDNfZ2VvX2NlbnRyb2lkLmxpbmVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIG5leHRQb2ludCjOuzAwLCDPhjAwKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZC5saW5lRW5kID0gZDNfZ2VvX2NlbnRyb2lkTGluZUVuZDtcbiAgICAgIGQzX2dlb19jZW50cm9pZC5wb2ludCA9IGQzX2dlb19jZW50cm9pZFBvaW50O1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KM67LCDPhikge1xuICAgICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GICo9IGQzX3JhZGlhbnMpLCB4ID0gY29zz4YgKiBNYXRoLmNvcyjOuyksIHkgPSBjb3PPhiAqIE1hdGguc2luKM67KSwgeiA9IE1hdGguc2luKM+GKSwgY3ggPSB5MCAqIHogLSB6MCAqIHksIGN5ID0gejAgKiB4IC0geDAgKiB6LCBjeiA9IHgwICogeSAtIHkwICogeCwgbSA9IE1hdGguc3FydChjeCAqIGN4ICsgY3kgKiBjeSArIGN6ICogY3opLCB1ID0geDAgKiB4ICsgeTAgKiB5ICsgejAgKiB6LCB2ID0gbSAmJiAtZDNfYWNvcyh1KSAvIG0sIHcgPSBNYXRoLmF0YW4yKG0sIHUpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDIgKz0gdiAqIGN4O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWTIgKz0gdiAqIGN5O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjIgKz0gdiAqIGN6O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkVzEgKz0gdztcbiAgICAgIGQzX2dlb19jZW50cm9pZFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgwLCB5MCwgejApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY29tcG9zZShhLCBiKSB7XG4gICAgZnVuY3Rpb24gY29tcG9zZSh4LCB5KSB7XG4gICAgICByZXR1cm4geCA9IGEoeCwgeSksIGIoeFswXSwgeFsxXSk7XG4gICAgfVxuICAgIGlmIChhLmludmVydCAmJiBiLmludmVydCkgY29tcG9zZS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICByZXR1cm4geCA9IGIuaW52ZXJ0KHgsIHkpLCB4ICYmIGEuaW52ZXJ0KHhbMF0sIHhbMV0pO1xuICAgIH07XG4gICAgcmV0dXJuIGNvbXBvc2U7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdHJ1ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcFBvbHlnb24oc2VnbWVudHMsIGNvbXBhcmUsIGNsaXBTdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIHN1YmplY3QgPSBbXSwgY2xpcCA9IFtdO1xuICAgIHNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24oc2VnbWVudCkge1xuICAgICAgaWYgKChuID0gc2VnbWVudC5sZW5ndGggLSAxKSA8PSAwKSByZXR1cm47XG4gICAgICB2YXIgbiwgcDAgPSBzZWdtZW50WzBdLCBwMSA9IHNlZ21lbnRbbl07XG4gICAgICBpZiAoZDNfZ2VvX3NwaGVyaWNhbEVxdWFsKHAwLCBwMSkpIHtcbiAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBsaXN0ZW5lci5wb2ludCgocDAgPSBzZWdtZW50W2ldKVswXSwgcDBbMV0pO1xuICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBhID0gbmV3IGQzX2dlb19jbGlwUG9seWdvbkludGVyc2VjdGlvbihwMCwgc2VnbWVudCwgbnVsbCwgdHJ1ZSksIGIgPSBuZXcgZDNfZ2VvX2NsaXBQb2x5Z29uSW50ZXJzZWN0aW9uKHAwLCBudWxsLCBhLCBmYWxzZSk7XG4gICAgICBhLm8gPSBiO1xuICAgICAgc3ViamVjdC5wdXNoKGEpO1xuICAgICAgY2xpcC5wdXNoKGIpO1xuICAgICAgYSA9IG5ldyBkM19nZW9fY2xpcFBvbHlnb25JbnRlcnNlY3Rpb24ocDEsIHNlZ21lbnQsIG51bGwsIGZhbHNlKTtcbiAgICAgIGIgPSBuZXcgZDNfZ2VvX2NsaXBQb2x5Z29uSW50ZXJzZWN0aW9uKHAxLCBudWxsLCBhLCB0cnVlKTtcbiAgICAgIGEubyA9IGI7XG4gICAgICBzdWJqZWN0LnB1c2goYSk7XG4gICAgICBjbGlwLnB1c2goYik7XG4gICAgfSk7XG4gICAgY2xpcC5zb3J0KGNvbXBhcmUpO1xuICAgIGQzX2dlb19jbGlwUG9seWdvbkxpbmtDaXJjdWxhcihzdWJqZWN0KTtcbiAgICBkM19nZW9fY2xpcFBvbHlnb25MaW5rQ2lyY3VsYXIoY2xpcCk7XG4gICAgaWYgKCFzdWJqZWN0Lmxlbmd0aCkgcmV0dXJuO1xuICAgIGZvciAodmFyIGkgPSAwLCBlbnRyeSA9IGNsaXBTdGFydEluc2lkZSwgbiA9IGNsaXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBjbGlwW2ldLmUgPSBlbnRyeSA9ICFlbnRyeTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0ID0gc3ViamVjdFswXSwgcG9pbnRzLCBwb2ludDtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBzdGFydCwgaXNTdWJqZWN0ID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChjdXJyZW50LnYpIGlmICgoY3VycmVudCA9IGN1cnJlbnQubikgPT09IHN0YXJ0KSByZXR1cm47XG4gICAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgIGRvIHtcbiAgICAgICAgY3VycmVudC52ID0gY3VycmVudC5vLnYgPSB0cnVlO1xuICAgICAgICBpZiAoY3VycmVudC5lKSB7XG4gICAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbjsgKytpKSBsaXN0ZW5lci5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5uLngsIDEsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgICBwb2ludHMgPSBjdXJyZW50LnAuejtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIGxpc3RlbmVyLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50LnAueCwgLTEsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5vO1xuICAgICAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgICAgIGlzU3ViamVjdCA9ICFpc1N1YmplY3Q7XG4gICAgICB9IHdoaWxlICghY3VycmVudC52KTtcbiAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBQb2x5Z29uTGlua0NpcmN1bGFyKGFycmF5KSB7XG4gICAgaWYgKCEobiA9IGFycmF5Lmxlbmd0aCkpIHJldHVybjtcbiAgICB2YXIgbiwgaSA9IDAsIGEgPSBhcnJheVswXSwgYjtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgYS5uID0gYiA9IGFycmF5W2ldO1xuICAgICAgYi5wID0gYTtcbiAgICAgIGEgPSBiO1xuICAgIH1cbiAgICBhLm4gPSBiID0gYXJyYXlbMF07XG4gICAgYi5wID0gYTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcFBvbHlnb25JbnRlcnNlY3Rpb24ocG9pbnQsIHBvaW50cywgb3RoZXIsIGVudHJ5KSB7XG4gICAgdGhpcy54ID0gcG9pbnQ7XG4gICAgdGhpcy56ID0gcG9pbnRzO1xuICAgIHRoaXMubyA9IG90aGVyO1xuICAgIHRoaXMuZSA9IGVudHJ5O1xuICAgIHRoaXMudiA9IGZhbHNlO1xuICAgIHRoaXMubiA9IHRoaXMucCA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXAocG9pbnRWaXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIGNsaXBTdGFydCkge1xuICAgIHJldHVybiBmdW5jdGlvbihyb3RhdGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGluZSA9IGNsaXBMaW5lKGxpc3RlbmVyKSwgcm90YXRlZENsaXBTdGFydCA9IHJvdGF0ZS5pbnZlcnQoY2xpcFN0YXJ0WzBdLCBjbGlwU3RhcnRbMV0pO1xuICAgICAgdmFyIGNsaXAgPSB7XG4gICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50UmluZztcbiAgICAgICAgICBjbGlwLmxpbmVTdGFydCA9IHJpbmdTdGFydDtcbiAgICAgICAgICBjbGlwLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgICAgICAgIHNlZ21lbnRzID0gW107XG4gICAgICAgICAgcG9seWdvbiA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgY2xpcC5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgICAgY2xpcC5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgICBzZWdtZW50cyA9IGQzLm1lcmdlKHNlZ21lbnRzKTtcbiAgICAgICAgICB2YXIgY2xpcFN0YXJ0SW5zaWRlID0gZDNfZ2VvX3BvaW50SW5Qb2x5Z29uKHJvdGF0ZWRDbGlwU3RhcnQsIHBvbHlnb24pO1xuICAgICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBkM19nZW9fY2xpcFBvbHlnb24oc2VnbWVudHMsIGQzX2dlb19jbGlwU29ydCwgY2xpcFN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgbGlzdGVuZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xpcFN0YXJ0SW5zaWRlKSB7XG4gICAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBsaXN0ZW5lci5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb2x5Z29uU3RhcnRlZCkgbGlzdGVuZXIucG9seWdvbkVuZCgpLCBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIHNlZ21lbnRzID0gcG9seWdvbiA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGlzdGVuZXIucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgbGlzdGVuZXIpO1xuICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2x5Z29uRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBwb2ludCjOuywgz4YpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gcm90YXRlKM67LCDPhik7XG4gICAgICAgIGlmIChwb2ludFZpc2libGUozrsgPSBwb2ludFswXSwgz4YgPSBwb2ludFsxXSkpIGxpc3RlbmVyLnBvaW50KM67LCDPhik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwb2ludExpbmUozrssIM+GKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHJvdGF0ZSjOuywgz4YpO1xuICAgICAgICBsaW5lLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludExpbmU7XG4gICAgICAgIGxpbmUubGluZVN0YXJ0KCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIGxpbmUubGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgdmFyIHNlZ21lbnRzO1xuICAgICAgdmFyIGJ1ZmZlciA9IGQzX2dlb19jbGlwQnVmZmVyTGlzdGVuZXIoKSwgcmluZ0xpc3RlbmVyID0gY2xpcExpbmUoYnVmZmVyKSwgcG9seWdvblN0YXJ0ZWQgPSBmYWxzZSwgcG9seWdvbiwgcmluZztcbiAgICAgIGZ1bmN0aW9uIHBvaW50UmluZyjOuywgz4YpIHtcbiAgICAgICAgcmluZy5wdXNoKFsgzrssIM+GIF0pO1xuICAgICAgICB2YXIgcG9pbnQgPSByb3RhdGUozrssIM+GKTtcbiAgICAgICAgcmluZ0xpc3RlbmVyLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICAgIHJpbmdMaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgcmluZyA9IFtdO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgICAgcG9pbnRSaW5nKHJpbmdbMF1bMF0sIHJpbmdbMF1bMV0pO1xuICAgICAgICByaW5nTGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICB2YXIgY2xlYW4gPSByaW5nTGlzdGVuZXIuY2xlYW4oKSwgcmluZ1NlZ21lbnRzID0gYnVmZmVyLmJ1ZmZlcigpLCBzZWdtZW50LCBuID0gcmluZ1NlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgcmluZy5wb3AoKTtcbiAgICAgICAgcG9seWdvbi5wdXNoKHJpbmcpO1xuICAgICAgICByaW5nID0gbnVsbDtcbiAgICAgICAgaWYgKCFuKSByZXR1cm47XG4gICAgICAgIGlmIChjbGVhbiAmIDEpIHtcbiAgICAgICAgICBzZWdtZW50ID0gcmluZ1NlZ21lbnRzWzBdO1xuICAgICAgICAgIHZhciBuID0gc2VnbWVudC5sZW5ndGggLSAxLCBpID0gLTEsIHBvaW50O1xuICAgICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgbGlzdGVuZXIucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIGxpc3RlbmVyLnBvaW50KChwb2ludCA9IHNlZ21lbnRbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA+IDEgJiYgY2xlYW4gJiAyKSByaW5nU2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMucG9wKCkuY29uY2F0KHJpbmdTZWdtZW50cy5zaGlmdCgpKSk7XG4gICAgICAgIHNlZ21lbnRzLnB1c2gocmluZ1NlZ21lbnRzLmZpbHRlcihkM19nZW9fY2xpcFNlZ21lbnRMZW5ndGgxKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xpcDtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwU2VnbWVudExlbmd0aDEoc2VnbWVudCkge1xuICAgIHJldHVybiBzZWdtZW50Lmxlbmd0aCA+IDE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBCdWZmZXJMaXN0ZW5lcigpIHtcbiAgICB2YXIgbGluZXMgPSBbXSwgbGluZTtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGluZXMucHVzaChsaW5lID0gW10pO1xuICAgICAgfSxcbiAgICAgIHBvaW50OiBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgICAgbGluZS5wdXNoKFsgzrssIM+GIF0pO1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGQzX25vb3AsXG4gICAgICBidWZmZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gbGluZXM7XG4gICAgICAgIGxpbmVzID0gW107XG4gICAgICAgIGxpbmUgPSBudWxsO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgfSxcbiAgICAgIHJlam9pbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSBsaW5lcy5wdXNoKGxpbmVzLnBvcCgpLmNvbmNhdChsaW5lcy5zaGlmdCgpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcFNvcnQoYSwgYikge1xuICAgIHJldHVybiAoKGEgPSBhLngpWzBdIDwgMCA/IGFbMV0gLSBoYWxmz4AgLSDOtSA6IGhhbGbPgCAtIGFbMV0pIC0gKChiID0gYi54KVswXSA8IDAgPyBiWzFdIC0gaGFsZs+AIC0gzrUgOiBoYWxmz4AgLSBiWzFdKTtcbiAgfVxuICB2YXIgZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW4gPSBkM19nZW9fY2xpcChkM190cnVlLCBkM19nZW9fY2xpcEFudGltZXJpZGlhbkxpbmUsIGQzX2dlb19jbGlwQW50aW1lcmlkaWFuSW50ZXJwb2xhdGUsIFsgLc+ALCAtz4AgLyAyIF0pO1xuICBmdW5jdGlvbiBkM19nZW9fY2xpcEFudGltZXJpZGlhbkxpbmUobGlzdGVuZXIpIHtcbiAgICB2YXIgzrswID0gTmFOLCDPhjAgPSBOYU4sIHPOuzAgPSBOYU4sIGNsZWFuO1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgY2xlYW4gPSAxO1xuICAgICAgfSxcbiAgICAgIHBvaW50OiBmdW5jdGlvbijOuzEsIM+GMSkge1xuICAgICAgICB2YXIgc867MSA9IM67MSA+IDAgPyDPgCA6IC3PgCwgZM67ID0gYWJzKM67MSAtIM67MCk7XG4gICAgICAgIGlmIChhYnMoZM67IC0gz4ApIDwgzrUpIHtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludCjOuzAsIM+GMCA9ICjPhjAgKyDPhjEpIC8gMiA+IDAgPyBoYWxmz4AgOiAtaGFsZs+AKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludChzzrswLCDPhjApO1xuICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludChzzrsxLCDPhjApO1xuICAgICAgICAgIGxpc3RlbmVyLnBvaW50KM67MSwgz4YwKTtcbiAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc867MCAhPT0gc867MSAmJiBkzrsgPj0gz4ApIHtcbiAgICAgICAgICBpZiAoYWJzKM67MCAtIHPOuzApIDwgzrUpIM67MCAtPSBzzrswICogzrU7XG4gICAgICAgICAgaWYgKGFicyjOuzEgLSBzzrsxKSA8IM61KSDOuzEgLT0gc867MSAqIM61O1xuICAgICAgICAgIM+GMCA9IGQzX2dlb19jbGlwQW50aW1lcmlkaWFuSW50ZXJzZWN0KM67MCwgz4YwLCDOuzEsIM+GMSk7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQoc867MCwgz4YwKTtcbiAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQoc867MSwgz4YwKTtcbiAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXIucG9pbnQozrswID0gzrsxLCDPhjAgPSDPhjEpO1xuICAgICAgICBzzrswID0gc867MTtcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICDOuzAgPSDPhjAgPSBOYU47XG4gICAgICB9LFxuICAgICAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMiAtIGNsZWFuO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QozrswLCDPhjAsIM67MSwgz4YxKSB7XG4gICAgdmFyIGNvc8+GMCwgY29zz4YxLCBzaW7OuzBfzrsxID0gTWF0aC5zaW4ozrswIC0gzrsxKTtcbiAgICByZXR1cm4gYWJzKHNpbs67MF/OuzEpID4gzrUgPyBNYXRoLmF0YW4oKE1hdGguc2luKM+GMCkgKiAoY29zz4YxID0gTWF0aC5jb3Moz4YxKSkgKiBNYXRoLnNpbijOuzEpIC0gTWF0aC5zaW4oz4YxKSAqIChjb3PPhjAgPSBNYXRoLmNvcyjPhjApKSAqIE1hdGguc2luKM67MCkpIC8gKGNvc8+GMCAqIGNvc8+GMSAqIHNpbs67MF/OuzEpKSA6ICjPhjAgKyDPhjEpIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIGxpc3RlbmVyKSB7XG4gICAgdmFyIM+GO1xuICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgIM+GID0gZGlyZWN0aW9uICogaGFsZs+AO1xuICAgICAgbGlzdGVuZXIucG9pbnQoLc+ALCDPhik7XG4gICAgICBsaXN0ZW5lci5wb2ludCgwLCDPhik7XG4gICAgICBsaXN0ZW5lci5wb2ludCjPgCwgz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoz4AsIDApO1xuICAgICAgbGlzdGVuZXIucG9pbnQoz4AsIC3Phik7XG4gICAgICBsaXN0ZW5lci5wb2ludCgwLCAtz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoLc+ALCAtz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoLc+ALCAwKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KC3PgCwgz4YpO1xuICAgIH0gZWxzZSBpZiAoYWJzKGZyb21bMF0gLSB0b1swXSkgPiDOtSkge1xuICAgICAgdmFyIHMgPSBmcm9tWzBdIDwgdG9bMF0gPyDPgCA6IC3PgDtcbiAgICAgIM+GID0gZGlyZWN0aW9uICogcyAvIDI7XG4gICAgICBsaXN0ZW5lci5wb2ludCgtcywgz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoMCwgz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQocywgz4YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0ZW5lci5wb2ludCh0b1swXSwgdG9bMV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcG9pbnRJblBvbHlnb24ocG9pbnQsIHBvbHlnb24pIHtcbiAgICB2YXIgbWVyaWRpYW4gPSBwb2ludFswXSwgcGFyYWxsZWwgPSBwb2ludFsxXSwgbWVyaWRpYW5Ob3JtYWwgPSBbIE1hdGguc2luKG1lcmlkaWFuKSwgLU1hdGguY29zKG1lcmlkaWFuKSwgMCBdLCBwb2xhckFuZ2xlID0gMCwgd2luZGluZyA9IDA7XG4gICAgZDNfZ2VvX2FyZWFSaW5nU3VtLnJlc2V0KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIHJpbmcgPSBwb2x5Z29uW2ldLCBtID0gcmluZy5sZW5ndGg7XG4gICAgICBpZiAoIW0pIGNvbnRpbnVlO1xuICAgICAgdmFyIHBvaW50MCA9IHJpbmdbMF0sIM67MCA9IHBvaW50MFswXSwgz4YwID0gcG9pbnQwWzFdIC8gMiArIM+AIC8gNCwgc2luz4YwID0gTWF0aC5zaW4oz4YwKSwgY29zz4YwID0gTWF0aC5jb3Moz4YwKSwgaiA9IDE7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoaiA9PT0gbSkgaiA9IDA7XG4gICAgICAgIHBvaW50ID0gcmluZ1tqXTtcbiAgICAgICAgdmFyIM67ID0gcG9pbnRbMF0sIM+GID0gcG9pbnRbMV0gLyAyICsgz4AgLyA0LCBzaW7PhiA9IE1hdGguc2luKM+GKSwgY29zz4YgPSBNYXRoLmNvcyjPhiksIGTOuyA9IM67IC0gzrswLCBzZM67ID0gZM67ID49IDAgPyAxIDogLTEsIGFkzrsgPSBzZM67ICogZM67LCBhbnRpbWVyaWRpYW4gPSBhZM67ID4gz4AsIGsgPSBzaW7PhjAgKiBzaW7PhjtcbiAgICAgICAgZDNfZ2VvX2FyZWFSaW5nU3VtLmFkZChNYXRoLmF0YW4yKGsgKiBzZM67ICogTWF0aC5zaW4oYWTOuyksIGNvc8+GMCAqIGNvc8+GICsgayAqIE1hdGguY29zKGFkzrspKSk7XG4gICAgICAgIHBvbGFyQW5nbGUgKz0gYW50aW1lcmlkaWFuID8gZM67ICsgc2TOuyAqIM+EIDogZM67O1xuICAgICAgICBpZiAoYW50aW1lcmlkaWFuIF4gzrswID49IG1lcmlkaWFuIF4gzrsgPj0gbWVyaWRpYW4pIHtcbiAgICAgICAgICB2YXIgYXJjID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKGQzX2dlb19jYXJ0ZXNpYW4ocG9pbnQwKSwgZDNfZ2VvX2NhcnRlc2lhbihwb2ludCkpO1xuICAgICAgICAgIGQzX2dlb19jYXJ0ZXNpYW5Ob3JtYWxpemUoYXJjKTtcbiAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKG1lcmlkaWFuTm9ybWFsLCBhcmMpO1xuICAgICAgICAgIGQzX2dlb19jYXJ0ZXNpYW5Ob3JtYWxpemUoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICB2YXIgz4ZhcmMgPSAoYW50aW1lcmlkaWFuIF4gZM67ID49IDAgPyAtMSA6IDEpICogZDNfYXNpbihpbnRlcnNlY3Rpb25bMl0pO1xuICAgICAgICAgIGlmIChwYXJhbGxlbCA+IM+GYXJjIHx8IHBhcmFsbGVsID09PSDPhmFyYyAmJiAoYXJjWzBdIHx8IGFyY1sxXSkpIHtcbiAgICAgICAgICAgIHdpbmRpbmcgKz0gYW50aW1lcmlkaWFuIF4gZM67ID49IDAgPyAxIDogLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaisrKSBicmVhaztcbiAgICAgICAgzrswID0gzrssIHNpbs+GMCA9IHNpbs+GLCBjb3PPhjAgPSBjb3PPhiwgcG9pbnQwID0gcG9pbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAocG9sYXJBbmdsZSA8IC3OtSB8fCBwb2xhckFuZ2xlIDwgzrUgJiYgZDNfZ2VvX2FyZWFSaW5nU3VtIDwgLc61KSBeIHdpbmRpbmcgJiAxO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwQ2lyY2xlKHJhZGl1cykge1xuICAgIHZhciBjciA9IE1hdGguY29zKHJhZGl1cyksIHNtYWxsUmFkaXVzID0gY3IgPiAwLCBub3RIZW1pc3BoZXJlID0gYWJzKGNyKSA+IM61LCBpbnRlcnBvbGF0ZSA9IGQzX2dlb19jaXJjbGVJbnRlcnBvbGF0ZShyYWRpdXMsIDYgKiBkM19yYWRpYW5zKTtcbiAgICByZXR1cm4gZDNfZ2VvX2NsaXAodmlzaWJsZSwgY2xpcExpbmUsIGludGVycG9sYXRlLCBzbWFsbFJhZGl1cyA/IFsgMCwgLXJhZGl1cyBdIDogWyAtz4AsIHJhZGl1cyAtIM+AIF0pO1xuICAgIGZ1bmN0aW9uIHZpc2libGUozrssIM+GKSB7XG4gICAgICByZXR1cm4gTWF0aC5jb3MozrspICogTWF0aC5jb3Moz4YpID4gY3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsaXBMaW5lKGxpc3RlbmVyKSB7XG4gICAgICB2YXIgcG9pbnQwLCBjMCwgdjAsIHYwMCwgY2xlYW47XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHYwMCA9IHYwID0gZmFsc2U7XG4gICAgICAgICAgY2xlYW4gPSAxO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludDogZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICAgICAgdmFyIHBvaW50MSA9IFsgzrssIM+GIF0sIHBvaW50MiwgdiA9IHZpc2libGUozrssIM+GKSwgYyA9IHNtYWxsUmFkaXVzID8gdiA/IDAgOiBjb2RlKM67LCDPhikgOiB2ID8gY29kZSjOuyArICjOuyA8IDAgPyDPgCA6IC3PgCksIM+GKSA6IDA7XG4gICAgICAgICAgaWYgKCFwb2ludDAgJiYgKHYwMCA9IHYwID0gdikpIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGlmICh2ICE9PSB2MCkge1xuICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MCwgcG9pbnQxKTtcbiAgICAgICAgICAgIGlmIChkM19nZW9fc3BoZXJpY2FsRXF1YWwocG9pbnQwLCBwb2ludDIpIHx8IGQzX2dlb19zcGhlcmljYWxFcXVhbChwb2ludDEsIHBvaW50MikpIHtcbiAgICAgICAgICAgICAgcG9pbnQxWzBdICs9IM61O1xuICAgICAgICAgICAgICBwb2ludDFbMV0gKz0gzrU7XG4gICAgICAgICAgICAgIHYgPSB2aXNpYmxlKHBvaW50MVswXSwgcG9pbnQxWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHYgIT09IHYwKSB7XG4gICAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwKTtcbiAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQocG9pbnQyWzBdLCBwb2ludDJbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MCwgcG9pbnQxKTtcbiAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQocG9pbnQyWzBdLCBwb2ludDJbMV0pO1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludDAgPSBwb2ludDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChub3RIZW1pc3BoZXJlICYmIHBvaW50MCAmJiBzbWFsbFJhZGl1cyBeIHYpIHtcbiAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgaWYgKCEoYyAmIGMwKSAmJiAodCA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICAgICAgaWYgKHNtYWxsUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQodFswXVswXSwgdFswXVsxXSk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHRbMV1bMF0sIHRbMV1bMV0pO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh0WzBdWzBdLCB0WzBdWzFdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodiAmJiAoIXBvaW50MCB8fCAhZDNfZ2VvX3NwaGVyaWNhbEVxdWFsKHBvaW50MCwgcG9pbnQxKSkpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHBvaW50MVswXSwgcG9pbnQxWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9pbnQwID0gcG9pbnQxLCB2MCA9IHYsIGMwID0gYztcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHYwKSBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgcG9pbnQwID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBjbGVhbiB8ICh2MDAgJiYgdjApIDw8IDE7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVyc2VjdChhLCBiLCB0d28pIHtcbiAgICAgIHZhciBwYSA9IGQzX2dlb19jYXJ0ZXNpYW4oYSksIHBiID0gZDNfZ2VvX2NhcnRlc2lhbihiKTtcbiAgICAgIHZhciBuMSA9IFsgMSwgMCwgMCBdLCBuMiA9IGQzX2dlb19jYXJ0ZXNpYW5Dcm9zcyhwYSwgcGIpLCBuMm4yID0gZDNfZ2VvX2NhcnRlc2lhbkRvdChuMiwgbjIpLCBuMW4yID0gbjJbMF0sIGRldGVybWluYW50ID0gbjJuMiAtIG4xbjIgKiBuMW4yO1xuICAgICAgaWYgKCFkZXRlcm1pbmFudCkgcmV0dXJuICF0d28gJiYgYTtcbiAgICAgIHZhciBjMSA9IGNyICogbjJuMiAvIGRldGVybWluYW50LCBjMiA9IC1jciAqIG4xbjIgLyBkZXRlcm1pbmFudCwgbjF4bjIgPSBkM19nZW9fY2FydGVzaWFuQ3Jvc3MobjEsIG4yKSwgQSA9IGQzX2dlb19jYXJ0ZXNpYW5TY2FsZShuMSwgYzEpLCBCID0gZDNfZ2VvX2NhcnRlc2lhblNjYWxlKG4yLCBjMik7XG4gICAgICBkM19nZW9fY2FydGVzaWFuQWRkKEEsIEIpO1xuICAgICAgdmFyIHUgPSBuMXhuMiwgdyA9IGQzX2dlb19jYXJ0ZXNpYW5Eb3QoQSwgdSksIHV1ID0gZDNfZ2VvX2NhcnRlc2lhbkRvdCh1LCB1KSwgdDIgPSB3ICogdyAtIHV1ICogKGQzX2dlb19jYXJ0ZXNpYW5Eb3QoQSwgQSkgLSAxKTtcbiAgICAgIGlmICh0MiA8IDApIHJldHVybjtcbiAgICAgIHZhciB0ID0gTWF0aC5zcXJ0KHQyKSwgcSA9IGQzX2dlb19jYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgLSB0KSAvIHV1KTtcbiAgICAgIGQzX2dlb19jYXJ0ZXNpYW5BZGQocSwgQSk7XG4gICAgICBxID0gZDNfZ2VvX3NwaGVyaWNhbChxKTtcbiAgICAgIGlmICghdHdvKSByZXR1cm4gcTtcbiAgICAgIHZhciDOuzAgPSBhWzBdLCDOuzEgPSBiWzBdLCDPhjAgPSBhWzFdLCDPhjEgPSBiWzFdLCB6O1xuICAgICAgaWYgKM67MSA8IM67MCkgeiA9IM67MCwgzrswID0gzrsxLCDOuzEgPSB6O1xuICAgICAgdmFyIM60zrsgPSDOuzEgLSDOuzAsIHBvbGFyID0gYWJzKM60zrsgLSDPgCkgPCDOtSwgbWVyaWRpYW4gPSBwb2xhciB8fCDOtM67IDwgzrU7XG4gICAgICBpZiAoIXBvbGFyICYmIM+GMSA8IM+GMCkgeiA9IM+GMCwgz4YwID0gz4YxLCDPhjEgPSB6O1xuICAgICAgaWYgKG1lcmlkaWFuID8gcG9sYXIgPyDPhjAgKyDPhjEgPiAwIF4gcVsxXSA8IChhYnMocVswXSAtIM67MCkgPCDOtSA/IM+GMCA6IM+GMSkgOiDPhjAgPD0gcVsxXSAmJiBxWzFdIDw9IM+GMSA6IM60zrsgPiDPgCBeICjOuzAgPD0gcVswXSAmJiBxWzBdIDw9IM67MSkpIHtcbiAgICAgICAgdmFyIHExID0gZDNfZ2VvX2NhcnRlc2lhblNjYWxlKHUsICgtdyArIHQpIC8gdXUpO1xuICAgICAgICBkM19nZW9fY2FydGVzaWFuQWRkKHExLCBBKTtcbiAgICAgICAgcmV0dXJuIFsgcSwgZDNfZ2VvX3NwaGVyaWNhbChxMSkgXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29kZSjOuywgz4YpIHtcbiAgICAgIHZhciByID0gc21hbGxSYWRpdXMgPyByYWRpdXMgOiDPgCAtIHJhZGl1cywgY29kZSA9IDA7XG4gICAgICBpZiAozrsgPCAtcikgY29kZSB8PSAxOyBlbHNlIGlmICjOuyA+IHIpIGNvZGUgfD0gMjtcbiAgICAgIGlmICjPhiA8IC1yKSBjb2RlIHw9IDQ7IGVsc2UgaWYgKM+GID4gcikgY29kZSB8PSA4O1xuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fY2xpcExpbmUoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIGEgPSBsaW5lLmEsIGIgPSBsaW5lLmIsIGF4ID0gYS54LCBheSA9IGEueSwgYnggPSBiLngsIGJ5ID0gYi55LCB0MCA9IDAsIHQxID0gMSwgZHggPSBieCAtIGF4LCBkeSA9IGJ5IC0gYXksIHI7XG4gICAgICByID0geDAgLSBheDtcbiAgICAgIGlmICghZHggJiYgciA+IDApIHJldHVybjtcbiAgICAgIHIgLz0gZHg7XG4gICAgICBpZiAoZHggPCAwKSB7XG4gICAgICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICAgICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICAgICAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICAgICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgICAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gICAgICB9XG4gICAgICByID0geDEgLSBheDtcbiAgICAgIGlmICghZHggJiYgciA8IDApIHJldHVybjtcbiAgICAgIHIgLz0gZHg7XG4gICAgICBpZiAoZHggPCAwKSB7XG4gICAgICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICAgICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICAgICAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICAgICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgICAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gICAgICB9XG4gICAgICByID0geTAgLSBheTtcbiAgICAgIGlmICghZHkgJiYgciA+IDApIHJldHVybjtcbiAgICAgIHIgLz0gZHk7XG4gICAgICBpZiAoZHkgPCAwKSB7XG4gICAgICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICAgICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICAgICAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICAgICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgICAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gICAgICB9XG4gICAgICByID0geTEgLSBheTtcbiAgICAgIGlmICghZHkgJiYgciA8IDApIHJldHVybjtcbiAgICAgIHIgLz0gZHk7XG4gICAgICBpZiAoZHkgPCAwKSB7XG4gICAgICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICAgICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICAgICAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICAgICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgICAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gICAgICB9XG4gICAgICBpZiAodDAgPiAwKSBsaW5lLmEgPSB7XG4gICAgICAgIHg6IGF4ICsgdDAgKiBkeCxcbiAgICAgICAgeTogYXkgKyB0MCAqIGR5XG4gICAgICB9O1xuICAgICAgaWYgKHQxIDwgMSkgbGluZS5iID0ge1xuICAgICAgICB4OiBheCArIHQxICogZHgsXG4gICAgICAgIHk6IGF5ICsgdDEgKiBkeVxuICAgICAgfTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gIH1cbiAgdmFyIGQzX2dlb19jbGlwRXh0ZW50TUFYID0gMWU5O1xuICBkMy5nZW8uY2xpcEV4dGVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4MCwgeTAsIHgxLCB5MSwgc3RyZWFtLCBjbGlwLCBjbGlwRXh0ZW50ID0ge1xuICAgICAgc3RyZWFtOiBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgaWYgKHN0cmVhbSkgc3RyZWFtLnZhbGlkID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbSA9IGNsaXAob3V0cHV0KTtcbiAgICAgICAgc3RyZWFtLnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sXG4gICAgICBleHRlbnQ6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyBbIHgwLCB5MCBdLCBbIHgxLCB5MSBdIF07XG4gICAgICAgIGNsaXAgPSBkM19nZW9fY2xpcEV4dGVudCh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdKTtcbiAgICAgICAgaWYgKHN0cmVhbSkgc3RyZWFtLnZhbGlkID0gZmFsc2UsIHN0cmVhbSA9IG51bGw7XG4gICAgICAgIHJldHVybiBjbGlwRXh0ZW50O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGNsaXBFeHRlbnQuZXh0ZW50KFsgWyAwLCAwIF0sIFsgOTYwLCA1MDAgXSBdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBFeHRlbnQoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0ZW5lcl8gPSBsaXN0ZW5lciwgYnVmZmVyTGlzdGVuZXIgPSBkM19nZW9fY2xpcEJ1ZmZlckxpc3RlbmVyKCksIGNsaXBMaW5lID0gZDNfZ2VvbV9jbGlwTGluZSh4MCwgeTAsIHgxLCB5MSksIHNlZ21lbnRzLCBwb2x5Z29uLCByaW5nO1xuICAgICAgdmFyIGNsaXAgPSB7XG4gICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGlzdGVuZXIgPSBidWZmZXJMaXN0ZW5lcjtcbiAgICAgICAgICBzZWdtZW50cyA9IFtdO1xuICAgICAgICAgIHBvbHlnb24gPSBbXTtcbiAgICAgICAgICBjbGVhbiA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXJfO1xuICAgICAgICAgIHNlZ21lbnRzID0gZDMubWVyZ2Uoc2VnbWVudHMpO1xuICAgICAgICAgIHZhciBjbGlwU3RhcnRJbnNpZGUgPSBpbnNpZGVQb2x5Z29uKFsgeDAsIHkxIF0pLCBpbnNpZGUgPSBjbGVhbiAmJiBjbGlwU3RhcnRJbnNpZGUsIHZpc2libGUgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGluc2lkZSB8fCB2aXNpYmxlKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICAgICAgZDNfZ2VvX2NsaXBQb2x5Z29uKHNlZ21lbnRzLCBjb21wYXJlLCBjbGlwU3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0ZW5lci5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlZ21lbnRzID0gcG9seWdvbiA9IHJpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gaW5zaWRlUG9seWdvbihwKSB7XG4gICAgICAgIHZhciB3biA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aCwgeSA9IHBbMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDEsIHYgPSBwb2x5Z29uW2ldLCBtID0gdi5sZW5ndGgsIGEgPSB2WzBdLCBiOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgICBiID0gdltqXTtcbiAgICAgICAgICAgIGlmIChhWzFdIDw9IHkpIHtcbiAgICAgICAgICAgICAgaWYgKGJbMV0gPiB5ICYmIGQzX2Nyb3NzMmQoYSwgYiwgcCkgPiAwKSArK3duO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGJbMV0gPD0geSAmJiBkM19jcm9zczJkKGEsIGIsIHApIDwgMCkgLS13bjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd24gIT09IDA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgYSA9IDAsIGExID0gMDtcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbCB8fCAoYSA9IGNvcm5lcihmcm9tLCBkaXJlY3Rpb24pKSAhPT0gKGExID0gY29ybmVyKHRvLCBkaXJlY3Rpb24pKSB8fCBjb21wYXJlUG9pbnRzKGZyb20sIHRvKSA8IDAgXiBkaXJlY3Rpb24gPiAwKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQoYSA9PT0gMCB8fCBhID09PSAzID8geDAgOiB4MSwgYSA+IDEgPyB5MSA6IHkwKTtcbiAgICAgICAgICB9IHdoaWxlICgoYSA9IChhICsgZGlyZWN0aW9uICsgNCkgJSA0KSAhPT0gYTEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHRvWzBdLCB0b1sxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBvaW50VmlzaWJsZSh4LCB5KSB7XG4gICAgICAgIHJldHVybiB4MCA8PSB4ICYmIHggPD0geDEgJiYgeTAgPD0geSAmJiB5IDw9IHkxO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgICBpZiAocG9pbnRWaXNpYmxlKHgsIHkpKSBsaXN0ZW5lci5wb2ludCh4LCB5KTtcbiAgICAgIH1cbiAgICAgIHZhciB4X18sIHlfXywgdl9fLCB4XywgeV8sIHZfLCBmaXJzdCwgY2xlYW47XG4gICAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICAgIGNsaXAucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICAgIGlmIChwb2x5Z29uKSBwb2x5Z29uLnB1c2gocmluZyA9IFtdKTtcbiAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICB2XyA9IGZhbHNlO1xuICAgICAgICB4XyA9IHlfID0gTmFOO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgICAgaWYgKHNlZ21lbnRzKSB7XG4gICAgICAgICAgbGluZVBvaW50KHhfXywgeV9fKTtcbiAgICAgICAgICBpZiAodl9fICYmIHZfKSBidWZmZXJMaXN0ZW5lci5yZWpvaW4oKTtcbiAgICAgICAgICBzZWdtZW50cy5wdXNoKGJ1ZmZlckxpc3RlbmVyLmJ1ZmZlcigpKTtcbiAgICAgICAgfVxuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIGlmICh2XykgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGluZVBvaW50KHgsIHkpIHtcbiAgICAgICAgeCA9IE1hdGgubWF4KC1kM19nZW9fY2xpcEV4dGVudE1BWCwgTWF0aC5taW4oZDNfZ2VvX2NsaXBFeHRlbnRNQVgsIHgpKTtcbiAgICAgICAgeSA9IE1hdGgubWF4KC1kM19nZW9fY2xpcEV4dGVudE1BWCwgTWF0aC5taW4oZDNfZ2VvX2NsaXBFeHRlbnRNQVgsIHkpKTtcbiAgICAgICAgdmFyIHYgPSBwb2ludFZpc2libGUoeCwgeSk7XG4gICAgICAgIGlmIChwb2x5Z29uKSByaW5nLnB1c2goWyB4LCB5IF0pO1xuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICB4X18gPSB4LCB5X18gPSB5LCB2X18gPSB2O1xuICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQoeCwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2ICYmIHZfKSBsaXN0ZW5lci5wb2ludCh4LCB5KTsgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbCA9IHtcbiAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgIHg6IHhfLFxuICAgICAgICAgICAgICAgIHk6IHlfXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGI6IHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjbGlwTGluZShsKSkge1xuICAgICAgICAgICAgICBpZiAoIXZfKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQobC5hLngsIGwuYS55KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludChsLmIueCwgbC5iLnkpO1xuICAgICAgICAgICAgICBpZiAoIXYpIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodikge1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHhfID0geCwgeV8gPSB5LCB2XyA9IHY7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xpcDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNvcm5lcihwLCBkaXJlY3Rpb24pIHtcbiAgICAgIHJldHVybiBhYnMocFswXSAtIHgwKSA8IM61ID8gZGlyZWN0aW9uID4gMCA/IDAgOiAzIDogYWJzKHBbMF0gLSB4MSkgPCDOtSA/IGRpcmVjdGlvbiA+IDAgPyAyIDogMSA6IGFicyhwWzFdIC0geTApIDwgzrUgPyBkaXJlY3Rpb24gPiAwID8gMSA6IDAgOiBkaXJlY3Rpb24gPiAwID8gMyA6IDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgcmV0dXJuIGNvbXBhcmVQb2ludHMoYS54LCBiLngpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlUG9pbnRzKGEsIGIpIHtcbiAgICAgIHZhciBjYSA9IGNvcm5lcihhLCAxKSwgY2IgPSBjb3JuZXIoYiwgMSk7XG4gICAgICByZXR1cm4gY2EgIT09IGNiID8gY2EgLSBjYiA6IGNhID09PSAwID8gYlsxXSAtIGFbMV0gOiBjYSA9PT0gMSA/IGFbMF0gLSBiWzBdIDogY2EgPT09IDIgPyBhWzFdIC0gYlsxXSA6IGJbMF0gLSBhWzBdO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY29uaWMocHJvamVjdEF0KSB7XG4gICAgdmFyIM+GMCA9IDAsIM+GMSA9IM+AIC8gMywgbSA9IGQzX2dlb19wcm9qZWN0aW9uTXV0YXRvcihwcm9qZWN0QXQpLCBwID0gbSjPhjAsIM+GMSk7XG4gICAgcC5wYXJhbGxlbHMgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIM+GMCAvIM+AICogMTgwLCDPhjEgLyDPgCAqIDE4MCBdO1xuICAgICAgcmV0dXJuIG0oz4YwID0gX1swXSAqIM+AIC8gMTgwLCDPhjEgPSBfWzFdICogz4AgLyAxODApO1xuICAgIH07XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NvbmljRXF1YWxBcmVhKM+GMCwgz4YxKSB7XG4gICAgdmFyIHNpbs+GMCA9IE1hdGguc2luKM+GMCksIG4gPSAoc2luz4YwICsgTWF0aC5zaW4oz4YxKSkgLyAyLCBDID0gMSArIHNpbs+GMCAqICgyICogbiAtIHNpbs+GMCksIM+BMCA9IE1hdGguc3FydChDKSAvIG47XG4gICAgZnVuY3Rpb24gZm9yd2FyZCjOuywgz4YpIHtcbiAgICAgIHZhciDPgSA9IE1hdGguc3FydChDIC0gMiAqIG4gKiBNYXRoLnNpbijPhikpIC8gbjtcbiAgICAgIHJldHVybiBbIM+BICogTWF0aC5zaW4ozrsgKj0gbiksIM+BMCAtIM+BICogTWF0aC5jb3MozrspIF07XG4gICAgfVxuICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIM+BMF95ID0gz4EwIC0geTtcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeCwgz4EwX3kpIC8gbiwgZDNfYXNpbigoQyAtICh4ICogeCArIM+BMF95ICogz4EwX3kpICogbiAqIG4pIC8gKDIgKiBuKSkgXTtcbiAgICB9O1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG4gIChkMy5nZW8uY29uaWNFcXVhbEFyZWEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX2NvbmljKGQzX2dlb19jb25pY0VxdWFsQXJlYSk7XG4gIH0pLnJhdyA9IGQzX2dlb19jb25pY0VxdWFsQXJlYTtcbiAgZDMuZ2VvLmFsYmVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5nZW8uY29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWyA5NiwgMCBdKS5jZW50ZXIoWyAtLjYsIDM4LjcgXSkucGFyYWxsZWxzKFsgMjkuNSwgNDUuNSBdKS5zY2FsZSgxMDcwKTtcbiAgfTtcbiAgZDMuZ2VvLmFsYmVyc1VzYSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsb3dlcjQ4ID0gZDMuZ2VvLmFsYmVycygpO1xuICAgIHZhciBhbGFza2EgPSBkMy5nZW8uY29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWyAxNTQsIDAgXSkuY2VudGVyKFsgLTIsIDU4LjUgXSkucGFyYWxsZWxzKFsgNTUsIDY1IF0pO1xuICAgIHZhciBoYXdhaWkgPSBkMy5nZW8uY29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWyAxNTcsIDAgXSkuY2VudGVyKFsgLTMsIDE5LjkgXSkucGFyYWxsZWxzKFsgOCwgMTggXSk7XG4gICAgdmFyIHBvaW50LCBwb2ludFN0cmVhbSA9IHtcbiAgICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHBvaW50ID0gWyB4LCB5IF07XG4gICAgICB9XG4gICAgfSwgbG93ZXI0OFBvaW50LCBhbGFza2FQb2ludCwgaGF3YWlpUG9pbnQ7XG4gICAgZnVuY3Rpb24gYWxiZXJzVXNhKGNvb3JkaW5hdGVzKSB7XG4gICAgICB2YXIgeCA9IGNvb3JkaW5hdGVzWzBdLCB5ID0gY29vcmRpbmF0ZXNbMV07XG4gICAgICBwb2ludCA9IG51bGw7XG4gICAgICAobG93ZXI0OFBvaW50KHgsIHkpLCBwb2ludCkgfHwgKGFsYXNrYVBvaW50KHgsIHkpLCBwb2ludCkgfHwgaGF3YWlpUG9pbnQoeCwgeSk7XG4gICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICAgIGFsYmVyc1VzYS5pbnZlcnQgPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgICAgdmFyIGsgPSBsb3dlcjQ4LnNjYWxlKCksIHQgPSBsb3dlcjQ4LnRyYW5zbGF0ZSgpLCB4ID0gKGNvb3JkaW5hdGVzWzBdIC0gdFswXSkgLyBrLCB5ID0gKGNvb3JkaW5hdGVzWzFdIC0gdFsxXSkgLyBrO1xuICAgICAgcmV0dXJuICh5ID49IC4xMiAmJiB5IDwgLjIzNCAmJiB4ID49IC0uNDI1ICYmIHggPCAtLjIxNCA/IGFsYXNrYSA6IHkgPj0gLjE2NiAmJiB5IDwgLjIzNCAmJiB4ID49IC0uMjE0ICYmIHggPCAtLjExNSA/IGhhd2FpaSA6IGxvd2VyNDgpLmludmVydChjb29yZGluYXRlcyk7XG4gICAgfTtcbiAgICBhbGJlcnNVc2Euc3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICB2YXIgbG93ZXI0OFN0cmVhbSA9IGxvd2VyNDguc3RyZWFtKHN0cmVhbSksIGFsYXNrYVN0cmVhbSA9IGFsYXNrYS5zdHJlYW0oc3RyZWFtKSwgaGF3YWlpU3RyZWFtID0gaGF3YWlpLnN0cmVhbShzdHJlYW0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgICBoYXdhaWlTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG93ZXI0OFN0cmVhbS5zcGhlcmUoKTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0uc3BoZXJlKCk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLnNwaGVyZSgpO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvd2VyNDhTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgYWxhc2thU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGhhd2FpaVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG93ZXI0OFN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgYWxhc2thU3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICBoYXdhaWlTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvd2VyNDhTdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgYWxhc2thU3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgIGhhd2FpaVN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG93ZXI0OFN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgYWxhc2thU3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICBoYXdhaWlTdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgYWxiZXJzVXNhLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDgucHJlY2lzaW9uKCk7XG4gICAgICBsb3dlcjQ4LnByZWNpc2lvbihfKTtcbiAgICAgIGFsYXNrYS5wcmVjaXNpb24oXyk7XG4gICAgICBoYXdhaWkucHJlY2lzaW9uKF8pO1xuICAgICAgcmV0dXJuIGFsYmVyc1VzYTtcbiAgICB9O1xuICAgIGFsYmVyc1VzYS5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDguc2NhbGUoKTtcbiAgICAgIGxvd2VyNDguc2NhbGUoXyk7XG4gICAgICBhbGFza2Euc2NhbGUoXyAqIC4zNSk7XG4gICAgICBoYXdhaWkuc2NhbGUoXyk7XG4gICAgICByZXR1cm4gYWxiZXJzVXNhLnRyYW5zbGF0ZShsb3dlcjQ4LnRyYW5zbGF0ZSgpKTtcbiAgICB9O1xuICAgIGFsYmVyc1VzYS50cmFuc2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb3dlcjQ4LnRyYW5zbGF0ZSgpO1xuICAgICAgdmFyIGsgPSBsb3dlcjQ4LnNjYWxlKCksIHggPSArX1swXSwgeSA9ICtfWzFdO1xuICAgICAgbG93ZXI0OFBvaW50ID0gbG93ZXI0OC50cmFuc2xhdGUoXykuY2xpcEV4dGVudChbIFsgeCAtIC40NTUgKiBrLCB5IC0gLjIzOCAqIGsgXSwgWyB4ICsgLjQ1NSAqIGssIHkgKyAuMjM4ICogayBdIF0pLnN0cmVhbShwb2ludFN0cmVhbSkucG9pbnQ7XG4gICAgICBhbGFza2FQb2ludCA9IGFsYXNrYS50cmFuc2xhdGUoWyB4IC0gLjMwNyAqIGssIHkgKyAuMjAxICogayBdKS5jbGlwRXh0ZW50KFsgWyB4IC0gLjQyNSAqIGsgKyDOtSwgeSArIC4xMiAqIGsgKyDOtSBdLCBbIHggLSAuMjE0ICogayAtIM61LCB5ICsgLjIzNCAqIGsgLSDOtSBdIF0pLnN0cmVhbShwb2ludFN0cmVhbSkucG9pbnQ7XG4gICAgICBoYXdhaWlQb2ludCA9IGhhd2FpaS50cmFuc2xhdGUoWyB4IC0gLjIwNSAqIGssIHkgKyAuMjEyICogayBdKS5jbGlwRXh0ZW50KFsgWyB4IC0gLjIxNCAqIGsgKyDOtSwgeSArIC4xNjYgKiBrICsgzrUgXSwgWyB4IC0gLjExNSAqIGsgLSDOtSwgeSArIC4yMzQgKiBrIC0gzrUgXSBdKS5zdHJlYW0ocG9pbnRTdHJlYW0pLnBvaW50O1xuICAgICAgcmV0dXJuIGFsYmVyc1VzYTtcbiAgICB9O1xuICAgIHJldHVybiBhbGJlcnNVc2Euc2NhbGUoMTA3MCk7XG4gIH07XG4gIHZhciBkM19nZW9fcGF0aEFyZWFTdW0sIGQzX2dlb19wYXRoQXJlYVBvbHlnb24sIGQzX2dlb19wYXRoQXJlYSA9IHtcbiAgICBwb2ludDogZDNfbm9vcCxcbiAgICBsaW5lU3RhcnQ6IGQzX25vb3AsXG4gICAgbGluZUVuZDogZDNfbm9vcCxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhUG9seWdvbiA9IDA7XG4gICAgICBkM19nZW9fcGF0aEFyZWEubGluZVN0YXJ0ID0gZDNfZ2VvX3BhdGhBcmVhUmluZ1N0YXJ0O1xuICAgIH0sXG4gICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fcGF0aEFyZWEubGluZVN0YXJ0ID0gZDNfZ2VvX3BhdGhBcmVhLmxpbmVFbmQgPSBkM19nZW9fcGF0aEFyZWEucG9pbnQgPSBkM19ub29wO1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhU3VtICs9IGFicyhkM19nZW9fcGF0aEFyZWFQb2x5Z29uIC8gMik7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fcGF0aEFyZWFSaW5nU3RhcnQoKSB7XG4gICAgdmFyIHgwMCwgeTAwLCB4MCwgeTA7XG4gICAgZDNfZ2VvX3BhdGhBcmVhLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhLnBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgeDAwID0geDAgPSB4LCB5MDAgPSB5MCA9IHk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXh0UG9pbnQoeCwgeSkge1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhUG9seWdvbiArPSB5MCAqIHggLSB4MCAqIHk7XG4gICAgICB4MCA9IHgsIHkwID0geTtcbiAgICB9XG4gICAgZDNfZ2VvX3BhdGhBcmVhLmxpbmVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIG5leHRQb2ludCh4MDAsIHkwMCk7XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfZ2VvX3BhdGhCb3VuZHNYMCwgZDNfZ2VvX3BhdGhCb3VuZHNZMCwgZDNfZ2VvX3BhdGhCb3VuZHNYMSwgZDNfZ2VvX3BhdGhCb3VuZHNZMTtcbiAgdmFyIGQzX2dlb19wYXRoQm91bmRzID0ge1xuICAgIHBvaW50OiBkM19nZW9fcGF0aEJvdW5kc1BvaW50LFxuICAgIGxpbmVTdGFydDogZDNfbm9vcCxcbiAgICBsaW5lRW5kOiBkM19ub29wLFxuICAgIHBvbHlnb25TdGFydDogZDNfbm9vcCxcbiAgICBwb2x5Z29uRW5kOiBkM19ub29wXG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQm91bmRzUG9pbnQoeCwgeSkge1xuICAgIGlmICh4IDwgZDNfZ2VvX3BhdGhCb3VuZHNYMCkgZDNfZ2VvX3BhdGhCb3VuZHNYMCA9IHg7XG4gICAgaWYgKHggPiBkM19nZW9fcGF0aEJvdW5kc1gxKSBkM19nZW9fcGF0aEJvdW5kc1gxID0geDtcbiAgICBpZiAoeSA8IGQzX2dlb19wYXRoQm91bmRzWTApIGQzX2dlb19wYXRoQm91bmRzWTAgPSB5O1xuICAgIGlmICh5ID4gZDNfZ2VvX3BhdGhCb3VuZHNZMSkgZDNfZ2VvX3BhdGhCb3VuZHNZMSA9IHk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhCdWZmZXIoKSB7XG4gICAgdmFyIHBvaW50Q2lyY2xlID0gZDNfZ2VvX3BhdGhCdWZmZXJDaXJjbGUoNC41KSwgYnVmZmVyID0gW107XG4gICAgdmFyIHN0cmVhbSA9IHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50TGluZVN0YXJ0O1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ubGluZUVuZCA9IGxpbmVFbmRQb2x5Z29uO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgICAgfSxcbiAgICAgIHBvaW50UmFkaXVzOiBmdW5jdGlvbihfKSB7XG4gICAgICAgIHBvaW50Q2lyY2xlID0gZDNfZ2VvX3BhdGhCdWZmZXJDaXJjbGUoXyk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICAgICAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gYnVmZmVyLmpvaW4oXCJcIik7XG4gICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgYnVmZmVyLnB1c2goXCJNXCIsIHgsIFwiLFwiLCB5LCBwb2ludENpcmNsZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50TGluZVN0YXJ0KHgsIHkpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKFwiTVwiLCB4LCBcIixcIiwgeSk7XG4gICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludExpbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50TGluZSh4LCB5KSB7XG4gICAgICBidWZmZXIucHVzaChcIkxcIiwgeCwgXCIsXCIsIHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVFbmRQb2x5Z29uKCkge1xuICAgICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQnVmZmVyQ2lyY2xlKHJhZGl1cykge1xuICAgIHJldHVybiBcIm0wLFwiICsgcmFkaXVzICsgXCJhXCIgKyByYWRpdXMgKyBcIixcIiArIHJhZGl1cyArIFwiIDAgMSwxIDAsXCIgKyAtMiAqIHJhZGl1cyArIFwiYVwiICsgcmFkaXVzICsgXCIsXCIgKyByYWRpdXMgKyBcIiAwIDEsMSAwLFwiICsgMiAqIHJhZGl1cyArIFwielwiO1xuICB9XG4gIHZhciBkM19nZW9fcGF0aENlbnRyb2lkID0ge1xuICAgIHBvaW50OiBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQsXG4gICAgbGluZVN0YXJ0OiBkM19nZW9fcGF0aENlbnRyb2lkTGluZVN0YXJ0LFxuICAgIGxpbmVFbmQ6IGQzX2dlb19wYXRoQ2VudHJvaWRMaW5lRW5kLFxuICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkLmxpbmVTdGFydCA9IGQzX2dlb19wYXRoQ2VudHJvaWRSaW5nU3RhcnQ7XG4gICAgfSxcbiAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQucG9pbnQgPSBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQ7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkLmxpbmVTdGFydCA9IGQzX2dlb19wYXRoQ2VudHJvaWRMaW5lU3RhcnQ7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkLmxpbmVFbmQgPSBkM19nZW9fcGF0aENlbnRyb2lkTGluZUVuZDtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludCh4LCB5KSB7XG4gICAgZDNfZ2VvX2NlbnRyb2lkWDAgKz0geDtcbiAgICBkM19nZW9fY2VudHJvaWRZMCArPSB5O1xuICAgICsrZDNfZ2VvX2NlbnRyb2lkWjA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVTdGFydCgpIHtcbiAgICB2YXIgeDAsIHkwO1xuICAgIGQzX2dlb19wYXRoQ2VudHJvaWQucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkLnBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50KHgwID0geCwgeTAgPSB5KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCh4LCB5KSB7XG4gICAgICB2YXIgZHggPSB4IC0geDAsIGR5ID0geSAtIHkwLCB6ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFgxICs9IHogKiAoeDAgKyB4KSAvIDI7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMSArPSB6ICogKHkwICsgeSkgLyAyO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjEgKz0gejtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludCh4MCA9IHgsIHkwID0geSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQ2VudHJvaWRMaW5lRW5kKCkge1xuICAgIGQzX2dlb19wYXRoQ2VudHJvaWQucG9pbnQgPSBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhDZW50cm9pZFJpbmdTdGFydCgpIHtcbiAgICB2YXIgeDAwLCB5MDAsIHgwLCB5MDtcbiAgICBkM19nZW9fcGF0aENlbnRyb2lkLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IG5leHRQb2ludDtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludCh4MDAgPSB4MCA9IHgsIHkwMCA9IHkwID0geSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXh0UG9pbnQoeCwgeSkge1xuICAgICAgdmFyIGR4ID0geCAtIHgwLCBkeSA9IHkgLSB5MCwgeiA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRYMSArPSB6ICogKHgwICsgeCkgLyAyO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWTEgKz0geiAqICh5MCArIHkpIC8gMjtcbiAgICAgIGQzX2dlb19jZW50cm9pZFoxICs9IHo7XG4gICAgICB6ID0geTAgKiB4IC0geDAgKiB5O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDIgKz0geiAqICh4MCArIHgpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWTIgKz0geiAqICh5MCArIHkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjIgKz0geiAqIDM7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQoeDAgPSB4LCB5MCA9IHkpO1xuICAgIH1cbiAgICBkM19nZW9fcGF0aENlbnRyb2lkLmxpbmVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIG5leHRQb2ludCh4MDAsIHkwMCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aENvbnRleHQoY29udGV4dCkge1xuICAgIHZhciBwb2ludFJhZGl1cyA9IDQuNTtcbiAgICB2YXIgc3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnRMaW5lU3RhcnQ7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kID0gbGluZUVuZFBvbHlnb247XG4gICAgICB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgICB9LFxuICAgICAgcG9pbnRSYWRpdXM6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgcG9pbnRSYWRpdXMgPSBfO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIHJlc3VsdDogZDNfbm9vcFxuICAgIH07XG4gICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgY29udGV4dC5tb3ZlVG8oeCArIHBvaW50UmFkaXVzLCB5KTtcbiAgICAgIGNvbnRleHQuYXJjKHgsIHksIHBvaW50UmFkaXVzLCAwLCDPhCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50TGluZVN0YXJ0KHgsIHkpIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnRMaW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludExpbmUoeCwgeSkge1xuICAgICAgY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZUVuZFBvbHlnb24oKSB7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19yZXNhbXBsZShwcm9qZWN0KSB7XG4gICAgdmFyIM60MiA9IC41LCBjb3NNaW5EaXN0YW5jZSA9IE1hdGguY29zKDMwICogZDNfcmFkaWFucyksIG1heERlcHRoID0gMTY7XG4gICAgZnVuY3Rpb24gcmVzYW1wbGUoc3RyZWFtKSB7XG4gICAgICByZXR1cm4gKG1heERlcHRoID8gcmVzYW1wbGVSZWN1cnNpdmUgOiByZXNhbXBsZU5vbmUpKHN0cmVhbSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2FtcGxlTm9uZShzdHJlYW0pIHtcbiAgICAgIHJldHVybiBkM19nZW9fdHJhbnNmb3JtUG9pbnQoc3RyZWFtLCBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoeFswXSwgeFsxXSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzYW1wbGVSZWN1cnNpdmUoc3RyZWFtKSB7XG4gICAgICB2YXIgzrswMCwgz4YwMCwgeDAwLCB5MDAsIGEwMCwgYjAwLCBjMDAsIM67MCwgeDAsIHkwLCBhMCwgYjAsIGMwO1xuICAgICAgdmFyIHJlc2FtcGxlID0ge1xuICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICByZXNhbXBsZS5saW5lU3RhcnQgPSByaW5nU3RhcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgcmVzYW1wbGUubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgICB4MCA9IE5hTjtcbiAgICAgICAgcmVzYW1wbGUucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVQb2ludCjOuywgz4YpIHtcbiAgICAgICAgdmFyIGMgPSBkM19nZW9fY2FydGVzaWFuKFsgzrssIM+GIF0pLCBwID0gcHJvamVjdCjOuywgz4YpO1xuICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIM67MCwgYTAsIGIwLCBjMCwgeDAgPSBwWzBdLCB5MCA9IHBbMV0sIM67MCA9IM67LCBhMCA9IGNbMF0sIGIwID0gY1sxXSwgYzAgPSBjWzJdLCBtYXhEZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHgwLCB5MCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgICByZXNhbXBsZS5wb2ludCA9IHBvaW50O1xuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgICBsaW5lU3RhcnQoKTtcbiAgICAgICAgcmVzYW1wbGUucG9pbnQgPSByaW5nUG9pbnQ7XG4gICAgICAgIHJlc2FtcGxlLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmluZ1BvaW50KM67LCDPhikge1xuICAgICAgICBsaW5lUG9pbnQozrswMCA9IM67LCDPhjAwID0gz4YpLCB4MDAgPSB4MCwgeTAwID0geTAsIGEwMCA9IGEwLCBiMDAgPSBiMCwgYzAwID0gYzA7XG4gICAgICAgIHJlc2FtcGxlLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCDOuzAsIGEwLCBiMCwgYzAsIHgwMCwgeTAwLCDOuzAwLCBhMDAsIGIwMCwgYzAwLCBtYXhEZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgcmVzYW1wbGUubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgIGxpbmVFbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNhbXBsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCDOuzAsIGEwLCBiMCwgYzAsIHgxLCB5MSwgzrsxLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKSB7XG4gICAgICB2YXIgZHggPSB4MSAtIHgwLCBkeSA9IHkxIC0geTAsIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICBpZiAoZDIgPiA0ICogzrQyICYmIGRlcHRoLS0pIHtcbiAgICAgICAgdmFyIGEgPSBhMCArIGExLCBiID0gYjAgKyBiMSwgYyA9IGMwICsgYzEsIG0gPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSwgz4YyID0gTWF0aC5hc2luKGMgLz0gbSksIM67MiA9IGFicyhhYnMoYykgLSAxKSA8IM61IHx8IGFicyjOuzAgLSDOuzEpIDwgzrUgPyAozrswICsgzrsxKSAvIDIgOiBNYXRoLmF0YW4yKGIsIGEpLCBwID0gcHJvamVjdCjOuzIsIM+GMiksIHgyID0gcFswXSwgeTIgPSBwWzFdLCBkeDIgPSB4MiAtIHgwLCBkeTIgPSB5MiAtIHkwLCBkeiA9IGR5ICogZHgyIC0gZHggKiBkeTI7XG4gICAgICAgIGlmIChkeiAqIGR6IC8gZDIgPiDOtDIgfHwgYWJzKChkeCAqIGR4MiArIGR5ICogZHkyKSAvIGQyIC0gLjUpID4gLjMgfHwgYTAgKiBhMSArIGIwICogYjEgKyBjMCAqIGMxIDwgY29zTWluRGlzdGFuY2UpIHtcbiAgICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIM67MCwgYTAsIGIwLCBjMCwgeDIsIHkyLCDOuzIsIGEgLz0gbSwgYiAvPSBtLCBjLCBkZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgICBzdHJlYW0ucG9pbnQoeDIsIHkyKTtcbiAgICAgICAgICByZXNhbXBsZUxpbmVUbyh4MiwgeTIsIM67MiwgYSwgYiwgYywgeDEsIHkxLCDOuzEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc2FtcGxlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIE1hdGguc3FydCjOtDIpO1xuICAgICAgbWF4RGVwdGggPSAozrQyID0gXyAqIF8pID4gMCAmJiAxNjtcbiAgICAgIHJldHVybiByZXNhbXBsZTtcbiAgICB9O1xuICAgIHJldHVybiByZXNhbXBsZTtcbiAgfVxuICBkMy5nZW8ucGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwb2ludFJhZGl1cyA9IDQuNSwgcHJvamVjdGlvbiwgY29udGV4dCwgcHJvamVjdFN0cmVhbSwgY29udGV4dFN0cmVhbSwgY2FjaGVTdHJlYW07XG4gICAgZnVuY3Rpb24gcGF0aChvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwb2ludFJhZGl1cyA9PT0gXCJmdW5jdGlvblwiKSBjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKCtwb2ludFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgaWYgKCFjYWNoZVN0cmVhbSB8fCAhY2FjaGVTdHJlYW0udmFsaWQpIGNhY2hlU3RyZWFtID0gcHJvamVjdFN0cmVhbShjb250ZXh0U3RyZWFtKTtcbiAgICAgICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIGNhY2hlU3RyZWFtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZXh0U3RyZWFtLnJlc3VsdCgpO1xuICAgIH1cbiAgICBwYXRoLmFyZWEgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGQzX2dlb19wYXRoQXJlYVN1bSA9IDA7XG4gICAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgcHJvamVjdFN0cmVhbShkM19nZW9fcGF0aEFyZWEpKTtcbiAgICAgIHJldHVybiBkM19nZW9fcGF0aEFyZWFTdW07XG4gICAgfTtcbiAgICBwYXRoLmNlbnRyb2lkID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBkM19nZW9fY2VudHJvaWRYMCA9IGQzX2dlb19jZW50cm9pZFkwID0gZDNfZ2VvX2NlbnRyb2lkWjAgPSBkM19nZW9fY2VudHJvaWRYMSA9IGQzX2dlb19jZW50cm9pZFkxID0gZDNfZ2VvX2NlbnRyb2lkWjEgPSBkM19nZW9fY2VudHJvaWRYMiA9IGQzX2dlb19jZW50cm9pZFkyID0gZDNfZ2VvX2NlbnRyb2lkWjIgPSAwO1xuICAgICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIHByb2plY3RTdHJlYW0oZDNfZ2VvX3BhdGhDZW50cm9pZCkpO1xuICAgICAgcmV0dXJuIGQzX2dlb19jZW50cm9pZFoyID8gWyBkM19nZW9fY2VudHJvaWRYMiAvIGQzX2dlb19jZW50cm9pZFoyLCBkM19nZW9fY2VudHJvaWRZMiAvIGQzX2dlb19jZW50cm9pZFoyIF0gOiBkM19nZW9fY2VudHJvaWRaMSA/IFsgZDNfZ2VvX2NlbnRyb2lkWDEgLyBkM19nZW9fY2VudHJvaWRaMSwgZDNfZ2VvX2NlbnRyb2lkWTEgLyBkM19nZW9fY2VudHJvaWRaMSBdIDogZDNfZ2VvX2NlbnRyb2lkWjAgPyBbIGQzX2dlb19jZW50cm9pZFgwIC8gZDNfZ2VvX2NlbnRyb2lkWjAsIGQzX2dlb19jZW50cm9pZFkwIC8gZDNfZ2VvX2NlbnRyb2lkWjAgXSA6IFsgTmFOLCBOYU4gXTtcbiAgICB9O1xuICAgIHBhdGguYm91bmRzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBkM19nZW9fcGF0aEJvdW5kc1gxID0gZDNfZ2VvX3BhdGhCb3VuZHNZMSA9IC0oZDNfZ2VvX3BhdGhCb3VuZHNYMCA9IGQzX2dlb19wYXRoQm91bmRzWTAgPSBJbmZpbml0eSk7XG4gICAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgcHJvamVjdFN0cmVhbShkM19nZW9fcGF0aEJvdW5kcykpO1xuICAgICAgcmV0dXJuIFsgWyBkM19nZW9fcGF0aEJvdW5kc1gwLCBkM19nZW9fcGF0aEJvdW5kc1kwIF0sIFsgZDNfZ2VvX3BhdGhCb3VuZHNYMSwgZDNfZ2VvX3BhdGhCb3VuZHNZMSBdIF07XG4gICAgfTtcbiAgICBwYXRoLnByb2plY3Rpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcm9qZWN0aW9uO1xuICAgICAgcHJvamVjdFN0cmVhbSA9IChwcm9qZWN0aW9uID0gXykgPyBfLnN0cmVhbSB8fCBkM19nZW9fcGF0aFByb2plY3RTdHJlYW0oXykgOiBkM19pZGVudGl0eTtcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gICAgcGF0aC5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29udGV4dDtcbiAgICAgIGNvbnRleHRTdHJlYW0gPSAoY29udGV4dCA9IF8pID09IG51bGwgPyBuZXcgZDNfZ2VvX3BhdGhCdWZmZXIoKSA6IG5ldyBkM19nZW9fcGF0aENvbnRleHQoXyk7XG4gICAgICBpZiAodHlwZW9mIHBvaW50UmFkaXVzICE9PSBcImZ1bmN0aW9uXCIpIGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMocG9pbnRSYWRpdXMpO1xuICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgfTtcbiAgICBwYXRoLnBvaW50UmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcG9pbnRSYWRpdXM7XG4gICAgICBwb2ludFJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogKGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK18pLCArXyk7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnByb2plY3Rpb24oZDMuZ2VvLmFsYmVyc1VzYSgpKS5jb250ZXh0KG51bGwpO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fcGF0aFByb2plY3RTdHJlYW0ocHJvamVjdCkge1xuICAgIHZhciByZXNhbXBsZSA9IGQzX2dlb19yZXNhbXBsZShmdW5jdGlvbih4LCB5KSB7XG4gICAgICByZXR1cm4gcHJvamVjdChbIHggKiBkM19kZWdyZWVzLCB5ICogZDNfZGVncmVlcyBdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb25SYWRpYW5zKHJlc2FtcGxlKHN0cmVhbSkpO1xuICAgIH07XG4gIH1cbiAgZDMuZ2VvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKG1ldGhvZHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyZWFtOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IG5ldyBkM19nZW9fdHJhbnNmb3JtKHN0cmVhbSk7XG4gICAgICAgIGZvciAodmFyIGsgaW4gbWV0aG9kcykgdHJhbnNmb3JtW2tdID0gbWV0aG9kc1trXTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fdHJhbnNmb3JtKHN0cmVhbSkge1xuICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICB9XG4gIGQzX2dlb190cmFuc2Zvcm0ucHJvdG90eXBlID0ge1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLnN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICB9LFxuICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0cmVhbS5zcGhlcmUoKTtcbiAgICB9LFxuICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICB9LFxuICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHJlYW0ubGluZUVuZCgpO1xuICAgIH0sXG4gICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgIH0sXG4gICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fdHJhbnNmb3JtUG9pbnQoc3RyZWFtLCBwb2ludCkge1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0uc3BoZXJlKCk7XG4gICAgICB9LFxuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGQzLmdlby5wcm9qZWN0aW9uID0gZDNfZ2VvX3Byb2plY3Rpb247XG4gIGQzLmdlby5wcm9qZWN0aW9uTXV0YXRvciA9IGQzX2dlb19wcm9qZWN0aW9uTXV0YXRvcjtcbiAgZnVuY3Rpb24gZDNfZ2VvX3Byb2plY3Rpb24ocHJvamVjdCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbk11dGF0b3IoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcHJvamVjdDtcbiAgICB9KSgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wcm9qZWN0aW9uTXV0YXRvcihwcm9qZWN0QXQpIHtcbiAgICB2YXIgcHJvamVjdCwgcm90YXRlLCBwcm9qZWN0Um90YXRlLCBwcm9qZWN0UmVzYW1wbGUgPSBkM19nZW9fcmVzYW1wbGUoZnVuY3Rpb24oeCwgeSkge1xuICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICByZXR1cm4gWyB4WzBdICogayArIM60eCwgzrR5IC0geFsxXSAqIGsgXTtcbiAgICB9KSwgayA9IDE1MCwgeCA9IDQ4MCwgeSA9IDI1MCwgzrsgPSAwLCDPhiA9IDAsIM60zrsgPSAwLCDOtM+GID0gMCwgzrTOsyA9IDAsIM60eCwgzrR5LCBwcmVjbGlwID0gZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW4sIHBvc3RjbGlwID0gZDNfaWRlbnRpdHksIGNsaXBBbmdsZSA9IG51bGwsIGNsaXBFeHRlbnQgPSBudWxsLCBzdHJlYW07XG4gICAgZnVuY3Rpb24gcHJvamVjdGlvbihwb2ludCkge1xuICAgICAgcG9pbnQgPSBwcm9qZWN0Um90YXRlKHBvaW50WzBdICogZDNfcmFkaWFucywgcG9pbnRbMV0gKiBkM19yYWRpYW5zKTtcbiAgICAgIHJldHVybiBbIHBvaW50WzBdICogayArIM60eCwgzrR5IC0gcG9pbnRbMV0gKiBrIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludmVydChwb2ludCkge1xuICAgICAgcG9pbnQgPSBwcm9qZWN0Um90YXRlLmludmVydCgocG9pbnRbMF0gLSDOtHgpIC8gaywgKM60eSAtIHBvaW50WzFdKSAvIGspO1xuICAgICAgcmV0dXJuIHBvaW50ICYmIFsgcG9pbnRbMF0gKiBkM19kZWdyZWVzLCBwb2ludFsxXSAqIGQzX2RlZ3JlZXMgXTtcbiAgICB9XG4gICAgcHJvamVjdGlvbi5zdHJlYW0gPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgIGlmIChzdHJlYW0pIHN0cmVhbS52YWxpZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtID0gZDNfZ2VvX3Byb2plY3Rpb25SYWRpYW5zKHByZWNsaXAocm90YXRlLCBwcm9qZWN0UmVzYW1wbGUocG9zdGNsaXAob3V0cHV0KSkpKTtcbiAgICAgIHN0cmVhbS52YWxpZCA9IHRydWU7XG4gICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi5jbGlwQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGlwQW5nbGU7XG4gICAgICBwcmVjbGlwID0gXyA9PSBudWxsID8gKGNsaXBBbmdsZSA9IF8sIGQzX2dlb19jbGlwQW50aW1lcmlkaWFuKSA6IGQzX2dlb19jbGlwQ2lyY2xlKChjbGlwQW5nbGUgPSArXykgKiBkM19yYWRpYW5zKTtcbiAgICAgIHJldHVybiBpbnZhbGlkYXRlKCk7XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGlwRXh0ZW50O1xuICAgICAgY2xpcEV4dGVudCA9IF87XG4gICAgICBwb3N0Y2xpcCA9IF8gPyBkM19nZW9fY2xpcEV4dGVudChfWzBdWzBdLCBfWzBdWzFdLCBfWzFdWzBdLCBfWzFdWzFdKSA6IGQzX2lkZW50aXR5O1xuICAgICAgcmV0dXJuIGludmFsaWRhdGUoKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24uc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBrO1xuICAgICAgayA9ICtfO1xuICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgeCwgeSBdO1xuICAgICAgeCA9ICtfWzBdO1xuICAgICAgeSA9ICtfWzFdO1xuICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgzrsgKiBkM19kZWdyZWVzLCDPhiAqIGQzX2RlZ3JlZXMgXTtcbiAgICAgIM67ID0gX1swXSAlIDM2MCAqIGQzX3JhZGlhbnM7XG4gICAgICDPhiA9IF9bMV0gJSAzNjAgKiBkM19yYWRpYW5zO1xuICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLnJvdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgzrTOuyAqIGQzX2RlZ3JlZXMsIM60z4YgKiBkM19kZWdyZWVzLCDOtM6zICogZDNfZGVncmVlcyBdO1xuICAgICAgzrTOuyA9IF9bMF0gJSAzNjAgKiBkM19yYWRpYW5zO1xuICAgICAgzrTPhiA9IF9bMV0gJSAzNjAgKiBkM19yYWRpYW5zO1xuICAgICAgzrTOsyA9IF8ubGVuZ3RoID4gMiA/IF9bMl0gJSAzNjAgKiBkM19yYWRpYW5zIDogMDtcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gICAgZDMucmViaW5kKHByb2plY3Rpb24sIHByb2plY3RSZXNhbXBsZSwgXCJwcmVjaXNpb25cIik7XG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBwcm9qZWN0Um90YXRlID0gZDNfZ2VvX2NvbXBvc2Uocm90YXRlID0gZDNfZ2VvX3JvdGF0aW9uKM60zrssIM60z4YsIM60zrMpLCBwcm9qZWN0KTtcbiAgICAgIHZhciBjZW50ZXIgPSBwcm9qZWN0KM67LCDPhik7XG4gICAgICDOtHggPSB4IC0gY2VudGVyWzBdICogaztcbiAgICAgIM60eSA9IHkgKyBjZW50ZXJbMV0gKiBrO1xuICAgICAgcmV0dXJuIGludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICAgIGlmIChzdHJlYW0pIHN0cmVhbS52YWxpZCA9IGZhbHNlLCBzdHJlYW0gPSBudWxsO1xuICAgICAgcmV0dXJuIHByb2plY3Rpb247XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHByb2plY3QgPSBwcm9qZWN0QXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHByb2plY3Rpb24uaW52ZXJ0ID0gcHJvamVjdC5pbnZlcnQgJiYgaW52ZXJ0O1xuICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcHJvamVjdGlvblJhZGlhbnMoc3RyZWFtKSB7XG4gICAgcmV0dXJuIGQzX2dlb190cmFuc2Zvcm1Qb2ludChzdHJlYW0sIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHN0cmVhbS5wb2ludCh4ICogZDNfcmFkaWFucywgeSAqIGQzX3JhZGlhbnMpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19lcXVpcmVjdGFuZ3VsYXIozrssIM+GKSB7XG4gICAgcmV0dXJuIFsgzrssIM+GIF07XG4gIH1cbiAgKGQzLmdlby5lcXVpcmVjdGFuZ3VsYXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb24oZDNfZ2VvX2VxdWlyZWN0YW5ndWxhcik7XG4gIH0pLnJhdyA9IGQzX2dlb19lcXVpcmVjdGFuZ3VsYXIuaW52ZXJ0ID0gZDNfZ2VvX2VxdWlyZWN0YW5ndWxhcjtcbiAgZDMuZ2VvLnJvdGF0aW9uID0gZnVuY3Rpb24ocm90YXRlKSB7XG4gICAgcm90YXRlID0gZDNfZ2VvX3JvdGF0aW9uKHJvdGF0ZVswXSAlIDM2MCAqIGQzX3JhZGlhbnMsIHJvdGF0ZVsxXSAqIGQzX3JhZGlhbnMsIHJvdGF0ZS5sZW5ndGggPiAyID8gcm90YXRlWzJdICogZDNfcmFkaWFucyA6IDApO1xuICAgIGZ1bmN0aW9uIGZvcndhcmQoY29vcmRpbmF0ZXMpIHtcbiAgICAgIGNvb3JkaW5hdGVzID0gcm90YXRlKGNvb3JkaW5hdGVzWzBdICogZDNfcmFkaWFucywgY29vcmRpbmF0ZXNbMV0gKiBkM19yYWRpYW5zKTtcbiAgICAgIHJldHVybiBjb29yZGluYXRlc1swXSAqPSBkM19kZWdyZWVzLCBjb29yZGluYXRlc1sxXSAqPSBkM19kZWdyZWVzLCBjb29yZGluYXRlcztcbiAgICB9XG4gICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgICAgY29vcmRpbmF0ZXMgPSByb3RhdGUuaW52ZXJ0KGNvb3JkaW5hdGVzWzBdICogZDNfcmFkaWFucywgY29vcmRpbmF0ZXNbMV0gKiBkM19yYWRpYW5zKTtcbiAgICAgIHJldHVybiBjb29yZGluYXRlc1swXSAqPSBkM19kZWdyZWVzLCBjb29yZGluYXRlc1sxXSAqPSBkM19kZWdyZWVzLCBjb29yZGluYXRlcztcbiAgICB9O1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9faWRlbnRpdHlSb3RhdGlvbijOuywgz4YpIHtcbiAgICByZXR1cm4gWyDOuyA+IM+AID8gzrsgLSDPhCA6IM67IDwgLc+AID8gzrsgKyDPhCA6IM67LCDPhiBdO1xuICB9XG4gIGQzX2dlb19pZGVudGl0eVJvdGF0aW9uLmludmVydCA9IGQzX2dlb19lcXVpcmVjdGFuZ3VsYXI7XG4gIGZ1bmN0aW9uIGQzX2dlb19yb3RhdGlvbijOtM67LCDOtM+GLCDOtM6zKSB7XG4gICAgcmV0dXJuIM60zrsgPyDOtM+GIHx8IM60zrMgPyBkM19nZW9fY29tcG9zZShkM19nZW9fcm90YXRpb27OuyjOtM67KSwgZDNfZ2VvX3JvdGF0aW9uz4bOsyjOtM+GLCDOtM6zKSkgOiBkM19nZW9fcm90YXRpb27OuyjOtM67KSA6IM60z4YgfHwgzrTOsyA/IGQzX2dlb19yb3RhdGlvbs+GzrMozrTPhiwgzrTOsykgOiBkM19nZW9faWRlbnRpdHlSb3RhdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fZm9yd2FyZFJvdGF0aW9uzrsozrTOuykge1xuICAgIHJldHVybiBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIHJldHVybiDOuyArPSDOtM67LCBbIM67ID4gz4AgPyDOuyAtIM+EIDogzrsgPCAtz4AgPyDOuyArIM+EIDogzrssIM+GIF07XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcm90YXRpb27OuyjOtM67KSB7XG4gICAgdmFyIHJvdGF0aW9uID0gZDNfZ2VvX2ZvcndhcmRSb3RhdGlvbs67KM60zrspO1xuICAgIHJvdGF0aW9uLmludmVydCA9IGQzX2dlb19mb3J3YXJkUm90YXRpb27OuygtzrTOuyk7XG4gICAgcmV0dXJuIHJvdGF0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19yb3RhdGlvbs+GzrMozrTPhiwgzrTOsykge1xuICAgIHZhciBjb3POtM+GID0gTWF0aC5jb3MozrTPhiksIHNpbs60z4YgPSBNYXRoLnNpbijOtM+GKSwgY29zzrTOsyA9IE1hdGguY29zKM60zrMpLCBzaW7OtM6zID0gTWF0aC5zaW4ozrTOsyk7XG4gICAgZnVuY3Rpb24gcm90YXRpb24ozrssIM+GKSB7XG4gICAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiksIHggPSBNYXRoLmNvcyjOuykgKiBjb3PPhiwgeSA9IE1hdGguc2luKM67KSAqIGNvc8+GLCB6ID0gTWF0aC5zaW4oz4YpLCBrID0geiAqIGNvc860z4YgKyB4ICogc2luzrTPhjtcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeSAqIGNvc860zrMgLSBrICogc2luzrTOsywgeCAqIGNvc860z4YgLSB6ICogc2luzrTPhiksIGQzX2FzaW4oayAqIGNvc860zrMgKyB5ICogc2luzrTOsykgXTtcbiAgICB9XG4gICAgcm90YXRpb24uaW52ZXJ0ID0gZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiksIHggPSBNYXRoLmNvcyjOuykgKiBjb3PPhiwgeSA9IE1hdGguc2luKM67KSAqIGNvc8+GLCB6ID0gTWF0aC5zaW4oz4YpLCBrID0geiAqIGNvc860zrMgLSB5ICogc2luzrTOsztcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeSAqIGNvc860zrMgKyB6ICogc2luzrTOsywgeCAqIGNvc860z4YgKyBrICogc2luzrTPhiksIGQzX2FzaW4oayAqIGNvc860z4YgLSB4ICogc2luzrTPhikgXTtcbiAgICB9O1xuICAgIHJldHVybiByb3RhdGlvbjtcbiAgfVxuICBkMy5nZW8uY2lyY2xlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9yaWdpbiA9IFsgMCwgMCBdLCBhbmdsZSwgcHJlY2lzaW9uID0gNiwgaW50ZXJwb2xhdGU7XG4gICAgZnVuY3Rpb24gY2lyY2xlKCkge1xuICAgICAgdmFyIGNlbnRlciA9IHR5cGVvZiBvcmlnaW4gPT09IFwiZnVuY3Rpb25cIiA/IG9yaWdpbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogb3JpZ2luLCByb3RhdGUgPSBkM19nZW9fcm90YXRpb24oLWNlbnRlclswXSAqIGQzX3JhZGlhbnMsIC1jZW50ZXJbMV0gKiBkM19yYWRpYW5zLCAwKS5pbnZlcnQsIHJpbmcgPSBbXTtcbiAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHtcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICByaW5nLnB1c2goeCA9IHJvdGF0ZSh4LCB5KSk7XG4gICAgICAgICAgeFswXSAqPSBkM19kZWdyZWVzLCB4WzFdICo9IGQzX2RlZ3JlZXM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbIHJpbmcgXVxuICAgICAgfTtcbiAgICB9XG4gICAgY2lyY2xlLm9yaWdpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWdpbjtcbiAgICAgIG9yaWdpbiA9IHg7XG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH07XG4gICAgY2lyY2xlLmFuZ2xlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYW5nbGU7XG4gICAgICBpbnRlcnBvbGF0ZSA9IGQzX2dlb19jaXJjbGVJbnRlcnBvbGF0ZSgoYW5nbGUgPSAreCkgKiBkM19yYWRpYW5zLCBwcmVjaXNpb24gKiBkM19yYWRpYW5zKTtcbiAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgfTtcbiAgICBjaXJjbGUucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJlY2lzaW9uO1xuICAgICAgaW50ZXJwb2xhdGUgPSBkM19nZW9fY2lyY2xlSW50ZXJwb2xhdGUoYW5nbGUgKiBkM19yYWRpYW5zLCAocHJlY2lzaW9uID0gK18pICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH07XG4gICAgcmV0dXJuIGNpcmNsZS5hbmdsZSg5MCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19jaXJjbGVJbnRlcnBvbGF0ZShyYWRpdXMsIHByZWNpc2lvbikge1xuICAgIHZhciBjciA9IE1hdGguY29zKHJhZGl1cyksIHNyID0gTWF0aC5zaW4ocmFkaXVzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZnJvbSwgdG8sIGRpcmVjdGlvbiwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBzdGVwID0gZGlyZWN0aW9uICogcHJlY2lzaW9uO1xuICAgICAgaWYgKGZyb20gIT0gbnVsbCkge1xuICAgICAgICBmcm9tID0gZDNfZ2VvX2NpcmNsZUFuZ2xlKGNyLCBmcm9tKTtcbiAgICAgICAgdG8gPSBkM19nZW9fY2lyY2xlQW5nbGUoY3IsIHRvKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDAgPyBmcm9tIDwgdG8gOiBmcm9tID4gdG8pIGZyb20gKz0gZGlyZWN0aW9uICogz4Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tID0gcmFkaXVzICsgZGlyZWN0aW9uICogz4Q7XG4gICAgICAgIHRvID0gcmFkaXVzIC0gLjUgKiBzdGVwO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgcG9pbnQsIHQgPSBmcm9tOyBkaXJlY3Rpb24gPiAwID8gdCA+IHRvIDogdCA8IHRvOyB0IC09IHN0ZXApIHtcbiAgICAgICAgbGlzdGVuZXIucG9pbnQoKHBvaW50ID0gZDNfZ2VvX3NwaGVyaWNhbChbIGNyLCAtc3IgKiBNYXRoLmNvcyh0KSwgLXNyICogTWF0aC5zaW4odCkgXSkpWzBdLCBwb2ludFsxXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2lyY2xlQW5nbGUoY3IsIHBvaW50KSB7XG4gICAgdmFyIGEgPSBkM19nZW9fY2FydGVzaWFuKHBvaW50KTtcbiAgICBhWzBdIC09IGNyO1xuICAgIGQzX2dlb19jYXJ0ZXNpYW5Ob3JtYWxpemUoYSk7XG4gICAgdmFyIGFuZ2xlID0gZDNfYWNvcygtYVsxXSk7XG4gICAgcmV0dXJuICgoLWFbMl0gPCAwID8gLWFuZ2xlIDogYW5nbGUpICsgMiAqIE1hdGguUEkgLSDOtSkgJSAoMiAqIE1hdGguUEkpO1xuICB9XG4gIGQzLmdlby5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgzpTOuyA9IChiWzBdIC0gYVswXSkgKiBkM19yYWRpYW5zLCDPhjAgPSBhWzFdICogZDNfcmFkaWFucywgz4YxID0gYlsxXSAqIGQzX3JhZGlhbnMsIHNpbs6UzrsgPSBNYXRoLnNpbijOlM67KSwgY29zzpTOuyA9IE1hdGguY29zKM6UzrspLCBzaW7PhjAgPSBNYXRoLnNpbijPhjApLCBjb3PPhjAgPSBNYXRoLmNvcyjPhjApLCBzaW7PhjEgPSBNYXRoLnNpbijPhjEpLCBjb3PPhjEgPSBNYXRoLmNvcyjPhjEpLCB0O1xuICAgIHJldHVybiBNYXRoLmF0YW4yKE1hdGguc3FydCgodCA9IGNvc8+GMSAqIHNpbs6UzrspICogdCArICh0ID0gY29zz4YwICogc2luz4YxIC0gc2luz4YwICogY29zz4YxICogY29zzpTOuykgKiB0KSwgc2luz4YwICogc2luz4YxICsgY29zz4YwICogY29zz4YxICogY29zzpTOuyk7XG4gIH07XG4gIGQzLmdlby5ncmF0aWN1bGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgeDEsIHgwLCBYMSwgWDAsIHkxLCB5MCwgWTEsIFkwLCBkeCA9IDEwLCBkeSA9IGR4LCBEWCA9IDkwLCBEWSA9IDM2MCwgeCwgeSwgWCwgWSwgcHJlY2lzaW9uID0gMi41O1xuICAgIGZ1bmN0aW9uIGdyYXRpY3VsZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBsaW5lcygpXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lcygpIHtcbiAgICAgIHJldHVybiBkMy5yYW5nZShNYXRoLmNlaWwoWDAgLyBEWCkgKiBEWCwgWDEsIERYKS5tYXAoWCkuY29uY2F0KGQzLnJhbmdlKE1hdGguY2VpbChZMCAvIERZKSAqIERZLCBZMSwgRFkpLm1hcChZKSkuY29uY2F0KGQzLnJhbmdlKE1hdGguY2VpbCh4MCAvIGR4KSAqIGR4LCB4MSwgZHgpLmZpbHRlcihmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBhYnMoeCAlIERYKSA+IM61O1xuICAgICAgfSkubWFwKHgpKS5jb25jYXQoZDMucmFuZ2UoTWF0aC5jZWlsKHkwIC8gZHkpICogZHksIHkxLCBkeSkuZmlsdGVyKGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIGFicyh5ICUgRFkpID4gzrU7XG4gICAgICB9KS5tYXAoeSkpO1xuICAgIH1cbiAgICBncmF0aWN1bGUubGluZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBsaW5lcygpLm1hcChmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBncmF0aWN1bGUub3V0bGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbIFgoWDApLmNvbmNhdChZKFkxKS5zbGljZSgxKSwgWChYMSkucmV2ZXJzZSgpLnNsaWNlKDEpLCBZKFkwKS5yZXZlcnNlKCkuc2xpY2UoMSkpIF1cbiAgICAgIH07XG4gICAgfTtcbiAgICBncmF0aWN1bGUuZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JhdGljdWxlLm1pbm9yRXh0ZW50KCk7XG4gICAgICByZXR1cm4gZ3JhdGljdWxlLm1ham9yRXh0ZW50KF8pLm1pbm9yRXh0ZW50KF8pO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLm1ham9yRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyBbIFgwLCBZMCBdLCBbIFgxLCBZMSBdIF07XG4gICAgICBYMCA9ICtfWzBdWzBdLCBYMSA9ICtfWzFdWzBdO1xuICAgICAgWTAgPSArX1swXVsxXSwgWTEgPSArX1sxXVsxXTtcbiAgICAgIGlmIChYMCA+IFgxKSBfID0gWDAsIFgwID0gWDEsIFgxID0gXztcbiAgICAgIGlmIChZMCA+IFkxKSBfID0gWTAsIFkwID0gWTEsIFkxID0gXztcbiAgICAgIHJldHVybiBncmF0aWN1bGUucHJlY2lzaW9uKHByZWNpc2lvbik7XG4gICAgfTtcbiAgICBncmF0aWN1bGUubWlub3JFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIFsgeDAsIHkwIF0sIFsgeDEsIHkxIF0gXTtcbiAgICAgIHgwID0gK19bMF1bMF0sIHgxID0gK19bMV1bMF07XG4gICAgICB5MCA9ICtfWzBdWzFdLCB5MSA9ICtfWzFdWzFdO1xuICAgICAgaWYgKHgwID4geDEpIF8gPSB4MCwgeDAgPSB4MSwgeDEgPSBfO1xuICAgICAgaWYgKHkwID4geTEpIF8gPSB5MCwgeTAgPSB5MSwgeTEgPSBfO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZS5wcmVjaXNpb24ocHJlY2lzaW9uKTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5zdGVwID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JhdGljdWxlLm1pbm9yU3RlcCgpO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZS5tYWpvclN0ZXAoXykubWlub3JTdGVwKF8pO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLm1ham9yU3RlcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgRFgsIERZIF07XG4gICAgICBEWCA9ICtfWzBdLCBEWSA9ICtfWzFdO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5taW5vclN0ZXAgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIGR4LCBkeSBdO1xuICAgICAgZHggPSArX1swXSwgZHkgPSArX1sxXTtcbiAgICAgIHJldHVybiBncmF0aWN1bGU7XG4gICAgfTtcbiAgICBncmF0aWN1bGUucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJlY2lzaW9uO1xuICAgICAgcHJlY2lzaW9uID0gK187XG4gICAgICB4ID0gZDNfZ2VvX2dyYXRpY3VsZVgoeTAsIHkxLCA5MCk7XG4gICAgICB5ID0gZDNfZ2VvX2dyYXRpY3VsZVkoeDAsIHgxLCBwcmVjaXNpb24pO1xuICAgICAgWCA9IGQzX2dlb19ncmF0aWN1bGVYKFkwLCBZMSwgOTApO1xuICAgICAgWSA9IGQzX2dlb19ncmF0aWN1bGVZKFgwLCBYMSwgcHJlY2lzaW9uKTtcbiAgICAgIHJldHVybiBncmF0aWN1bGU7XG4gICAgfTtcbiAgICByZXR1cm4gZ3JhdGljdWxlLm1ham9yRXh0ZW50KFsgWyAtMTgwLCAtOTAgKyDOtSBdLCBbIDE4MCwgOTAgLSDOtSBdIF0pLm1pbm9yRXh0ZW50KFsgWyAtMTgwLCAtODAgLSDOtSBdLCBbIDE4MCwgODAgKyDOtSBdIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fZ3JhdGljdWxlWCh5MCwgeTEsIGR5KSB7XG4gICAgdmFyIHkgPSBkMy5yYW5nZSh5MCwgeTEgLSDOtSwgZHkpLmNvbmNhdCh5MSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB5Lm1hcChmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiBbIHgsIHkgXTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2dyYXRpY3VsZVkoeDAsIHgxLCBkeCkge1xuICAgIHZhciB4ID0gZDMucmFuZ2UoeDAsIHgxIC0gzrUsIGR4KS5jb25jYXQoeDEpO1xuICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4geC5tYXAoZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gWyB4LCB5IF07XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NvdXJjZShkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RhcmdldChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9XG4gIGQzLmdlby5ncmVhdEFyYyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzb3VyY2UgPSBkM19zb3VyY2UsIHNvdXJjZV8sIHRhcmdldCA9IGQzX3RhcmdldCwgdGFyZ2V0XztcbiAgICBmdW5jdGlvbiBncmVhdEFyYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgICBjb29yZGluYXRlczogWyBzb3VyY2VfIHx8IHNvdXJjZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0YXJnZXRfIHx8IHRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIF1cbiAgICAgIH07XG4gICAgfVxuICAgIGdyZWF0QXJjLmRpc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDMuZ2VvLmRpc3RhbmNlKHNvdXJjZV8gfHwgc291cmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRhcmdldF8gfHwgdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgZ3JlYXRBcmMuc291cmNlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc291cmNlO1xuICAgICAgc291cmNlID0gXywgc291cmNlXyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBudWxsIDogXztcbiAgICAgIHJldHVybiBncmVhdEFyYztcbiAgICB9O1xuICAgIGdyZWF0QXJjLnRhcmdldCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRhcmdldDtcbiAgICAgIHRhcmdldCA9IF8sIHRhcmdldF8gPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IF87XG4gICAgICByZXR1cm4gZ3JlYXRBcmM7XG4gICAgfTtcbiAgICBncmVhdEFyYy5wcmVjaXNpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gZ3JlYXRBcmMgOiAwO1xuICAgIH07XG4gICAgcmV0dXJuIGdyZWF0QXJjO1xuICB9O1xuICBkMy5nZW8uaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihzb3VyY2UsIHRhcmdldCkge1xuICAgIHJldHVybiBkM19nZW9faW50ZXJwb2xhdGUoc291cmNlWzBdICogZDNfcmFkaWFucywgc291cmNlWzFdICogZDNfcmFkaWFucywgdGFyZ2V0WzBdICogZDNfcmFkaWFucywgdGFyZ2V0WzFdICogZDNfcmFkaWFucyk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19pbnRlcnBvbGF0ZSh4MCwgeTAsIHgxLCB5MSkge1xuICAgIHZhciBjeTAgPSBNYXRoLmNvcyh5MCksIHN5MCA9IE1hdGguc2luKHkwKSwgY3kxID0gTWF0aC5jb3MoeTEpLCBzeTEgPSBNYXRoLnNpbih5MSksIGt4MCA9IGN5MCAqIE1hdGguY29zKHgwKSwga3kwID0gY3kwICogTWF0aC5zaW4oeDApLCBreDEgPSBjeTEgKiBNYXRoLmNvcyh4MSksIGt5MSA9IGN5MSAqIE1hdGguc2luKHgxKSwgZCA9IDIgKiBNYXRoLmFzaW4oTWF0aC5zcXJ0KGQzX2hhdmVyc2luKHkxIC0geTApICsgY3kwICogY3kxICogZDNfaGF2ZXJzaW4oeDEgLSB4MCkpKSwgayA9IDEgLyBNYXRoLnNpbihkKTtcbiAgICB2YXIgaW50ZXJwb2xhdGUgPSBkID8gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIEIgPSBNYXRoLnNpbih0ICo9IGQpICogaywgQSA9IE1hdGguc2luKGQgLSB0KSAqIGssIHggPSBBICoga3gwICsgQiAqIGt4MSwgeSA9IEEgKiBreTAgKyBCICoga3kxLCB6ID0gQSAqIHN5MCArIEIgKiBzeTE7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHksIHgpICogZDNfZGVncmVlcywgTWF0aC5hdGFuMih6LCBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSkpICogZDNfZGVncmVlcyBdO1xuICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbIHgwICogZDNfZGVncmVlcywgeTAgKiBkM19kZWdyZWVzIF07XG4gICAgfTtcbiAgICBpbnRlcnBvbGF0ZS5kaXN0YW5jZSA9IGQ7XG4gICAgcmV0dXJuIGludGVycG9sYXRlO1xuICB9XG4gIGQzLmdlby5sZW5ndGggPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBkM19nZW9fbGVuZ3RoU3VtID0gMDtcbiAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgZDNfZ2VvX2xlbmd0aCk7XG4gICAgcmV0dXJuIGQzX2dlb19sZW5ndGhTdW07XG4gIH07XG4gIHZhciBkM19nZW9fbGVuZ3RoU3VtO1xuICB2YXIgZDNfZ2VvX2xlbmd0aCA9IHtcbiAgICBzcGhlcmU6IGQzX25vb3AsXG4gICAgcG9pbnQ6IGQzX25vb3AsXG4gICAgbGluZVN0YXJ0OiBkM19nZW9fbGVuZ3RoTGluZVN0YXJ0LFxuICAgIGxpbmVFbmQ6IGQzX25vb3AsXG4gICAgcG9seWdvblN0YXJ0OiBkM19ub29wLFxuICAgIHBvbHlnb25FbmQ6IGQzX25vb3BcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2xlbmd0aExpbmVTdGFydCgpIHtcbiAgICB2YXIgzrswLCBzaW7PhjAsIGNvc8+GMDtcbiAgICBkM19nZW9fbGVuZ3RoLnBvaW50ID0gZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICDOuzAgPSDOuyAqIGQzX3JhZGlhbnMsIHNpbs+GMCA9IE1hdGguc2luKM+GICo9IGQzX3JhZGlhbnMpLCBjb3PPhjAgPSBNYXRoLmNvcyjPhik7XG4gICAgICBkM19nZW9fbGVuZ3RoLnBvaW50ID0gbmV4dFBvaW50O1xuICAgIH07XG4gICAgZDNfZ2VvX2xlbmd0aC5saW5lRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fbGVuZ3RoLnBvaW50ID0gZDNfZ2VvX2xlbmd0aC5saW5lRW5kID0gZDNfbm9vcDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCjOuywgz4YpIHtcbiAgICAgIHZhciBzaW7PhiA9IE1hdGguc2luKM+GICo9IGQzX3JhZGlhbnMpLCBjb3PPhiA9IE1hdGguY29zKM+GKSwgdCA9IGFicygozrsgKj0gZDNfcmFkaWFucykgLSDOuzApLCBjb3POlM67ID0gTWF0aC5jb3ModCk7XG4gICAgICBkM19nZW9fbGVuZ3RoU3VtICs9IE1hdGguYXRhbjIoTWF0aC5zcXJ0KCh0ID0gY29zz4YgKiBNYXRoLnNpbih0KSkgKiB0ICsgKHQgPSBjb3PPhjAgKiBzaW7PhiAtIHNpbs+GMCAqIGNvc8+GICogY29zzpTOuykgKiB0KSwgc2luz4YwICogc2luz4YgKyBjb3PPhjAgKiBjb3PPhiAqIGNvc86UzrspO1xuICAgICAgzrswID0gzrssIHNpbs+GMCA9IHNpbs+GLCBjb3PPhjAgPSBjb3PPhjtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2F6aW11dGhhbChzY2FsZSwgYW5nbGUpIHtcbiAgICBmdW5jdGlvbiBhemltdXRoYWwozrssIM+GKSB7XG4gICAgICB2YXIgY29zzrsgPSBNYXRoLmNvcyjOuyksIGNvc8+GID0gTWF0aC5jb3Moz4YpLCBrID0gc2NhbGUoY29zzrsgKiBjb3PPhik7XG4gICAgICByZXR1cm4gWyBrICogY29zz4YgKiBNYXRoLnNpbijOuyksIGsgKiBNYXRoLnNpbijPhikgXTtcbiAgICB9XG4gICAgYXppbXV0aGFsLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciDPgSA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KSwgYyA9IGFuZ2xlKM+BKSwgc2luYyA9IE1hdGguc2luKGMpLCBjb3NjID0gTWF0aC5jb3MoYyk7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHggKiBzaW5jLCDPgSAqIGNvc2MpLCBNYXRoLmFzaW4oz4EgJiYgeSAqIHNpbmMgLyDPgSkgXTtcbiAgICB9O1xuICAgIHJldHVybiBhemltdXRoYWw7XG4gIH1cbiAgdmFyIGQzX2dlb19hemltdXRoYWxFcXVhbEFyZWEgPSBkM19nZW9fYXppbXV0aGFsKGZ1bmN0aW9uKGNvc867Y29zz4YpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDIgLyAoMSArIGNvc867Y29zz4YpKTtcbiAgfSwgZnVuY3Rpb24oz4EpIHtcbiAgICByZXR1cm4gMiAqIE1hdGguYXNpbijPgSAvIDIpO1xuICB9KTtcbiAgKGQzLmdlby5hemltdXRoYWxFcXVhbEFyZWEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb24oZDNfZ2VvX2F6aW11dGhhbEVxdWFsQXJlYSk7XG4gIH0pLnJhdyA9IGQzX2dlb19hemltdXRoYWxFcXVhbEFyZWE7XG4gIHZhciBkM19nZW9fYXppbXV0aGFsRXF1aWRpc3RhbnQgPSBkM19nZW9fYXppbXV0aGFsKGZ1bmN0aW9uKGNvc867Y29zz4YpIHtcbiAgICB2YXIgYyA9IE1hdGguYWNvcyhjb3POu2Nvc8+GKTtcbiAgICByZXR1cm4gYyAmJiBjIC8gTWF0aC5zaW4oYyk7XG4gIH0sIGQzX2lkZW50aXR5KTtcbiAgKGQzLmdlby5hemltdXRoYWxFcXVpZGlzdGFudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbihkM19nZW9fYXppbXV0aGFsRXF1aWRpc3RhbnQpO1xuICB9KS5yYXcgPSBkM19nZW9fYXppbXV0aGFsRXF1aWRpc3RhbnQ7XG4gIGZ1bmN0aW9uIGQzX2dlb19jb25pY0NvbmZvcm1hbCjPhjAsIM+GMSkge1xuICAgIHZhciBjb3PPhjAgPSBNYXRoLmNvcyjPhjApLCB0ID0gZnVuY3Rpb24oz4YpIHtcbiAgICAgIHJldHVybiBNYXRoLnRhbijPgCAvIDQgKyDPhiAvIDIpO1xuICAgIH0sIG4gPSDPhjAgPT09IM+GMSA/IE1hdGguc2luKM+GMCkgOiBNYXRoLmxvZyhjb3PPhjAgLyBNYXRoLmNvcyjPhjEpKSAvIE1hdGgubG9nKHQoz4YxKSAvIHQoz4YwKSksIEYgPSBjb3PPhjAgKiBNYXRoLnBvdyh0KM+GMCksIG4pIC8gbjtcbiAgICBpZiAoIW4pIHJldHVybiBkM19nZW9fbWVyY2F0b3I7XG4gICAgZnVuY3Rpb24gZm9yd2FyZCjOuywgz4YpIHtcbiAgICAgIGlmIChGID4gMCkge1xuICAgICAgICBpZiAoz4YgPCAtaGFsZs+AICsgzrUpIM+GID0gLWhhbGbPgCArIM61O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKM+GID4gaGFsZs+AIC0gzrUpIM+GID0gaGFsZs+AIC0gzrU7XG4gICAgICB9XG4gICAgICB2YXIgz4EgPSBGIC8gTWF0aC5wb3codCjPhiksIG4pO1xuICAgICAgcmV0dXJuIFsgz4EgKiBNYXRoLnNpbihuICogzrspLCBGIC0gz4EgKiBNYXRoLmNvcyhuICogzrspIF07XG4gICAgfVxuICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIM+BMF95ID0gRiAtIHksIM+BID0gZDNfc2duKG4pICogTWF0aC5zcXJ0KHggKiB4ICsgz4EwX3kgKiDPgTBfeSk7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHgsIM+BMF95KSAvIG4sIDIgKiBNYXRoLmF0YW4oTWF0aC5wb3coRiAvIM+BLCAxIC8gbikpIC0gaGFsZs+AIF07XG4gICAgfTtcbiAgICByZXR1cm4gZm9yd2FyZDtcbiAgfVxuICAoZDMuZ2VvLmNvbmljQ29uZm9ybWFsID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19jb25pYyhkM19nZW9fY29uaWNDb25mb3JtYWwpO1xuICB9KS5yYXcgPSBkM19nZW9fY29uaWNDb25mb3JtYWw7XG4gIGZ1bmN0aW9uIGQzX2dlb19jb25pY0VxdWlkaXN0YW50KM+GMCwgz4YxKSB7XG4gICAgdmFyIGNvc8+GMCA9IE1hdGguY29zKM+GMCksIG4gPSDPhjAgPT09IM+GMSA/IE1hdGguc2luKM+GMCkgOiAoY29zz4YwIC0gTWF0aC5jb3Moz4YxKSkgLyAoz4YxIC0gz4YwKSwgRyA9IGNvc8+GMCAvIG4gKyDPhjA7XG4gICAgaWYgKGFicyhuKSA8IM61KSByZXR1cm4gZDNfZ2VvX2VxdWlyZWN0YW5ndWxhcjtcbiAgICBmdW5jdGlvbiBmb3J3YXJkKM67LCDPhikge1xuICAgICAgdmFyIM+BID0gRyAtIM+GO1xuICAgICAgcmV0dXJuIFsgz4EgKiBNYXRoLnNpbihuICogzrspLCBHIC0gz4EgKiBNYXRoLmNvcyhuICogzrspIF07XG4gICAgfVxuICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIM+BMF95ID0gRyAtIHk7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHgsIM+BMF95KSAvIG4sIEcgLSBkM19zZ24obikgKiBNYXRoLnNxcnQoeCAqIHggKyDPgTBfeSAqIM+BMF95KSBdO1xuICAgIH07XG4gICAgcmV0dXJuIGZvcndhcmQ7XG4gIH1cbiAgKGQzLmdlby5jb25pY0VxdWlkaXN0YW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19jb25pYyhkM19nZW9fY29uaWNFcXVpZGlzdGFudCk7XG4gIH0pLnJhdyA9IGQzX2dlb19jb25pY0VxdWlkaXN0YW50O1xuICB2YXIgZDNfZ2VvX2dub21vbmljID0gZDNfZ2VvX2F6aW11dGhhbChmdW5jdGlvbihjb3POu2Nvc8+GKSB7XG4gICAgcmV0dXJuIDEgLyBjb3POu2Nvc8+GO1xuICB9LCBNYXRoLmF0YW4pO1xuICAoZDMuZ2VvLmdub21vbmljID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19nbm9tb25pYyk7XG4gIH0pLnJhdyA9IGQzX2dlb19nbm9tb25pYztcbiAgZnVuY3Rpb24gZDNfZ2VvX21lcmNhdG9yKM67LCDPhikge1xuICAgIHJldHVybiBbIM67LCBNYXRoLmxvZyhNYXRoLnRhbijPgCAvIDQgKyDPhiAvIDIpKSBdO1xuICB9XG4gIGQzX2dlb19tZXJjYXRvci5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIFsgeCwgMiAqIE1hdGguYXRhbihNYXRoLmV4cCh5KSkgLSBoYWxmz4AgXTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX21lcmNhdG9yUHJvamVjdGlvbihwcm9qZWN0KSB7XG4gICAgdmFyIG0gPSBkM19nZW9fcHJvamVjdGlvbihwcm9qZWN0KSwgc2NhbGUgPSBtLnNjYWxlLCB0cmFuc2xhdGUgPSBtLnRyYW5zbGF0ZSwgY2xpcEV4dGVudCA9IG0uY2xpcEV4dGVudCwgY2xpcEF1dG87XG4gICAgbS5zY2FsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSBzY2FsZS5hcHBseShtLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHYgPT09IG0gPyBjbGlwQXV0byA/IG0uY2xpcEV4dGVudChudWxsKSA6IG0gOiB2O1xuICAgIH07XG4gICAgbS50cmFuc2xhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdHJhbnNsYXRlLmFwcGx5KG0sIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdiA9PT0gbSA/IGNsaXBBdXRvID8gbS5jbGlwRXh0ZW50KG51bGwpIDogbSA6IHY7XG4gICAgfTtcbiAgICBtLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICB2YXIgdiA9IGNsaXBFeHRlbnQuYXBwbHkobSwgYXJndW1lbnRzKTtcbiAgICAgIGlmICh2ID09PSBtKSB7XG4gICAgICAgIGlmIChjbGlwQXV0byA9IF8gPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBrID0gz4AgKiBzY2FsZSgpLCB0ID0gdHJhbnNsYXRlKCk7XG4gICAgICAgICAgY2xpcEV4dGVudChbIFsgdFswXSAtIGssIHRbMV0gLSBrIF0sIFsgdFswXSArIGssIHRbMV0gKyBrIF0gXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2xpcEF1dG8pIHtcbiAgICAgICAgdiA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9O1xuICAgIHJldHVybiBtLmNsaXBFeHRlbnQobnVsbCk7XG4gIH1cbiAgKGQzLmdlby5tZXJjYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fbWVyY2F0b3JQcm9qZWN0aW9uKGQzX2dlb19tZXJjYXRvcik7XG4gIH0pLnJhdyA9IGQzX2dlb19tZXJjYXRvcjtcbiAgdmFyIGQzX2dlb19vcnRob2dyYXBoaWMgPSBkM19nZW9fYXppbXV0aGFsKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAxO1xuICB9LCBNYXRoLmFzaW4pO1xuICAoZDMuZ2VvLm9ydGhvZ3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbihkM19nZW9fb3J0aG9ncmFwaGljKTtcbiAgfSkucmF3ID0gZDNfZ2VvX29ydGhvZ3JhcGhpYztcbiAgdmFyIGQzX2dlb19zdGVyZW9ncmFwaGljID0gZDNfZ2VvX2F6aW11dGhhbChmdW5jdGlvbihjb3POu2Nvc8+GKSB7XG4gICAgcmV0dXJuIDEgLyAoMSArIGNvc867Y29zz4YpO1xuICB9LCBmdW5jdGlvbijPgSkge1xuICAgIHJldHVybiAyICogTWF0aC5hdGFuKM+BKTtcbiAgfSk7XG4gIChkMy5nZW8uc3RlcmVvZ3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbihkM19nZW9fc3RlcmVvZ3JhcGhpYyk7XG4gIH0pLnJhdyA9IGQzX2dlb19zdGVyZW9ncmFwaGljO1xuICBmdW5jdGlvbiBkM19nZW9fdHJhbnN2ZXJzZU1lcmNhdG9yKM67LCDPhikge1xuICAgIHJldHVybiBbIE1hdGgubG9nKE1hdGgudGFuKM+AIC8gNCArIM+GIC8gMikpLCAtzrsgXTtcbiAgfVxuICBkM19nZW9fdHJhbnN2ZXJzZU1lcmNhdG9yLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gWyAteSwgMiAqIE1hdGguYXRhbihNYXRoLmV4cCh4KSkgLSBoYWxmz4AgXTtcbiAgfTtcbiAgKGQzLmdlby50cmFuc3ZlcnNlTWVyY2F0b3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcHJvamVjdGlvbiA9IGQzX2dlb19tZXJjYXRvclByb2plY3Rpb24oZDNfZ2VvX3RyYW5zdmVyc2VNZXJjYXRvciksIGNlbnRlciA9IHByb2plY3Rpb24uY2VudGVyLCByb3RhdGUgPSBwcm9qZWN0aW9uLnJvdGF0ZTtcbiAgICBwcm9qZWN0aW9uLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBfID8gY2VudGVyKFsgLV9bMV0sIF9bMF0gXSkgOiAoXyA9IGNlbnRlcigpLCBbIF9bMV0sIC1fWzBdIF0pO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi5yb3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gXyA/IHJvdGF0ZShbIF9bMF0sIF9bMV0sIF8ubGVuZ3RoID4gMiA/IF9bMl0gKyA5MCA6IDkwIF0pIDogKF8gPSByb3RhdGUoKSwgXG4gICAgICBbIF9bMF0sIF9bMV0sIF9bMl0gLSA5MCBdKTtcbiAgICB9O1xuICAgIHJldHVybiByb3RhdGUoWyAwLCAwLCA5MCBdKTtcbiAgfSkucmF3ID0gZDNfZ2VvX3RyYW5zdmVyc2VNZXJjYXRvcjtcbiAgZDMuZ2VvbSA9IHt9O1xuICBmdW5jdGlvbiBkM19nZW9tX3BvaW50WChkKSB7XG4gICAgcmV0dXJuIGRbMF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9wb2ludFkoZCkge1xuICAgIHJldHVybiBkWzFdO1xuICB9XG4gIGQzLmdlb20uaHVsbCA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgdmFyIHggPSBkM19nZW9tX3BvaW50WCwgeSA9IGQzX2dlb21fcG9pbnRZO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaHVsbCh2ZXJ0aWNlcyk7XG4gICAgZnVuY3Rpb24gaHVsbChkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggPCAzKSByZXR1cm4gW107XG4gICAgICB2YXIgZnggPSBkM19mdW5jdG9yKHgpLCBmeSA9IGQzX2Z1bmN0b3IoeSksIGksIG4gPSBkYXRhLmxlbmd0aCwgcG9pbnRzID0gW10sIGZsaXBwZWRQb2ludHMgPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgcG9pbnRzLnB1c2goWyArZnguY2FsbCh0aGlzLCBkYXRhW2ldLCBpKSwgK2Z5LmNhbGwodGhpcywgZGF0YVtpXSwgaSksIGkgXSk7XG4gICAgICB9XG4gICAgICBwb2ludHMuc29ydChkM19nZW9tX2h1bGxPcmRlcik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBmbGlwcGVkUG9pbnRzLnB1c2goWyBwb2ludHNbaV1bMF0sIC1wb2ludHNbaV1bMV0gXSk7XG4gICAgICB2YXIgdXBwZXIgPSBkM19nZW9tX2h1bGxVcHBlcihwb2ludHMpLCBsb3dlciA9IGQzX2dlb21faHVsbFVwcGVyKGZsaXBwZWRQb2ludHMpO1xuICAgICAgdmFyIHNraXBMZWZ0ID0gbG93ZXJbMF0gPT09IHVwcGVyWzBdLCBza2lwUmlnaHQgPSBsb3dlcltsb3dlci5sZW5ndGggLSAxXSA9PT0gdXBwZXJbdXBwZXIubGVuZ3RoIC0gMV0sIHBvbHlnb24gPSBbXTtcbiAgICAgIGZvciAoaSA9IHVwcGVyLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSBwb2x5Z29uLnB1c2goZGF0YVtwb2ludHNbdXBwZXJbaV1dWzJdXSk7XG4gICAgICBmb3IgKGkgPSArc2tpcExlZnQ7IGkgPCBsb3dlci5sZW5ndGggLSBza2lwUmlnaHQ7ICsraSkgcG9seWdvbi5wdXNoKGRhdGFbcG9pbnRzW2xvd2VyW2ldXVsyXV0pO1xuICAgICAgcmV0dXJuIHBvbHlnb247XG4gICAgfVxuICAgIGh1bGwueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSBfLCBodWxsKSA6IHg7XG4gICAgfTtcbiAgICBodWxsLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gXywgaHVsbCkgOiB5O1xuICAgIH07XG4gICAgcmV0dXJuIGh1bGw7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb21faHVsbFVwcGVyKHBvaW50cykge1xuICAgIHZhciBuID0gcG9pbnRzLmxlbmd0aCwgaHVsbCA9IFsgMCwgMSBdLCBocyA9IDI7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBuOyBpKyspIHtcbiAgICAgIHdoaWxlIChocyA+IDEgJiYgZDNfY3Jvc3MyZChwb2ludHNbaHVsbFtocyAtIDJdXSwgcG9pbnRzW2h1bGxbaHMgLSAxXV0sIHBvaW50c1tpXSkgPD0gMCkgLS1ocztcbiAgICAgIGh1bGxbaHMrK10gPSBpO1xuICAgIH1cbiAgICByZXR1cm4gaHVsbC5zbGljZSgwLCBocyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9odWxsT3JkZXIoYSwgYikge1xuICAgIHJldHVybiBhWzBdIC0gYlswXSB8fCBhWzFdIC0gYlsxXTtcbiAgfVxuICBkMy5nZW9tLnBvbHlnb24gPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgIGQzX3N1YmNsYXNzKGNvb3JkaW5hdGVzLCBkM19nZW9tX3BvbHlnb25Qcm90b3R5cGUpO1xuICAgIHJldHVybiBjb29yZGluYXRlcztcbiAgfTtcbiAgdmFyIGQzX2dlb21fcG9seWdvblByb3RvdHlwZSA9IGQzLmdlb20ucG9seWdvbi5wcm90b3R5cGUgPSBbXTtcbiAgZDNfZ2VvbV9wb2x5Z29uUHJvdG90eXBlLmFyZWEgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gdGhpcy5sZW5ndGgsIGEsIGIgPSB0aGlzW24gLSAxXSwgYXJlYSA9IDA7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGEgPSBiO1xuICAgICAgYiA9IHRoaXNbaV07XG4gICAgICBhcmVhICs9IGFbMV0gKiBiWzBdIC0gYVswXSAqIGJbMV07XG4gICAgfVxuICAgIHJldHVybiBhcmVhICogLjU7XG4gIH07XG4gIGQzX2dlb21fcG9seWdvblByb3RvdHlwZS5jZW50cm9pZCA9IGZ1bmN0aW9uKGspIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gdGhpcy5sZW5ndGgsIHggPSAwLCB5ID0gMCwgYSwgYiA9IHRoaXNbbiAtIDFdLCBjO1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgayA9IC0xIC8gKDYgKiB0aGlzLmFyZWEoKSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGEgPSBiO1xuICAgICAgYiA9IHRoaXNbaV07XG4gICAgICBjID0gYVswXSAqIGJbMV0gLSBiWzBdICogYVsxXTtcbiAgICAgIHggKz0gKGFbMF0gKyBiWzBdKSAqIGM7XG4gICAgICB5ICs9IChhWzFdICsgYlsxXSkgKiBjO1xuICAgIH1cbiAgICByZXR1cm4gWyB4ICogaywgeSAqIGsgXTtcbiAgfTtcbiAgZDNfZ2VvbV9wb2x5Z29uUHJvdG90eXBlLmNsaXAgPSBmdW5jdGlvbihzdWJqZWN0KSB7XG4gICAgdmFyIGlucHV0LCBjbG9zZWQgPSBkM19nZW9tX3BvbHlnb25DbG9zZWQoc3ViamVjdCksIGkgPSAtMSwgbiA9IHRoaXMubGVuZ3RoIC0gZDNfZ2VvbV9wb2x5Z29uQ2xvc2VkKHRoaXMpLCBqLCBtLCBhID0gdGhpc1tuIC0gMV0sIGIsIGMsIGQ7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlucHV0ID0gc3ViamVjdC5zbGljZSgpO1xuICAgICAgc3ViamVjdC5sZW5ndGggPSAwO1xuICAgICAgYiA9IHRoaXNbaV07XG4gICAgICBjID0gaW5wdXRbKG0gPSBpbnB1dC5sZW5ndGggLSBjbG9zZWQpIC0gMV07XG4gICAgICBqID0gLTE7XG4gICAgICB3aGlsZSAoKytqIDwgbSkge1xuICAgICAgICBkID0gaW5wdXRbal07XG4gICAgICAgIGlmIChkM19nZW9tX3BvbHlnb25JbnNpZGUoZCwgYSwgYikpIHtcbiAgICAgICAgICBpZiAoIWQzX2dlb21fcG9seWdvbkluc2lkZShjLCBhLCBiKSkge1xuICAgICAgICAgICAgc3ViamVjdC5wdXNoKGQzX2dlb21fcG9seWdvbkludGVyc2VjdChjLCBkLCBhLCBiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1YmplY3QucHVzaChkKTtcbiAgICAgICAgfSBlbHNlIGlmIChkM19nZW9tX3BvbHlnb25JbnNpZGUoYywgYSwgYikpIHtcbiAgICAgICAgICBzdWJqZWN0LnB1c2goZDNfZ2VvbV9wb2x5Z29uSW50ZXJzZWN0KGMsIGQsIGEsIGIpKTtcbiAgICAgICAgfVxuICAgICAgICBjID0gZDtcbiAgICAgIH1cbiAgICAgIGlmIChjbG9zZWQpIHN1YmplY3QucHVzaChzdWJqZWN0WzBdKTtcbiAgICAgIGEgPSBiO1xuICAgIH1cbiAgICByZXR1cm4gc3ViamVjdDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV9wb2x5Z29uSW5zaWRlKHAsIGEsIGIpIHtcbiAgICByZXR1cm4gKGJbMF0gLSBhWzBdKSAqIChwWzFdIC0gYVsxXSkgPCAoYlsxXSAtIGFbMV0pICogKHBbMF0gLSBhWzBdKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3BvbHlnb25JbnRlcnNlY3QoYywgZCwgYSwgYikge1xuICAgIHZhciB4MSA9IGNbMF0sIHgzID0gYVswXSwgeDIxID0gZFswXSAtIHgxLCB4NDMgPSBiWzBdIC0geDMsIHkxID0gY1sxXSwgeTMgPSBhWzFdLCB5MjEgPSBkWzFdIC0geTEsIHk0MyA9IGJbMV0gLSB5MywgdWEgPSAoeDQzICogKHkxIC0geTMpIC0geTQzICogKHgxIC0geDMpKSAvICh5NDMgKiB4MjEgLSB4NDMgKiB5MjEpO1xuICAgIHJldHVybiBbIHgxICsgdWEgKiB4MjEsIHkxICsgdWEgKiB5MjEgXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3BvbHlnb25DbG9zZWQoY29vcmRpbmF0ZXMpIHtcbiAgICB2YXIgYSA9IGNvb3JkaW5hdGVzWzBdLCBiID0gY29vcmRpbmF0ZXNbY29vcmRpbmF0ZXMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuICEoYVswXSAtIGJbMF0gfHwgYVsxXSAtIGJbMV0pO1xuICB9XG4gIHZhciBkM19nZW9tX3Zvcm9ub2lFZGdlcywgZDNfZ2VvbV92b3Jvbm9pQ2VsbHMsIGQzX2dlb21fdm9yb25vaUJlYWNoZXMsIGQzX2dlb21fdm9yb25vaUJlYWNoUG9vbCA9IFtdLCBkM19nZW9tX3Zvcm9ub2lGaXJzdENpcmNsZSwgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlcywgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlUG9vbCA9IFtdO1xuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lCZWFjaCgpIHtcbiAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja05vZGUodGhpcyk7XG4gICAgdGhpcy5lZGdlID0gdGhpcy5zaXRlID0gdGhpcy5jaXJjbGUgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNyZWF0ZUJlYWNoKHNpdGUpIHtcbiAgICB2YXIgYmVhY2ggPSBkM19nZW9tX3Zvcm9ub2lCZWFjaFBvb2wucG9wKCkgfHwgbmV3IGQzX2dlb21fdm9yb25vaUJlYWNoKCk7XG4gICAgYmVhY2guc2l0ZSA9IHNpdGU7XG4gICAgcmV0dXJuIGJlYWNoO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaURldGFjaEJlYWNoKGJlYWNoKSB7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKGJlYWNoKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzLnJlbW92ZShiZWFjaCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQmVhY2hQb29sLnB1c2goYmVhY2gpO1xuICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrTm9kZShiZWFjaCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmVtb3ZlQmVhY2goYmVhY2gpIHtcbiAgICB2YXIgY2lyY2xlID0gYmVhY2guY2lyY2xlLCB4ID0gY2lyY2xlLngsIHkgPSBjaXJjbGUuY3ksIHZlcnRleCA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfSwgcHJldmlvdXMgPSBiZWFjaC5QLCBuZXh0ID0gYmVhY2guTiwgZGlzYXBwZWFyaW5nID0gWyBiZWFjaCBdO1xuICAgIGQzX2dlb21fdm9yb25vaURldGFjaEJlYWNoKGJlYWNoKTtcbiAgICB2YXIgbEFyYyA9IHByZXZpb3VzO1xuICAgIHdoaWxlIChsQXJjLmNpcmNsZSAmJiBhYnMoeCAtIGxBcmMuY2lyY2xlLngpIDwgzrUgJiYgYWJzKHkgLSBsQXJjLmNpcmNsZS5jeSkgPCDOtSkge1xuICAgICAgcHJldmlvdXMgPSBsQXJjLlA7XG4gICAgICBkaXNhcHBlYXJpbmcudW5zaGlmdChsQXJjKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaURldGFjaEJlYWNoKGxBcmMpO1xuICAgICAgbEFyYyA9IHByZXZpb3VzO1xuICAgIH1cbiAgICBkaXNhcHBlYXJpbmcudW5zaGlmdChsQXJjKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUobEFyYyk7XG4gICAgdmFyIHJBcmMgPSBuZXh0O1xuICAgIHdoaWxlIChyQXJjLmNpcmNsZSAmJiBhYnMoeCAtIHJBcmMuY2lyY2xlLngpIDwgzrUgJiYgYWJzKHkgLSByQXJjLmNpcmNsZS5jeSkgPCDOtSkge1xuICAgICAgbmV4dCA9IHJBcmMuTjtcbiAgICAgIGRpc2FwcGVhcmluZy5wdXNoKHJBcmMpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQmVhY2gockFyYyk7XG4gICAgICByQXJjID0gbmV4dDtcbiAgICB9XG4gICAgZGlzYXBwZWFyaW5nLnB1c2gockFyYyk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKHJBcmMpO1xuICAgIHZhciBuQXJjcyA9IGRpc2FwcGVhcmluZy5sZW5ndGgsIGlBcmM7XG4gICAgZm9yIChpQXJjID0gMTsgaUFyYyA8IG5BcmNzOyArK2lBcmMpIHtcbiAgICAgIHJBcmMgPSBkaXNhcHBlYXJpbmdbaUFyY107XG4gICAgICBsQXJjID0gZGlzYXBwZWFyaW5nW2lBcmMgLSAxXTtcbiAgICAgIGQzX2dlb21fdm9yb25vaVNldEVkZ2VFbmQockFyYy5lZGdlLCBsQXJjLnNpdGUsIHJBcmMuc2l0ZSwgdmVydGV4KTtcbiAgICB9XG4gICAgbEFyYyA9IGRpc2FwcGVhcmluZ1swXTtcbiAgICByQXJjID0gZGlzYXBwZWFyaW5nW25BcmNzIC0gMV07XG4gICAgckFyYy5lZGdlID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlRWRnZShsQXJjLnNpdGUsIHJBcmMuc2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgICBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUobEFyYyk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKHJBcmMpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUFkZEJlYWNoKHNpdGUpIHtcbiAgICB2YXIgeCA9IHNpdGUueCwgZGlyZWN0cml4ID0gc2l0ZS55LCBsQXJjLCByQXJjLCBkeGwsIGR4ciwgbm9kZSA9IGQzX2dlb21fdm9yb25vaUJlYWNoZXMuXztcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgZHhsID0gZDNfZ2VvbV92b3Jvbm9pTGVmdEJyZWFrUG9pbnQobm9kZSwgZGlyZWN0cml4KSAtIHg7XG4gICAgICBpZiAoZHhsID4gzrUpIG5vZGUgPSBub2RlLkw7IGVsc2Uge1xuICAgICAgICBkeHIgPSB4IC0gZDNfZ2VvbV92b3Jvbm9pUmlnaHRCcmVha1BvaW50KG5vZGUsIGRpcmVjdHJpeCk7XG4gICAgICAgIGlmIChkeHIgPiDOtSkge1xuICAgICAgICAgIGlmICghbm9kZS5SKSB7XG4gICAgICAgICAgICBsQXJjID0gbm9kZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlID0gbm9kZS5SO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChkeGwgPiAtzrUpIHtcbiAgICAgICAgICAgIGxBcmMgPSBub2RlLlA7XG4gICAgICAgICAgICByQXJjID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGR4ciA+IC3OtSkge1xuICAgICAgICAgICAgbEFyYyA9IG5vZGU7XG4gICAgICAgICAgICByQXJjID0gbm9kZS5OO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsQXJjID0gckFyYyA9IG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBuZXdBcmMgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVCZWFjaChzaXRlKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzLmluc2VydChsQXJjLCBuZXdBcmMpO1xuICAgIGlmICghbEFyYyAmJiAhckFyYykgcmV0dXJuO1xuICAgIGlmIChsQXJjID09PSByQXJjKSB7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUobEFyYyk7XG4gICAgICByQXJjID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlQmVhY2gobEFyYy5zaXRlKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaUJlYWNoZXMuaW5zZXJ0KG5ld0FyYywgckFyYyk7XG4gICAgICBuZXdBcmMuZWRnZSA9IHJBcmMuZWRnZSA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUVkZ2UobEFyYy5zaXRlLCBuZXdBcmMuc2l0ZSk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUobEFyYyk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUockFyYyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghckFyYykge1xuICAgICAgbmV3QXJjLmVkZ2UgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVFZGdlKGxBcmMuc2l0ZSwgbmV3QXJjLnNpdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUobEFyYyk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKHJBcmMpO1xuICAgIHZhciBsU2l0ZSA9IGxBcmMuc2l0ZSwgYXggPSBsU2l0ZS54LCBheSA9IGxTaXRlLnksIGJ4ID0gc2l0ZS54IC0gYXgsIGJ5ID0gc2l0ZS55IC0gYXksIHJTaXRlID0gckFyYy5zaXRlLCBjeCA9IHJTaXRlLnggLSBheCwgY3kgPSByU2l0ZS55IC0gYXksIGQgPSAyICogKGJ4ICogY3kgLSBieSAqIGN4KSwgaGIgPSBieCAqIGJ4ICsgYnkgKiBieSwgaGMgPSBjeCAqIGN4ICsgY3kgKiBjeSwgdmVydGV4ID0ge1xuICAgICAgeDogKGN5ICogaGIgLSBieSAqIGhjKSAvIGQgKyBheCxcbiAgICAgIHk6IChieCAqIGhjIC0gY3ggKiBoYikgLyBkICsgYXlcbiAgICB9O1xuICAgIGQzX2dlb21fdm9yb25vaVNldEVkZ2VFbmQockFyYy5lZGdlLCBsU2l0ZSwgclNpdGUsIHZlcnRleCk7XG4gICAgbmV3QXJjLmVkZ2UgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVFZGdlKGxTaXRlLCBzaXRlLCBudWxsLCB2ZXJ0ZXgpO1xuICAgIHJBcmMuZWRnZSA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUVkZ2Uoc2l0ZSwgclNpdGUsIG51bGwsIHZlcnRleCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKGxBcmMpO1xuICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShyQXJjKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lMZWZ0QnJlYWtQb2ludChhcmMsIGRpcmVjdHJpeCkge1xuICAgIHZhciBzaXRlID0gYXJjLnNpdGUsIHJmb2N4ID0gc2l0ZS54LCByZm9jeSA9IHNpdGUueSwgcGJ5MiA9IHJmb2N5IC0gZGlyZWN0cml4O1xuICAgIGlmICghcGJ5MikgcmV0dXJuIHJmb2N4O1xuICAgIHZhciBsQXJjID0gYXJjLlA7XG4gICAgaWYgKCFsQXJjKSByZXR1cm4gLUluZmluaXR5O1xuICAgIHNpdGUgPSBsQXJjLnNpdGU7XG4gICAgdmFyIGxmb2N4ID0gc2l0ZS54LCBsZm9jeSA9IHNpdGUueSwgcGxieTIgPSBsZm9jeSAtIGRpcmVjdHJpeDtcbiAgICBpZiAoIXBsYnkyKSByZXR1cm4gbGZvY3g7XG4gICAgdmFyIGhsID0gbGZvY3ggLSByZm9jeCwgYWJ5MiA9IDEgLyBwYnkyIC0gMSAvIHBsYnkyLCBiID0gaGwgLyBwbGJ5MjtcbiAgICBpZiAoYWJ5MikgcmV0dXJuICgtYiArIE1hdGguc3FydChiICogYiAtIDIgKiBhYnkyICogKGhsICogaGwgLyAoLTIgKiBwbGJ5MikgLSBsZm9jeSArIHBsYnkyIC8gMiArIHJmb2N5IC0gcGJ5MiAvIDIpKSkgLyBhYnkyICsgcmZvY3g7XG4gICAgcmV0dXJuIChyZm9jeCArIGxmb2N4KSAvIDI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmlnaHRCcmVha1BvaW50KGFyYywgZGlyZWN0cml4KSB7XG4gICAgdmFyIHJBcmMgPSBhcmMuTjtcbiAgICBpZiAockFyYykgcmV0dXJuIGQzX2dlb21fdm9yb25vaUxlZnRCcmVha1BvaW50KHJBcmMsIGRpcmVjdHJpeCk7XG4gICAgdmFyIHNpdGUgPSBhcmMuc2l0ZTtcbiAgICByZXR1cm4gc2l0ZS55ID09PSBkaXJlY3RyaXggPyBzaXRlLnggOiBJbmZpbml0eTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDZWxsKHNpdGUpIHtcbiAgICB0aGlzLnNpdGUgPSBzaXRlO1xuICAgIHRoaXMuZWRnZXMgPSBbXTtcbiAgfVxuICBkM19nZW9tX3Zvcm9ub2lDZWxsLnByb3RvdHlwZS5wcmVwYXJlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhhbGZFZGdlcyA9IHRoaXMuZWRnZXMsIGlIYWxmRWRnZSA9IGhhbGZFZGdlcy5sZW5ndGgsIGVkZ2U7XG4gICAgd2hpbGUgKGlIYWxmRWRnZS0tKSB7XG4gICAgICBlZGdlID0gaGFsZkVkZ2VzW2lIYWxmRWRnZV0uZWRnZTtcbiAgICAgIGlmICghZWRnZS5iIHx8ICFlZGdlLmEpIGhhbGZFZGdlcy5zcGxpY2UoaUhhbGZFZGdlLCAxKTtcbiAgICB9XG4gICAgaGFsZkVkZ2VzLnNvcnQoZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2VPcmRlcik7XG4gICAgcmV0dXJuIGhhbGZFZGdlcy5sZW5ndGg7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNsb3NlQ2VsbHMoZXh0ZW50KSB7XG4gICAgdmFyIHgwID0gZXh0ZW50WzBdWzBdLCB4MSA9IGV4dGVudFsxXVswXSwgeTAgPSBleHRlbnRbMF1bMV0sIHkxID0gZXh0ZW50WzFdWzFdLCB4MiwgeTIsIHgzLCB5MywgY2VsbHMgPSBkM19nZW9tX3Zvcm9ub2lDZWxscywgaUNlbGwgPSBjZWxscy5sZW5ndGgsIGNlbGwsIGlIYWxmRWRnZSwgaGFsZkVkZ2VzLCBuSGFsZkVkZ2VzLCBzdGFydCwgZW5kO1xuICAgIHdoaWxlIChpQ2VsbC0tKSB7XG4gICAgICBjZWxsID0gY2VsbHNbaUNlbGxdO1xuICAgICAgaWYgKCFjZWxsIHx8ICFjZWxsLnByZXBhcmUoKSkgY29udGludWU7XG4gICAgICBoYWxmRWRnZXMgPSBjZWxsLmVkZ2VzO1xuICAgICAgbkhhbGZFZGdlcyA9IGhhbGZFZGdlcy5sZW5ndGg7XG4gICAgICBpSGFsZkVkZ2UgPSAwO1xuICAgICAgd2hpbGUgKGlIYWxmRWRnZSA8IG5IYWxmRWRnZXMpIHtcbiAgICAgICAgZW5kID0gaGFsZkVkZ2VzW2lIYWxmRWRnZV0uZW5kKCksIHgzID0gZW5kLngsIHkzID0gZW5kLnk7XG4gICAgICAgIHN0YXJ0ID0gaGFsZkVkZ2VzWysraUhhbGZFZGdlICUgbkhhbGZFZGdlc10uc3RhcnQoKSwgeDIgPSBzdGFydC54LCB5MiA9IHN0YXJ0Lnk7XG4gICAgICAgIGlmIChhYnMoeDMgLSB4MikgPiDOtSB8fCBhYnMoeTMgLSB5MikgPiDOtSkge1xuICAgICAgICAgIGhhbGZFZGdlcy5zcGxpY2UoaUhhbGZFZGdlLCAwLCBuZXcgZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2UoZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlQm9yZGVyRWRnZShjZWxsLnNpdGUsIGVuZCwgYWJzKHgzIC0geDApIDwgzrUgJiYgeTEgLSB5MyA+IM61ID8ge1xuICAgICAgICAgICAgeDogeDAsXG4gICAgICAgICAgICB5OiBhYnMoeDIgLSB4MCkgPCDOtSA/IHkyIDogeTFcbiAgICAgICAgICB9IDogYWJzKHkzIC0geTEpIDwgzrUgJiYgeDEgLSB4MyA+IM61ID8ge1xuICAgICAgICAgICAgeDogYWJzKHkyIC0geTEpIDwgzrUgPyB4MiA6IHgxLFxuICAgICAgICAgICAgeTogeTFcbiAgICAgICAgICB9IDogYWJzKHgzIC0geDEpIDwgzrUgJiYgeTMgLSB5MCA+IM61ID8ge1xuICAgICAgICAgICAgeDogeDEsXG4gICAgICAgICAgICB5OiBhYnMoeDIgLSB4MSkgPCDOtSA/IHkyIDogeTBcbiAgICAgICAgICB9IDogYWJzKHkzIC0geTApIDwgzrUgJiYgeDMgLSB4MCA+IM61ID8ge1xuICAgICAgICAgICAgeDogYWJzKHkyIC0geTApIDwgzrUgPyB4MiA6IHgwLFxuICAgICAgICAgICAgeTogeTBcbiAgICAgICAgICB9IDogbnVsbCksIGNlbGwuc2l0ZSwgbnVsbCkpO1xuICAgICAgICAgICsrbkhhbGZFZGdlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZU9yZGVyKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hbmdsZSAtIGEuYW5nbGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlKCkge1xuICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrTm9kZSh0aGlzKTtcbiAgICB0aGlzLnggPSB0aGlzLnkgPSB0aGlzLmFyYyA9IHRoaXMuc2l0ZSA9IHRoaXMuY3kgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShhcmMpIHtcbiAgICB2YXIgbEFyYyA9IGFyYy5QLCByQXJjID0gYXJjLk47XG4gICAgaWYgKCFsQXJjIHx8ICFyQXJjKSByZXR1cm47XG4gICAgdmFyIGxTaXRlID0gbEFyYy5zaXRlLCBjU2l0ZSA9IGFyYy5zaXRlLCByU2l0ZSA9IHJBcmMuc2l0ZTtcbiAgICBpZiAobFNpdGUgPT09IHJTaXRlKSByZXR1cm47XG4gICAgdmFyIGJ4ID0gY1NpdGUueCwgYnkgPSBjU2l0ZS55LCBheCA9IGxTaXRlLnggLSBieCwgYXkgPSBsU2l0ZS55IC0gYnksIGN4ID0gclNpdGUueCAtIGJ4LCBjeSA9IHJTaXRlLnkgLSBieTtcbiAgICB2YXIgZCA9IDIgKiAoYXggKiBjeSAtIGF5ICogY3gpO1xuICAgIGlmIChkID49IC3OtTIpIHJldHVybjtcbiAgICB2YXIgaGEgPSBheCAqIGF4ICsgYXkgKiBheSwgaGMgPSBjeCAqIGN4ICsgY3kgKiBjeSwgeCA9IChjeSAqIGhhIC0gYXkgKiBoYykgLyBkLCB5ID0gKGF4ICogaGMgLSBjeCAqIGhhKSAvIGQsIGN5ID0geSArIGJ5O1xuICAgIHZhciBjaXJjbGUgPSBkM19nZW9tX3Zvcm9ub2lDaXJjbGVQb29sLnBvcCgpIHx8IG5ldyBkM19nZW9tX3Zvcm9ub2lDaXJjbGUoKTtcbiAgICBjaXJjbGUuYXJjID0gYXJjO1xuICAgIGNpcmNsZS5zaXRlID0gY1NpdGU7XG4gICAgY2lyY2xlLnggPSB4ICsgYng7XG4gICAgY2lyY2xlLnkgPSBjeSArIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICBjaXJjbGUuY3kgPSBjeTtcbiAgICBhcmMuY2lyY2xlID0gY2lyY2xlO1xuICAgIHZhciBiZWZvcmUgPSBudWxsLCBub2RlID0gZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlcy5fO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBpZiAoY2lyY2xlLnkgPCBub2RlLnkgfHwgY2lyY2xlLnkgPT09IG5vZGUueSAmJiBjaXJjbGUueCA8PSBub2RlLngpIHtcbiAgICAgICAgaWYgKG5vZGUuTCkgbm9kZSA9IG5vZGUuTDsgZWxzZSB7XG4gICAgICAgICAgYmVmb3JlID0gbm9kZS5QO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobm9kZS5SKSBub2RlID0gbm9kZS5SOyBlbHNlIHtcbiAgICAgICAgICBiZWZvcmUgPSBub2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGQzX2dlb21fdm9yb25vaUNpcmNsZXMuaW5zZXJ0KGJlZm9yZSwgY2lyY2xlKTtcbiAgICBpZiAoIWJlZm9yZSkgZDNfZ2VvbV92b3Jvbm9pRmlyc3RDaXJjbGUgPSBjaXJjbGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKGFyYykge1xuICAgIHZhciBjaXJjbGUgPSBhcmMuY2lyY2xlO1xuICAgIGlmIChjaXJjbGUpIHtcbiAgICAgIGlmICghY2lyY2xlLlApIGQzX2dlb21fdm9yb25vaUZpcnN0Q2lyY2xlID0gY2lyY2xlLk47XG4gICAgICBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzLnJlbW92ZShjaXJjbGUpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlUG9vbC5wdXNoKGNpcmNsZSk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja05vZGUoY2lyY2xlKTtcbiAgICAgIGFyYy5jaXJjbGUgPSBudWxsO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDbGlwRWRnZXMoZXh0ZW50KSB7XG4gICAgdmFyIGVkZ2VzID0gZDNfZ2VvbV92b3Jvbm9pRWRnZXMsIGNsaXAgPSBkM19nZW9tX2NsaXBMaW5lKGV4dGVudFswXVswXSwgZXh0ZW50WzBdWzFdLCBleHRlbnRbMV1bMF0sIGV4dGVudFsxXVsxXSksIGkgPSBlZGdlcy5sZW5ndGgsIGU7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgZSA9IGVkZ2VzW2ldO1xuICAgICAgaWYgKCFkM19nZW9tX3Zvcm9ub2lDb25uZWN0RWRnZShlLCBleHRlbnQpIHx8ICFjbGlwKGUpIHx8IGFicyhlLmEueCAtIGUuYi54KSA8IM61ICYmIGFicyhlLmEueSAtIGUuYi55KSA8IM61KSB7XG4gICAgICAgIGUuYSA9IGUuYiA9IG51bGw7XG4gICAgICAgIGVkZ2VzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ29ubmVjdEVkZ2UoZWRnZSwgZXh0ZW50KSB7XG4gICAgdmFyIHZiID0gZWRnZS5iO1xuICAgIGlmICh2YikgcmV0dXJuIHRydWU7XG4gICAgdmFyIHZhID0gZWRnZS5hLCB4MCA9IGV4dGVudFswXVswXSwgeDEgPSBleHRlbnRbMV1bMF0sIHkwID0gZXh0ZW50WzBdWzFdLCB5MSA9IGV4dGVudFsxXVsxXSwgbFNpdGUgPSBlZGdlLmwsIHJTaXRlID0gZWRnZS5yLCBseCA9IGxTaXRlLngsIGx5ID0gbFNpdGUueSwgcnggPSByU2l0ZS54LCByeSA9IHJTaXRlLnksIGZ4ID0gKGx4ICsgcngpIC8gMiwgZnkgPSAobHkgKyByeSkgLyAyLCBmbSwgZmI7XG4gICAgaWYgKHJ5ID09PSBseSkge1xuICAgICAgaWYgKGZ4IDwgeDAgfHwgZnggPj0geDEpIHJldHVybjtcbiAgICAgIGlmIChseCA+IHJ4KSB7XG4gICAgICAgIGlmICghdmEpIHZhID0ge1xuICAgICAgICAgIHg6IGZ4LFxuICAgICAgICAgIHk6IHkwXG4gICAgICAgIH07IGVsc2UgaWYgKHZhLnkgPj0geTEpIHJldHVybjtcbiAgICAgICAgdmIgPSB7XG4gICAgICAgICAgeDogZngsXG4gICAgICAgICAgeTogeTFcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdmEpIHZhID0ge1xuICAgICAgICAgIHg6IGZ4LFxuICAgICAgICAgIHk6IHkxXG4gICAgICAgIH07IGVsc2UgaWYgKHZhLnkgPCB5MCkgcmV0dXJuO1xuICAgICAgICB2YiA9IHtcbiAgICAgICAgICB4OiBmeCxcbiAgICAgICAgICB5OiB5MFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmbSA9IChseCAtIHJ4KSAvIChyeSAtIGx5KTtcbiAgICAgIGZiID0gZnkgLSBmbSAqIGZ4O1xuICAgICAgaWYgKGZtIDwgLTEgfHwgZm0gPiAxKSB7XG4gICAgICAgIGlmIChseCA+IHJ4KSB7XG4gICAgICAgICAgaWYgKCF2YSkgdmEgPSB7XG4gICAgICAgICAgICB4OiAoeTAgLSBmYikgLyBmbSxcbiAgICAgICAgICAgIHk6IHkwXG4gICAgICAgICAgfTsgZWxzZSBpZiAodmEueSA+PSB5MSkgcmV0dXJuO1xuICAgICAgICAgIHZiID0ge1xuICAgICAgICAgICAgeDogKHkxIC0gZmIpIC8gZm0sXG4gICAgICAgICAgICB5OiB5MVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF2YSkgdmEgPSB7XG4gICAgICAgICAgICB4OiAoeTEgLSBmYikgLyBmbSxcbiAgICAgICAgICAgIHk6IHkxXG4gICAgICAgICAgfTsgZWxzZSBpZiAodmEueSA8IHkwKSByZXR1cm47XG4gICAgICAgICAgdmIgPSB7XG4gICAgICAgICAgICB4OiAoeTAgLSBmYikgLyBmbSxcbiAgICAgICAgICAgIHk6IHkwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGx5IDwgcnkpIHtcbiAgICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICAgIHg6IHgwLFxuICAgICAgICAgICAgeTogZm0gKiB4MCArIGZiXG4gICAgICAgICAgfTsgZWxzZSBpZiAodmEueCA+PSB4MSkgcmV0dXJuO1xuICAgICAgICAgIHZiID0ge1xuICAgICAgICAgICAgeDogeDEsXG4gICAgICAgICAgICB5OiBmbSAqIHgxICsgZmJcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdmEpIHZhID0ge1xuICAgICAgICAgICAgeDogeDEsXG4gICAgICAgICAgICB5OiBmbSAqIHgxICsgZmJcbiAgICAgICAgICB9OyBlbHNlIGlmICh2YS54IDwgeDApIHJldHVybjtcbiAgICAgICAgICB2YiA9IHtcbiAgICAgICAgICAgIHg6IHgwLFxuICAgICAgICAgICAgeTogZm0gKiB4MCArIGZiXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlZGdlLmEgPSB2YTtcbiAgICBlZGdlLmIgPSB2YjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lFZGdlKGxTaXRlLCByU2l0ZSkge1xuICAgIHRoaXMubCA9IGxTaXRlO1xuICAgIHRoaXMuciA9IHJTaXRlO1xuICAgIHRoaXMuYSA9IHRoaXMuYiA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlRWRnZShsU2l0ZSwgclNpdGUsIHZhLCB2Yikge1xuICAgIHZhciBlZGdlID0gbmV3IGQzX2dlb21fdm9yb25vaUVkZ2UobFNpdGUsIHJTaXRlKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lFZGdlcy5wdXNoKGVkZ2UpO1xuICAgIGlmICh2YSkgZDNfZ2VvbV92b3Jvbm9pU2V0RWRnZUVuZChlZGdlLCBsU2l0ZSwgclNpdGUsIHZhKTtcbiAgICBpZiAodmIpIGQzX2dlb21fdm9yb25vaVNldEVkZ2VFbmQoZWRnZSwgclNpdGUsIGxTaXRlLCB2Yik7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQ2VsbHNbbFNpdGUuaV0uZWRnZXMucHVzaChuZXcgZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2UoZWRnZSwgbFNpdGUsIHJTaXRlKSk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQ2VsbHNbclNpdGUuaV0uZWRnZXMucHVzaChuZXcgZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2UoZWRnZSwgclNpdGUsIGxTaXRlKSk7XG4gICAgcmV0dXJuIGVkZ2U7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlQm9yZGVyRWRnZShsU2l0ZSwgdmEsIHZiKSB7XG4gICAgdmFyIGVkZ2UgPSBuZXcgZDNfZ2VvbV92b3Jvbm9pRWRnZShsU2l0ZSwgbnVsbCk7XG4gICAgZWRnZS5hID0gdmE7XG4gICAgZWRnZS5iID0gdmI7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRWRnZXMucHVzaChlZGdlKTtcbiAgICByZXR1cm4gZWRnZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lTZXRFZGdlRW5kKGVkZ2UsIGxTaXRlLCByU2l0ZSwgdmVydGV4KSB7XG4gICAgaWYgKCFlZGdlLmEgJiYgIWVkZ2UuYikge1xuICAgICAgZWRnZS5hID0gdmVydGV4O1xuICAgICAgZWRnZS5sID0gbFNpdGU7XG4gICAgICBlZGdlLnIgPSByU2l0ZTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UubCA9PT0gclNpdGUpIHtcbiAgICAgIGVkZ2UuYiA9IHZlcnRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRnZS5hID0gdmVydGV4O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZShlZGdlLCBsU2l0ZSwgclNpdGUpIHtcbiAgICB2YXIgdmEgPSBlZGdlLmEsIHZiID0gZWRnZS5iO1xuICAgIHRoaXMuZWRnZSA9IGVkZ2U7XG4gICAgdGhpcy5zaXRlID0gbFNpdGU7XG4gICAgdGhpcy5hbmdsZSA9IHJTaXRlID8gTWF0aC5hdGFuMihyU2l0ZS55IC0gbFNpdGUueSwgclNpdGUueCAtIGxTaXRlLngpIDogZWRnZS5sID09PSBsU2l0ZSA/IE1hdGguYXRhbjIodmIueCAtIHZhLngsIHZhLnkgLSB2Yi55KSA6IE1hdGguYXRhbjIodmEueCAtIHZiLngsIHZiLnkgLSB2YS55KTtcbiAgfVxuICBkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZS5wcm90b3R5cGUgPSB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWRnZS5sID09PSB0aGlzLnNpdGUgPyB0aGlzLmVkZ2UuYSA6IHRoaXMuZWRnZS5iO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVkZ2UubCA9PT0gdGhpcy5zaXRlID8gdGhpcy5lZGdlLmIgOiB0aGlzLmVkZ2UuYTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrVHJlZSgpIHtcbiAgICB0aGlzLl8gPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrTm9kZShub2RlKSB7XG4gICAgbm9kZS5VID0gbm9kZS5DID0gbm9kZS5MID0gbm9kZS5SID0gbm9kZS5QID0gbm9kZS5OID0gbnVsbDtcbiAgfVxuICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1RyZWUucHJvdG90eXBlID0ge1xuICAgIGluc2VydDogZnVuY3Rpb24oYWZ0ZXIsIG5vZGUpIHtcbiAgICAgIHZhciBwYXJlbnQsIGdyYW5kcGEsIHVuY2xlO1xuICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgIG5vZGUuUCA9IGFmdGVyO1xuICAgICAgICBub2RlLk4gPSBhZnRlci5OO1xuICAgICAgICBpZiAoYWZ0ZXIuTikgYWZ0ZXIuTi5QID0gbm9kZTtcbiAgICAgICAgYWZ0ZXIuTiA9IG5vZGU7XG4gICAgICAgIGlmIChhZnRlci5SKSB7XG4gICAgICAgICAgYWZ0ZXIgPSBhZnRlci5SO1xuICAgICAgICAgIHdoaWxlIChhZnRlci5MKSBhZnRlciA9IGFmdGVyLkw7XG4gICAgICAgICAgYWZ0ZXIuTCA9IG5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZ0ZXIuUiA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gYWZ0ZXI7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuXykge1xuICAgICAgICBhZnRlciA9IGQzX2dlb21fdm9yb25vaVJlZEJsYWNrRmlyc3QodGhpcy5fKTtcbiAgICAgICAgbm9kZS5QID0gbnVsbDtcbiAgICAgICAgbm9kZS5OID0gYWZ0ZXI7XG4gICAgICAgIGFmdGVyLlAgPSBhZnRlci5MID0gbm9kZTtcbiAgICAgICAgcGFyZW50ID0gYWZ0ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLlAgPSBub2RlLk4gPSBudWxsO1xuICAgICAgICB0aGlzLl8gPSBub2RlO1xuICAgICAgICBwYXJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZS5MID0gbm9kZS5SID0gbnVsbDtcbiAgICAgIG5vZGUuVSA9IHBhcmVudDtcbiAgICAgIG5vZGUuQyA9IHRydWU7XG4gICAgICBhZnRlciA9IG5vZGU7XG4gICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5DKSB7XG4gICAgICAgIGdyYW5kcGEgPSBwYXJlbnQuVTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gZ3JhbmRwYS5MKSB7XG4gICAgICAgICAgdW5jbGUgPSBncmFuZHBhLlI7XG4gICAgICAgICAgaWYgKHVuY2xlICYmIHVuY2xlLkMpIHtcbiAgICAgICAgICAgIHBhcmVudC5DID0gdW5jbGUuQyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICAgIGFmdGVyID0gZ3JhbmRwYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFmdGVyID09PSBwYXJlbnQuUikge1xuICAgICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgIHBhcmVudCA9IGFmdGVyLlU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQuQyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgZ3JhbmRwYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVuY2xlID0gZ3JhbmRwYS5MO1xuICAgICAgICAgIGlmICh1bmNsZSAmJiB1bmNsZS5DKSB7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHVuY2xlLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgICBhZnRlciA9IGdyYW5kcGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhZnRlciA9PT0gcGFyZW50LkwpIHtcbiAgICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgICBhZnRlciA9IHBhcmVudDtcbiAgICAgICAgICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5DID0gZmFsc2U7XG4gICAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIGdyYW5kcGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBhZnRlci5VO1xuICAgICAgfVxuICAgICAgdGhpcy5fLkMgPSBmYWxzZTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUuTikgbm9kZS5OLlAgPSBub2RlLlA7XG4gICAgICBpZiAobm9kZS5QKSBub2RlLlAuTiA9IG5vZGUuTjtcbiAgICAgIG5vZGUuTiA9IG5vZGUuUCA9IG51bGw7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZS5VLCBzaWJsaW5nLCBsZWZ0ID0gbm9kZS5MLCByaWdodCA9IG5vZGUuUiwgbmV4dCwgcmVkO1xuICAgICAgaWYgKCFsZWZ0KSBuZXh0ID0gcmlnaHQ7IGVsc2UgaWYgKCFyaWdodCkgbmV4dCA9IGxlZnQ7IGVsc2UgbmV4dCA9IGQzX2dlb21fdm9yb25vaVJlZEJsYWNrRmlyc3QocmlnaHQpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LkwgPT09IG5vZGUpIHBhcmVudC5MID0gbmV4dDsgZWxzZSBwYXJlbnQuUiA9IG5leHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl8gPSBuZXh0O1xuICAgICAgfVxuICAgICAgaWYgKGxlZnQgJiYgcmlnaHQpIHtcbiAgICAgICAgcmVkID0gbmV4dC5DO1xuICAgICAgICBuZXh0LkMgPSBub2RlLkM7XG4gICAgICAgIG5leHQuTCA9IGxlZnQ7XG4gICAgICAgIGxlZnQuVSA9IG5leHQ7XG4gICAgICAgIGlmIChuZXh0ICE9PSByaWdodCkge1xuICAgICAgICAgIHBhcmVudCA9IG5leHQuVTtcbiAgICAgICAgICBuZXh0LlUgPSBub2RlLlU7XG4gICAgICAgICAgbm9kZSA9IG5leHQuUjtcbiAgICAgICAgICBwYXJlbnQuTCA9IG5vZGU7XG4gICAgICAgICAgbmV4dC5SID0gcmlnaHQ7XG4gICAgICAgICAgcmlnaHQuVSA9IG5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dC5VID0gcGFyZW50O1xuICAgICAgICAgIHBhcmVudCA9IG5leHQ7XG4gICAgICAgICAgbm9kZSA9IG5leHQuUjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVkID0gbm9kZS5DO1xuICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlKSBub2RlLlUgPSBwYXJlbnQ7XG4gICAgICBpZiAocmVkKSByZXR1cm47XG4gICAgICBpZiAobm9kZSAmJiBub2RlLkMpIHtcbiAgICAgICAgbm9kZS5DID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuXykgYnJlYWs7XG4gICAgICAgIGlmIChub2RlID09PSBwYXJlbnQuTCkge1xuICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuUjtcbiAgICAgICAgICBpZiAoc2libGluZy5DKSB7XG4gICAgICAgICAgICBzaWJsaW5nLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIHBhcmVudC5DID0gdHJ1ZTtcbiAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2libGluZy5MICYmIHNpYmxpbmcuTC5DIHx8IHNpYmxpbmcuUiAmJiBzaWJsaW5nLlIuQykge1xuICAgICAgICAgICAgaWYgKCFzaWJsaW5nLlIgfHwgIXNpYmxpbmcuUi5DKSB7XG4gICAgICAgICAgICAgIHNpYmxpbmcuTC5DID0gZmFsc2U7XG4gICAgICAgICAgICAgIHNpYmxpbmcuQyA9IHRydWU7XG4gICAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgc2libGluZyk7XG4gICAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpYmxpbmcuQyA9IHBhcmVudC5DO1xuICAgICAgICAgICAgcGFyZW50LkMgPSBzaWJsaW5nLlIuQyA9IGZhbHNlO1xuICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5fO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcbiAgICAgICAgICBpZiAoc2libGluZy5DKSB7XG4gICAgICAgICAgICBzaWJsaW5nLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIHBhcmVudC5DID0gdHJ1ZTtcbiAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNpYmxpbmcuTCAmJiBzaWJsaW5nLkwuQyB8fCBzaWJsaW5nLlIgJiYgc2libGluZy5SLkMpIHtcbiAgICAgICAgICAgIGlmICghc2libGluZy5MIHx8ICFzaWJsaW5nLkwuQykge1xuICAgICAgICAgICAgICBzaWJsaW5nLlIuQyA9IGZhbHNlO1xuICAgICAgICAgICAgICBzaWJsaW5nLkMgPSB0cnVlO1xuICAgICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgc2libGluZyk7XG4gICAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpYmxpbmcuQyA9IHBhcmVudC5DO1xuICAgICAgICAgICAgcGFyZW50LkMgPSBzaWJsaW5nLkwuQyA9IGZhbHNlO1xuICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuXztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nLkMgPSB0cnVlO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuVTtcbiAgICAgIH0gd2hpbGUgKCFub2RlLkMpO1xuICAgICAgaWYgKG5vZGUpIG5vZGUuQyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVMZWZ0KHRyZWUsIG5vZGUpIHtcbiAgICB2YXIgcCA9IG5vZGUsIHEgPSBub2RlLlIsIHBhcmVudCA9IHAuVTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LkwgPT09IHApIHBhcmVudC5MID0gcTsgZWxzZSBwYXJlbnQuUiA9IHE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWUuXyA9IHE7XG4gICAgfVxuICAgIHEuVSA9IHBhcmVudDtcbiAgICBwLlUgPSBxO1xuICAgIHAuUiA9IHEuTDtcbiAgICBpZiAocC5SKSBwLlIuVSA9IHA7XG4gICAgcS5MID0gcDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRyZWUsIG5vZGUpIHtcbiAgICB2YXIgcCA9IG5vZGUsIHEgPSBub2RlLkwsIHBhcmVudCA9IHAuVTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LkwgPT09IHApIHBhcmVudC5MID0gcTsgZWxzZSBwYXJlbnQuUiA9IHE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWUuXyA9IHE7XG4gICAgfVxuICAgIHEuVSA9IHBhcmVudDtcbiAgICBwLlUgPSBxO1xuICAgIHAuTCA9IHEuUjtcbiAgICBpZiAocC5MKSBwLkwuVSA9IHA7XG4gICAgcS5SID0gcDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja0ZpcnN0KG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5MKSBub2RlID0gbm9kZS5MO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaShzaXRlcywgYmJveCkge1xuICAgIHZhciBzaXRlID0gc2l0ZXMuc29ydChkM19nZW9tX3Zvcm9ub2lWZXJ0ZXhPcmRlcikucG9wKCksIHgwLCB5MCwgY2lyY2xlO1xuICAgIGQzX2dlb21fdm9yb25vaUVkZ2VzID0gW107XG4gICAgZDNfZ2VvbV92b3Jvbm9pQ2VsbHMgPSBuZXcgQXJyYXkoc2l0ZXMubGVuZ3RoKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzID0gbmV3IGQzX2dlb21fdm9yb25vaVJlZEJsYWNrVHJlZSgpO1xuICAgIGQzX2dlb21fdm9yb25vaUNpcmNsZXMgPSBuZXcgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tUcmVlKCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNpcmNsZSA9IGQzX2dlb21fdm9yb25vaUZpcnN0Q2lyY2xlO1xuICAgICAgaWYgKHNpdGUgJiYgKCFjaXJjbGUgfHwgc2l0ZS55IDwgY2lyY2xlLnkgfHwgc2l0ZS55ID09PSBjaXJjbGUueSAmJiBzaXRlLnggPCBjaXJjbGUueCkpIHtcbiAgICAgICAgaWYgKHNpdGUueCAhPT0geDAgfHwgc2l0ZS55ICE9PSB5MCkge1xuICAgICAgICAgIGQzX2dlb21fdm9yb25vaUNlbGxzW3NpdGUuaV0gPSBuZXcgZDNfZ2VvbV92b3Jvbm9pQ2VsbChzaXRlKTtcbiAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lBZGRCZWFjaChzaXRlKTtcbiAgICAgICAgICB4MCA9IHNpdGUueCwgeTAgPSBzaXRlLnk7XG4gICAgICAgIH1cbiAgICAgICAgc2l0ZSA9IHNpdGVzLnBvcCgpO1xuICAgICAgfSBlbHNlIGlmIChjaXJjbGUpIHtcbiAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVtb3ZlQmVhY2goY2lyY2xlLmFyYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJib3gpIGQzX2dlb21fdm9yb25vaUNsaXBFZGdlcyhiYm94KSwgZDNfZ2VvbV92b3Jvbm9pQ2xvc2VDZWxscyhiYm94KTtcbiAgICB2YXIgZGlhZ3JhbSA9IHtcbiAgICAgIGNlbGxzOiBkM19nZW9tX3Zvcm9ub2lDZWxscyxcbiAgICAgIGVkZ2VzOiBkM19nZW9tX3Zvcm9ub2lFZGdlc1xuICAgIH07XG4gICAgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcyA9IGQzX2dlb21fdm9yb25vaUNpcmNsZXMgPSBkM19nZW9tX3Zvcm9ub2lFZGdlcyA9IGQzX2dlb21fdm9yb25vaUNlbGxzID0gbnVsbDtcbiAgICByZXR1cm4gZGlhZ3JhbTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lWZXJ0ZXhPcmRlcihhLCBiKSB7XG4gICAgcmV0dXJuIGIueSAtIGEueSB8fCBiLnggLSBhLng7XG4gIH1cbiAgZDMuZ2VvbS52b3Jvbm9pID0gZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgdmFyIHggPSBkM19nZW9tX3BvaW50WCwgeSA9IGQzX2dlb21fcG9pbnRZLCBmeCA9IHgsIGZ5ID0geSwgY2xpcEV4dGVudCA9IGQzX2dlb21fdm9yb25vaUNsaXBFeHRlbnQ7XG4gICAgaWYgKHBvaW50cykgcmV0dXJuIHZvcm9ub2kocG9pbnRzKTtcbiAgICBmdW5jdGlvbiB2b3Jvbm9pKGRhdGEpIHtcbiAgICAgIHZhciBwb2x5Z29ucyA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCksIHgwID0gY2xpcEV4dGVudFswXVswXSwgeTAgPSBjbGlwRXh0ZW50WzBdWzFdLCB4MSA9IGNsaXBFeHRlbnRbMV1bMF0sIHkxID0gY2xpcEV4dGVudFsxXVsxXTtcbiAgICAgIGQzX2dlb21fdm9yb25vaShzaXRlcyhkYXRhKSwgY2xpcEV4dGVudCkuY2VsbHMuZm9yRWFjaChmdW5jdGlvbihjZWxsLCBpKSB7XG4gICAgICAgIHZhciBlZGdlcyA9IGNlbGwuZWRnZXMsIHNpdGUgPSBjZWxsLnNpdGUsIHBvbHlnb24gPSBwb2x5Z29uc1tpXSA9IGVkZ2VzLmxlbmd0aCA/IGVkZ2VzLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdmFyIHMgPSBlLnN0YXJ0KCk7XG4gICAgICAgICAgcmV0dXJuIFsgcy54LCBzLnkgXTtcbiAgICAgICAgfSkgOiBzaXRlLnggPj0geDAgJiYgc2l0ZS54IDw9IHgxICYmIHNpdGUueSA+PSB5MCAmJiBzaXRlLnkgPD0geTEgPyBbIFsgeDAsIHkxIF0sIFsgeDEsIHkxIF0sIFsgeDEsIHkwIF0sIFsgeDAsIHkwIF0gXSA6IFtdO1xuICAgICAgICBwb2x5Z29uLnBvaW50ID0gZGF0YVtpXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBvbHlnb25zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaXRlcyhkYXRhKSB7XG4gICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IE1hdGgucm91bmQoZngoZCwgaSkgLyDOtSkgKiDOtSxcbiAgICAgICAgICB5OiBNYXRoLnJvdW5kKGZ5KGQsIGkpIC8gzrUpICogzrUsXG4gICAgICAgICAgaTogaVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZvcm9ub2kubGlua3MgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gZDNfZ2VvbV92b3Jvbm9pKHNpdGVzKGRhdGEpKS5lZGdlcy5maWx0ZXIoZnVuY3Rpb24oZWRnZSkge1xuICAgICAgICByZXR1cm4gZWRnZS5sICYmIGVkZ2UucjtcbiAgICAgIH0pLm1hcChmdW5jdGlvbihlZGdlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBkYXRhW2VkZ2UubC5pXSxcbiAgICAgICAgICB0YXJnZXQ6IGRhdGFbZWRnZS5yLmldXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZvcm9ub2kudHJpYW5nbGVzID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIHRyaWFuZ2xlcyA9IFtdO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pKHNpdGVzKGRhdGEpKS5jZWxscy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIGkpIHtcbiAgICAgICAgdmFyIHNpdGUgPSBjZWxsLnNpdGUsIGVkZ2VzID0gY2VsbC5lZGdlcy5zb3J0KGQzX2dlb21fdm9yb25vaUhhbGZFZGdlT3JkZXIpLCBqID0gLTEsIG0gPSBlZGdlcy5sZW5ndGgsIGUwLCBzMCwgZTEgPSBlZGdlc1ttIC0gMV0uZWRnZSwgczEgPSBlMS5sID09PSBzaXRlID8gZTEuciA6IGUxLmw7XG4gICAgICAgIHdoaWxlICgrK2ogPCBtKSB7XG4gICAgICAgICAgZTAgPSBlMTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIGUxID0gZWRnZXNbal0uZWRnZTtcbiAgICAgICAgICBzMSA9IGUxLmwgPT09IHNpdGUgPyBlMS5yIDogZTEubDtcbiAgICAgICAgICBpZiAoaSA8IHMwLmkgJiYgaSA8IHMxLmkgJiYgZDNfZ2VvbV92b3Jvbm9pVHJpYW5nbGVBcmVhKHNpdGUsIHMwLCBzMSkgPCAwKSB7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChbIGRhdGFbaV0sIGRhdGFbczAuaV0sIGRhdGFbczEuaV0gXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cmlhbmdsZXM7XG4gICAgfTtcbiAgICB2b3Jvbm9pLnggPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmeCA9IGQzX2Z1bmN0b3IoeCA9IF8pLCB2b3Jvbm9pKSA6IHg7XG4gICAgfTtcbiAgICB2b3Jvbm9pLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmeSA9IGQzX2Z1bmN0b3IoeSA9IF8pLCB2b3Jvbm9pKSA6IHk7XG4gICAgfTtcbiAgICB2b3Jvbm9pLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGlwRXh0ZW50ID09PSBkM19nZW9tX3Zvcm9ub2lDbGlwRXh0ZW50ID8gbnVsbCA6IGNsaXBFeHRlbnQ7XG4gICAgICBjbGlwRXh0ZW50ID0gXyA9PSBudWxsID8gZDNfZ2VvbV92b3Jvbm9pQ2xpcEV4dGVudCA6IF87XG4gICAgICByZXR1cm4gdm9yb25vaTtcbiAgICB9O1xuICAgIHZvcm9ub2kuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsaXBFeHRlbnQgPT09IGQzX2dlb21fdm9yb25vaUNsaXBFeHRlbnQgPyBudWxsIDogY2xpcEV4dGVudCAmJiBjbGlwRXh0ZW50WzFdO1xuICAgICAgcmV0dXJuIHZvcm9ub2kuY2xpcEV4dGVudChfICYmIFsgWyAwLCAwIF0sIF8gXSk7XG4gICAgfTtcbiAgICByZXR1cm4gdm9yb25vaTtcbiAgfTtcbiAgdmFyIGQzX2dlb21fdm9yb25vaUNsaXBFeHRlbnQgPSBbIFsgLTFlNiwgLTFlNiBdLCBbIDFlNiwgMWU2IF0gXTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pVHJpYW5nbGVBcmVhKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGEueCAtIGMueCkgKiAoYi55IC0gYS55KSAtIChhLnggLSBiLngpICogKGMueSAtIGEueSk7XG4gIH1cbiAgZDMuZ2VvbS5kZWxhdW5heSA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgcmV0dXJuIGQzLmdlb20udm9yb25vaSgpLnRyaWFuZ2xlcyh2ZXJ0aWNlcyk7XG4gIH07XG4gIGQzLmdlb20ucXVhZHRyZWUgPSBmdW5jdGlvbihwb2ludHMsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIHggPSBkM19nZW9tX3BvaW50WCwgeSA9IGQzX2dlb21fcG9pbnRZLCBjb21wYXQ7XG4gICAgaWYgKGNvbXBhdCA9IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHggPSBkM19nZW9tX3F1YWR0cmVlQ29tcGF0WDtcbiAgICAgIHkgPSBkM19nZW9tX3F1YWR0cmVlQ29tcGF0WTtcbiAgICAgIGlmIChjb21wYXQgPT09IDMpIHtcbiAgICAgICAgeTIgPSB5MTtcbiAgICAgICAgeDIgPSB4MTtcbiAgICAgICAgeTEgPSB4MSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcXVhZHRyZWUocG9pbnRzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcXVhZHRyZWUoZGF0YSkge1xuICAgICAgdmFyIGQsIGZ4ID0gZDNfZnVuY3Rvcih4KSwgZnkgPSBkM19mdW5jdG9yKHkpLCB4cywgeXMsIGksIG4sIHgxXywgeTFfLCB4Ml8sIHkyXztcbiAgICAgIGlmICh4MSAhPSBudWxsKSB7XG4gICAgICAgIHgxXyA9IHgxLCB5MV8gPSB5MSwgeDJfID0geDIsIHkyXyA9IHkyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDJfID0geTJfID0gLSh4MV8gPSB5MV8gPSBJbmZpbml0eSk7XG4gICAgICAgIHhzID0gW10sIHlzID0gW107XG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvbXBhdCkgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGQgPSBkYXRhW2ldO1xuICAgICAgICAgIGlmIChkLnggPCB4MV8pIHgxXyA9IGQueDtcbiAgICAgICAgICBpZiAoZC55IDwgeTFfKSB5MV8gPSBkLnk7XG4gICAgICAgICAgaWYgKGQueCA+IHgyXykgeDJfID0gZC54O1xuICAgICAgICAgIGlmIChkLnkgPiB5Ml8pIHkyXyA9IGQueTtcbiAgICAgICAgICB4cy5wdXNoKGQueCk7XG4gICAgICAgICAgeXMucHVzaChkLnkpO1xuICAgICAgICB9IGVsc2UgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIHZhciB4XyA9ICtmeChkID0gZGF0YVtpXSwgaSksIHlfID0gK2Z5KGQsIGkpO1xuICAgICAgICAgIGlmICh4XyA8IHgxXykgeDFfID0geF87XG4gICAgICAgICAgaWYgKHlfIDwgeTFfKSB5MV8gPSB5XztcbiAgICAgICAgICBpZiAoeF8gPiB4Ml8pIHgyXyA9IHhfO1xuICAgICAgICAgIGlmICh5XyA+IHkyXykgeTJfID0geV87XG4gICAgICAgICAgeHMucHVzaCh4Xyk7XG4gICAgICAgICAgeXMucHVzaCh5Xyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBkeCA9IHgyXyAtIHgxXywgZHkgPSB5Ml8gLSB5MV87XG4gICAgICBpZiAoZHggPiBkeSkgeTJfID0geTFfICsgZHg7IGVsc2UgeDJfID0geDFfICsgZHk7XG4gICAgICBmdW5jdGlvbiBpbnNlcnQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSByZXR1cm47XG4gICAgICAgIGlmIChuLmxlYWYpIHtcbiAgICAgICAgICB2YXIgbnggPSBuLngsIG55ID0gbi55O1xuICAgICAgICAgIGlmIChueCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoYWJzKG54IC0geCkgKyBhYnMobnkgLSB5KSA8IC4wMSkge1xuICAgICAgICAgICAgICBpbnNlcnRDaGlsZChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgblBvaW50ID0gbi5wb2ludDtcbiAgICAgICAgICAgICAgbi54ID0gbi55ID0gbi5wb2ludCA9IG51bGw7XG4gICAgICAgICAgICAgIGluc2VydENoaWxkKG4sIG5Qb2ludCwgbngsIG55LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgICAgICAgIGluc2VydENoaWxkKG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbi54ID0geCwgbi55ID0geSwgbi5wb2ludCA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc2VydENoaWxkKG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaW5zZXJ0Q2hpbGQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgdmFyIHhtID0gKHgxICsgeDIpICogLjUsIHltID0gKHkxICsgeTIpICogLjUsIHJpZ2h0ID0geCA+PSB4bSwgYmVsb3cgPSB5ID49IHltLCBpID0gYmVsb3cgPDwgMSB8IHJpZ2h0O1xuICAgICAgICBuLmxlYWYgPSBmYWxzZTtcbiAgICAgICAgbiA9IG4ubm9kZXNbaV0gfHwgKG4ubm9kZXNbaV0gPSBkM19nZW9tX3F1YWR0cmVlTm9kZSgpKTtcbiAgICAgICAgaWYgKHJpZ2h0KSB4MSA9IHhtOyBlbHNlIHgyID0geG07XG4gICAgICAgIGlmIChiZWxvdykgeTEgPSB5bTsgZWxzZSB5MiA9IHltO1xuICAgICAgICBpbnNlcnQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgfVxuICAgICAgdmFyIHJvb3QgPSBkM19nZW9tX3F1YWR0cmVlTm9kZSgpO1xuICAgICAgcm9vdC5hZGQgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgIGluc2VydChyb290LCBkLCArZngoZCwgKytpKSwgK2Z5KGQsIGkpLCB4MV8sIHkxXywgeDJfLCB5Ml8pO1xuICAgICAgfTtcbiAgICAgIHJvb3QudmlzaXQgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIGQzX2dlb21fcXVhZHRyZWVWaXNpdChmLCByb290LCB4MV8sIHkxXywgeDJfLCB5Ml8pO1xuICAgICAgfTtcbiAgICAgIHJvb3QuZmluZCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBkM19nZW9tX3F1YWR0cmVlRmluZChyb290LCBwb2ludFswXSwgcG9pbnRbMV0sIHgxXywgeTFfLCB4Ml8sIHkyXyk7XG4gICAgICB9O1xuICAgICAgaSA9IC0xO1xuICAgICAgaWYgKHgxID09IG51bGwpIHtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBpbnNlcnQocm9vdCwgZGF0YVtpXSwgeHNbaV0sIHlzW2ldLCB4MV8sIHkxXywgeDJfLCB5Ml8pO1xuICAgICAgICB9XG4gICAgICAgIC0taTtcbiAgICAgIH0gZWxzZSBkYXRhLmZvckVhY2gocm9vdC5hZGQpO1xuICAgICAgeHMgPSB5cyA9IGRhdGEgPSBkID0gbnVsbDtcbiAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICBxdWFkdHJlZS54ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IF8sIHF1YWR0cmVlKSA6IHg7XG4gICAgfTtcbiAgICBxdWFkdHJlZS55ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IF8sIHF1YWR0cmVlKSA6IHk7XG4gICAgfTtcbiAgICBxdWFkdHJlZS5leHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4MSA9PSBudWxsID8gbnVsbCA6IFsgWyB4MSwgeTEgXSwgWyB4MiwgeTIgXSBdO1xuICAgICAgaWYgKF8gPT0gbnVsbCkgeDEgPSB5MSA9IHgyID0geTIgPSBudWxsOyBlbHNlIHgxID0gK19bMF1bMF0sIHkxID0gK19bMF1bMV0sIHgyID0gK19bMV1bMF0sIFxuICAgICAgeTIgPSArX1sxXVsxXTtcbiAgICAgIHJldHVybiBxdWFkdHJlZTtcbiAgICB9O1xuICAgIHF1YWR0cmVlLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4MSA9PSBudWxsID8gbnVsbCA6IFsgeDIgLSB4MSwgeTIgLSB5MSBdO1xuICAgICAgaWYgKF8gPT0gbnVsbCkgeDEgPSB5MSA9IHgyID0geTIgPSBudWxsOyBlbHNlIHgxID0geTEgPSAwLCB4MiA9ICtfWzBdLCB5MiA9ICtfWzFdO1xuICAgICAgcmV0dXJuIHF1YWR0cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIHF1YWR0cmVlO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX3F1YWR0cmVlQ29tcGF0WChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3F1YWR0cmVlQ29tcGF0WShkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3F1YWR0cmVlTm9kZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVhZjogdHJ1ZSxcbiAgICAgIG5vZGVzOiBbXSxcbiAgICAgIHBvaW50OiBudWxsLFxuICAgICAgeDogbnVsbCxcbiAgICAgIHk6IG51bGxcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcXVhZHRyZWVWaXNpdChmLCBub2RlLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIGlmICghZihub2RlLCB4MSwgeTEsIHgyLCB5MikpIHtcbiAgICAgIHZhciBzeCA9ICh4MSArIHgyKSAqIC41LCBzeSA9ICh5MSArIHkyKSAqIC41LCBjaGlsZHJlbiA9IG5vZGUubm9kZXM7XG4gICAgICBpZiAoY2hpbGRyZW5bMF0pIGQzX2dlb21fcXVhZHRyZWVWaXNpdChmLCBjaGlsZHJlblswXSwgeDEsIHkxLCBzeCwgc3kpO1xuICAgICAgaWYgKGNoaWxkcmVuWzFdKSBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgY2hpbGRyZW5bMV0sIHN4LCB5MSwgeDIsIHN5KTtcbiAgICAgIGlmIChjaGlsZHJlblsyXSkgZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIGNoaWxkcmVuWzJdLCB4MSwgc3ksIHN4LCB5Mik7XG4gICAgICBpZiAoY2hpbGRyZW5bM10pIGQzX2dlb21fcXVhZHRyZWVWaXNpdChmLCBjaGlsZHJlblszXSwgc3gsIHN5LCB4MiwgeTIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3F1YWR0cmVlRmluZChyb290LCB4LCB5LCB4MCwgeTAsIHgzLCB5Mykge1xuICAgIHZhciBtaW5EaXN0YW5jZTIgPSBJbmZpbml0eSwgY2xvc2VzdFBvaW50O1xuICAgIChmdW5jdGlvbiBmaW5kKG5vZGUsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICBpZiAoeDEgPiB4MyB8fCB5MSA+IHkzIHx8IHgyIDwgeDAgfHwgeTIgPCB5MCkgcmV0dXJuO1xuICAgICAgaWYgKHBvaW50ID0gbm9kZS5wb2ludCkge1xuICAgICAgICB2YXIgcG9pbnQsIGR4ID0geCAtIG5vZGUueCwgZHkgPSB5IC0gbm9kZS55LCBkaXN0YW5jZTIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgaWYgKGRpc3RhbmNlMiA8IG1pbkRpc3RhbmNlMikge1xuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChtaW5EaXN0YW5jZTIgPSBkaXN0YW5jZTIpO1xuICAgICAgICAgIHgwID0geCAtIGRpc3RhbmNlLCB5MCA9IHkgLSBkaXN0YW5jZTtcbiAgICAgICAgICB4MyA9IHggKyBkaXN0YW5jZSwgeTMgPSB5ICsgZGlzdGFuY2U7XG4gICAgICAgICAgY2xvc2VzdFBvaW50ID0gcG9pbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUubm9kZXMsIHhtID0gKHgxICsgeDIpICogLjUsIHltID0gKHkxICsgeTIpICogLjUsIHJpZ2h0ID0geCA+PSB4bSwgYmVsb3cgPSB5ID49IHltO1xuICAgICAgZm9yICh2YXIgaSA9IGJlbG93IDw8IDEgfCByaWdodCwgaiA9IGkgKyA0OyBpIDwgajsgKytpKSB7XG4gICAgICAgIGlmIChub2RlID0gY2hpbGRyZW5baSAmIDNdKSBzd2l0Y2ggKGkgJiAzKSB7XG4gICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgZmluZChub2RlLCB4MSwgeTEsIHhtLCB5bSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBmaW5kKG5vZGUsIHhtLCB5MSwgeDIsIHltKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGZpbmQobm9kZSwgeDEsIHltLCB4bSwgeTIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZmluZChub2RlLCB4bSwgeW0sIHgyLCB5Mik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KShyb290LCB4MCwgeTAsIHgzLCB5Myk7XG4gICAgcmV0dXJuIGNsb3Nlc3RQb2ludDtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZVJnYiA9IGQzX2ludGVycG9sYXRlUmdiO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVJnYihhLCBiKSB7XG4gICAgYSA9IGQzLnJnYihhKTtcbiAgICBiID0gZDMucmdiKGIpO1xuICAgIHZhciBhciA9IGEuciwgYWcgPSBhLmcsIGFiID0gYS5iLCBiciA9IGIuciAtIGFyLCBiZyA9IGIuZyAtIGFnLCBiYiA9IGIuYiAtIGFiO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gXCIjXCIgKyBkM19yZ2JfaGV4KE1hdGgucm91bmQoYXIgKyBiciAqIHQpKSArIGQzX3JnYl9oZXgoTWF0aC5yb3VuZChhZyArIGJnICogdCkpICsgZDNfcmdiX2hleChNYXRoLnJvdW5kKGFiICsgYmIgKiB0KSk7XG4gICAgfTtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZU9iamVjdCA9IGQzX2ludGVycG9sYXRlT2JqZWN0O1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZU9iamVjdChhLCBiKSB7XG4gICAgdmFyIGkgPSB7fSwgYyA9IHt9LCBrO1xuICAgIGZvciAoayBpbiBhKSB7XG4gICAgICBpZiAoayBpbiBiKSB7XG4gICAgICAgIGlba10gPSBkM19pbnRlcnBvbGF0ZShhW2tdLCBiW2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNba10gPSBhW2tdO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGsgaW4gYikge1xuICAgICAgaWYgKCEoayBpbiBhKSkge1xuICAgICAgICBjW2tdID0gYltrXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGZvciAoayBpbiBpKSBjW2tdID0gaVtrXSh0KTtcbiAgICAgIHJldHVybiBjO1xuICAgIH07XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVOdW1iZXIgPSBkM19pbnRlcnBvbGF0ZU51bWJlcjtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVOdW1iZXIoYSwgYikge1xuICAgIGEgPSArYSwgYiA9ICtiO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gYSAqICgxIC0gdCkgKyBiICogdDtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlU3RyaW5nID0gZDNfaW50ZXJwb2xhdGVTdHJpbmc7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlU3RyaW5nKGEsIGIpIHtcbiAgICB2YXIgYmkgPSBkM19pbnRlcnBvbGF0ZV9udW1iZXJBLmxhc3RJbmRleCA9IGQzX2ludGVycG9sYXRlX251bWJlckIubGFzdEluZGV4ID0gMCwgYW0sIGJtLCBicywgaSA9IC0xLCBzID0gW10sIHEgPSBbXTtcbiAgICBhID0gYSArIFwiXCIsIGIgPSBiICsgXCJcIjtcbiAgICB3aGlsZSAoKGFtID0gZDNfaW50ZXJwb2xhdGVfbnVtYmVyQS5leGVjKGEpKSAmJiAoYm0gPSBkM19pbnRlcnBvbGF0ZV9udW1iZXJCLmV4ZWMoYikpKSB7XG4gICAgICBpZiAoKGJzID0gYm0uaW5kZXgpID4gYmkpIHtcbiAgICAgICAgYnMgPSBiLnNsaWNlKGJpLCBicyk7XG4gICAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyBlbHNlIHNbKytpXSA9IGJzO1xuICAgICAgfVxuICAgICAgaWYgKChhbSA9IGFtWzBdKSA9PT0gKGJtID0gYm1bMF0pKSB7XG4gICAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJtOyBlbHNlIHNbKytpXSA9IGJtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc1srK2ldID0gbnVsbDtcbiAgICAgICAgcS5wdXNoKHtcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKGFtLCBibSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBiaSA9IGQzX2ludGVycG9sYXRlX251bWJlckIubGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoYmkgPCBiLmxlbmd0aCkge1xuICAgICAgYnMgPSBiLnNsaWNlKGJpKTtcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyBlbHNlIHNbKytpXSA9IGJzO1xuICAgIH1cbiAgICByZXR1cm4gcy5sZW5ndGggPCAyID8gcVswXSA/IChiID0gcVswXS54LCBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gYih0KSArIFwiXCI7XG4gICAgfSkgOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH0gOiAoYiA9IHEubGVuZ3RoLCBmdW5jdGlvbih0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IGI7ICsraSkgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICB9KTtcbiAgfVxuICB2YXIgZDNfaW50ZXJwb2xhdGVfbnVtYmVyQSA9IC9bLStdPyg/OlxcZCtcXC4/XFxkKnxcXC4/XFxkKykoPzpbZUVdWy0rXT9cXGQrKT8vZywgZDNfaW50ZXJwb2xhdGVfbnVtYmVyQiA9IG5ldyBSZWdFeHAoZDNfaW50ZXJwb2xhdGVfbnVtYmVyQS5zb3VyY2UsIFwiZ1wiKTtcbiAgZDMuaW50ZXJwb2xhdGUgPSBkM19pbnRlcnBvbGF0ZTtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGUoYSwgYikge1xuICAgIHZhciBpID0gZDMuaW50ZXJwb2xhdG9ycy5sZW5ndGgsIGY7XG4gICAgd2hpbGUgKC0taSA+PSAwICYmICEoZiA9IGQzLmludGVycG9sYXRvcnNbaV0oYSwgYikpKSA7XG4gICAgcmV0dXJuIGY7XG4gIH1cbiAgZDMuaW50ZXJwb2xhdG9ycyA9IFsgZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB0ID0gdHlwZW9mIGI7XG4gICAgcmV0dXJuICh0ID09PSBcInN0cmluZ1wiID8gZDNfcmdiX25hbWVzLmhhcyhiLnRvTG93ZXJDYXNlKCkpIHx8IC9eKCN8cmdiXFwofGhzbFxcKCkvaS50ZXN0KGIpID8gZDNfaW50ZXJwb2xhdGVSZ2IgOiBkM19pbnRlcnBvbGF0ZVN0cmluZyA6IGIgaW5zdGFuY2VvZiBkM19jb2xvciA/IGQzX2ludGVycG9sYXRlUmdiIDogQXJyYXkuaXNBcnJheShiKSA/IGQzX2ludGVycG9sYXRlQXJyYXkgOiB0ID09PSBcIm9iamVjdFwiICYmIGlzTmFOKGIpID8gZDNfaW50ZXJwb2xhdGVPYmplY3QgOiBkM19pbnRlcnBvbGF0ZU51bWJlcikoYSwgYik7XG4gIH0gXTtcbiAgZDMuaW50ZXJwb2xhdGVBcnJheSA9IGQzX2ludGVycG9sYXRlQXJyYXk7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlQXJyYXkoYSwgYikge1xuICAgIHZhciB4ID0gW10sIGMgPSBbXSwgbmEgPSBhLmxlbmd0aCwgbmIgPSBiLmxlbmd0aCwgbjAgPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuMDsgKytpKSB4LnB1c2goZDNfaW50ZXJwb2xhdGUoYVtpXSwgYltpXSkpO1xuICAgIGZvciAoO2kgPCBuYTsgKytpKSBjW2ldID0gYVtpXTtcbiAgICBmb3IgKDtpIDwgbmI7ICsraSkgY1tpXSA9IGJbaV07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuMDsgKytpKSBjW2ldID0geFtpXSh0KTtcbiAgICAgIHJldHVybiBjO1xuICAgIH07XG4gIH1cbiAgdmFyIGQzX2Vhc2VfZGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19pZGVudGl0eTtcbiAgfTtcbiAgdmFyIGQzX2Vhc2UgPSBkMy5tYXAoe1xuICAgIGxpbmVhcjogZDNfZWFzZV9kZWZhdWx0LFxuICAgIHBvbHk6IGQzX2Vhc2VfcG9seSxcbiAgICBxdWFkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX3F1YWQ7XG4gICAgfSxcbiAgICBjdWJpYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfZWFzZV9jdWJpYztcbiAgICB9LFxuICAgIHNpbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfZWFzZV9zaW47XG4gICAgfSxcbiAgICBleHA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfZXhwO1xuICAgIH0sXG4gICAgY2lyY2xlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX2NpcmNsZTtcbiAgICB9LFxuICAgIGVsYXN0aWM6IGQzX2Vhc2VfZWxhc3RpYyxcbiAgICBiYWNrOiBkM19lYXNlX2JhY2ssXG4gICAgYm91bmNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX2JvdW5jZTtcbiAgICB9XG4gIH0pO1xuICB2YXIgZDNfZWFzZV9tb2RlID0gZDMubWFwKHtcbiAgICBcImluXCI6IGQzX2lkZW50aXR5LFxuICAgIG91dDogZDNfZWFzZV9yZXZlcnNlLFxuICAgIFwiaW4tb3V0XCI6IGQzX2Vhc2VfcmVmbGVjdCxcbiAgICBcIm91dC1pblwiOiBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZDNfZWFzZV9yZWZsZWN0KGQzX2Vhc2VfcmV2ZXJzZShmKSk7XG4gICAgfVxuICB9KTtcbiAgZDMuZWFzZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IG5hbWUuaW5kZXhPZihcIi1cIiksIHQgPSBpID49IDAgPyBuYW1lLnNsaWNlKDAsIGkpIDogbmFtZSwgbSA9IGkgPj0gMCA/IG5hbWUuc2xpY2UoaSArIDEpIDogXCJpblwiO1xuICAgIHQgPSBkM19lYXNlLmdldCh0KSB8fCBkM19lYXNlX2RlZmF1bHQ7XG4gICAgbSA9IGQzX2Vhc2VfbW9kZS5nZXQobSkgfHwgZDNfaWRlbnRpdHk7XG4gICAgcmV0dXJuIGQzX2Vhc2VfY2xhbXAobSh0LmFwcGx5KG51bGwsIGQzX2FycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19lYXNlX2NsYW1wKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHQgPD0gMCA/IDAgOiB0ID49IDEgPyAxIDogZih0KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfcmV2ZXJzZShmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiAxIC0gZigxIC0gdCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX3JlZmxlY3QoZikge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gLjUgKiAodCA8IC41ID8gZigyICogdCkgOiAyIC0gZigyIC0gMiAqIHQpKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfcXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfY3ViaWModCkge1xuICAgIHJldHVybiB0ICogdCAqIHQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9jdWJpY0luT3V0KHQpIHtcbiAgICBpZiAodCA8PSAwKSByZXR1cm4gMDtcbiAgICBpZiAodCA+PSAxKSByZXR1cm4gMTtcbiAgICB2YXIgdDIgPSB0ICogdCwgdDMgPSB0MiAqIHQ7XG4gICAgcmV0dXJuIDQgKiAodCA8IC41ID8gdDMgOiAzICogKHQgLSB0MikgKyB0MyAtIC43NSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9wb2x5KGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIE1hdGgucG93KHQsIGUpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9zaW4odCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5jb3ModCAqIGhhbGbPgCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9leHAodCkge1xuICAgIHJldHVybiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfY2lyY2xlKHQpIHtcbiAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfZWxhc3RpYyhhLCBwKSB7XG4gICAgdmFyIHM7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBwID0gLjQ1O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSBzID0gcCAvIM+EICogTWF0aC5hc2luKDEgLyBhKTsgZWxzZSBhID0gMSwgcyA9IHAgLyA0O1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gMSArIGEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0IC0gcykgKiDPhCAvIHApO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9iYWNrKHMpIHtcbiAgICBpZiAoIXMpIHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfYm91bmNlKHQpIHtcbiAgICByZXR1cm4gdCA8IDEgLyAyLjc1ID8gNy41NjI1ICogdCAqIHQgOiB0IDwgMiAvIDIuNzUgPyA3LjU2MjUgKiAodCAtPSAxLjUgLyAyLjc1KSAqIHQgKyAuNzUgOiB0IDwgMi41IC8gMi43NSA/IDcuNTYyNSAqICh0IC09IDIuMjUgLyAyLjc1KSAqIHQgKyAuOTM3NSA6IDcuNTYyNSAqICh0IC09IDIuNjI1IC8gMi43NSkgKiB0ICsgLjk4NDM3NTtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZUhjbCA9IGQzX2ludGVycG9sYXRlSGNsO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZUhjbChhLCBiKSB7XG4gICAgYSA9IGQzLmhjbChhKTtcbiAgICBiID0gZDMuaGNsKGIpO1xuICAgIHZhciBhaCA9IGEuaCwgYWMgPSBhLmMsIGFsID0gYS5sLCBiaCA9IGIuaCAtIGFoLCBiYyA9IGIuYyAtIGFjLCBibCA9IGIubCAtIGFsO1xuICAgIGlmIChpc05hTihiYykpIGJjID0gMCwgYWMgPSBpc05hTihhYykgPyBiLmMgOiBhYztcbiAgICBpZiAoaXNOYU4oYmgpKSBiaCA9IDAsIGFoID0gaXNOYU4oYWgpID8gYi5oIDogYWg7IGVsc2UgaWYgKGJoID4gMTgwKSBiaCAtPSAzNjA7IGVsc2UgaWYgKGJoIDwgLTE4MCkgYmggKz0gMzYwO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gZDNfaGNsX2xhYihhaCArIGJoICogdCwgYWMgKyBiYyAqIHQsIGFsICsgYmwgKiB0KSArIFwiXCI7XG4gICAgfTtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZUhzbCA9IGQzX2ludGVycG9sYXRlSHNsO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZUhzbChhLCBiKSB7XG4gICAgYSA9IGQzLmhzbChhKTtcbiAgICBiID0gZDMuaHNsKGIpO1xuICAgIHZhciBhaCA9IGEuaCwgYXMgPSBhLnMsIGFsID0gYS5sLCBiaCA9IGIuaCAtIGFoLCBicyA9IGIucyAtIGFzLCBibCA9IGIubCAtIGFsO1xuICAgIGlmIChpc05hTihicykpIGJzID0gMCwgYXMgPSBpc05hTihhcykgPyBiLnMgOiBhcztcbiAgICBpZiAoaXNOYU4oYmgpKSBiaCA9IDAsIGFoID0gaXNOYU4oYWgpID8gYi5oIDogYWg7IGVsc2UgaWYgKGJoID4gMTgwKSBiaCAtPSAzNjA7IGVsc2UgaWYgKGJoIDwgLTE4MCkgYmggKz0gMzYwO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gZDNfaHNsX3JnYihhaCArIGJoICogdCwgYXMgKyBicyAqIHQsIGFsICsgYmwgKiB0KSArIFwiXCI7XG4gICAgfTtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZUxhYiA9IGQzX2ludGVycG9sYXRlTGFiO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZUxhYihhLCBiKSB7XG4gICAgYSA9IGQzLmxhYihhKTtcbiAgICBiID0gZDMubGFiKGIpO1xuICAgIHZhciBhbCA9IGEubCwgYWEgPSBhLmEsIGFiID0gYS5iLCBibCA9IGIubCAtIGFsLCBiYSA9IGIuYSAtIGFhLCBiYiA9IGIuYiAtIGFiO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gZDNfbGFiX3JnYihhbCArIGJsICogdCwgYWEgKyBiYSAqIHQsIGFiICsgYmIgKiB0KSArIFwiXCI7XG4gICAgfTtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZVJvdW5kID0gZDNfaW50ZXJwb2xhdGVSb3VuZDtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVSb3VuZChhLCBiKSB7XG4gICAgYiAtPSBhO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChhICsgYiAqIHQpO1xuICAgIH07XG4gIH1cbiAgZDMudHJhbnNmb3JtID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGcgPSBkM19kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZDMubnMucHJlZml4LnN2ZywgXCJnXCIpO1xuICAgIHJldHVybiAoZDMudHJhbnNmb3JtID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICBpZiAoc3RyaW5nICE9IG51bGwpIHtcbiAgICAgICAgZy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgc3RyaW5nKTtcbiAgICAgICAgdmFyIHQgPSBnLnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IGQzX3RyYW5zZm9ybSh0ID8gdC5tYXRyaXggOiBkM190cmFuc2Zvcm1JZGVudGl0eSk7XG4gICAgfSkoc3RyaW5nKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdHJhbnNmb3JtKG0pIHtcbiAgICB2YXIgcjAgPSBbIG0uYSwgbS5iIF0sIHIxID0gWyBtLmMsIG0uZCBdLCBreCA9IGQzX3RyYW5zZm9ybU5vcm1hbGl6ZShyMCksIGt6ID0gZDNfdHJhbnNmb3JtRG90KHIwLCByMSksIGt5ID0gZDNfdHJhbnNmb3JtTm9ybWFsaXplKGQzX3RyYW5zZm9ybUNvbWJpbmUocjEsIHIwLCAta3opKSB8fCAwO1xuICAgIGlmIChyMFswXSAqIHIxWzFdIDwgcjFbMF0gKiByMFsxXSkge1xuICAgICAgcjBbMF0gKj0gLTE7XG4gICAgICByMFsxXSAqPSAtMTtcbiAgICAgIGt4ICo9IC0xO1xuICAgICAga3ogKj0gLTE7XG4gICAgfVxuICAgIHRoaXMucm90YXRlID0gKGt4ID8gTWF0aC5hdGFuMihyMFsxXSwgcjBbMF0pIDogTWF0aC5hdGFuMigtcjFbMF0sIHIxWzFdKSkgKiBkM19kZWdyZWVzO1xuICAgIHRoaXMudHJhbnNsYXRlID0gWyBtLmUsIG0uZiBdO1xuICAgIHRoaXMuc2NhbGUgPSBbIGt4LCBreSBdO1xuICAgIHRoaXMuc2tldyA9IGt5ID8gTWF0aC5hdGFuMihreiwga3kpICogZDNfZGVncmVlcyA6IDA7XG4gIH1cbiAgZDNfdHJhbnNmb3JtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIHRoaXMudHJhbnNsYXRlICsgXCIpcm90YXRlKFwiICsgdGhpcy5yb3RhdGUgKyBcIilza2V3WChcIiArIHRoaXMuc2tldyArIFwiKXNjYWxlKFwiICsgdGhpcy5zY2FsZSArIFwiKVwiO1xuICB9O1xuICBmdW5jdGlvbiBkM190cmFuc2Zvcm1Eb3QoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RyYW5zZm9ybU5vcm1hbGl6ZShhKSB7XG4gICAgdmFyIGsgPSBNYXRoLnNxcnQoZDNfdHJhbnNmb3JtRG90KGEsIGEpKTtcbiAgICBpZiAoaykge1xuICAgICAgYVswXSAvPSBrO1xuICAgICAgYVsxXSAvPSBrO1xuICAgIH1cbiAgICByZXR1cm4gaztcbiAgfVxuICBmdW5jdGlvbiBkM190cmFuc2Zvcm1Db21iaW5lKGEsIGIsIGspIHtcbiAgICBhWzBdICs9IGsgKiBiWzBdO1xuICAgIGFbMV0gKz0gayAqIGJbMV07XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgdmFyIGQzX3RyYW5zZm9ybUlkZW50aXR5ID0ge1xuICAgIGE6IDEsXG4gICAgYjogMCxcbiAgICBjOiAwLFxuICAgIGQ6IDEsXG4gICAgZTogMCxcbiAgICBmOiAwXG4gIH07XG4gIGQzLmludGVycG9sYXRlVHJhbnNmb3JtID0gZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm07XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlVHJhbnNmb3JtUG9wKHMpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPyBzLnBvcCgpICsgXCIsXCIgOiBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlVHJhbnNsYXRlKHRhLCB0YiwgcywgcSkge1xuICAgIGlmICh0YVswXSAhPT0gdGJbMF0gfHwgdGFbMV0gIT09IHRiWzFdKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChcInRyYW5zbGF0ZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcbiAgICAgIHEucHVzaCh7XG4gICAgICAgIGk6IGkgLSA0LFxuICAgICAgICB4OiBkM19pbnRlcnBvbGF0ZU51bWJlcih0YVswXSwgdGJbMF0pXG4gICAgICB9LCB7XG4gICAgICAgIGk6IGkgLSAyLFxuICAgICAgICB4OiBkM19pbnRlcnBvbGF0ZU51bWJlcih0YVsxXSwgdGJbMV0pXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRiWzBdIHx8IHRiWzFdKSB7XG4gICAgICBzLnB1c2goXCJ0cmFuc2xhdGUoXCIgKyB0YiArIFwiKVwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVSb3RhdGUocmEsIHJiLCBzLCBxKSB7XG4gICAgaWYgKHJhICE9PSByYikge1xuICAgICAgaWYgKHJhIC0gcmIgPiAxODApIHJiICs9IDM2MDsgZWxzZSBpZiAocmIgLSByYSA+IDE4MCkgcmEgKz0gMzYwO1xuICAgICAgcS5wdXNoKHtcbiAgICAgICAgaTogcy5wdXNoKGQzX2ludGVycG9sYXRlVHJhbnNmb3JtUG9wKHMpICsgXCJyb3RhdGUoXCIsIG51bGwsIFwiKVwiKSAtIDIsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKHJhLCByYilcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocmIpIHtcbiAgICAgIHMucHVzaChkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSArIFwicm90YXRlKFwiICsgcmIgKyBcIilcIik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlU2tldyh3YSwgd2IsIHMsIHEpIHtcbiAgICBpZiAod2EgIT09IHdiKSB7XG4gICAgICBxLnB1c2goe1xuICAgICAgICBpOiBzLnB1c2goZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3AocykgKyBcInNrZXdYKFwiLCBudWxsLCBcIilcIikgLSAyLFxuICAgICAgICB4OiBkM19pbnRlcnBvbGF0ZU51bWJlcih3YSwgd2IpXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHdiKSB7XG4gICAgICBzLnB1c2goZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3AocykgKyBcInNrZXdYKFwiICsgd2IgKyBcIilcIik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlU2NhbGUoa2EsIGtiLCBzLCBxKSB7XG4gICAgaWYgKGthWzBdICE9PSBrYlswXSB8fCBrYVsxXSAhPT0ga2JbMV0pIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKGQzX2ludGVycG9sYXRlVHJhbnNmb3JtUG9wKHMpICsgXCJzY2FsZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcbiAgICAgIHEucHVzaCh7XG4gICAgICAgIGk6IGkgLSA0LFxuICAgICAgICB4OiBkM19pbnRlcnBvbGF0ZU51bWJlcihrYVswXSwga2JbMF0pXG4gICAgICB9LCB7XG4gICAgICAgIGk6IGkgLSAyLFxuICAgICAgICB4OiBkM19pbnRlcnBvbGF0ZU51bWJlcihrYVsxXSwga2JbMV0pXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGtiWzBdICE9PSAxIHx8IGtiWzFdICE9PSAxKSB7XG4gICAgICBzLnB1c2goZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3AocykgKyBcInNjYWxlKFwiICsga2IgKyBcIilcIik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlVHJhbnNmb3JtKGEsIGIpIHtcbiAgICB2YXIgcyA9IFtdLCBxID0gW107XG4gICAgYSA9IGQzLnRyYW5zZm9ybShhKSwgYiA9IGQzLnRyYW5zZm9ybShiKTtcbiAgICBkM19pbnRlcnBvbGF0ZVRyYW5zbGF0ZShhLnRyYW5zbGF0ZSwgYi50cmFuc2xhdGUsIHMsIHEpO1xuICAgIGQzX2ludGVycG9sYXRlUm90YXRlKGEucm90YXRlLCBiLnJvdGF0ZSwgcywgcSk7XG4gICAgZDNfaW50ZXJwb2xhdGVTa2V3KGEuc2tldywgYi5za2V3LCBzLCBxKTtcbiAgICBkM19pbnRlcnBvbGF0ZVNjYWxlKGEuc2NhbGUsIGIuc2NhbGUsIHMsIHEpO1xuICAgIGEgPSBiID0gbnVsbDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IHEubGVuZ3RoLCBvO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM191bmludGVycG9sYXRlTnVtYmVyKGEsIGIpIHtcbiAgICBiID0gKGIgLT0gYSA9ICthKSB8fCAxIC8gYjtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuICh4IC0gYSkgLyBiO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfdW5pbnRlcnBvbGF0ZUNsYW1wKGEsIGIpIHtcbiAgICBiID0gKGIgLT0gYSA9ICthKSB8fCAxIC8gYjtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEsICh4IC0gYSkgLyBiKSk7XG4gICAgfTtcbiAgfVxuICBkMy5sYXlvdXQgPSB7fTtcbiAgZDMubGF5b3V0LmJ1bmRsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihsaW5rcykge1xuICAgICAgdmFyIHBhdGhzID0gW10sIGkgPSAtMSwgbiA9IGxpbmtzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBwYXRocy5wdXNoKGQzX2xheW91dF9idW5kbGVQYXRoKGxpbmtzW2ldKSk7XG4gICAgICByZXR1cm4gcGF0aHM7XG4gICAgfTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2J1bmRsZVBhdGgobGluaykge1xuICAgIHZhciBzdGFydCA9IGxpbmsuc291cmNlLCBlbmQgPSBsaW5rLnRhcmdldCwgbGNhID0gZDNfbGF5b3V0X2J1bmRsZUxlYXN0Q29tbW9uQW5jZXN0b3Ioc3RhcnQsIGVuZCksIHBvaW50cyA9IFsgc3RhcnQgXTtcbiAgICB3aGlsZSAoc3RhcnQgIT09IGxjYSkge1xuICAgICAgc3RhcnQgPSBzdGFydC5wYXJlbnQ7XG4gICAgICBwb2ludHMucHVzaChzdGFydCk7XG4gICAgfVxuICAgIHZhciBrID0gcG9pbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoZW5kICE9PSBsY2EpIHtcbiAgICAgIHBvaW50cy5zcGxpY2UoaywgMCwgZW5kKTtcbiAgICAgIGVuZCA9IGVuZC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2J1bmRsZUFuY2VzdG9ycyhub2RlKSB7XG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdLCBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuICAgIHJldHVybiBhbmNlc3RvcnM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2J1bmRsZUxlYXN0Q29tbW9uQW5jZXN0b3IoYSwgYikge1xuICAgIGlmIChhID09PSBiKSByZXR1cm4gYTtcbiAgICB2YXIgYU5vZGVzID0gZDNfbGF5b3V0X2J1bmRsZUFuY2VzdG9ycyhhKSwgYk5vZGVzID0gZDNfbGF5b3V0X2J1bmRsZUFuY2VzdG9ycyhiKSwgYU5vZGUgPSBhTm9kZXMucG9wKCksIGJOb2RlID0gYk5vZGVzLnBvcCgpLCBzaGFyZWROb2RlID0gbnVsbDtcbiAgICB3aGlsZSAoYU5vZGUgPT09IGJOb2RlKSB7XG4gICAgICBzaGFyZWROb2RlID0gYU5vZGU7XG4gICAgICBhTm9kZSA9IGFOb2Rlcy5wb3AoKTtcbiAgICAgIGJOb2RlID0gYk5vZGVzLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcmVkTm9kZTtcbiAgfVxuICBkMy5sYXlvdXQuY2hvcmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2hvcmQgPSB7fSwgY2hvcmRzLCBncm91cHMsIG1hdHJpeCwgbiwgcGFkZGluZyA9IDAsIHNvcnRHcm91cHMsIHNvcnRTdWJncm91cHMsIHNvcnRDaG9yZHM7XG4gICAgZnVuY3Rpb24gcmVsYXlvdXQoKSB7XG4gICAgICB2YXIgc3ViZ3JvdXBzID0ge30sIGdyb3VwU3VtcyA9IFtdLCBncm91cEluZGV4ID0gZDMucmFuZ2UobiksIHN1Ymdyb3VwSW5kZXggPSBbXSwgaywgeCwgeDAsIGksIGo7XG4gICAgICBjaG9yZHMgPSBbXTtcbiAgICAgIGdyb3VwcyA9IFtdO1xuICAgICAgayA9IDAsIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIHggPSAwLCBqID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2ogPCBuKSB7XG4gICAgICAgICAgeCArPSBtYXRyaXhbaV1bal07XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBTdW1zLnB1c2goeCk7XG4gICAgICAgIHN1Ymdyb3VwSW5kZXgucHVzaChkMy5yYW5nZShuKSk7XG4gICAgICAgIGsgKz0geDtcbiAgICAgIH1cbiAgICAgIGlmIChzb3J0R3JvdXBzKSB7XG4gICAgICAgIGdyb3VwSW5kZXguc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIHNvcnRHcm91cHMoZ3JvdXBTdW1zW2FdLCBncm91cFN1bXNbYl0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3J0U3ViZ3JvdXBzKSB7XG4gICAgICAgIHN1Ymdyb3VwSW5kZXguZm9yRWFjaChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0U3ViZ3JvdXBzKG1hdHJpeFtpXVthXSwgbWF0cml4W2ldW2JdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBrID0gKM+EIC0gcGFkZGluZyAqIG4pIC8gaztcbiAgICAgIHggPSAwLCBpID0gLTE7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICB4MCA9IHgsIGogPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraiA8IG4pIHtcbiAgICAgICAgICB2YXIgZGkgPSBncm91cEluZGV4W2ldLCBkaiA9IHN1Ymdyb3VwSW5kZXhbZGldW2pdLCB2ID0gbWF0cml4W2RpXVtkal0sIGEwID0geCwgYTEgPSB4ICs9IHYgKiBrO1xuICAgICAgICAgIHN1Ymdyb3Vwc1tkaSArIFwiLVwiICsgZGpdID0ge1xuICAgICAgICAgICAgaW5kZXg6IGRpLFxuICAgICAgICAgICAgc3ViaW5kZXg6IGRqLFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogYTAsXG4gICAgICAgICAgICBlbmRBbmdsZTogYTEsXG4gICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBzW2RpXSA9IHtcbiAgICAgICAgICBpbmRleDogZGksXG4gICAgICAgICAgc3RhcnRBbmdsZTogeDAsXG4gICAgICAgICAgZW5kQW5nbGU6IHgsXG4gICAgICAgICAgdmFsdWU6IGdyb3VwU3Vtc1tkaV1cbiAgICAgICAgfTtcbiAgICAgICAgeCArPSBwYWRkaW5nO1xuICAgICAgfVxuICAgICAgaSA9IC0xO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaiA9IGkgLSAxO1xuICAgICAgICB3aGlsZSAoKytqIDwgbikge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBzdWJncm91cHNbaSArIFwiLVwiICsgal0sIHRhcmdldCA9IHN1Ymdyb3Vwc1tqICsgXCItXCIgKyBpXTtcbiAgICAgICAgICBpZiAoc291cmNlLnZhbHVlIHx8IHRhcmdldC52YWx1ZSkge1xuICAgICAgICAgICAgY2hvcmRzLnB1c2goc291cmNlLnZhbHVlIDwgdGFyZ2V0LnZhbHVlID8ge1xuICAgICAgICAgICAgICBzb3VyY2U6IHRhcmdldCxcbiAgICAgICAgICAgICAgdGFyZ2V0OiBzb3VyY2VcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc29ydENob3JkcykgcmVzb3J0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29ydCgpIHtcbiAgICAgIGNob3Jkcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRDaG9yZHMoKGEuc291cmNlLnZhbHVlICsgYS50YXJnZXQudmFsdWUpIC8gMiwgKGIuc291cmNlLnZhbHVlICsgYi50YXJnZXQudmFsdWUpIC8gMik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2hvcmQubWF0cml4ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWF0cml4O1xuICAgICAgbiA9IChtYXRyaXggPSB4KSAmJiBtYXRyaXgubGVuZ3RoO1xuICAgICAgY2hvcmRzID0gZ3JvdXBzID0gbnVsbDtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnBhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRkaW5nO1xuICAgICAgcGFkZGluZyA9IHg7XG4gICAgICBjaG9yZHMgPSBncm91cHMgPSBudWxsO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuc29ydEdyb3VwcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvcnRHcm91cHM7XG4gICAgICBzb3J0R3JvdXBzID0geDtcbiAgICAgIGNob3JkcyA9IGdyb3VwcyA9IG51bGw7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5zb3J0U3ViZ3JvdXBzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc29ydFN1Ymdyb3VwcztcbiAgICAgIHNvcnRTdWJncm91cHMgPSB4O1xuICAgICAgY2hvcmRzID0gbnVsbDtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnNvcnRDaG9yZHMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3J0Q2hvcmRzO1xuICAgICAgc29ydENob3JkcyA9IHg7XG4gICAgICBpZiAoY2hvcmRzKSByZXNvcnQoKTtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLmNob3JkcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFjaG9yZHMpIHJlbGF5b3V0KCk7XG4gICAgICByZXR1cm4gY2hvcmRzO1xuICAgIH07XG4gICAgY2hvcmQuZ3JvdXBzID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWdyb3VwcykgcmVsYXlvdXQoKTtcbiAgICAgIHJldHVybiBncm91cHM7XG4gICAgfTtcbiAgICByZXR1cm4gY2hvcmQ7XG4gIH07XG4gIGQzLmxheW91dC5mb3JjZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmb3JjZSA9IHt9LCBldmVudCA9IGQzLmRpc3BhdGNoKFwic3RhcnRcIiwgXCJ0aWNrXCIsIFwiZW5kXCIpLCB0aW1lciwgc2l6ZSA9IFsgMSwgMSBdLCBkcmFnLCBhbHBoYSwgZnJpY3Rpb24gPSAuOSwgbGlua0Rpc3RhbmNlID0gZDNfbGF5b3V0X2ZvcmNlTGlua0Rpc3RhbmNlLCBsaW5rU3RyZW5ndGggPSBkM19sYXlvdXRfZm9yY2VMaW5rU3RyZW5ndGgsIGNoYXJnZSA9IC0zMCwgY2hhcmdlRGlzdGFuY2UyID0gZDNfbGF5b3V0X2ZvcmNlQ2hhcmdlRGlzdGFuY2UyLCBncmF2aXR5ID0gLjEsIHRoZXRhMiA9IC42NCwgbm9kZXMgPSBbXSwgbGlua3MgPSBbXSwgZGlzdGFuY2VzLCBzdHJlbmd0aHMsIGNoYXJnZXM7XG4gICAgZnVuY3Rpb24gcmVwdWxzZShub2RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocXVhZCwgeDEsIF8sIHgyKSB7XG4gICAgICAgIGlmIChxdWFkLnBvaW50ICE9PSBub2RlKSB7XG4gICAgICAgICAgdmFyIGR4ID0gcXVhZC5jeCAtIG5vZGUueCwgZHkgPSBxdWFkLmN5IC0gbm9kZS55LCBkdyA9IHgyIC0geDEsIGRuID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgICAgaWYgKGR3ICogZHcgLyB0aGV0YTIgPCBkbikge1xuICAgICAgICAgICAgaWYgKGRuIDwgY2hhcmdlRGlzdGFuY2UyKSB7XG4gICAgICAgICAgICAgIHZhciBrID0gcXVhZC5jaGFyZ2UgLyBkbjtcbiAgICAgICAgICAgICAgbm9kZS5weCAtPSBkeCAqIGs7XG4gICAgICAgICAgICAgIG5vZGUucHkgLT0gZHkgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChxdWFkLnBvaW50ICYmIGRuICYmIGRuIDwgY2hhcmdlRGlzdGFuY2UyKSB7XG4gICAgICAgICAgICB2YXIgayA9IHF1YWQucG9pbnRDaGFyZ2UgLyBkbjtcbiAgICAgICAgICAgIG5vZGUucHggLT0gZHggKiBrO1xuICAgICAgICAgICAgbm9kZS5weSAtPSBkeSAqIGs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhcXVhZC5jaGFyZ2U7XG4gICAgICB9O1xuICAgIH1cbiAgICBmb3JjZS50aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoKGFscGhhICo9IC45OSkgPCAuMDA1KSB7XG4gICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgZXZlbnQuZW5kKHtcbiAgICAgICAgICB0eXBlOiBcImVuZFwiLFxuICAgICAgICAgIGFscGhhOiBhbHBoYSA9IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIG4gPSBub2Rlcy5sZW5ndGgsIG0gPSBsaW5rcy5sZW5ndGgsIHEsIGksIG8sIHMsIHQsIGwsIGssIHgsIHk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICAgIG8gPSBsaW5rc1tpXTtcbiAgICAgICAgcyA9IG8uc291cmNlO1xuICAgICAgICB0ID0gby50YXJnZXQ7XG4gICAgICAgIHggPSB0LnggLSBzLng7XG4gICAgICAgIHkgPSB0LnkgLSBzLnk7XG4gICAgICAgIGlmIChsID0geCAqIHggKyB5ICogeSkge1xuICAgICAgICAgIGwgPSBhbHBoYSAqIHN0cmVuZ3Roc1tpXSAqICgobCA9IE1hdGguc3FydChsKSkgLSBkaXN0YW5jZXNbaV0pIC8gbDtcbiAgICAgICAgICB4ICo9IGw7XG4gICAgICAgICAgeSAqPSBsO1xuICAgICAgICAgIHQueCAtPSB4ICogKGsgPSBzLndlaWdodCArIHQud2VpZ2h0ID8gcy53ZWlnaHQgLyAocy53ZWlnaHQgKyB0LndlaWdodCkgOiAuNSk7XG4gICAgICAgICAgdC55IC09IHkgKiBrO1xuICAgICAgICAgIHMueCArPSB4ICogKGsgPSAxIC0gayk7XG4gICAgICAgICAgcy55ICs9IHkgKiBrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoayA9IGFscGhhICogZ3Jhdml0eSkge1xuICAgICAgICB4ID0gc2l6ZVswXSAvIDI7XG4gICAgICAgIHkgPSBzaXplWzFdIC8gMjtcbiAgICAgICAgaSA9IC0xO1xuICAgICAgICBpZiAoaykgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBvID0gbm9kZXNbaV07XG4gICAgICAgICAgby54ICs9ICh4IC0gby54KSAqIGs7XG4gICAgICAgICAgby55ICs9ICh5IC0gby55KSAqIGs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaGFyZ2UpIHtcbiAgICAgICAgZDNfbGF5b3V0X2ZvcmNlQWNjdW11bGF0ZShxID0gZDMuZ2VvbS5xdWFkdHJlZShub2RlcyksIGFscGhhLCBjaGFyZ2VzKTtcbiAgICAgICAgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIGlmICghKG8gPSBub2Rlc1tpXSkuZml4ZWQpIHtcbiAgICAgICAgICAgIHEudmlzaXQocmVwdWxzZShvKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpID0gLTE7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBvID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChvLmZpeGVkKSB7XG4gICAgICAgICAgby54ID0gby5weDtcbiAgICAgICAgICBvLnkgPSBvLnB5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8ueCAtPSAoby5weCAtIChvLnB4ID0gby54KSkgKiBmcmljdGlvbjtcbiAgICAgICAgICBvLnkgLT0gKG8ucHkgLSAoby5weSA9IG8ueSkpICogZnJpY3Rpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGV2ZW50LnRpY2soe1xuICAgICAgICB0eXBlOiBcInRpY2tcIixcbiAgICAgICAgYWxwaGE6IGFscGhhXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZvcmNlLm5vZGVzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9kZXM7XG4gICAgICBub2RlcyA9IHg7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5saW5rcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxpbmtzO1xuICAgICAgbGlua3MgPSB4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2Uuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0geDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmxpbmtEaXN0YW5jZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxpbmtEaXN0YW5jZTtcbiAgICAgIGxpbmtEaXN0YW5jZSA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogK3g7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5kaXN0YW5jZSA9IGZvcmNlLmxpbmtEaXN0YW5jZTtcbiAgICBmb3JjZS5saW5rU3RyZW5ndGggPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsaW5rU3RyZW5ndGg7XG4gICAgICBsaW5rU3RyZW5ndGggPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6ICt4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UuZnJpY3Rpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBmcmljdGlvbjtcbiAgICAgIGZyaWN0aW9uID0gK3g7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5jaGFyZ2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjaGFyZ2U7XG4gICAgICBjaGFyZ2UgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6ICt4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UuY2hhcmdlRGlzdGFuY2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBNYXRoLnNxcnQoY2hhcmdlRGlzdGFuY2UyKTtcbiAgICAgIGNoYXJnZURpc3RhbmNlMiA9IHggKiB4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UuZ3Jhdml0eSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXZpdHk7XG4gICAgICBncmF2aXR5ID0gK3g7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS50aGV0YSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIE1hdGguc3FydCh0aGV0YTIpO1xuICAgICAgdGhldGEyID0geCAqIHg7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5hbHBoYSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGFscGhhO1xuICAgICAgeCA9ICt4O1xuICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgIGlmICh4ID4gMCkge1xuICAgICAgICAgIGFscGhhID0geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lci5jID0gbnVsbCwgdGltZXIudCA9IE5hTiwgdGltZXIgPSBudWxsO1xuICAgICAgICAgIGV2ZW50LmVuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImVuZFwiLFxuICAgICAgICAgICAgYWxwaGE6IGFscGhhID0gMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHggPiAwKSB7XG4gICAgICAgIGV2ZW50LnN0YXJ0KHtcbiAgICAgICAgICB0eXBlOiBcInN0YXJ0XCIsXG4gICAgICAgICAgYWxwaGE6IGFscGhhID0geFxuICAgICAgICB9KTtcbiAgICAgICAgdGltZXIgPSBkM190aW1lcihmb3JjZS50aWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbSA9IGxpbmtzLmxlbmd0aCwgdyA9IHNpemVbMF0sIGggPSBzaXplWzFdLCBuZWlnaGJvcnMsIG87XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIChvID0gbm9kZXNbaV0pLmluZGV4ID0gaTtcbiAgICAgICAgby53ZWlnaHQgPSAwO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IG07ICsraSkge1xuICAgICAgICBvID0gbGlua3NbaV07XG4gICAgICAgIGlmICh0eXBlb2Ygby5zb3VyY2UgPT0gXCJudW1iZXJcIikgby5zb3VyY2UgPSBub2Rlc1tvLnNvdXJjZV07XG4gICAgICAgIGlmICh0eXBlb2Ygby50YXJnZXQgPT0gXCJudW1iZXJcIikgby50YXJnZXQgPSBub2Rlc1tvLnRhcmdldF07XG4gICAgICAgICsrby5zb3VyY2Uud2VpZ2h0O1xuICAgICAgICArK28udGFyZ2V0LndlaWdodDtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbyA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoaXNOYU4oby54KSkgby54ID0gcG9zaXRpb24oXCJ4XCIsIHcpO1xuICAgICAgICBpZiAoaXNOYU4oby55KSkgby55ID0gcG9zaXRpb24oXCJ5XCIsIGgpO1xuICAgICAgICBpZiAoaXNOYU4oby5weCkpIG8ucHggPSBvLng7XG4gICAgICAgIGlmIChpc05hTihvLnB5KSkgby5weSA9IG8ueTtcbiAgICAgIH1cbiAgICAgIGRpc3RhbmNlcyA9IFtdO1xuICAgICAgaWYgKHR5cGVvZiBsaW5rRGlzdGFuY2UgPT09IFwiZnVuY3Rpb25cIikgZm9yIChpID0gMDsgaSA8IG07ICsraSkgZGlzdGFuY2VzW2ldID0gK2xpbmtEaXN0YW5jZS5jYWxsKHRoaXMsIGxpbmtzW2ldLCBpKTsgZWxzZSBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSBkaXN0YW5jZXNbaV0gPSBsaW5rRGlzdGFuY2U7XG4gICAgICBzdHJlbmd0aHMgPSBbXTtcbiAgICAgIGlmICh0eXBlb2YgbGlua1N0cmVuZ3RoID09PSBcImZ1bmN0aW9uXCIpIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHN0cmVuZ3Roc1tpXSA9ICtsaW5rU3RyZW5ndGguY2FsbCh0aGlzLCBsaW5rc1tpXSwgaSk7IGVsc2UgZm9yIChpID0gMDsgaSA8IG07ICsraSkgc3RyZW5ndGhzW2ldID0gbGlua1N0cmVuZ3RoO1xuICAgICAgY2hhcmdlcyA9IFtdO1xuICAgICAgaWYgKHR5cGVvZiBjaGFyZ2UgPT09IFwiZnVuY3Rpb25cIikgZm9yIChpID0gMDsgaSA8IG47ICsraSkgY2hhcmdlc1tpXSA9ICtjaGFyZ2UuY2FsbCh0aGlzLCBub2Rlc1tpXSwgaSk7IGVsc2UgZm9yIChpID0gMDsgaSA8IG47ICsraSkgY2hhcmdlc1tpXSA9IGNoYXJnZTtcbiAgICAgIGZ1bmN0aW9uIHBvc2l0aW9uKGRpbWVuc2lvbiwgc2l6ZSkge1xuICAgICAgICBpZiAoIW5laWdoYm9ycykge1xuICAgICAgICAgIG5laWdoYm9ycyA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICBuZWlnaGJvcnNbal0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICAgICAgdmFyIG8gPSBsaW5rc1tqXTtcbiAgICAgICAgICAgIG5laWdoYm9yc1tvLnNvdXJjZS5pbmRleF0ucHVzaChvLnRhcmdldCk7XG4gICAgICAgICAgICBuZWlnaGJvcnNbby50YXJnZXQuaW5kZXhdLnB1c2goby5zb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FuZGlkYXRlcyA9IG5laWdoYm9yc1tpXSwgaiA9IC0xLCBsID0gY2FuZGlkYXRlcy5sZW5ndGgsIHg7XG4gICAgICAgIHdoaWxlICgrK2ogPCBsKSBpZiAoIWlzTmFOKHggPSBjYW5kaWRhdGVzW2pdW2RpbWVuc2lvbl0pKSByZXR1cm4geDtcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiBzaXplO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvcmNlLnJlc3VtZSgpO1xuICAgIH07XG4gICAgZm9yY2UucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZm9yY2UuYWxwaGEoLjEpO1xuICAgIH07XG4gICAgZm9yY2Uuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZvcmNlLmFscGhhKDApO1xuICAgIH07XG4gICAgZm9yY2UuZHJhZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFkcmFnKSBkcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpLm9yaWdpbihkM19pZGVudGl0eSkub24oXCJkcmFnc3RhcnQuZm9yY2VcIiwgZDNfbGF5b3V0X2ZvcmNlRHJhZ3N0YXJ0KS5vbihcImRyYWcuZm9yY2VcIiwgZHJhZ21vdmUpLm9uKFwiZHJhZ2VuZC5mb3JjZVwiLCBkM19sYXlvdXRfZm9yY2VEcmFnZW5kKTtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRyYWc7XG4gICAgICB0aGlzLm9uKFwibW91c2VvdmVyLmZvcmNlXCIsIGQzX2xheW91dF9mb3JjZU1vdXNlb3Zlcikub24oXCJtb3VzZW91dC5mb3JjZVwiLCBkM19sYXlvdXRfZm9yY2VNb3VzZW91dCkuY2FsbChkcmFnKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGRyYWdtb3ZlKGQpIHtcbiAgICAgIGQucHggPSBkMy5ldmVudC54LCBkLnB5ID0gZDMuZXZlbnQueTtcbiAgICAgIGZvcmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZDMucmViaW5kKGZvcmNlLCBldmVudCwgXCJvblwiKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2ZvcmNlRHJhZ3N0YXJ0KGQpIHtcbiAgICBkLmZpeGVkIHw9IDI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2ZvcmNlRHJhZ2VuZChkKSB7XG4gICAgZC5maXhlZCAmPSB+NjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfZm9yY2VNb3VzZW92ZXIoZCkge1xuICAgIGQuZml4ZWQgfD0gNDtcbiAgICBkLnB4ID0gZC54LCBkLnB5ID0gZC55O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9mb3JjZU1vdXNlb3V0KGQpIHtcbiAgICBkLmZpeGVkICY9IH40O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9mb3JjZUFjY3VtdWxhdGUocXVhZCwgYWxwaGEsIGNoYXJnZXMpIHtcbiAgICB2YXIgY3ggPSAwLCBjeSA9IDA7XG4gICAgcXVhZC5jaGFyZ2UgPSAwO1xuICAgIGlmICghcXVhZC5sZWFmKSB7XG4gICAgICB2YXIgbm9kZXMgPSBxdWFkLm5vZGVzLCBuID0gbm9kZXMubGVuZ3RoLCBpID0gLTEsIGM7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBjID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChjID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICBkM19sYXlvdXRfZm9yY2VBY2N1bXVsYXRlKGMsIGFscGhhLCBjaGFyZ2VzKTtcbiAgICAgICAgcXVhZC5jaGFyZ2UgKz0gYy5jaGFyZ2U7XG4gICAgICAgIGN4ICs9IGMuY2hhcmdlICogYy5jeDtcbiAgICAgICAgY3kgKz0gYy5jaGFyZ2UgKiBjLmN5O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocXVhZC5wb2ludCkge1xuICAgICAgaWYgKCFxdWFkLmxlYWYpIHtcbiAgICAgICAgcXVhZC5wb2ludC54ICs9IE1hdGgucmFuZG9tKCkgLSAuNTtcbiAgICAgICAgcXVhZC5wb2ludC55ICs9IE1hdGgucmFuZG9tKCkgLSAuNTtcbiAgICAgIH1cbiAgICAgIHZhciBrID0gYWxwaGEgKiBjaGFyZ2VzW3F1YWQucG9pbnQuaW5kZXhdO1xuICAgICAgcXVhZC5jaGFyZ2UgKz0gcXVhZC5wb2ludENoYXJnZSA9IGs7XG4gICAgICBjeCArPSBrICogcXVhZC5wb2ludC54O1xuICAgICAgY3kgKz0gayAqIHF1YWQucG9pbnQueTtcbiAgICB9XG4gICAgcXVhZC5jeCA9IGN4IC8gcXVhZC5jaGFyZ2U7XG4gICAgcXVhZC5jeSA9IGN5IC8gcXVhZC5jaGFyZ2U7XG4gIH1cbiAgdmFyIGQzX2xheW91dF9mb3JjZUxpbmtEaXN0YW5jZSA9IDIwLCBkM19sYXlvdXRfZm9yY2VMaW5rU3RyZW5ndGggPSAxLCBkM19sYXlvdXRfZm9yY2VDaGFyZ2VEaXN0YW5jZTIgPSBJbmZpbml0eTtcbiAgZDMubGF5b3V0LmhpZXJhcmNoeSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzb3J0ID0gZDNfbGF5b3V0X2hpZXJhcmNoeVNvcnQsIGNoaWxkcmVuID0gZDNfbGF5b3V0X2hpZXJhcmNoeUNoaWxkcmVuLCB2YWx1ZSA9IGQzX2xheW91dF9oaWVyYXJjaHlWYWx1ZTtcbiAgICBmdW5jdGlvbiBoaWVyYXJjaHkocm9vdCkge1xuICAgICAgdmFyIHN0YWNrID0gWyByb290IF0sIG5vZGVzID0gW10sIG5vZGU7XG4gICAgICByb290LmRlcHRoID0gMDtcbiAgICAgIHdoaWxlICgobm9kZSA9IHN0YWNrLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIGlmICgoY2hpbGRzID0gY2hpbGRyZW4uY2FsbChoaWVyYXJjaHksIG5vZGUsIG5vZGUuZGVwdGgpKSAmJiAobiA9IGNoaWxkcy5sZW5ndGgpKSB7XG4gICAgICAgICAgdmFyIG4sIGNoaWxkcywgY2hpbGQ7XG4gICAgICAgICAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGNoaWxkID0gY2hpbGRzW25dKTtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICBjaGlsZC5kZXB0aCA9IG5vZGUuZGVwdGggKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUpIG5vZGUudmFsdWUgPSAwO1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW4gPSBjaGlsZHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZhbHVlKSBub2RlLnZhbHVlID0gK3ZhbHVlLmNhbGwoaGllcmFyY2h5LCBub2RlLCBub2RlLmRlcHRoKSB8fCAwO1xuICAgICAgICAgIGRlbGV0ZSBub2RlLmNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBjaGlsZHMsIHBhcmVudDtcbiAgICAgICAgaWYgKHNvcnQgJiYgKGNoaWxkcyA9IG5vZGUuY2hpbGRyZW4pKSBjaGlsZHMuc29ydChzb3J0KTtcbiAgICAgICAgaWYgKHZhbHVlICYmIChwYXJlbnQgPSBub2RlLnBhcmVudCkpIHBhcmVudC52YWx1ZSArPSBub2RlLnZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIGhpZXJhcmNoeS5zb3J0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc29ydDtcbiAgICAgIHNvcnQgPSB4O1xuICAgICAgcmV0dXJuIGhpZXJhcmNoeTtcbiAgICB9O1xuICAgIGhpZXJhcmNoeS5jaGlsZHJlbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgY2hpbGRyZW4gPSB4O1xuICAgICAgcmV0dXJuIGhpZXJhcmNoeTtcbiAgICB9O1xuICAgIGhpZXJhcmNoeS52YWx1ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZhbHVlO1xuICAgICAgdmFsdWUgPSB4O1xuICAgICAgcmV0dXJuIGhpZXJhcmNoeTtcbiAgICB9O1xuICAgIGhpZXJhcmNoeS5yZXZhbHVlID0gZnVuY3Rpb24ocm9vdCkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEJlZm9yZShyb290LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIG5vZGUudmFsdWUgPSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIHZhciBwYXJlbnQ7XG4gICAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSBub2RlLnZhbHVlID0gK3ZhbHVlLmNhbGwoaGllcmFyY2h5LCBub2RlLCBub2RlLmRlcHRoKSB8fCAwO1xuICAgICAgICAgIGlmIChwYXJlbnQgPSBub2RlLnBhcmVudCkgcGFyZW50LnZhbHVlICs9IG5vZGUudmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfTtcbiAgICByZXR1cm4gaGllcmFyY2h5O1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5UmViaW5kKG9iamVjdCwgaGllcmFyY2h5KSB7XG4gICAgZDMucmViaW5kKG9iamVjdCwgaGllcmFyY2h5LCBcInNvcnRcIiwgXCJjaGlsZHJlblwiLCBcInZhbHVlXCIpO1xuICAgIG9iamVjdC5ub2RlcyA9IG9iamVjdDtcbiAgICBvYmplY3QubGlua3MgPSBkM19sYXlvdXRfaGllcmFyY2h5TGlua3M7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRCZWZvcmUobm9kZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgbm9kZXMgPSBbIG5vZGUgXTtcbiAgICB3aGlsZSAoKG5vZGUgPSBub2Rlcy5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2sobm9kZSk7XG4gICAgICBpZiAoKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikgJiYgKG4gPSBjaGlsZHJlbi5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBuLCBjaGlsZHJlbjtcbiAgICAgICAgd2hpbGUgKC0tbiA+PSAwKSBub2Rlcy5wdXNoKGNoaWxkcmVuW25dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIobm9kZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgbm9kZXMgPSBbIG5vZGUgXSwgbm9kZXMyID0gW107XG4gICAgd2hpbGUgKChub2RlID0gbm9kZXMucG9wKCkpICE9IG51bGwpIHtcbiAgICAgIG5vZGVzMi5wdXNoKG5vZGUpO1xuICAgICAgaWYgKChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pICYmIChuID0gY2hpbGRyZW4ubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuLCBjaGlsZHJlbjtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIG5vZGVzLnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoKG5vZGUgPSBub2RlczIucG9wKCkpICE9IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrKG5vZGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5Q2hpbGRyZW4oZCkge1xuICAgIHJldHVybiBkLmNoaWxkcmVuO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlWYWx1ZShkKSB7XG4gICAgcmV0dXJuIGQudmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpZXJhcmNoeVNvcnQoYSwgYikge1xuICAgIHJldHVybiBiLnZhbHVlIC0gYS52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5TGlua3Mobm9kZXMpIHtcbiAgICByZXR1cm4gZDMubWVyZ2Uobm9kZXMubWFwKGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgcmV0dXJuIChwYXJlbnQuY2hpbGRyZW4gfHwgW10pLm1hcChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogcGFyZW50LFxuICAgICAgICAgIHRhcmdldDogY2hpbGRcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfVxuICBkMy5sYXlvdXQucGFydGl0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IGQzLmxheW91dC5oaWVyYXJjaHkoKSwgc2l6ZSA9IFsgMSwgMSBdO1xuICAgIGZ1bmN0aW9uIHBvc2l0aW9uKG5vZGUsIHgsIGR4LCBkeSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIG5vZGUueCA9IHg7XG4gICAgICBub2RlLnkgPSBub2RlLmRlcHRoICogZHk7XG4gICAgICBub2RlLmR4ID0gZHg7XG4gICAgICBub2RlLmR5ID0gZHk7XG4gICAgICBpZiAoY2hpbGRyZW4gJiYgKG4gPSBjaGlsZHJlbi5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG4sIGMsIGQ7XG4gICAgICAgIGR4ID0gbm9kZS52YWx1ZSA/IGR4IC8gbm9kZS52YWx1ZSA6IDA7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgcG9zaXRpb24oYyA9IGNoaWxkcmVuW2ldLCB4LCBkID0gYy52YWx1ZSAqIGR4LCBkeSk7XG4gICAgICAgICAgeCArPSBkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlcHRoKG5vZGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4sIGQgPSAwO1xuICAgICAgaWYgKGNoaWxkcmVuICYmIChuID0gY2hpbGRyZW4ubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgZCA9IE1hdGgubWF4KGQsIGRlcHRoKGNoaWxkcmVuW2ldKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMSArIGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnRpdGlvbihkLCBpKSB7XG4gICAgICB2YXIgbm9kZXMgPSBoaWVyYXJjaHkuY2FsbCh0aGlzLCBkLCBpKTtcbiAgICAgIHBvc2l0aW9uKG5vZGVzWzBdLCAwLCBzaXplWzBdLCBzaXplWzFdIC8gZGVwdGgobm9kZXNbMF0pKTtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgcGFydGl0aW9uLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgc2l6ZSA9IHg7XG4gICAgICByZXR1cm4gcGFydGl0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQocGFydGl0aW9uLCBoaWVyYXJjaHkpO1xuICB9O1xuICBkMy5sYXlvdXQucGllID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gTnVtYmVyLCBzb3J0ID0gZDNfbGF5b3V0X3BpZVNvcnRCeVZhbHVlLCBzdGFydEFuZ2xlID0gMCwgZW5kQW5nbGUgPSDPhCwgcGFkQW5nbGUgPSAwO1xuICAgIGZ1bmN0aW9uIHBpZShkYXRhKSB7XG4gICAgICB2YXIgbiA9IGRhdGEubGVuZ3RoLCB2YWx1ZXMgPSBkYXRhLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgIHJldHVybiArdmFsdWUuY2FsbChwaWUsIGQsIGkpO1xuICAgICAgfSksIGEgPSArKHR5cGVvZiBzdGFydEFuZ2xlID09PSBcImZ1bmN0aW9uXCIgPyBzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBzdGFydEFuZ2xlKSwgZGEgPSAodHlwZW9mIGVuZEFuZ2xlID09PSBcImZ1bmN0aW9uXCIgPyBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogZW5kQW5nbGUpIC0gYSwgcCA9IE1hdGgubWluKE1hdGguYWJzKGRhKSAvIG4sICsodHlwZW9mIHBhZEFuZ2xlID09PSBcImZ1bmN0aW9uXCIgPyBwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogcGFkQW5nbGUpKSwgcGEgPSBwICogKGRhIDwgMCA/IC0xIDogMSksIHN1bSA9IGQzLnN1bSh2YWx1ZXMpLCBrID0gc3VtID8gKGRhIC0gbiAqIHBhKSAvIHN1bSA6IDAsIGluZGV4ID0gZDMucmFuZ2UobiksIGFyY3MgPSBbXSwgdjtcbiAgICAgIGlmIChzb3J0ICE9IG51bGwpIGluZGV4LnNvcnQoc29ydCA9PT0gZDNfbGF5b3V0X3BpZVNvcnRCeVZhbHVlID8gZnVuY3Rpb24oaSwgaikge1xuICAgICAgICByZXR1cm4gdmFsdWVzW2pdIC0gdmFsdWVzW2ldO1xuICAgICAgfSA6IGZ1bmN0aW9uKGksIGopIHtcbiAgICAgICAgcmV0dXJuIHNvcnQoZGF0YVtpXSwgZGF0YVtqXSk7XG4gICAgICB9KTtcbiAgICAgIGluZGV4LmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICBhcmNzW2ldID0ge1xuICAgICAgICAgIGRhdGE6IGRhdGFbaV0sXG4gICAgICAgICAgdmFsdWU6IHYgPSB2YWx1ZXNbaV0sXG4gICAgICAgICAgc3RhcnRBbmdsZTogYSxcbiAgICAgICAgICBlbmRBbmdsZTogYSArPSB2ICogayArIHBhLFxuICAgICAgICAgIHBhZEFuZ2xlOiBwXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhcmNzO1xuICAgIH1cbiAgICBwaWUudmFsdWUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2YWx1ZTtcbiAgICAgIHZhbHVlID0gXztcbiAgICAgIHJldHVybiBwaWU7XG4gICAgfTtcbiAgICBwaWUuc29ydCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvcnQ7XG4gICAgICBzb3J0ID0gXztcbiAgICAgIHJldHVybiBwaWU7XG4gICAgfTtcbiAgICBwaWUuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YXJ0QW5nbGU7XG4gICAgICBzdGFydEFuZ2xlID0gXztcbiAgICAgIHJldHVybiBwaWU7XG4gICAgfTtcbiAgICBwaWUuZW5kQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBlbmRBbmdsZTtcbiAgICAgIGVuZEFuZ2xlID0gXztcbiAgICAgIHJldHVybiBwaWU7XG4gICAgfTtcbiAgICBwaWUucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRBbmdsZTtcbiAgICAgIHBhZEFuZ2xlID0gXztcbiAgICAgIHJldHVybiBwaWU7XG4gICAgfTtcbiAgICByZXR1cm4gcGllO1xuICB9O1xuICB2YXIgZDNfbGF5b3V0X3BpZVNvcnRCeVZhbHVlID0ge307XG4gIGQzLmxheW91dC5zdGFjayA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZXMgPSBkM19pZGVudGl0eSwgb3JkZXIgPSBkM19sYXlvdXRfc3RhY2tPcmRlckRlZmF1bHQsIG9mZnNldCA9IGQzX2xheW91dF9zdGFja09mZnNldFplcm8sIG91dCA9IGQzX2xheW91dF9zdGFja091dCwgeCA9IGQzX2xheW91dF9zdGFja1gsIHkgPSBkM19sYXlvdXRfc3RhY2tZO1xuICAgIGZ1bmN0aW9uIHN0YWNrKGRhdGEsIGluZGV4KSB7XG4gICAgICBpZiAoIShuID0gZGF0YS5sZW5ndGgpKSByZXR1cm4gZGF0YTtcbiAgICAgIHZhciBzZXJpZXMgPSBkYXRhLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXMuY2FsbChzdGFjaywgZCwgaSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBwb2ludHMgPSBzZXJpZXMubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQubWFwKGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgICAgICByZXR1cm4gWyB4LmNhbGwoc3RhY2ssIHYsIGkpLCB5LmNhbGwoc3RhY2ssIHYsIGkpIF07XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3JkZXJzID0gb3JkZXIuY2FsbChzdGFjaywgcG9pbnRzLCBpbmRleCk7XG4gICAgICBzZXJpZXMgPSBkMy5wZXJtdXRlKHNlcmllcywgb3JkZXJzKTtcbiAgICAgIHBvaW50cyA9IGQzLnBlcm11dGUocG9pbnRzLCBvcmRlcnMpO1xuICAgICAgdmFyIG9mZnNldHMgPSBvZmZzZXQuY2FsbChzdGFjaywgcG9pbnRzLCBpbmRleCk7XG4gICAgICB2YXIgbSA9IHNlcmllc1swXS5sZW5ndGgsIG4sIGksIGosIG87XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIG91dC5jYWxsKHN0YWNrLCBzZXJpZXNbMF1bal0sIG8gPSBvZmZzZXRzW2pdLCBwb2ludHNbMF1bal1bMV0pO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgb3V0LmNhbGwoc3RhY2ssIHNlcmllc1tpXVtqXSwgbyArPSBwb2ludHNbaSAtIDFdW2pdWzFdLCBwb2ludHNbaV1bal1bMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgc3RhY2sudmFsdWVzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmFsdWVzO1xuICAgICAgdmFsdWVzID0geDtcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHN0YWNrLm9yZGVyID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JkZXI7XG4gICAgICBvcmRlciA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogZDNfbGF5b3V0X3N0YWNrT3JkZXJzLmdldCh4KSB8fCBkM19sYXlvdXRfc3RhY2tPcmRlckRlZmF1bHQ7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICBzdGFjay5vZmZzZXQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGQzX2xheW91dF9zdGFja09mZnNldHMuZ2V0KHgpIHx8IGQzX2xheW91dF9zdGFja09mZnNldFplcm87XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICBzdGFjay54ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDtcbiAgICAgIHggPSB6O1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gICAgc3RhY2sueSA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHk7XG4gICAgICB5ID0gejtcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHN0YWNrLm91dCA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dDtcbiAgICAgIG91dCA9IHo7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja1goZCkge1xuICAgIHJldHVybiBkLng7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrWShkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tPdXQoZCwgeTAsIHkpIHtcbiAgICBkLnkwID0geTA7XG4gICAgZC55ID0geTtcbiAgfVxuICB2YXIgZDNfbGF5b3V0X3N0YWNrT3JkZXJzID0gZDMubWFwKHtcbiAgICBcImluc2lkZS1vdXRcIjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIG4gPSBkYXRhLmxlbmd0aCwgaSwgaiwgbWF4ID0gZGF0YS5tYXAoZDNfbGF5b3V0X3N0YWNrTWF4SW5kZXgpLCBzdW1zID0gZGF0YS5tYXAoZDNfbGF5b3V0X3N0YWNrUmVkdWNlU3VtKSwgaW5kZXggPSBkMy5yYW5nZShuKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG1heFthXSAtIG1heFtiXTtcbiAgICAgIH0pLCB0b3AgPSAwLCBib3R0b20gPSAwLCB0b3BzID0gW10sIGJvdHRvbXMgPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaiA9IGluZGV4W2ldO1xuICAgICAgICBpZiAodG9wIDwgYm90dG9tKSB7XG4gICAgICAgICAgdG9wICs9IHN1bXNbal07XG4gICAgICAgICAgdG9wcy5wdXNoKGopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJvdHRvbSArPSBzdW1zW2pdO1xuICAgICAgICAgIGJvdHRvbXMucHVzaChqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJvdHRvbXMucmV2ZXJzZSgpLmNvbmNhdCh0b3BzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkMy5yYW5nZShkYXRhLmxlbmd0aCkucmV2ZXJzZSgpO1xuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IGQzX2xheW91dF9zdGFja09yZGVyRGVmYXVsdFxuICB9KTtcbiAgdmFyIGQzX2xheW91dF9zdGFja09mZnNldHMgPSBkMy5tYXAoe1xuICAgIHNpbGhvdWV0dGU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBuID0gZGF0YS5sZW5ndGgsIG0gPSBkYXRhWzBdLmxlbmd0aCwgc3VtcyA9IFtdLCBtYXggPSAwLCBpLCBqLCBvLCB5MCA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICBmb3IgKGkgPSAwLCBvID0gMDsgaSA8IG47IGkrKykgbyArPSBkYXRhW2ldW2pdWzFdO1xuICAgICAgICBpZiAobyA+IG1heCkgbWF4ID0gbztcbiAgICAgICAgc3Vtcy5wdXNoKG8pO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICB5MFtqXSA9IChtYXggLSBzdW1zW2pdKSAvIDI7XG4gICAgICB9XG4gICAgICByZXR1cm4geTA7XG4gICAgfSxcbiAgICB3aWdnbGU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBuID0gZGF0YS5sZW5ndGgsIHggPSBkYXRhWzBdLCBtID0geC5sZW5ndGgsIGksIGosIGssIHMxLCBzMiwgczMsIGR4LCBvLCBvMCwgeTAgPSBbXTtcbiAgICAgIHkwWzBdID0gbyA9IG8wID0gMDtcbiAgICAgIGZvciAoaiA9IDE7IGogPCBtOyArK2opIHtcbiAgICAgICAgZm9yIChpID0gMCwgczEgPSAwOyBpIDwgbjsgKytpKSBzMSArPSBkYXRhW2ldW2pdWzFdO1xuICAgICAgICBmb3IgKGkgPSAwLCBzMiA9IDAsIGR4ID0geFtqXVswXSAtIHhbaiAtIDFdWzBdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgZm9yIChrID0gMCwgczMgPSAoZGF0YVtpXVtqXVsxXSAtIGRhdGFbaV1baiAtIDFdWzFdKSAvICgyICogZHgpOyBrIDwgaTsgKytrKSB7XG4gICAgICAgICAgICBzMyArPSAoZGF0YVtrXVtqXVsxXSAtIGRhdGFba11baiAtIDFdWzFdKSAvIGR4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzMiArPSBzMyAqIGRhdGFbaV1bal1bMV07XG4gICAgICAgIH1cbiAgICAgICAgeTBbal0gPSBvIC09IHMxID8gczIgLyBzMSAqIGR4IDogMDtcbiAgICAgICAgaWYgKG8gPCBvMCkgbzAgPSBvO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikgeTBbal0gLT0gbzA7XG4gICAgICByZXR1cm4geTA7XG4gICAgfSxcbiAgICBleHBhbmQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBuID0gZGF0YS5sZW5ndGgsIG0gPSBkYXRhWzBdLmxlbmd0aCwgayA9IDEgLyBuLCBpLCBqLCBvLCB5MCA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICBmb3IgKGkgPSAwLCBvID0gMDsgaSA8IG47IGkrKykgbyArPSBkYXRhW2ldW2pdWzFdO1xuICAgICAgICBpZiAobykgZm9yIChpID0gMDsgaSA8IG47IGkrKykgZGF0YVtpXVtqXVsxXSAvPSBvOyBlbHNlIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGRhdGFbaV1bal1bMV0gPSBrO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikgeTBbal0gPSAwO1xuICAgICAgcmV0dXJuIHkwO1xuICAgIH0sXG4gICAgemVybzogZDNfbGF5b3V0X3N0YWNrT2Zmc2V0WmVyb1xuICB9KTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrT3JkZXJEZWZhdWx0KGRhdGEpIHtcbiAgICByZXR1cm4gZDMucmFuZ2UoZGF0YS5sZW5ndGgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja09mZnNldFplcm8oZGF0YSkge1xuICAgIHZhciBqID0gLTEsIG0gPSBkYXRhWzBdLmxlbmd0aCwgeTAgPSBbXTtcbiAgICB3aGlsZSAoKytqIDwgbSkgeTBbal0gPSAwO1xuICAgIHJldHVybiB5MDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tNYXhJbmRleChhcnJheSkge1xuICAgIHZhciBpID0gMSwgaiA9IDAsIHYgPSBhcnJheVswXVsxXSwgaywgbiA9IGFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKDtpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKGsgPSBhcnJheVtpXVsxXSkgPiB2KSB7XG4gICAgICAgIGogPSBpO1xuICAgICAgICB2ID0gaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGo7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrUmVkdWNlU3VtKGQpIHtcbiAgICByZXR1cm4gZC5yZWR1Y2UoZDNfbGF5b3V0X3N0YWNrU3VtLCAwKTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tTdW0ocCwgZCkge1xuICAgIHJldHVybiBwICsgZFsxXTtcbiAgfVxuICBkMy5sYXlvdXQuaGlzdG9ncmFtID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZyZXF1ZW5jeSA9IHRydWUsIHZhbHVlciA9IE51bWJlciwgcmFuZ2VyID0gZDNfbGF5b3V0X2hpc3RvZ3JhbVJhbmdlLCBiaW5uZXIgPSBkM19sYXlvdXRfaGlzdG9ncmFtQmluU3R1cmdlcztcbiAgICBmdW5jdGlvbiBoaXN0b2dyYW0oZGF0YSwgaSkge1xuICAgICAgdmFyIGJpbnMgPSBbXSwgdmFsdWVzID0gZGF0YS5tYXAodmFsdWVyLCB0aGlzKSwgcmFuZ2UgPSByYW5nZXIuY2FsbCh0aGlzLCB2YWx1ZXMsIGkpLCB0aHJlc2hvbGRzID0gYmlubmVyLmNhbGwodGhpcywgcmFuZ2UsIHZhbHVlcywgaSksIGJpbiwgaSA9IC0xLCBuID0gdmFsdWVzLmxlbmd0aCwgbSA9IHRocmVzaG9sZHMubGVuZ3RoIC0gMSwgayA9IGZyZXF1ZW5jeSA/IDEgOiAxIC8gbiwgeDtcbiAgICAgIHdoaWxlICgrK2kgPCBtKSB7XG4gICAgICAgIGJpbiA9IGJpbnNbaV0gPSBbXTtcbiAgICAgICAgYmluLmR4ID0gdGhyZXNob2xkc1tpICsgMV0gLSAoYmluLnggPSB0aHJlc2hvbGRzW2ldKTtcbiAgICAgICAgYmluLnkgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKG0gPiAwKSB7XG4gICAgICAgIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICB4ID0gdmFsdWVzW2ldO1xuICAgICAgICAgIGlmICh4ID49IHJhbmdlWzBdICYmIHggPD0gcmFuZ2VbMV0pIHtcbiAgICAgICAgICAgIGJpbiA9IGJpbnNbZDMuYmlzZWN0KHRocmVzaG9sZHMsIHgsIDEsIG0pIC0gMV07XG4gICAgICAgICAgICBiaW4ueSArPSBrO1xuICAgICAgICAgICAgYmluLnB1c2goZGF0YVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYmlucztcbiAgICB9XG4gICAgaGlzdG9ncmFtLnZhbHVlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmFsdWVyO1xuICAgICAgdmFsdWVyID0geDtcbiAgICAgIHJldHVybiBoaXN0b2dyYW07XG4gICAgfTtcbiAgICBoaXN0b2dyYW0ucmFuZ2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYW5nZXI7XG4gICAgICByYW5nZXIgPSBkM19mdW5jdG9yKHgpO1xuICAgICAgcmV0dXJuIGhpc3RvZ3JhbTtcbiAgICB9O1xuICAgIGhpc3RvZ3JhbS5iaW5zID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYmlubmVyO1xuICAgICAgYmlubmVyID0gdHlwZW9mIHggPT09IFwibnVtYmVyXCIgPyBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICByZXR1cm4gZDNfbGF5b3V0X2hpc3RvZ3JhbUJpbkZpeGVkKHJhbmdlLCB4KTtcbiAgICAgIH0gOiBkM19mdW5jdG9yKHgpO1xuICAgICAgcmV0dXJuIGhpc3RvZ3JhbTtcbiAgICB9O1xuICAgIGhpc3RvZ3JhbS5mcmVxdWVuY3kgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBmcmVxdWVuY3k7XG4gICAgICBmcmVxdWVuY3kgPSAhIXg7XG4gICAgICByZXR1cm4gaGlzdG9ncmFtO1xuICAgIH07XG4gICAgcmV0dXJuIGhpc3RvZ3JhbTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpc3RvZ3JhbUJpblN0dXJnZXMocmFuZ2UsIHZhbHVlcykge1xuICAgIHJldHVybiBkM19sYXlvdXRfaGlzdG9ncmFtQmluRml4ZWQocmFuZ2UsIE1hdGguY2VpbChNYXRoLmxvZyh2YWx1ZXMubGVuZ3RoKSAvIE1hdGguTE4yICsgMSkpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaXN0b2dyYW1CaW5GaXhlZChyYW5nZSwgbikge1xuICAgIHZhciB4ID0gLTEsIGIgPSArcmFuZ2VbMF0sIG0gPSAocmFuZ2VbMV0gLSBiKSAvIG4sIGYgPSBbXTtcbiAgICB3aGlsZSAoKyt4IDw9IG4pIGZbeF0gPSBtICogeCArIGI7XG4gICAgcmV0dXJuIGY7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpc3RvZ3JhbVJhbmdlKHZhbHVlcykge1xuICAgIHJldHVybiBbIGQzLm1pbih2YWx1ZXMpLCBkMy5tYXgodmFsdWVzKSBdO1xuICB9XG4gIGQzLmxheW91dC5wYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IGQzLmxheW91dC5oaWVyYXJjaHkoKS5zb3J0KGQzX2xheW91dF9wYWNrU29ydCksIHBhZGRpbmcgPSAwLCBzaXplID0gWyAxLCAxIF0sIHJhZGl1cztcbiAgICBmdW5jdGlvbiBwYWNrKGQsIGkpIHtcbiAgICAgIHZhciBub2RlcyA9IGhpZXJhcmNoeS5jYWxsKHRoaXMsIGQsIGkpLCByb290ID0gbm9kZXNbMF0sIHcgPSBzaXplWzBdLCBoID0gc2l6ZVsxXSwgciA9IHJhZGl1cyA9PSBudWxsID8gTWF0aC5zcXJ0IDogdHlwZW9mIHJhZGl1cyA9PT0gXCJmdW5jdGlvblwiID8gcmFkaXVzIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByYWRpdXM7XG4gICAgICB9O1xuICAgICAgcm9vdC54ID0gcm9vdC55ID0gMDtcbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgZC5yID0gK3IoZC52YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGQzX2xheW91dF9wYWNrU2libGluZ3MpO1xuICAgICAgaWYgKHBhZGRpbmcpIHtcbiAgICAgICAgdmFyIGRyID0gcGFkZGluZyAqIChyYWRpdXMgPyAxIDogTWF0aC5tYXgoMiAqIHJvb3QuciAvIHcsIDIgKiByb290LnIgLyBoKSkgLyAyO1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgZC5yICs9IGRyO1xuICAgICAgICB9KTtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZDNfbGF5b3V0X3BhY2tTaWJsaW5ncyk7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICBkLnIgLT0gZHI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZDNfbGF5b3V0X3BhY2tUcmFuc2Zvcm0ocm9vdCwgdyAvIDIsIGggLyAyLCByYWRpdXMgPyAxIDogMSAvIE1hdGgubWF4KDIgKiByb290LnIgLyB3LCAyICogcm9vdC5yIC8gaCkpO1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBwYWNrLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgc2l6ZSA9IF87XG4gICAgICByZXR1cm4gcGFjaztcbiAgICB9O1xuICAgIHBhY2sucmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFkaXVzO1xuICAgICAgcmFkaXVzID0gXyA9PSBudWxsIHx8IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogK187XG4gICAgICByZXR1cm4gcGFjaztcbiAgICB9O1xuICAgIHBhY2sucGFkZGluZyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZGRpbmc7XG4gICAgICBwYWRkaW5nID0gK187XG4gICAgICByZXR1cm4gcGFjaztcbiAgICB9O1xuICAgIHJldHVybiBkM19sYXlvdXRfaGllcmFyY2h5UmViaW5kKHBhY2ssIGhpZXJhcmNoeSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrU29ydChhLCBiKSB7XG4gICAgcmV0dXJuIGEudmFsdWUgLSBiLnZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrSW5zZXJ0KGEsIGIpIHtcbiAgICB2YXIgYyA9IGEuX3BhY2tfbmV4dDtcbiAgICBhLl9wYWNrX25leHQgPSBiO1xuICAgIGIuX3BhY2tfcHJldiA9IGE7XG4gICAgYi5fcGFja19uZXh0ID0gYztcbiAgICBjLl9wYWNrX3ByZXYgPSBiO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrU3BsaWNlKGEsIGIpIHtcbiAgICBhLl9wYWNrX25leHQgPSBiO1xuICAgIGIuX3BhY2tfcHJldiA9IGE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tJbnRlcnNlY3RzKGEsIGIpIHtcbiAgICB2YXIgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55LCBkciA9IGEuciArIGIucjtcbiAgICByZXR1cm4gLjk5OSAqIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja1NpYmxpbmdzKG5vZGUpIHtcbiAgICBpZiAoIShub2RlcyA9IG5vZGUuY2hpbGRyZW4pIHx8ICEobiA9IG5vZGVzLmxlbmd0aCkpIHJldHVybjtcbiAgICB2YXIgbm9kZXMsIHhNaW4gPSBJbmZpbml0eSwgeE1heCA9IC1JbmZpbml0eSwgeU1pbiA9IEluZmluaXR5LCB5TWF4ID0gLUluZmluaXR5LCBhLCBiLCBjLCBpLCBqLCBrLCBuO1xuICAgIGZ1bmN0aW9uIGJvdW5kKG5vZGUpIHtcbiAgICAgIHhNaW4gPSBNYXRoLm1pbihub2RlLnggLSBub2RlLnIsIHhNaW4pO1xuICAgICAgeE1heCA9IE1hdGgubWF4KG5vZGUueCArIG5vZGUuciwgeE1heCk7XG4gICAgICB5TWluID0gTWF0aC5taW4obm9kZS55IC0gbm9kZS5yLCB5TWluKTtcbiAgICAgIHlNYXggPSBNYXRoLm1heChub2RlLnkgKyBub2RlLnIsIHlNYXgpO1xuICAgIH1cbiAgICBub2Rlcy5mb3JFYWNoKGQzX2xheW91dF9wYWNrTGluayk7XG4gICAgYSA9IG5vZGVzWzBdO1xuICAgIGEueCA9IC1hLnI7XG4gICAgYS55ID0gMDtcbiAgICBib3VuZChhKTtcbiAgICBpZiAobiA+IDEpIHtcbiAgICAgIGIgPSBub2Rlc1sxXTtcbiAgICAgIGIueCA9IGIucjtcbiAgICAgIGIueSA9IDA7XG4gICAgICBib3VuZChiKTtcbiAgICAgIGlmIChuID4gMikge1xuICAgICAgICBjID0gbm9kZXNbMl07XG4gICAgICAgIGQzX2xheW91dF9wYWNrUGxhY2UoYSwgYiwgYyk7XG4gICAgICAgIGJvdW5kKGMpO1xuICAgICAgICBkM19sYXlvdXRfcGFja0luc2VydChhLCBjKTtcbiAgICAgICAgYS5fcGFja19wcmV2ID0gYztcbiAgICAgICAgZDNfbGF5b3V0X3BhY2tJbnNlcnQoYywgYik7XG4gICAgICAgIGIgPSBhLl9wYWNrX25leHQ7XG4gICAgICAgIGZvciAoaSA9IDM7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBkM19sYXlvdXRfcGFja1BsYWNlKGEsIGIsIGMgPSBub2Rlc1tpXSk7XG4gICAgICAgICAgdmFyIGlzZWN0ID0gMCwgczEgPSAxLCBzMiA9IDE7XG4gICAgICAgICAgZm9yIChqID0gYi5fcGFja19uZXh0OyBqICE9PSBiOyBqID0gai5fcGFja19uZXh0LCBzMSsrKSB7XG4gICAgICAgICAgICBpZiAoZDNfbGF5b3V0X3BhY2tJbnRlcnNlY3RzKGosIGMpKSB7XG4gICAgICAgICAgICAgIGlzZWN0ID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc2VjdCA9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKGsgPSBhLl9wYWNrX3ByZXY7IGsgIT09IGouX3BhY2tfcHJldjsgayA9IGsuX3BhY2tfcHJldiwgczIrKykge1xuICAgICAgICAgICAgICBpZiAoZDNfbGF5b3V0X3BhY2tJbnRlcnNlY3RzKGssIGMpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzZWN0KSB7XG4gICAgICAgICAgICBpZiAoczEgPCBzMiB8fCBzMSA9PSBzMiAmJiBiLnIgPCBhLnIpIGQzX2xheW91dF9wYWNrU3BsaWNlKGEsIGIgPSBqKTsgZWxzZSBkM19sYXlvdXRfcGFja1NwbGljZShhID0gaywgYik7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQzX2xheW91dF9wYWNrSW5zZXJ0KGEsIGMpO1xuICAgICAgICAgICAgYiA9IGM7XG4gICAgICAgICAgICBib3VuZChjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGN4ID0gKHhNaW4gKyB4TWF4KSAvIDIsIGN5ID0gKHlNaW4gKyB5TWF4KSAvIDIsIGNyID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjID0gbm9kZXNbaV07XG4gICAgICBjLnggLT0gY3g7XG4gICAgICBjLnkgLT0gY3k7XG4gICAgICBjciA9IE1hdGgubWF4KGNyLCBjLnIgKyBNYXRoLnNxcnQoYy54ICogYy54ICsgYy55ICogYy55KSk7XG4gICAgfVxuICAgIG5vZGUuciA9IGNyO1xuICAgIG5vZGVzLmZvckVhY2goZDNfbGF5b3V0X3BhY2tVbmxpbmspO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrTGluayhub2RlKSB7XG4gICAgbm9kZS5fcGFja19uZXh0ID0gbm9kZS5fcGFja19wcmV2ID0gbm9kZTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja1VubGluayhub2RlKSB7XG4gICAgZGVsZXRlIG5vZGUuX3BhY2tfbmV4dDtcbiAgICBkZWxldGUgbm9kZS5fcGFja19wcmV2O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrVHJhbnNmb3JtKG5vZGUsIHgsIHksIGspIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgIG5vZGUueCA9IHggKz0gayAqIG5vZGUueDtcbiAgICBub2RlLnkgPSB5ICs9IGsgKiBub2RlLnk7XG4gICAgbm9kZS5yICo9IGs7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGQzX2xheW91dF9wYWNrVHJhbnNmb3JtKGNoaWxkcmVuW2ldLCB4LCB5LCBrKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tQbGFjZShhLCBiLCBjKSB7XG4gICAgdmFyIGRiID0gYS5yICsgYy5yLCBkeCA9IGIueCAtIGEueCwgZHkgPSBiLnkgLSBhLnk7XG4gICAgaWYgKGRiICYmIChkeCB8fCBkeSkpIHtcbiAgICAgIHZhciBkYSA9IGIuciArIGMuciwgZGMgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIGRhICo9IGRhO1xuICAgICAgZGIgKj0gZGI7XG4gICAgICB2YXIgeCA9IC41ICsgKGRiIC0gZGEpIC8gKDIgKiBkYyksIHkgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgMiAqIGRhICogKGRiICsgZGMpIC0gKGRiIC09IGRjKSAqIGRiIC0gZGEgKiBkYSkpIC8gKDIgKiBkYyk7XG4gICAgICBjLnggPSBhLnggKyB4ICogZHggKyB5ICogZHk7XG4gICAgICBjLnkgPSBhLnkgKyB4ICogZHkgLSB5ICogZHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMueCA9IGEueCArIGRiO1xuICAgICAgYy55ID0gYS55O1xuICAgIH1cbiAgfVxuICBkMy5sYXlvdXQudHJlZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaWVyYXJjaHkgPSBkMy5sYXlvdXQuaGllcmFyY2h5KCkuc29ydChudWxsKS52YWx1ZShudWxsKSwgc2VwYXJhdGlvbiA9IGQzX2xheW91dF90cmVlU2VwYXJhdGlvbiwgc2l6ZSA9IFsgMSwgMSBdLCBub2RlU2l6ZSA9IG51bGw7XG4gICAgZnVuY3Rpb24gdHJlZShkLCBpKSB7XG4gICAgICB2YXIgbm9kZXMgPSBoaWVyYXJjaHkuY2FsbCh0aGlzLCBkLCBpKSwgcm9vdDAgPSBub2Rlc1swXSwgcm9vdDEgPSB3cmFwVHJlZShyb290MCk7XG4gICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290MSwgZmlyc3RXYWxrKSwgcm9vdDEucGFyZW50Lm0gPSAtcm9vdDEuejtcbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEJlZm9yZShyb290MSwgc2Vjb25kV2Fsayk7XG4gICAgICBpZiAobm9kZVNpemUpIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEJlZm9yZShyb290MCwgc2l6ZU5vZGUpOyBlbHNlIHtcbiAgICAgICAgdmFyIGxlZnQgPSByb290MCwgcmlnaHQgPSByb290MCwgYm90dG9tID0gcm9vdDA7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEJlZm9yZShyb290MCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGlmIChub2RlLnggPCBsZWZ0LngpIGxlZnQgPSBub2RlO1xuICAgICAgICAgIGlmIChub2RlLnggPiByaWdodC54KSByaWdodCA9IG5vZGU7XG4gICAgICAgICAgaWYgKG5vZGUuZGVwdGggPiBib3R0b20uZGVwdGgpIGJvdHRvbSA9IG5vZGU7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdHggPSBzZXBhcmF0aW9uKGxlZnQsIHJpZ2h0KSAvIDIgLSBsZWZ0LngsIGt4ID0gc2l6ZVswXSAvIChyaWdodC54ICsgc2VwYXJhdGlvbihyaWdodCwgbGVmdCkgLyAyICsgdHgpLCBreSA9IHNpemVbMV0gLyAoYm90dG9tLmRlcHRoIHx8IDEpO1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRCZWZvcmUocm9vdDAsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBub2RlLnggPSAobm9kZS54ICsgdHgpICoga3g7XG4gICAgICAgICAgbm9kZS55ID0gbm9kZS5kZXB0aCAqIGt5O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JhcFRyZWUocm9vdDApIHtcbiAgICAgIHZhciByb290MSA9IHtcbiAgICAgICAgQTogbnVsbCxcbiAgICAgICAgY2hpbGRyZW46IFsgcm9vdDAgXVxuICAgICAgfSwgcXVldWUgPSBbIHJvb3QxIF0sIG5vZGUxO1xuICAgICAgd2hpbGUgKChub2RlMSA9IHF1ZXVlLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGNoaWxkcmVuID0gbm9kZTEuY2hpbGRyZW4sIGNoaWxkLCBpID0gMCwgbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIHF1ZXVlLnB1c2goKGNoaWxkcmVuW2ldID0gY2hpbGQgPSB7XG4gICAgICAgICAgICBfOiBjaGlsZHJlbltpXSxcbiAgICAgICAgICAgIHBhcmVudDogbm9kZTEsXG4gICAgICAgICAgICBjaGlsZHJlbjogKGNoaWxkID0gY2hpbGRyZW5baV0uY2hpbGRyZW4pICYmIGNoaWxkLnNsaWNlKCkgfHwgW10sXG4gICAgICAgICAgICBBOiBudWxsLFxuICAgICAgICAgICAgYTogbnVsbCxcbiAgICAgICAgICAgIHo6IDAsXG4gICAgICAgICAgICBtOiAwLFxuICAgICAgICAgICAgYzogMCxcbiAgICAgICAgICAgIHM6IDAsXG4gICAgICAgICAgICB0OiBudWxsLFxuICAgICAgICAgICAgaTogaVxuICAgICAgICAgIH0pLmEgPSBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByb290MS5jaGlsZHJlblswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmlyc3RXYWxrKHYpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW4sIHNpYmxpbmdzID0gdi5wYXJlbnQuY2hpbGRyZW4sIHcgPSB2LmkgPyBzaWJsaW5nc1t2LmkgLSAxXSA6IG51bGw7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGQzX2xheW91dF90cmVlU2hpZnQodik7XG4gICAgICAgIHZhciBtaWRwb2ludCA9IChjaGlsZHJlblswXS56ICsgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0ueikgLyAyO1xuICAgICAgICBpZiAodykge1xuICAgICAgICAgIHYueiA9IHcueiArIHNlcGFyYXRpb24odi5fLCB3Ll8pO1xuICAgICAgICAgIHYubSA9IHYueiAtIG1pZHBvaW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHYueiA9IG1pZHBvaW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHcpIHtcbiAgICAgICAgdi56ID0gdy56ICsgc2VwYXJhdGlvbih2Ll8sIHcuXyk7XG4gICAgICB9XG4gICAgICB2LnBhcmVudC5BID0gYXBwb3J0aW9uKHYsIHcsIHYucGFyZW50LkEgfHwgc2libGluZ3NbMF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZWNvbmRXYWxrKHYpIHtcbiAgICAgIHYuXy54ID0gdi56ICsgdi5wYXJlbnQubTtcbiAgICAgIHYubSArPSB2LnBhcmVudC5tO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBvcnRpb24odiwgdywgYW5jZXN0b3IpIHtcbiAgICAgIGlmICh3KSB7XG4gICAgICAgIHZhciB2aXAgPSB2LCB2b3AgPSB2LCB2aW0gPSB3LCB2b20gPSB2aXAucGFyZW50LmNoaWxkcmVuWzBdLCBzaXAgPSB2aXAubSwgc29wID0gdm9wLm0sIHNpbSA9IHZpbS5tLCBzb20gPSB2b20ubSwgc2hpZnQ7XG4gICAgICAgIHdoaWxlICh2aW0gPSBkM19sYXlvdXRfdHJlZVJpZ2h0KHZpbSksIHZpcCA9IGQzX2xheW91dF90cmVlTGVmdCh2aXApLCB2aW0gJiYgdmlwKSB7XG4gICAgICAgICAgdm9tID0gZDNfbGF5b3V0X3RyZWVMZWZ0KHZvbSk7XG4gICAgICAgICAgdm9wID0gZDNfbGF5b3V0X3RyZWVSaWdodCh2b3ApO1xuICAgICAgICAgIHZvcC5hID0gdjtcbiAgICAgICAgICBzaGlmdCA9IHZpbS56ICsgc2ltIC0gdmlwLnogLSBzaXAgKyBzZXBhcmF0aW9uKHZpbS5fLCB2aXAuXyk7XG4gICAgICAgICAgaWYgKHNoaWZ0ID4gMCkge1xuICAgICAgICAgICAgZDNfbGF5b3V0X3RyZWVNb3ZlKGQzX2xheW91dF90cmVlQW5jZXN0b3IodmltLCB2LCBhbmNlc3RvciksIHYsIHNoaWZ0KTtcbiAgICAgICAgICAgIHNpcCArPSBzaGlmdDtcbiAgICAgICAgICAgIHNvcCArPSBzaGlmdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2ltICs9IHZpbS5tO1xuICAgICAgICAgIHNpcCArPSB2aXAubTtcbiAgICAgICAgICBzb20gKz0gdm9tLm07XG4gICAgICAgICAgc29wICs9IHZvcC5tO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aW0gJiYgIWQzX2xheW91dF90cmVlUmlnaHQodm9wKSkge1xuICAgICAgICAgIHZvcC50ID0gdmltO1xuICAgICAgICAgIHZvcC5tICs9IHNpbSAtIHNvcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlwICYmICFkM19sYXlvdXRfdHJlZUxlZnQodm9tKSkge1xuICAgICAgICAgIHZvbS50ID0gdmlwO1xuICAgICAgICAgIHZvbS5tICs9IHNpcCAtIHNvbTtcbiAgICAgICAgICBhbmNlc3RvciA9IHY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhbmNlc3RvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2l6ZU5vZGUobm9kZSkge1xuICAgICAgbm9kZS54ICo9IHNpemVbMF07XG4gICAgICBub2RlLnkgPSBub2RlLmRlcHRoICogc2l6ZVsxXTtcbiAgICB9XG4gICAgdHJlZS5zZXBhcmF0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2VwYXJhdGlvbjtcbiAgICAgIHNlcGFyYXRpb24gPSB4O1xuICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfTtcbiAgICB0cmVlLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlU2l6ZSA/IG51bGwgOiBzaXplO1xuICAgICAgbm9kZVNpemUgPSAoc2l6ZSA9IHgpID09IG51bGwgPyBzaXplTm9kZSA6IG51bGw7XG4gICAgICByZXR1cm4gdHJlZTtcbiAgICB9O1xuICAgIHRyZWUubm9kZVNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlU2l6ZSA/IHNpemUgOiBudWxsO1xuICAgICAgbm9kZVNpemUgPSAoc2l6ZSA9IHgpID09IG51bGwgPyBudWxsIDogc2l6ZU5vZGU7XG4gICAgICByZXR1cm4gdHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBkM19sYXlvdXRfaGllcmFyY2h5UmViaW5kKHRyZWUsIGhpZXJhcmNoeSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlU2VwYXJhdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGEucGFyZW50ID09IGIucGFyZW50ID8gMSA6IDI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVMZWZ0KHYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuO1xuICAgIHJldHVybiBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlblswXSA6IHYudDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZVJpZ2h0KHYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLCBuO1xuICAgIHJldHVybiAobiA9IGNoaWxkcmVuLmxlbmd0aCkgPyBjaGlsZHJlbltuIC0gMV0gOiB2LnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVNb3ZlKHdtLCB3cCwgc2hpZnQpIHtcbiAgICB2YXIgY2hhbmdlID0gc2hpZnQgLyAod3AuaSAtIHdtLmkpO1xuICAgIHdwLmMgLT0gY2hhbmdlO1xuICAgIHdwLnMgKz0gc2hpZnQ7XG4gICAgd20uYyArPSBjaGFuZ2U7XG4gICAgd3AueiArPSBzaGlmdDtcbiAgICB3cC5tICs9IHNoaWZ0O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlU2hpZnQodikge1xuICAgIHZhciBzaGlmdCA9IDAsIGNoYW5nZSA9IDAsIGNoaWxkcmVuID0gdi5jaGlsZHJlbiwgaSA9IGNoaWxkcmVuLmxlbmd0aCwgdztcbiAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgIHcgPSBjaGlsZHJlbltpXTtcbiAgICAgIHcueiArPSBzaGlmdDtcbiAgICAgIHcubSArPSBzaGlmdDtcbiAgICAgIHNoaWZ0ICs9IHcucyArIChjaGFuZ2UgKz0gdy5jKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSB7XG4gICAgcmV0dXJuIHZpbS5hLnBhcmVudCA9PT0gdi5wYXJlbnQgPyB2aW0uYSA6IGFuY2VzdG9yO1xuICB9XG4gIGQzLmxheW91dC5jbHVzdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IGQzLmxheW91dC5oaWVyYXJjaHkoKS5zb3J0KG51bGwpLnZhbHVlKG51bGwpLCBzZXBhcmF0aW9uID0gZDNfbGF5b3V0X3RyZWVTZXBhcmF0aW9uLCBzaXplID0gWyAxLCAxIF0sIG5vZGVTaXplID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gY2x1c3RlcihkLCBpKSB7XG4gICAgICB2YXIgbm9kZXMgPSBoaWVyYXJjaHkuY2FsbCh0aGlzLCBkLCBpKSwgcm9vdCA9IG5vZGVzWzBdLCBwcmV2aW91c05vZGUsIHggPSAwO1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgbm9kZS54ID0gZDNfbGF5b3V0X2NsdXN0ZXJYKGNoaWxkcmVuKTtcbiAgICAgICAgICBub2RlLnkgPSBkM19sYXlvdXRfY2x1c3RlclkoY2hpbGRyZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUueCA9IHByZXZpb3VzTm9kZSA/IHggKz0gc2VwYXJhdGlvbihub2RlLCBwcmV2aW91c05vZGUpIDogMDtcbiAgICAgICAgICBub2RlLnkgPSAwO1xuICAgICAgICAgIHByZXZpb3VzTm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGxlZnQgPSBkM19sYXlvdXRfY2x1c3RlckxlZnQocm9vdCksIHJpZ2h0ID0gZDNfbGF5b3V0X2NsdXN0ZXJSaWdodChyb290KSwgeDAgPSBsZWZ0LnggLSBzZXBhcmF0aW9uKGxlZnQsIHJpZ2h0KSAvIDIsIHgxID0gcmlnaHQueCArIHNlcGFyYXRpb24ocmlnaHQsIGxlZnQpIC8gMjtcbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIG5vZGVTaXplID8gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBub2RlLnggPSAobm9kZS54IC0gcm9vdC54KSAqIHNpemVbMF07XG4gICAgICAgIG5vZGUueSA9IChyb290LnkgLSBub2RlLnkpICogc2l6ZVsxXTtcbiAgICAgIH0gOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIG5vZGUueCA9IChub2RlLnggLSB4MCkgLyAoeDEgLSB4MCkgKiBzaXplWzBdO1xuICAgICAgICBub2RlLnkgPSAoMSAtIChyb290LnkgPyBub2RlLnkgLyByb290LnkgOiAxKSkgKiBzaXplWzFdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIGNsdXN0ZXIuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNlcGFyYXRpb247XG4gICAgICBzZXBhcmF0aW9uID0geDtcbiAgICAgIHJldHVybiBjbHVzdGVyO1xuICAgIH07XG4gICAgY2x1c3Rlci5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9kZVNpemUgPyBudWxsIDogc2l6ZTtcbiAgICAgIG5vZGVTaXplID0gKHNpemUgPSB4KSA9PSBudWxsO1xuICAgICAgcmV0dXJuIGNsdXN0ZXI7XG4gICAgfTtcbiAgICBjbHVzdGVyLm5vZGVTaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9kZVNpemUgPyBzaXplIDogbnVsbDtcbiAgICAgIG5vZGVTaXplID0gKHNpemUgPSB4KSAhPSBudWxsO1xuICAgICAgcmV0dXJuIGNsdXN0ZXI7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfbGF5b3V0X2hpZXJhcmNoeVJlYmluZChjbHVzdGVyLCBoaWVyYXJjaHkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfY2x1c3RlclkoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gMSArIGQzLm1heChjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC55O1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9jbHVzdGVyWChjaGlsZHJlbikge1xuICAgIHJldHVybiBjaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24oeCwgY2hpbGQpIHtcbiAgICAgIHJldHVybiB4ICsgY2hpbGQueDtcbiAgICB9LCAwKSAvIGNoaWxkcmVuLmxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfY2x1c3RlckxlZnQobm9kZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgcmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA/IGQzX2xheW91dF9jbHVzdGVyTGVmdChjaGlsZHJlblswXSkgOiBub2RlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9jbHVzdGVyUmlnaHQobm9kZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4sIG47XG4gICAgcmV0dXJuIGNoaWxkcmVuICYmIChuID0gY2hpbGRyZW4ubGVuZ3RoKSA/IGQzX2xheW91dF9jbHVzdGVyUmlnaHQoY2hpbGRyZW5bbiAtIDFdKSA6IG5vZGU7XG4gIH1cbiAgZDMubGF5b3V0LnRyZWVtYXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gZDMubGF5b3V0LmhpZXJhcmNoeSgpLCByb3VuZCA9IE1hdGgucm91bmQsIHNpemUgPSBbIDEsIDEgXSwgcGFkZGluZyA9IG51bGwsIHBhZCA9IGQzX2xheW91dF90cmVlbWFwUGFkTnVsbCwgc3RpY2t5ID0gZmFsc2UsIHN0aWNraWVzLCBtb2RlID0gXCJzcXVhcmlmeVwiLCByYXRpbyA9IC41ICogKDEgKyBNYXRoLnNxcnQoNSkpO1xuICAgIGZ1bmN0aW9uIHNjYWxlKGNoaWxkcmVuLCBrKSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gY2hpbGRyZW4ubGVuZ3RoLCBjaGlsZCwgYXJlYTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGFyZWEgPSAoY2hpbGQgPSBjaGlsZHJlbltpXSkudmFsdWUgKiAoayA8IDAgPyAwIDogayk7XG4gICAgICAgIGNoaWxkLmFyZWEgPSBpc05hTihhcmVhKSB8fCBhcmVhIDw9IDAgPyAwIDogYXJlYTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3F1YXJpZnkobm9kZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBwYWQobm9kZSksIHJvdyA9IFtdLCByZW1haW5pbmcgPSBjaGlsZHJlbi5zbGljZSgpLCBjaGlsZCwgYmVzdCA9IEluZmluaXR5LCBzY29yZSwgdSA9IG1vZGUgPT09IFwic2xpY2VcIiA/IHJlY3QuZHggOiBtb2RlID09PSBcImRpY2VcIiA/IHJlY3QuZHkgOiBtb2RlID09PSBcInNsaWNlLWRpY2VcIiA/IG5vZGUuZGVwdGggJiAxID8gcmVjdC5keSA6IHJlY3QuZHggOiBNYXRoLm1pbihyZWN0LmR4LCByZWN0LmR5KSwgbjtcbiAgICAgICAgc2NhbGUocmVtYWluaW5nLCByZWN0LmR4ICogcmVjdC5keSAvIG5vZGUudmFsdWUpO1xuICAgICAgICByb3cuYXJlYSA9IDA7XG4gICAgICAgIHdoaWxlICgobiA9IHJlbWFpbmluZy5sZW5ndGgpID4gMCkge1xuICAgICAgICAgIHJvdy5wdXNoKGNoaWxkID0gcmVtYWluaW5nW24gLSAxXSk7XG4gICAgICAgICAgcm93LmFyZWEgKz0gY2hpbGQuYXJlYTtcbiAgICAgICAgICBpZiAobW9kZSAhPT0gXCJzcXVhcmlmeVwiIHx8IChzY29yZSA9IHdvcnN0KHJvdywgdSkpIDw9IGJlc3QpIHtcbiAgICAgICAgICAgIHJlbWFpbmluZy5wb3AoKTtcbiAgICAgICAgICAgIGJlc3QgPSBzY29yZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm93LmFyZWEgLT0gcm93LnBvcCgpLmFyZWE7XG4gICAgICAgICAgICBwb3NpdGlvbihyb3csIHUsIHJlY3QsIGZhbHNlKTtcbiAgICAgICAgICAgIHUgPSBNYXRoLm1pbihyZWN0LmR4LCByZWN0LmR5KTtcbiAgICAgICAgICAgIHJvdy5sZW5ndGggPSByb3cuYXJlYSA9IDA7XG4gICAgICAgICAgICBiZXN0ID0gSW5maW5pdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyb3cubGVuZ3RoKSB7XG4gICAgICAgICAgcG9zaXRpb24ocm93LCB1LCByZWN0LCB0cnVlKTtcbiAgICAgICAgICByb3cubGVuZ3RoID0gcm93LmFyZWEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goc3F1YXJpZnkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdGlja2lmeShub2RlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB2YXIgcmVjdCA9IHBhZChub2RlKSwgcmVtYWluaW5nID0gY2hpbGRyZW4uc2xpY2UoKSwgY2hpbGQsIHJvdyA9IFtdO1xuICAgICAgICBzY2FsZShyZW1haW5pbmcsIHJlY3QuZHggKiByZWN0LmR5IC8gbm9kZS52YWx1ZSk7XG4gICAgICAgIHJvdy5hcmVhID0gMDtcbiAgICAgICAgd2hpbGUgKGNoaWxkID0gcmVtYWluaW5nLnBvcCgpKSB7XG4gICAgICAgICAgcm93LnB1c2goY2hpbGQpO1xuICAgICAgICAgIHJvdy5hcmVhICs9IGNoaWxkLmFyZWE7XG4gICAgICAgICAgaWYgKGNoaWxkLnogIT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zaXRpb24ocm93LCBjaGlsZC56ID8gcmVjdC5keCA6IHJlY3QuZHksIHJlY3QsICFyZW1haW5pbmcubGVuZ3RoKTtcbiAgICAgICAgICAgIHJvdy5sZW5ndGggPSByb3cuYXJlYSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goc3RpY2tpZnkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3b3JzdChyb3csIHUpIHtcbiAgICAgIHZhciBzID0gcm93LmFyZWEsIHIsIHJtYXggPSAwLCBybWluID0gSW5maW5pdHksIGkgPSAtMSwgbiA9IHJvdy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoIShyID0gcm93W2ldLmFyZWEpKSBjb250aW51ZTtcbiAgICAgICAgaWYgKHIgPCBybWluKSBybWluID0gcjtcbiAgICAgICAgaWYgKHIgPiBybWF4KSBybWF4ID0gcjtcbiAgICAgIH1cbiAgICAgIHMgKj0gcztcbiAgICAgIHUgKj0gdTtcbiAgICAgIHJldHVybiBzID8gTWF0aC5tYXgodSAqIHJtYXggKiByYXRpbyAvIHMsIHMgLyAodSAqIHJtaW4gKiByYXRpbykpIDogSW5maW5pdHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uKHJvdywgdSwgcmVjdCwgZmx1c2gpIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSByb3cubGVuZ3RoLCB4ID0gcmVjdC54LCB5ID0gcmVjdC55LCB2ID0gdSA/IHJvdW5kKHJvdy5hcmVhIC8gdSkgOiAwLCBvO1xuICAgICAgaWYgKHUgPT0gcmVjdC5keCkge1xuICAgICAgICBpZiAoZmx1c2ggfHwgdiA+IHJlY3QuZHkpIHYgPSByZWN0LmR5O1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIG8gPSByb3dbaV07XG4gICAgICAgICAgby54ID0geDtcbiAgICAgICAgICBvLnkgPSB5O1xuICAgICAgICAgIG8uZHkgPSB2O1xuICAgICAgICAgIHggKz0gby5keCA9IE1hdGgubWluKHJlY3QueCArIHJlY3QuZHggLSB4LCB2ID8gcm91bmQoby5hcmVhIC8gdikgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBvLnogPSB0cnVlO1xuICAgICAgICBvLmR4ICs9IHJlY3QueCArIHJlY3QuZHggLSB4O1xuICAgICAgICByZWN0LnkgKz0gdjtcbiAgICAgICAgcmVjdC5keSAtPSB2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZsdXNoIHx8IHYgPiByZWN0LmR4KSB2ID0gcmVjdC5keDtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBvID0gcm93W2ldO1xuICAgICAgICAgIG8ueCA9IHg7XG4gICAgICAgICAgby55ID0geTtcbiAgICAgICAgICBvLmR4ID0gdjtcbiAgICAgICAgICB5ICs9IG8uZHkgPSBNYXRoLm1pbihyZWN0LnkgKyByZWN0LmR5IC0geSwgdiA/IHJvdW5kKG8uYXJlYSAvIHYpIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgby56ID0gZmFsc2U7XG4gICAgICAgIG8uZHkgKz0gcmVjdC55ICsgcmVjdC5keSAtIHk7XG4gICAgICAgIHJlY3QueCArPSB2O1xuICAgICAgICByZWN0LmR4IC09IHY7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyZWVtYXAoZCkge1xuICAgICAgdmFyIG5vZGVzID0gc3RpY2tpZXMgfHwgaGllcmFyY2h5KGQpLCByb290ID0gbm9kZXNbMF07XG4gICAgICByb290LnggPSByb290LnkgPSAwO1xuICAgICAgaWYgKHJvb3QudmFsdWUpIHJvb3QuZHggPSBzaXplWzBdLCByb290LmR5ID0gc2l6ZVsxXTsgZWxzZSByb290LmR4ID0gcm9vdC5keSA9IDA7XG4gICAgICBpZiAoc3RpY2tpZXMpIGhpZXJhcmNoeS5yZXZhbHVlKHJvb3QpO1xuICAgICAgc2NhbGUoWyByb290IF0sIHJvb3QuZHggKiByb290LmR5IC8gcm9vdC52YWx1ZSk7XG4gICAgICAoc3RpY2tpZXMgPyBzdGlja2lmeSA6IHNxdWFyaWZ5KShyb290KTtcbiAgICAgIGlmIChzdGlja3kpIHN0aWNraWVzID0gbm9kZXM7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHRyZWVtYXAuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0geDtcbiAgICAgIHJldHVybiB0cmVlbWFwO1xuICAgIH07XG4gICAgdHJlZW1hcC5wYWRkaW5nID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGFkZGluZztcbiAgICAgIGZ1bmN0aW9uIHBhZEZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHAgPSB4LmNhbGwodHJlZW1hcCwgbm9kZSwgbm9kZS5kZXB0aCk7XG4gICAgICAgIHJldHVybiBwID09IG51bGwgPyBkM19sYXlvdXRfdHJlZW1hcFBhZE51bGwobm9kZSkgOiBkM19sYXlvdXRfdHJlZW1hcFBhZChub2RlLCB0eXBlb2YgcCA9PT0gXCJudW1iZXJcIiA/IFsgcCwgcCwgcCwgcCBdIDogcCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYWRDb25zdGFudChub2RlKSB7XG4gICAgICAgIHJldHVybiBkM19sYXlvdXRfdHJlZW1hcFBhZChub2RlLCB4KTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlO1xuICAgICAgcGFkID0gKHBhZGRpbmcgPSB4KSA9PSBudWxsID8gZDNfbGF5b3V0X3RyZWVtYXBQYWROdWxsIDogKHR5cGUgPSB0eXBlb2YgeCkgPT09IFwiZnVuY3Rpb25cIiA/IHBhZEZ1bmN0aW9uIDogdHlwZSA9PT0gXCJudW1iZXJcIiA/ICh4ID0gWyB4LCB4LCB4LCB4IF0sIFxuICAgICAgcGFkQ29uc3RhbnQpIDogcGFkQ29uc3RhbnQ7XG4gICAgICByZXR1cm4gdHJlZW1hcDtcbiAgICB9O1xuICAgIHRyZWVtYXAucm91bmQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByb3VuZCAhPSBOdW1iZXI7XG4gICAgICByb3VuZCA9IHggPyBNYXRoLnJvdW5kIDogTnVtYmVyO1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICB0cmVlbWFwLnN0aWNreSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0aWNreTtcbiAgICAgIHN0aWNreSA9IHg7XG4gICAgICBzdGlja2llcyA9IG51bGw7XG4gICAgICByZXR1cm4gdHJlZW1hcDtcbiAgICB9O1xuICAgIHRyZWVtYXAucmF0aW8gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYXRpbztcbiAgICAgIHJhdGlvID0geDtcbiAgICAgIHJldHVybiB0cmVlbWFwO1xuICAgIH07XG4gICAgdHJlZW1hcC5tb2RlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbW9kZTtcbiAgICAgIG1vZGUgPSB4ICsgXCJcIjtcbiAgICAgIHJldHVybiB0cmVlbWFwO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQodHJlZW1hcCwgaGllcmFyY2h5KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVtYXBQYWROdWxsKG5vZGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogbm9kZS54LFxuICAgICAgeTogbm9kZS55LFxuICAgICAgZHg6IG5vZGUuZHgsXG4gICAgICBkeTogbm9kZS5keVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVtYXBQYWQobm9kZSwgcGFkZGluZykge1xuICAgIHZhciB4ID0gbm9kZS54ICsgcGFkZGluZ1szXSwgeSA9IG5vZGUueSArIHBhZGRpbmdbMF0sIGR4ID0gbm9kZS5keCAtIHBhZGRpbmdbMV0gLSBwYWRkaW5nWzNdLCBkeSA9IG5vZGUuZHkgLSBwYWRkaW5nWzBdIC0gcGFkZGluZ1syXTtcbiAgICBpZiAoZHggPCAwKSB7XG4gICAgICB4ICs9IGR4IC8gMjtcbiAgICAgIGR4ID0gMDtcbiAgICB9XG4gICAgaWYgKGR5IDwgMCkge1xuICAgICAgeSArPSBkeSAvIDI7XG4gICAgICBkeSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIGR4OiBkeCxcbiAgICAgIGR5OiBkeVxuICAgIH07XG4gIH1cbiAgZDMucmFuZG9tID0ge1xuICAgIG5vcm1hbDogZnVuY3Rpb24owrUsIM+DKSB7XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAobiA8IDIpIM+DID0gMTtcbiAgICAgIGlmIChuIDwgMSkgwrUgPSAwO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeCwgeSwgcjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHggPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG4gICAgICAgICAgeSA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcbiAgICAgICAgICByID0geCAqIHggKyB5ICogeTtcbiAgICAgICAgfSB3aGlsZSAoIXIgfHwgciA+IDEpO1xuICAgICAgICByZXR1cm4gwrUgKyDPgyAqIHggKiBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhyKSAvIHIpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGxvZ05vcm1hbDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmFuZG9tID0gZDMucmFuZG9tLm5vcm1hbC5hcHBseShkMywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZXhwKHJhbmRvbSgpKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBiYXRlczogZnVuY3Rpb24obSkge1xuICAgICAgdmFyIHJhbmRvbSA9IGQzLnJhbmRvbS5pcndpbkhhbGwobSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByYW5kb20oKSAvIG07XG4gICAgICB9O1xuICAgIH0sXG4gICAgaXJ3aW5IYWxsOiBmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSAwLCBqID0gMDsgaiA8IG07IGorKykgcyArPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBkMy5zY2FsZSA9IHt9O1xuICBmdW5jdGlvbiBkM19zY2FsZUV4dGVudChkb21haW4pIHtcbiAgICB2YXIgc3RhcnQgPSBkb21haW5bMF0sIHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBzdGFydCA8IHN0b3AgPyBbIHN0YXJ0LCBzdG9wIF0gOiBbIHN0b3AsIHN0YXJ0IF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVSYW5nZShzY2FsZSkge1xuICAgIHJldHVybiBzY2FsZS5yYW5nZUV4dGVudCA/IHNjYWxlLnJhbmdlRXh0ZW50KCkgOiBkM19zY2FsZUV4dGVudChzY2FsZS5yYW5nZSgpKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9iaWxpbmVhcihkb21haW4sIHJhbmdlLCB1bmludGVycG9sYXRlLCBpbnRlcnBvbGF0ZSkge1xuICAgIHZhciB1ID0gdW5pbnRlcnBvbGF0ZShkb21haW5bMF0sIGRvbWFpblsxXSksIGkgPSBpbnRlcnBvbGF0ZShyYW5nZVswXSwgcmFuZ2VbMV0pO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaSh1KHgpKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX25pY2UoZG9tYWluLCBuaWNlKSB7XG4gICAgdmFyIGkwID0gMCwgaTEgPSBkb21haW4ubGVuZ3RoIC0gMSwgeDAgPSBkb21haW5baTBdLCB4MSA9IGRvbWFpbltpMV0sIGR4O1xuICAgIGlmICh4MSA8IHgwKSB7XG4gICAgICBkeCA9IGkwLCBpMCA9IGkxLCBpMSA9IGR4O1xuICAgICAgZHggPSB4MCwgeDAgPSB4MSwgeDEgPSBkeDtcbiAgICB9XG4gICAgZG9tYWluW2kwXSA9IG5pY2UuZmxvb3IoeDApO1xuICAgIGRvbWFpbltpMV0gPSBuaWNlLmNlaWwoeDEpO1xuICAgIHJldHVybiBkb21haW47XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbmljZVN0ZXAoc3RlcCkge1xuICAgIHJldHVybiBzdGVwID8ge1xuICAgICAgZmxvb3I6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoeCAvIHN0ZXApICogc3RlcDtcbiAgICAgIH0sXG4gICAgICBjZWlsOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoeCAvIHN0ZXApICogc3RlcDtcbiAgICAgIH1cbiAgICB9IDogZDNfc2NhbGVfbmljZUlkZW50aXR5O1xuICB9XG4gIHZhciBkM19zY2FsZV9uaWNlSWRlbnRpdHkgPSB7XG4gICAgZmxvb3I6IGQzX2lkZW50aXR5LFxuICAgIGNlaWw6IGQzX2lkZW50aXR5XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3BvbHlsaW5lYXIoZG9tYWluLCByYW5nZSwgdW5pbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGUpIHtcbiAgICB2YXIgdSA9IFtdLCBpID0gW10sIGogPSAwLCBrID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKSAtIDE7XG4gICAgaWYgKGRvbWFpbltrXSA8IGRvbWFpblswXSkge1xuICAgICAgZG9tYWluID0gZG9tYWluLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgcmFuZ2UgPSByYW5nZS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICB9XG4gICAgd2hpbGUgKCsraiA8PSBrKSB7XG4gICAgICB1LnB1c2godW5pbnRlcnBvbGF0ZShkb21haW5baiAtIDFdLCBkb21haW5bal0pKTtcbiAgICAgIGkucHVzaChpbnRlcnBvbGF0ZShyYW5nZVtqIC0gMV0sIHJhbmdlW2pdKSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgaiA9IGQzLmJpc2VjdChkb21haW4sIHgsIDEsIGspIC0gMTtcbiAgICAgIHJldHVybiBpW2pdKHVbal0oeCkpO1xuICAgIH07XG4gIH1cbiAgZDMuc2NhbGUubGluZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhcihbIDAsIDEgXSwgWyAwLCAxIF0sIGQzX2ludGVycG9sYXRlLCBmYWxzZSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhcihkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSwgY2xhbXApIHtcbiAgICB2YXIgb3V0cHV0LCBpbnB1dDtcbiAgICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgICAgdmFyIGxpbmVhciA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgPiAyID8gZDNfc2NhbGVfcG9seWxpbmVhciA6IGQzX3NjYWxlX2JpbGluZWFyLCB1bmludGVycG9sYXRlID0gY2xhbXAgPyBkM191bmludGVycG9sYXRlQ2xhbXAgOiBkM191bmludGVycG9sYXRlTnVtYmVyO1xuICAgICAgb3V0cHV0ID0gbGluZWFyKGRvbWFpbiwgcmFuZ2UsIHVuaW50ZXJwb2xhdGUsIGludGVycG9sYXRlKTtcbiAgICAgIGlucHV0ID0gbGluZWFyKHJhbmdlLCBkb21haW4sIHVuaW50ZXJwb2xhdGUsIGQzX2ludGVycG9sYXRlKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIG91dHB1dCh4KTtcbiAgICB9XG4gICAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIGlucHV0KHkpO1xuICAgIH07XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgZG9tYWluID0geC5tYXAoTnVtYmVyKTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlO1xuICAgICAgcmFuZ2UgPSB4O1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlUm91bmQgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gc2NhbGUucmFuZ2UoeCkuaW50ZXJwb2xhdGUoZDNfaW50ZXJwb2xhdGVSb3VuZCk7XG4gICAgfTtcbiAgICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsYW1wO1xuICAgICAgY2xhbXAgPSB4O1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLmludGVycG9sYXRlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaW50ZXJwb2xhdGU7XG4gICAgICBpbnRlcnBvbGF0ZSA9IHg7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyVGlja3MoZG9tYWluLCBtKTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihtLCBmb3JtYXQpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrRm9ybWF0KGRvbWFpbiwgbSwgZm9ybWF0KTtcbiAgICB9O1xuICAgIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihtKSB7XG4gICAgICBkM19zY2FsZV9saW5lYXJOaWNlKGRvbWFpbiwgbSk7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhcihkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSwgY2xhbXApO1xuICAgIH07XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJSZWJpbmQoc2NhbGUsIGxpbmVhcikge1xuICAgIHJldHVybiBkMy5yZWJpbmQoc2NhbGUsIGxpbmVhciwgXCJyYW5nZVwiLCBcInJhbmdlUm91bmRcIiwgXCJpbnRlcnBvbGF0ZVwiLCBcImNsYW1wXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhck5pY2UoZG9tYWluLCBtKSB7XG4gICAgZDNfc2NhbGVfbmljZShkb21haW4sIGQzX3NjYWxlX25pY2VTdGVwKGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShkb21haW4sIG0pWzJdKSk7XG4gICAgZDNfc2NhbGVfbmljZShkb21haW4sIGQzX3NjYWxlX25pY2VTdGVwKGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShkb21haW4sIG0pWzJdKSk7XG4gICAgcmV0dXJuIGRvbWFpbjtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZG9tYWluLCBtKSB7XG4gICAgaWYgKG0gPT0gbnVsbCkgbSA9IDEwO1xuICAgIHZhciBleHRlbnQgPSBkM19zY2FsZUV4dGVudChkb21haW4pLCBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdLCBzdGVwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc3BhbiAvIG0pIC8gTWF0aC5MTjEwKSksIGVyciA9IG0gLyBzcGFuICogc3RlcDtcbiAgICBpZiAoZXJyIDw9IC4xNSkgc3RlcCAqPSAxMDsgZWxzZSBpZiAoZXJyIDw9IC4zNSkgc3RlcCAqPSA1OyBlbHNlIGlmIChlcnIgPD0gLjc1KSBzdGVwICo9IDI7XG4gICAgZXh0ZW50WzBdID0gTWF0aC5jZWlsKGV4dGVudFswXSAvIHN0ZXApICogc3RlcDtcbiAgICBleHRlbnRbMV0gPSBNYXRoLmZsb29yKGV4dGVudFsxXSAvIHN0ZXApICogc3RlcCArIHN0ZXAgKiAuNTtcbiAgICBleHRlbnRbMl0gPSBzdGVwO1xuICAgIHJldHVybiBleHRlbnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyVGlja3MoZG9tYWluLCBtKSB7XG4gICAgcmV0dXJuIGQzLnJhbmdlLmFwcGx5KGQzLCBkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZG9tYWluLCBtKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyVGlja0Zvcm1hdChkb21haW4sIG0sIGZvcm1hdCkge1xuICAgIHZhciByYW5nZSA9IGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShkb21haW4sIG0pO1xuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgIHZhciBtYXRjaCA9IGQzX2Zvcm1hdF9yZS5leGVjKGZvcm1hdCk7XG4gICAgICBtYXRjaC5zaGlmdCgpO1xuICAgICAgaWYgKG1hdGNoWzhdID09PSBcInNcIikge1xuICAgICAgICB2YXIgcHJlZml4ID0gZDMuZm9ybWF0UHJlZml4KE1hdGgubWF4KGFicyhyYW5nZVswXSksIGFicyhyYW5nZVsxXSkpKTtcbiAgICAgICAgaWYgKCFtYXRjaFs3XSkgbWF0Y2hbN10gPSBcIi5cIiArIGQzX3NjYWxlX2xpbmVhclByZWNpc2lvbihwcmVmaXguc2NhbGUocmFuZ2VbMl0pKTtcbiAgICAgICAgbWF0Y2hbOF0gPSBcImZcIjtcbiAgICAgICAgZm9ybWF0ID0gZDMuZm9ybWF0KG1hdGNoLmpvaW4oXCJcIikpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiBmb3JtYXQocHJlZml4LnNjYWxlKGQpKSArIHByZWZpeC5zeW1ib2w7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoIW1hdGNoWzddKSBtYXRjaFs3XSA9IFwiLlwiICsgZDNfc2NhbGVfbGluZWFyRm9ybWF0UHJlY2lzaW9uKG1hdGNoWzhdLCByYW5nZSk7XG4gICAgICBmb3JtYXQgPSBtYXRjaC5qb2luKFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtYXQgPSBcIiwuXCIgKyBkM19zY2FsZV9saW5lYXJQcmVjaXNpb24ocmFuZ2VbMl0pICsgXCJmXCI7XG4gICAgfVxuICAgIHJldHVybiBkMy5mb3JtYXQoZm9ybWF0KTtcbiAgfVxuICB2YXIgZDNfc2NhbGVfbGluZWFyRm9ybWF0U2lnbmlmaWNhbnQgPSB7XG4gICAgczogMSxcbiAgICBnOiAxLFxuICAgIHA6IDEsXG4gICAgcjogMSxcbiAgICBlOiAxXG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhclByZWNpc2lvbih2YWx1ZSkge1xuICAgIHJldHVybiAtTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMTAgKyAuMDEpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhckZvcm1hdFByZWNpc2lvbih0eXBlLCByYW5nZSkge1xuICAgIHZhciBwID0gZDNfc2NhbGVfbGluZWFyUHJlY2lzaW9uKHJhbmdlWzJdKTtcbiAgICByZXR1cm4gdHlwZSBpbiBkM19zY2FsZV9saW5lYXJGb3JtYXRTaWduaWZpY2FudCA/IE1hdGguYWJzKHAgLSBkM19zY2FsZV9saW5lYXJQcmVjaXNpb24oTWF0aC5tYXgoYWJzKHJhbmdlWzBdKSwgYWJzKHJhbmdlWzFdKSkpKSArICsodHlwZSAhPT0gXCJlXCIpIDogcCAtICh0eXBlID09PSBcIiVcIikgKiAyO1xuICB9XG4gIGQzLnNjYWxlLmxvZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV9sb2coZDMuc2NhbGUubGluZWFyKCkuZG9tYWluKFsgMCwgMSBdKSwgMTAsIHRydWUsIFsgMSwgMTAgXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xvZyhsaW5lYXIsIGJhc2UsIHBvc2l0aXZlLCBkb21haW4pIHtcbiAgICBmdW5jdGlvbiBsb2coeCkge1xuICAgICAgcmV0dXJuIChwb3NpdGl2ZSA/IE1hdGgubG9nKHggPCAwID8gMCA6IHgpIDogLU1hdGgubG9nKHggPiAwID8gMCA6IC14KSkgLyBNYXRoLmxvZyhiYXNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG93KHgpIHtcbiAgICAgIHJldHVybiBwb3NpdGl2ZSA/IE1hdGgucG93KGJhc2UsIHgpIDogLU1hdGgucG93KGJhc2UsIC14KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIGxpbmVhcihsb2coeCkpO1xuICAgIH1cbiAgICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gcG93KGxpbmVhci5pbnZlcnQoeCkpO1xuICAgIH07XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgcG9zaXRpdmUgPSB4WzBdID49IDA7XG4gICAgICBsaW5lYXIuZG9tYWluKChkb21haW4gPSB4Lm1hcChOdW1iZXIpKS5tYXAobG9nKSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5iYXNlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYmFzZTtcbiAgICAgIGJhc2UgPSArXztcbiAgICAgIGxpbmVhci5kb21haW4oZG9tYWluLm1hcChsb2cpKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLm5pY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuaWNlZCA9IGQzX3NjYWxlX25pY2UoZG9tYWluLm1hcChsb2cpLCBwb3NpdGl2ZSA/IE1hdGggOiBkM19zY2FsZV9sb2dOaWNlTmVnYXRpdmUpO1xuICAgICAgbGluZWFyLmRvbWFpbihuaWNlZCk7XG4gICAgICBkb21haW4gPSBuaWNlZC5tYXAocG93KTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXh0ZW50ID0gZDNfc2NhbGVFeHRlbnQoZG9tYWluKSwgdGlja3MgPSBbXSwgdSA9IGV4dGVudFswXSwgdiA9IGV4dGVudFsxXSwgaSA9IE1hdGguZmxvb3IobG9nKHUpKSwgaiA9IE1hdGguY2VpbChsb2codikpLCBuID0gYmFzZSAlIDEgPyAyIDogYmFzZTtcbiAgICAgIGlmIChpc0Zpbml0ZShqIC0gaSkpIHtcbiAgICAgICAgaWYgKHBvc2l0aXZlKSB7XG4gICAgICAgICAgZm9yICg7aSA8IGo7IGkrKykgZm9yICh2YXIgayA9IDE7IGsgPCBuOyBrKyspIHRpY2tzLnB1c2gocG93KGkpICogayk7XG4gICAgICAgICAgdGlja3MucHVzaChwb3coaSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpY2tzLnB1c2gocG93KGkpKTtcbiAgICAgICAgICBmb3IgKDtpKysgPCBqOyApIGZvciAodmFyIGsgPSBuIC0gMTsgayA+IDA7IGstLSkgdGlja3MucHVzaChwb3coaSkgKiBrKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyB0aWNrc1tpXSA8IHU7IGkrKykge31cbiAgICAgICAgZm9yIChqID0gdGlja3MubGVuZ3RoOyB0aWNrc1tqIC0gMV0gPiB2OyBqLS0pIHt9XG4gICAgICAgIHRpY2tzID0gdGlja3Muc2xpY2UoaSwgaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGlja3M7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24obiwgZm9ybWF0KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkM19zY2FsZV9sb2dGb3JtYXQ7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIGZvcm1hdCA9IGQzX3NjYWxlX2xvZ0Zvcm1hdDsgZWxzZSBpZiAodHlwZW9mIGZvcm1hdCAhPT0gXCJmdW5jdGlvblwiKSBmb3JtYXQgPSBkMy5mb3JtYXQoZm9ybWF0KTtcbiAgICAgIHZhciBrID0gTWF0aC5tYXgoMSwgYmFzZSAqIG4gLyBzY2FsZS50aWNrcygpLmxlbmd0aCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgICAgICB2YXIgaSA9IGQgLyBwb3coTWF0aC5yb3VuZChsb2coZCkpKTtcbiAgICAgICAgaWYgKGkgKiBiYXNlIDwgYmFzZSAtIC41KSBpICo9IGJhc2U7XG4gICAgICAgIHJldHVybiBpIDw9IGsgPyBmb3JtYXQoZCkgOiBcIlwiO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9sb2cobGluZWFyLmNvcHkoKSwgYmFzZSwgcG9zaXRpdmUsIGRvbWFpbik7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyUmViaW5kKHNjYWxlLCBsaW5lYXIpO1xuICB9XG4gIHZhciBkM19zY2FsZV9sb2dGb3JtYXQgPSBkMy5mb3JtYXQoXCIuMGVcIiksIGQzX3NjYWxlX2xvZ05pY2VOZWdhdGl2ZSA9IHtcbiAgICBmbG9vcjogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIC1NYXRoLmNlaWwoLXgpO1xuICAgIH0sXG4gICAgY2VpbDogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIC1NYXRoLmZsb29yKC14KTtcbiAgICB9XG4gIH07XG4gIGQzLnNjYWxlLnBvdyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV9wb3coZDMuc2NhbGUubGluZWFyKCksIDEsIFsgMCwgMSBdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfcG93KGxpbmVhciwgZXhwb25lbnQsIGRvbWFpbikge1xuICAgIHZhciBwb3dwID0gZDNfc2NhbGVfcG93UG93KGV4cG9uZW50KSwgcG93YiA9IGQzX3NjYWxlX3Bvd1BvdygxIC8gZXhwb25lbnQpO1xuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiBsaW5lYXIocG93cCh4KSk7XG4gICAgfVxuICAgIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBwb3diKGxpbmVhci5pbnZlcnQoeCkpO1xuICAgIH07XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgbGluZWFyLmRvbWFpbigoZG9tYWluID0geC5tYXAoTnVtYmVyKSkubWFwKHBvd3ApKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclRpY2tzKGRvbWFpbiwgbSk7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24obSwgZm9ybWF0KSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyVGlja0Zvcm1hdChkb21haW4sIG0sIGZvcm1hdCk7XG4gICAgfTtcbiAgICBzY2FsZS5uaWNlID0gZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuIHNjYWxlLmRvbWFpbihkM19zY2FsZV9saW5lYXJOaWNlKGRvbWFpbiwgbSkpO1xuICAgIH07XG4gICAgc2NhbGUuZXhwb25lbnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBleHBvbmVudDtcbiAgICAgIHBvd3AgPSBkM19zY2FsZV9wb3dQb3coZXhwb25lbnQgPSB4KTtcbiAgICAgIHBvd2IgPSBkM19zY2FsZV9wb3dQb3coMSAvIGV4cG9uZW50KTtcbiAgICAgIGxpbmVhci5kb21haW4oZG9tYWluLm1hcChwb3dwKSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfcG93KGxpbmVhci5jb3B5KCksIGV4cG9uZW50LCBkb21haW4pO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclJlYmluZChzY2FsZSwgbGluZWFyKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9wb3dQb3coZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geCA8IDAgPyAtTWF0aC5wb3coLXgsIGUpIDogTWF0aC5wb3coeCwgZSk7XG4gICAgfTtcbiAgfVxuICBkMy5zY2FsZS5zcXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnNjYWxlLnBvdygpLmV4cG9uZW50KC41KTtcbiAgfTtcbiAgZDMuc2NhbGUub3JkaW5hbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV9vcmRpbmFsKFtdLCB7XG4gICAgICB0OiBcInJhbmdlXCIsXG4gICAgICBhOiBbIFtdIF1cbiAgICB9KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfb3JkaW5hbChkb21haW4sIHJhbmdlcikge1xuICAgIHZhciBpbmRleCwgcmFuZ2UsIHJhbmdlQmFuZDtcbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gcmFuZ2VbKChpbmRleC5nZXQoeCkgfHwgKHJhbmdlci50ID09PSBcInJhbmdlXCIgPyBpbmRleC5zZXQoeCwgZG9tYWluLnB1c2goeCkpIDogTmFOKSkgLSAxKSAlIHJhbmdlLmxlbmd0aF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXBzKHN0YXJ0LCBzdGVwKSB7XG4gICAgICByZXR1cm4gZDMucmFuZ2UoZG9tYWluLmxlbmd0aCkubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgc3RlcCAqIGk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgZG9tYWluID0gW107XG4gICAgICBpbmRleCA9IG5ldyBkM19NYXAoKTtcbiAgICAgIHZhciBpID0gLTEsIG4gPSB4Lmxlbmd0aCwgeGk7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFpbmRleC5oYXMoeGkgPSB4W2ldKSkgaW5kZXguc2V0KHhpLCBkb21haW4ucHVzaCh4aSkpO1xuICAgICAgcmV0dXJuIHNjYWxlW3Jhbmdlci50XS5hcHBseShzY2FsZSwgcmFuZ2VyLmEpO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYW5nZTtcbiAgICAgIHJhbmdlID0geDtcbiAgICAgIHJhbmdlQmFuZCA9IDA7XG4gICAgICByYW5nZXIgPSB7XG4gICAgICAgIHQ6IFwicmFuZ2VcIixcbiAgICAgICAgYTogYXJndW1lbnRzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VQb2ludHMgPSBmdW5jdGlvbih4LCBwYWRkaW5nKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHBhZGRpbmcgPSAwO1xuICAgICAgdmFyIHN0YXJ0ID0geFswXSwgc3RvcCA9IHhbMV0sIHN0ZXAgPSBkb21haW4ubGVuZ3RoIDwgMiA/IChzdGFydCA9IChzdGFydCArIHN0b3ApIC8gMiwgXG4gICAgICAwKSA6IChzdG9wIC0gc3RhcnQpIC8gKGRvbWFpbi5sZW5ndGggLSAxICsgcGFkZGluZyk7XG4gICAgICByYW5nZSA9IHN0ZXBzKHN0YXJ0ICsgc3RlcCAqIHBhZGRpbmcgLyAyLCBzdGVwKTtcbiAgICAgIHJhbmdlQmFuZCA9IDA7XG4gICAgICByYW5nZXIgPSB7XG4gICAgICAgIHQ6IFwicmFuZ2VQb2ludHNcIixcbiAgICAgICAgYTogYXJndW1lbnRzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VSb3VuZFBvaW50cyA9IGZ1bmN0aW9uKHgsIHBhZGRpbmcpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcGFkZGluZyA9IDA7XG4gICAgICB2YXIgc3RhcnQgPSB4WzBdLCBzdG9wID0geFsxXSwgc3RlcCA9IGRvbWFpbi5sZW5ndGggPCAyID8gKHN0YXJ0ID0gc3RvcCA9IE1hdGgucm91bmQoKHN0YXJ0ICsgc3RvcCkgLyAyKSwgXG4gICAgICAwKSA6IChzdG9wIC0gc3RhcnQpIC8gKGRvbWFpbi5sZW5ndGggLSAxICsgcGFkZGluZykgfCAwO1xuICAgICAgcmFuZ2UgPSBzdGVwcyhzdGFydCArIE1hdGgucm91bmQoc3RlcCAqIHBhZGRpbmcgLyAyICsgKHN0b3AgLSBzdGFydCAtIChkb21haW4ubGVuZ3RoIC0gMSArIHBhZGRpbmcpICogc3RlcCkgLyAyKSwgc3RlcCk7XG4gICAgICByYW5nZUJhbmQgPSAwO1xuICAgICAgcmFuZ2VyID0ge1xuICAgICAgICB0OiBcInJhbmdlUm91bmRQb2ludHNcIixcbiAgICAgICAgYTogYXJndW1lbnRzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VCYW5kcyA9IGZ1bmN0aW9uKHgsIHBhZGRpbmcsIG91dGVyUGFkZGluZykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBwYWRkaW5nID0gMDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgb3V0ZXJQYWRkaW5nID0gcGFkZGluZztcbiAgICAgIHZhciByZXZlcnNlID0geFsxXSA8IHhbMF0sIHN0YXJ0ID0geFtyZXZlcnNlIC0gMF0sIHN0b3AgPSB4WzEgLSByZXZlcnNlXSwgc3RlcCA9IChzdG9wIC0gc3RhcnQpIC8gKGRvbWFpbi5sZW5ndGggLSBwYWRkaW5nICsgMiAqIG91dGVyUGFkZGluZyk7XG4gICAgICByYW5nZSA9IHN0ZXBzKHN0YXJ0ICsgc3RlcCAqIG91dGVyUGFkZGluZywgc3RlcCk7XG4gICAgICBpZiAocmV2ZXJzZSkgcmFuZ2UucmV2ZXJzZSgpO1xuICAgICAgcmFuZ2VCYW5kID0gc3RlcCAqICgxIC0gcGFkZGluZyk7XG4gICAgICByYW5nZXIgPSB7XG4gICAgICAgIHQ6IFwicmFuZ2VCYW5kc1wiLFxuICAgICAgICBhOiBhcmd1bWVudHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZVJvdW5kQmFuZHMgPSBmdW5jdGlvbih4LCBwYWRkaW5nLCBvdXRlclBhZGRpbmcpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcGFkZGluZyA9IDA7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIG91dGVyUGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICB2YXIgcmV2ZXJzZSA9IHhbMV0gPCB4WzBdLCBzdGFydCA9IHhbcmV2ZXJzZSAtIDBdLCBzdG9wID0geFsxIC0gcmV2ZXJzZV0sIHN0ZXAgPSBNYXRoLmZsb29yKChzdG9wIC0gc3RhcnQpIC8gKGRvbWFpbi5sZW5ndGggLSBwYWRkaW5nICsgMiAqIG91dGVyUGFkZGluZykpO1xuICAgICAgcmFuZ2UgPSBzdGVwcyhzdGFydCArIE1hdGgucm91bmQoKHN0b3AgLSBzdGFydCAtIChkb21haW4ubGVuZ3RoIC0gcGFkZGluZykgKiBzdGVwKSAvIDIpLCBzdGVwKTtcbiAgICAgIGlmIChyZXZlcnNlKSByYW5nZS5yZXZlcnNlKCk7XG4gICAgICByYW5nZUJhbmQgPSBNYXRoLnJvdW5kKHN0ZXAgKiAoMSAtIHBhZGRpbmcpKTtcbiAgICAgIHJhbmdlciA9IHtcbiAgICAgICAgdDogXCJyYW5nZVJvdW5kQmFuZHNcIixcbiAgICAgICAgYTogYXJndW1lbnRzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VCYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmFuZ2VCYW5kO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VFeHRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZUV4dGVudChyYW5nZXIuYVswXSk7XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfb3JkaW5hbChkb21haW4sIHJhbmdlcik7XG4gICAgfTtcbiAgICByZXR1cm4gc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gIH1cbiAgZDMuc2NhbGUuY2F0ZWdvcnkxMCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkucmFuZ2UoZDNfY2F0ZWdvcnkxMCk7XG4gIH07XG4gIGQzLnNjYWxlLmNhdGVnb3J5MjAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLnJhbmdlKGQzX2NhdGVnb3J5MjApO1xuICB9O1xuICBkMy5zY2FsZS5jYXRlZ29yeTIwYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkucmFuZ2UoZDNfY2F0ZWdvcnkyMGIpO1xuICB9O1xuICBkMy5zY2FsZS5jYXRlZ29yeTIwYyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkucmFuZ2UoZDNfY2F0ZWdvcnkyMGMpO1xuICB9O1xuICB2YXIgZDNfY2F0ZWdvcnkxMCA9IFsgMjA2MjI2MCwgMTY3NDQyMDYsIDI5MjQ1ODgsIDE0MDM0NzI4LCA5NzI1ODg1LCA5MTk3MTMxLCAxNDkwNzMzMCwgODM1NTcxMSwgMTIzNjkxODYsIDE1NTYxNzUgXS5tYXAoZDNfcmdiU3RyaW5nKTtcbiAgdmFyIGQzX2NhdGVnb3J5MjAgPSBbIDIwNjIyNjAsIDExNDU0NDQwLCAxNjc0NDIwNiwgMTY3NTk2NzIsIDI5MjQ1ODgsIDEwMDE4Njk4LCAxNDAzNDcyOCwgMTY3NTA3NDIsIDk3MjU4ODUsIDEyOTU1ODYxLCA5MTk3MTMxLCAxMjg4NTE0MCwgMTQ5MDczMzAsIDE2MjM0MTk0LCA4MzU1NzExLCAxMzA5MjgwNywgMTIzNjkxODYsIDE0NDA4NTg5LCAxNTU2MTc1LCAxMDQxMDcyNSBdLm1hcChkM19yZ2JTdHJpbmcpO1xuICB2YXIgZDNfY2F0ZWdvcnkyMGIgPSBbIDM3NTA3NzcsIDUzOTU2MTksIDcwNDA3MTksIDEwMjY0Mjg2LCA2NTE5MDk3LCA5MjE2NTk0LCAxMTkxNTExNSwgMTM1NTY2MzYsIDkyMDI5OTMsIDEyNDI2ODA5LCAxNTE4NjUxNCwgMTUxOTA5MzIsIDg2NjYxNjksIDExMzU2NDkwLCAxNDA0OTY0MywgMTUxNzczNzIsIDgwNzc2ODMsIDEwODM0MzI0LCAxMzUyODUwOSwgMTQ1ODk2NTQgXS5tYXAoZDNfcmdiU3RyaW5nKTtcbiAgdmFyIGQzX2NhdGVnb3J5MjBjID0gWyAzMjQ0NzMzLCA3MDU3MTEwLCAxMDQwNjYyNSwgMTMwMzI0MzEsIDE1MDk1MDUzLCAxNjYxNjc2NCwgMTY2MjUyNTksIDE2NjM0MDE4LCAzMjUzMDc2LCA3NjUyNDcwLCAxMDYwNzAwMywgMTMxMDE1MDQsIDc2OTUyODEsIDEwMzk0MzEyLCAxMjM2OTM3MiwgMTQzNDI4OTEsIDY1MTM1MDcsIDk4Njg5NTAsIDEyNDM0ODc3LCAxNDI3NzA4MSBdLm1hcChkM19yZ2JTdHJpbmcpO1xuICBkMy5zY2FsZS5xdWFudGlsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV9xdWFudGlsZShbXSwgW10pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9xdWFudGlsZShkb21haW4sIHJhbmdlKSB7XG4gICAgdmFyIHRocmVzaG9sZHM7XG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIHZhciBrID0gMCwgcSA9IHJhbmdlLmxlbmd0aDtcbiAgICAgIHRocmVzaG9sZHMgPSBbXTtcbiAgICAgIHdoaWxlICgrK2sgPCBxKSB0aHJlc2hvbGRzW2sgLSAxXSA9IGQzLnF1YW50aWxlKGRvbWFpbiwgayAvIHEpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICBpZiAoIWlzTmFOKHggPSAreCkpIHJldHVybiByYW5nZVtkMy5iaXNlY3QodGhyZXNob2xkcywgeCldO1xuICAgIH1cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBkb21haW4gPSB4Lm1hcChkM19udW1iZXIpLmZpbHRlcihkM19udW1lcmljKS5zb3J0KGQzX2FzY2VuZGluZyk7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYW5nZTtcbiAgICAgIHJhbmdlID0geDtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5xdWFudGlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aHJlc2hvbGRzO1xuICAgIH07XG4gICAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgICAgeSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgICByZXR1cm4geSA8IDAgPyBbIE5hTiwgTmFOIF0gOiBbIHkgPiAwID8gdGhyZXNob2xkc1t5IC0gMV0gOiBkb21haW5bMF0sIHkgPCB0aHJlc2hvbGRzLmxlbmd0aCA/IHRocmVzaG9sZHNbeV0gOiBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdIF07XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfcXVhbnRpbGUoZG9tYWluLCByYW5nZSk7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9XG4gIGQzLnNjYWxlLnF1YW50aXplID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX3F1YW50aXplKDAsIDEsIFsgMCwgMSBdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfcXVhbnRpemUoeDAsIHgxLCByYW5nZSkge1xuICAgIHZhciBreCwgaTtcbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gcmFuZ2VbTWF0aC5tYXgoMCwgTWF0aC5taW4oaSwgTWF0aC5mbG9vcihreCAqICh4IC0geDApKSkpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIGt4ID0gcmFuZ2UubGVuZ3RoIC8gKHgxIC0geDApO1xuICAgICAgaSA9IHJhbmdlLmxlbmd0aCAtIDE7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgeDAsIHgxIF07XG4gICAgICB4MCA9ICt4WzBdO1xuICAgICAgeDEgPSAreFt4Lmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2U7XG4gICAgICByYW5nZSA9IHg7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgICAgeSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgICB5ID0geSA8IDAgPyBOYU4gOiB5IC8ga3ggKyB4MDtcbiAgICAgIHJldHVybiBbIHksIHkgKyAxIC8ga3ggXTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9xdWFudGl6ZSh4MCwgeDEsIHJhbmdlKTtcbiAgICB9O1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH1cbiAgZDMuc2NhbGUudGhyZXNob2xkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX3RocmVzaG9sZChbIC41IF0sIFsgMCwgMSBdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfdGhyZXNob2xkKGRvbWFpbiwgcmFuZ2UpIHtcbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICBpZiAoeCA8PSB4KSByZXR1cm4gcmFuZ2VbZDMuYmlzZWN0KGRvbWFpbiwgeCldO1xuICAgIH1cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBkb21haW4gPSBfO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYW5nZTtcbiAgICAgIHJhbmdlID0gXztcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgICAgcmV0dXJuIFsgZG9tYWluW3kgLSAxXSwgZG9tYWluW3ldIF07XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfdGhyZXNob2xkKGRvbWFpbiwgcmFuZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG4gIGQzLnNjYWxlLmlkZW50aXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX2lkZW50aXR5KFsgMCwgMSBdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfaWRlbnRpdHkoZG9tYWluKSB7XG4gICAgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgICAgcmV0dXJuICt4O1xuICAgIH1cbiAgICBpZGVudGl0eS5pbnZlcnQgPSBpZGVudGl0eTtcbiAgICBpZGVudGl0eS5kb21haW4gPSBpZGVudGl0eS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIGRvbWFpbiA9IHgubWFwKGlkZW50aXR5KTtcbiAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICB9O1xuICAgIGlkZW50aXR5LnRpY2tzID0gZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclRpY2tzKGRvbWFpbiwgbSk7XG4gICAgfTtcbiAgICBpZGVudGl0eS50aWNrRm9ybWF0ID0gZnVuY3Rpb24obSwgZm9ybWF0KSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyVGlja0Zvcm1hdChkb21haW4sIG0sIGZvcm1hdCk7XG4gICAgfTtcbiAgICBpZGVudGl0eS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfaWRlbnRpdHkoZG9tYWluKTtcbiAgICB9O1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBkMy5zdmcgPSB7fTtcbiAgZnVuY3Rpb24gZDNfemVybygpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBkMy5zdmcuYXJjID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlubmVyUmFkaXVzID0gZDNfc3ZnX2FyY0lubmVyUmFkaXVzLCBvdXRlclJhZGl1cyA9IGQzX3N2Z19hcmNPdXRlclJhZGl1cywgY29ybmVyUmFkaXVzID0gZDNfemVybywgcGFkUmFkaXVzID0gZDNfc3ZnX2FyY0F1dG8sIHN0YXJ0QW5nbGUgPSBkM19zdmdfYXJjU3RhcnRBbmdsZSwgZW5kQW5nbGUgPSBkM19zdmdfYXJjRW5kQW5nbGUsIHBhZEFuZ2xlID0gZDNfc3ZnX2FyY1BhZEFuZ2xlO1xuICAgIGZ1bmN0aW9uIGFyYygpIHtcbiAgICAgIHZhciByMCA9IE1hdGgubWF4KDAsICtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSwgcjEgPSBNYXRoLm1heCgwLCArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSksIGEwID0gc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZs+ALCBhMSA9IGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmz4AsIGRhID0gTWF0aC5hYnMoYTEgLSBhMCksIGN3ID0gYTAgPiBhMSA/IDAgOiAxO1xuICAgICAgaWYgKHIxIDwgcjApIHJjID0gcjEsIHIxID0gcjAsIHIwID0gcmM7XG4gICAgICBpZiAoZGEgPj0gz4TOtSkgcmV0dXJuIGNpcmNsZVNlZ21lbnQocjEsIGN3KSArIChyMCA/IGNpcmNsZVNlZ21lbnQocjAsIDEgLSBjdykgOiBcIlwiKSArIFwiWlwiO1xuICAgICAgdmFyIHJjLCBjciwgcnAsIGFwLCBwMCA9IDAsIHAxID0gMCwgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBwYXRoID0gW107XG4gICAgICBpZiAoYXAgPSAoK3BhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMCkgLyAyKSB7XG4gICAgICAgIHJwID0gcGFkUmFkaXVzID09PSBkM19zdmdfYXJjQXV0byA/IE1hdGguc3FydChyMCAqIHIwICsgcjEgKiByMSkgOiArcGFkUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICghY3cpIHAxICo9IC0xO1xuICAgICAgICBpZiAocjEpIHAxID0gZDNfYXNpbihycCAvIHIxICogTWF0aC5zaW4oYXApKTtcbiAgICAgICAgaWYgKHIwKSBwMCA9IGQzX2FzaW4ocnAgLyByMCAqIE1hdGguc2luKGFwKSk7XG4gICAgICB9XG4gICAgICBpZiAocjEpIHtcbiAgICAgICAgeDAgPSByMSAqIE1hdGguY29zKGEwICsgcDEpO1xuICAgICAgICB5MCA9IHIxICogTWF0aC5zaW4oYTAgKyBwMSk7XG4gICAgICAgIHgxID0gcjEgKiBNYXRoLmNvcyhhMSAtIHAxKTtcbiAgICAgICAgeTEgPSByMSAqIE1hdGguc2luKGExIC0gcDEpO1xuICAgICAgICB2YXIgbDEgPSBNYXRoLmFicyhhMSAtIGEwIC0gMiAqIHAxKSA8PSDPgCA/IDAgOiAxO1xuICAgICAgICBpZiAocDEgJiYgZDNfc3ZnX2FyY1N3ZWVwKHgwLCB5MCwgeDEsIHkxKSA9PT0gY3cgXiBsMSkge1xuICAgICAgICAgIHZhciBoMSA9IChhMCArIGExKSAvIDI7XG4gICAgICAgICAgeDAgPSByMSAqIE1hdGguY29zKGgxKTtcbiAgICAgICAgICB5MCA9IHIxICogTWF0aC5zaW4oaDEpO1xuICAgICAgICAgIHgxID0geTEgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MCA9IHkwID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChyMCkge1xuICAgICAgICB4MiA9IHIwICogTWF0aC5jb3MoYTEgLSBwMCk7XG4gICAgICAgIHkyID0gcjAgKiBNYXRoLnNpbihhMSAtIHAwKTtcbiAgICAgICAgeDMgPSByMCAqIE1hdGguY29zKGEwICsgcDApO1xuICAgICAgICB5MyA9IHIwICogTWF0aC5zaW4oYTAgKyBwMCk7XG4gICAgICAgIHZhciBsMCA9IE1hdGguYWJzKGEwIC0gYTEgKyAyICogcDApIDw9IM+AID8gMCA6IDE7XG4gICAgICAgIGlmIChwMCAmJiBkM19zdmdfYXJjU3dlZXAoeDIsIHkyLCB4MywgeTMpID09PSAxIC0gY3cgXiBsMCkge1xuICAgICAgICAgIHZhciBoMCA9IChhMCArIGExKSAvIDI7XG4gICAgICAgICAgeDIgPSByMCAqIE1hdGguY29zKGgwKTtcbiAgICAgICAgICB5MiA9IHIwICogTWF0aC5zaW4oaDApO1xuICAgICAgICAgIHgzID0geTMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MiA9IHkyID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChkYSA+IM61ICYmIChyYyA9IE1hdGgubWluKE1hdGguYWJzKHIxIC0gcjApIC8gMiwgK2Nvcm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSkgPiAuMDAxKSB7XG4gICAgICAgIGNyID0gcjAgPCByMSBeIGN3ID8gMCA6IDE7XG4gICAgICAgIHZhciByYzEgPSByYywgcmMwID0gcmM7XG4gICAgICAgIGlmIChkYSA8IM+AKSB7XG4gICAgICAgICAgdmFyIG9jID0geDMgPT0gbnVsbCA/IFsgeDIsIHkyIF0gOiB4MSA9PSBudWxsID8gWyB4MCwgeTAgXSA6IGQzX2dlb21fcG9seWdvbkludGVyc2VjdChbIHgwLCB5MCBdLCBbIHgzLCB5MyBdLCBbIHgxLCB5MSBdLCBbIHgyLCB5MiBdKSwgYXggPSB4MCAtIG9jWzBdLCBheSA9IHkwIC0gb2NbMV0sIGJ4ID0geDEgLSBvY1swXSwgYnkgPSB5MSAtIG9jWzFdLCBrYyA9IDEgLyBNYXRoLnNpbihNYXRoLmFjb3MoKGF4ICogYnggKyBheSAqIGJ5KSAvIChNYXRoLnNxcnQoYXggKiBheCArIGF5ICogYXkpICogTWF0aC5zcXJ0KGJ4ICogYnggKyBieSAqIGJ5KSkpIC8gMiksIGxjID0gTWF0aC5zcXJ0KG9jWzBdICogb2NbMF0gKyBvY1sxXSAqIG9jWzFdKTtcbiAgICAgICAgICByYzAgPSBNYXRoLm1pbihyYywgKHIwIC0gbGMpIC8gKGtjIC0gMSkpO1xuICAgICAgICAgIHJjMSA9IE1hdGgubWluKHJjLCAocjEgLSBsYykgLyAoa2MgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHgxICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgdDMwID0gZDNfc3ZnX2FyY0Nvcm5lclRhbmdlbnRzKHgzID09IG51bGwgPyBbIHgyLCB5MiBdIDogWyB4MywgeTMgXSwgWyB4MCwgeTAgXSwgcjEsIHJjMSwgY3cpLCB0MTIgPSBkM19zdmdfYXJjQ29ybmVyVGFuZ2VudHMoWyB4MSwgeTEgXSwgWyB4MiwgeTIgXSwgcjEsIHJjMSwgY3cpO1xuICAgICAgICAgIGlmIChyYyA9PT0gcmMxKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goXCJNXCIsIHQzMFswXSwgXCJBXCIsIHJjMSwgXCIsXCIsIHJjMSwgXCIgMCAwLFwiLCBjciwgXCIgXCIsIHQzMFsxXSwgXCJBXCIsIHIxLCBcIixcIiwgcjEsIFwiIDAgXCIsIDEgLSBjdyBeIGQzX3N2Z19hcmNTd2VlcCh0MzBbMV1bMF0sIHQzMFsxXVsxXSwgdDEyWzFdWzBdLCB0MTJbMV1bMV0pLCBcIixcIiwgY3csIFwiIFwiLCB0MTJbMV0sIFwiQVwiLCByYzEsIFwiLFwiLCByYzEsIFwiIDAgMCxcIiwgY3IsIFwiIFwiLCB0MTJbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goXCJNXCIsIHQzMFswXSwgXCJBXCIsIHJjMSwgXCIsXCIsIHJjMSwgXCIgMCAxLFwiLCBjciwgXCIgXCIsIHQxMlswXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgucHVzaChcIk1cIiwgeDAsIFwiLFwiLCB5MCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHgzICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgdDAzID0gZDNfc3ZnX2FyY0Nvcm5lclRhbmdlbnRzKFsgeDAsIHkwIF0sIFsgeDMsIHkzIF0sIHIwLCAtcmMwLCBjdyksIHQyMSA9IGQzX3N2Z19hcmNDb3JuZXJUYW5nZW50cyhbIHgyLCB5MiBdLCB4MSA9PSBudWxsID8gWyB4MCwgeTAgXSA6IFsgeDEsIHkxIF0sIHIwLCAtcmMwLCBjdyk7XG4gICAgICAgICAgaWYgKHJjID09PSByYzApIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChcIkxcIiwgdDIxWzBdLCBcIkFcIiwgcmMwLCBcIixcIiwgcmMwLCBcIiAwIDAsXCIsIGNyLCBcIiBcIiwgdDIxWzFdLCBcIkFcIiwgcjAsIFwiLFwiLCByMCwgXCIgMCBcIiwgY3cgXiBkM19zdmdfYXJjU3dlZXAodDIxWzFdWzBdLCB0MjFbMV1bMV0sIHQwM1sxXVswXSwgdDAzWzFdWzFdKSwgXCIsXCIsIDEgLSBjdywgXCIgXCIsIHQwM1sxXSwgXCJBXCIsIHJjMCwgXCIsXCIsIHJjMCwgXCIgMCAwLFwiLCBjciwgXCIgXCIsIHQwM1swXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChcIkxcIiwgdDIxWzBdLCBcIkFcIiwgcmMwLCBcIixcIiwgcmMwLCBcIiAwIDAsXCIsIGNyLCBcIiBcIiwgdDAzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC5wdXNoKFwiTFwiLCB4MiwgXCIsXCIsIHkyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aC5wdXNoKFwiTVwiLCB4MCwgXCIsXCIsIHkwKTtcbiAgICAgICAgaWYgKHgxICE9IG51bGwpIHBhdGgucHVzaChcIkFcIiwgcjEsIFwiLFwiLCByMSwgXCIgMCBcIiwgbDEsIFwiLFwiLCBjdywgXCIgXCIsIHgxLCBcIixcIiwgeTEpO1xuICAgICAgICBwYXRoLnB1c2goXCJMXCIsIHgyLCBcIixcIiwgeTIpO1xuICAgICAgICBpZiAoeDMgIT0gbnVsbCkgcGF0aC5wdXNoKFwiQVwiLCByMCwgXCIsXCIsIHIwLCBcIiAwIFwiLCBsMCwgXCIsXCIsIDEgLSBjdywgXCIgXCIsIHgzLCBcIixcIiwgeTMpO1xuICAgICAgfVxuICAgICAgcGF0aC5wdXNoKFwiWlwiKTtcbiAgICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNpcmNsZVNlZ21lbnQocjEsIGN3KSB7XG4gICAgICByZXR1cm4gXCJNMCxcIiArIHIxICsgXCJBXCIgKyByMSArIFwiLFwiICsgcjEgKyBcIiAwIDEsXCIgKyBjdyArIFwiIDAsXCIgKyAtcjEgKyBcIkFcIiArIHIxICsgXCIsXCIgKyByMSArIFwiIDAgMSxcIiArIGN3ICsgXCIgMCxcIiArIHIxO1xuICAgIH1cbiAgICBhcmMuaW5uZXJSYWRpdXMgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbm5lclJhZGl1cztcbiAgICAgIGlubmVyUmFkaXVzID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMub3V0ZXJSYWRpdXMgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRlclJhZGl1cztcbiAgICAgIG91dGVyUmFkaXVzID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMuY29ybmVyUmFkaXVzID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29ybmVyUmFkaXVzO1xuICAgICAgY29ybmVyUmFkaXVzID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMucGFkUmFkaXVzID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGFkUmFkaXVzO1xuICAgICAgcGFkUmFkaXVzID0gdiA9PSBkM19zdmdfYXJjQXV0byA/IGQzX3N2Z19hcmNBdXRvIDogZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YXJ0QW5nbGU7XG4gICAgICBzdGFydEFuZ2xlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMuZW5kQW5nbGUgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBlbmRBbmdsZTtcbiAgICAgIGVuZEFuZ2xlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMucGFkQW5nbGUgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRBbmdsZTtcbiAgICAgIHBhZEFuZ2xlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMuY2VudHJvaWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByID0gKCtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMiwgYSA9ICgrc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK2VuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMiAtIGhhbGbPgDtcbiAgICAgIHJldHVybiBbIE1hdGguY29zKGEpICogciwgTWF0aC5zaW4oYSkgKiByIF07XG4gICAgfTtcbiAgICByZXR1cm4gYXJjO1xuICB9O1xuICB2YXIgZDNfc3ZnX2FyY0F1dG8gPSBcImF1dG9cIjtcbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY0lubmVyUmFkaXVzKGQpIHtcbiAgICByZXR1cm4gZC5pbm5lclJhZGl1cztcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXJjT3V0ZXJSYWRpdXMoZCkge1xuICAgIHJldHVybiBkLm91dGVyUmFkaXVzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNTdGFydEFuZ2xlKGQpIHtcbiAgICByZXR1cm4gZC5zdGFydEFuZ2xlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNFbmRBbmdsZShkKSB7XG4gICAgcmV0dXJuIGQuZW5kQW5nbGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY1BhZEFuZ2xlKGQpIHtcbiAgICByZXR1cm4gZCAmJiBkLnBhZEFuZ2xlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNTd2VlcCh4MCwgeTAsIHgxLCB5MSkge1xuICAgIHJldHVybiAoeDAgLSB4MSkgKiB5MCAtICh5MCAtIHkxKSAqIHgwID4gMCA/IDAgOiAxO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNDb3JuZXJUYW5nZW50cyhwMCwgcDEsIHIxLCByYywgY3cpIHtcbiAgICB2YXIgeDAxID0gcDBbMF0gLSBwMVswXSwgeTAxID0gcDBbMV0gLSBwMVsxXSwgbG8gPSAoY3cgPyByYyA6IC1yYykgLyBNYXRoLnNxcnQoeDAxICogeDAxICsgeTAxICogeTAxKSwgb3ggPSBsbyAqIHkwMSwgb3kgPSAtbG8gKiB4MDEsIHgxID0gcDBbMF0gKyBveCwgeTEgPSBwMFsxXSArIG95LCB4MiA9IHAxWzBdICsgb3gsIHkyID0gcDFbMV0gKyBveSwgeDMgPSAoeDEgKyB4MikgLyAyLCB5MyA9ICh5MSArIHkyKSAvIDIsIGR4ID0geDIgLSB4MSwgZHkgPSB5MiAtIHkxLCBkMiA9IGR4ICogZHggKyBkeSAqIGR5LCByID0gcjEgLSByYywgRCA9IHgxICogeTIgLSB4MiAqIHkxLCBkID0gKGR5IDwgMCA/IC0xIDogMSkgKiBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgciAqIHIgKiBkMiAtIEQgKiBEKSksIGN4MCA9IChEICogZHkgLSBkeCAqIGQpIC8gZDIsIGN5MCA9ICgtRCAqIGR4IC0gZHkgKiBkKSAvIGQyLCBjeDEgPSAoRCAqIGR5ICsgZHggKiBkKSAvIGQyLCBjeTEgPSAoLUQgKiBkeCArIGR5ICogZCkgLyBkMiwgZHgwID0gY3gwIC0geDMsIGR5MCA9IGN5MCAtIHkzLCBkeDEgPSBjeDEgLSB4MywgZHkxID0gY3kxIC0geTM7XG4gICAgaWYgKGR4MCAqIGR4MCArIGR5MCAqIGR5MCA+IGR4MSAqIGR4MSArIGR5MSAqIGR5MSkgY3gwID0gY3gxLCBjeTAgPSBjeTE7XG4gICAgcmV0dXJuIFsgWyBjeDAgLSBveCwgY3kwIC0gb3kgXSwgWyBjeDAgKiByMSAvIHIsIGN5MCAqIHIxIC8gciBdIF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmUocHJvamVjdGlvbikge1xuICAgIHZhciB4ID0gZDNfZ2VvbV9wb2ludFgsIHkgPSBkM19nZW9tX3BvaW50WSwgZGVmaW5lZCA9IGQzX3RydWUsIGludGVycG9sYXRlID0gZDNfc3ZnX2xpbmVMaW5lYXIsIGludGVycG9sYXRlS2V5ID0gaW50ZXJwb2xhdGUua2V5LCB0ZW5zaW9uID0gLjc7XG4gICAgZnVuY3Rpb24gbGluZShkYXRhKSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSBbXSwgcG9pbnRzID0gW10sIGkgPSAtMSwgbiA9IGRhdGEubGVuZ3RoLCBkLCBmeCA9IGQzX2Z1bmN0b3IoeCksIGZ5ID0gZDNfZnVuY3Rvcih5KTtcbiAgICAgIGZ1bmN0aW9uIHNlZ21lbnQoKSB7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goXCJNXCIsIGludGVycG9sYXRlKHByb2plY3Rpb24ocG9pbnRzKSwgdGVuc2lvbikpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKGRlZmluZWQuY2FsbCh0aGlzLCBkID0gZGF0YVtpXSwgaSkpIHtcbiAgICAgICAgICBwb2ludHMucHVzaChbICtmeC5jYWxsKHRoaXMsIGQsIGkpLCArZnkuY2FsbCh0aGlzLCBkLCBpKSBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgc2VnbWVudCgpO1xuICAgICAgICAgIHBvaW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9pbnRzLmxlbmd0aCkgc2VnbWVudCgpO1xuICAgICAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA/IHNlZ21lbnRzLmpvaW4oXCJcIikgOiBudWxsO1xuICAgIH1cbiAgICBsaW5lLnggPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4O1xuICAgICAgeCA9IF87XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICAgIGxpbmUueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHk7XG4gICAgICB5ID0gXztcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgbGluZS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGVmaW5lZDtcbiAgICAgIGRlZmluZWQgPSBfO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICBsaW5lLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaW50ZXJwb2xhdGVLZXk7XG4gICAgICBpZiAodHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIikgaW50ZXJwb2xhdGVLZXkgPSBpbnRlcnBvbGF0ZSA9IF87IGVsc2UgaW50ZXJwb2xhdGVLZXkgPSAoaW50ZXJwb2xhdGUgPSBkM19zdmdfbGluZUludGVycG9sYXRvcnMuZ2V0KF8pIHx8IGQzX3N2Z19saW5lTGluZWFyKS5rZXk7XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICAgIGxpbmUudGVuc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRlbnNpb247XG4gICAgICB0ZW5zaW9uID0gXztcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgcmV0dXJuIGxpbmU7XG4gIH1cbiAgZDMuc3ZnLmxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc3ZnX2xpbmUoZDNfaWRlbnRpdHkpO1xuICB9O1xuICB2YXIgZDNfc3ZnX2xpbmVJbnRlcnBvbGF0b3JzID0gZDMubWFwKHtcbiAgICBsaW5lYXI6IGQzX3N2Z19saW5lTGluZWFyLFxuICAgIFwibGluZWFyLWNsb3NlZFwiOiBkM19zdmdfbGluZUxpbmVhckNsb3NlZCxcbiAgICBzdGVwOiBkM19zdmdfbGluZVN0ZXAsXG4gICAgXCJzdGVwLWJlZm9yZVwiOiBkM19zdmdfbGluZVN0ZXBCZWZvcmUsXG4gICAgXCJzdGVwLWFmdGVyXCI6IGQzX3N2Z19saW5lU3RlcEFmdGVyLFxuICAgIGJhc2lzOiBkM19zdmdfbGluZUJhc2lzLFxuICAgIFwiYmFzaXMtb3BlblwiOiBkM19zdmdfbGluZUJhc2lzT3BlbixcbiAgICBcImJhc2lzLWNsb3NlZFwiOiBkM19zdmdfbGluZUJhc2lzQ2xvc2VkLFxuICAgIGJ1bmRsZTogZDNfc3ZnX2xpbmVCdW5kbGUsXG4gICAgY2FyZGluYWw6IGQzX3N2Z19saW5lQ2FyZGluYWwsXG4gICAgXCJjYXJkaW5hbC1vcGVuXCI6IGQzX3N2Z19saW5lQ2FyZGluYWxPcGVuLFxuICAgIFwiY2FyZGluYWwtY2xvc2VkXCI6IGQzX3N2Z19saW5lQ2FyZGluYWxDbG9zZWQsXG4gICAgbW9ub3RvbmU6IGQzX3N2Z19saW5lTW9ub3RvbmVcbiAgfSk7XG4gIGQzX3N2Z19saW5lSW50ZXJwb2xhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB2YWx1ZS5rZXkgPSBrZXk7XG4gICAgdmFsdWUuY2xvc2VkID0gLy1jbG9zZWQkLy50ZXN0KGtleSk7XG4gIH0pO1xuICBmdW5jdGlvbiBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpIHtcbiAgICByZXR1cm4gcG9pbnRzLmxlbmd0aCA+IDEgPyBwb2ludHMuam9pbihcIkxcIikgOiBwb2ludHMgKyBcIlpcIjtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUxpbmVhckNsb3NlZChwb2ludHMpIHtcbiAgICByZXR1cm4gcG9pbnRzLmpvaW4oXCJMXCIpICsgXCJaXCI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVTdGVwKHBvaW50cykge1xuICAgIHZhciBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGgsIHAgPSBwb2ludHNbMF0sIHBhdGggPSBbIHBbMF0sIFwiLFwiLCBwWzFdIF07XG4gICAgd2hpbGUgKCsraSA8IG4pIHBhdGgucHVzaChcIkhcIiwgKHBbMF0gKyAocCA9IHBvaW50c1tpXSlbMF0pIC8gMiwgXCJWXCIsIHBbMV0pO1xuICAgIGlmIChuID4gMSkgcGF0aC5wdXNoKFwiSFwiLCBwWzBdKTtcbiAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lU3RlcEJlZm9yZShwb2ludHMpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoLCBwID0gcG9pbnRzWzBdLCBwYXRoID0gWyBwWzBdLCBcIixcIiwgcFsxXSBdO1xuICAgIHdoaWxlICgrK2kgPCBuKSBwYXRoLnB1c2goXCJWXCIsIChwID0gcG9pbnRzW2ldKVsxXSwgXCJIXCIsIHBbMF0pO1xuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVTdGVwQWZ0ZXIocG9pbnRzKSB7XG4gICAgdmFyIGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aCwgcCA9IHBvaW50c1swXSwgcGF0aCA9IFsgcFswXSwgXCIsXCIsIHBbMV0gXTtcbiAgICB3aGlsZSAoKytpIDwgbikgcGF0aC5wdXNoKFwiSFwiLCAocCA9IHBvaW50c1tpXSlbMF0sIFwiVlwiLCBwWzFdKTtcbiAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQ2FyZGluYWxPcGVuKHBvaW50cywgdGVuc2lvbikge1xuICAgIHJldHVybiBwb2ludHMubGVuZ3RoIDwgNCA/IGQzX3N2Z19saW5lTGluZWFyKHBvaW50cykgOiBwb2ludHNbMV0gKyBkM19zdmdfbGluZUhlcm1pdGUocG9pbnRzLnNsaWNlKDEsIC0xKSwgZDNfc3ZnX2xpbmVDYXJkaW5hbFRhbmdlbnRzKHBvaW50cywgdGVuc2lvbikpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQ2FyZGluYWxDbG9zZWQocG9pbnRzLCB0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIHBvaW50cy5sZW5ndGggPCAzID8gZDNfc3ZnX2xpbmVMaW5lYXJDbG9zZWQocG9pbnRzKSA6IHBvaW50c1swXSArIGQzX3N2Z19saW5lSGVybWl0ZSgocG9pbnRzLnB1c2gocG9pbnRzWzBdKSwgXG4gICAgcG9pbnRzKSwgZDNfc3ZnX2xpbmVDYXJkaW5hbFRhbmdlbnRzKFsgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSBdLmNvbmNhdChwb2ludHMsIFsgcG9pbnRzWzFdIF0pLCB0ZW5zaW9uKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVDYXJkaW5hbChwb2ludHMsIHRlbnNpb24pIHtcbiAgICByZXR1cm4gcG9pbnRzLmxlbmd0aCA8IDMgPyBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpIDogcG9pbnRzWzBdICsgZDNfc3ZnX2xpbmVIZXJtaXRlKHBvaW50cywgZDNfc3ZnX2xpbmVDYXJkaW5hbFRhbmdlbnRzKHBvaW50cywgdGVuc2lvbikpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lSGVybWl0ZShwb2ludHMsIHRhbmdlbnRzKSB7XG4gICAgaWYgKHRhbmdlbnRzLmxlbmd0aCA8IDEgfHwgcG9pbnRzLmxlbmd0aCAhPSB0YW5nZW50cy5sZW5ndGggJiYgcG9pbnRzLmxlbmd0aCAhPSB0YW5nZW50cy5sZW5ndGggKyAyKSB7XG4gICAgICByZXR1cm4gZDNfc3ZnX2xpbmVMaW5lYXIocG9pbnRzKTtcbiAgICB9XG4gICAgdmFyIHF1YWQgPSBwb2ludHMubGVuZ3RoICE9IHRhbmdlbnRzLmxlbmd0aCwgcGF0aCA9IFwiXCIsIHAwID0gcG9pbnRzWzBdLCBwID0gcG9pbnRzWzFdLCB0MCA9IHRhbmdlbnRzWzBdLCB0ID0gdDAsIHBpID0gMTtcbiAgICBpZiAocXVhZCkge1xuICAgICAgcGF0aCArPSBcIlFcIiArIChwWzBdIC0gdDBbMF0gKiAyIC8gMykgKyBcIixcIiArIChwWzFdIC0gdDBbMV0gKiAyIC8gMykgKyBcIixcIiArIHBbMF0gKyBcIixcIiArIHBbMV07XG4gICAgICBwMCA9IHBvaW50c1sxXTtcbiAgICAgIHBpID0gMjtcbiAgICB9XG4gICAgaWYgKHRhbmdlbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHQgPSB0YW5nZW50c1sxXTtcbiAgICAgIHAgPSBwb2ludHNbcGldO1xuICAgICAgcGkrKztcbiAgICAgIHBhdGggKz0gXCJDXCIgKyAocDBbMF0gKyB0MFswXSkgKyBcIixcIiArIChwMFsxXSArIHQwWzFdKSArIFwiLFwiICsgKHBbMF0gLSB0WzBdKSArIFwiLFwiICsgKHBbMV0gLSB0WzFdKSArIFwiLFwiICsgcFswXSArIFwiLFwiICsgcFsxXTtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgdGFuZ2VudHMubGVuZ3RoOyBpKyssIHBpKyspIHtcbiAgICAgICAgcCA9IHBvaW50c1twaV07XG4gICAgICAgIHQgPSB0YW5nZW50c1tpXTtcbiAgICAgICAgcGF0aCArPSBcIlNcIiArIChwWzBdIC0gdFswXSkgKyBcIixcIiArIChwWzFdIC0gdFsxXSkgKyBcIixcIiArIHBbMF0gKyBcIixcIiArIHBbMV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxdWFkKSB7XG4gICAgICB2YXIgbHAgPSBwb2ludHNbcGldO1xuICAgICAgcGF0aCArPSBcIlFcIiArIChwWzBdICsgdFswXSAqIDIgLyAzKSArIFwiLFwiICsgKHBbMV0gKyB0WzFdICogMiAvIDMpICsgXCIsXCIgKyBscFswXSArIFwiLFwiICsgbHBbMV07XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQ2FyZGluYWxUYW5nZW50cyhwb2ludHMsIHRlbnNpb24pIHtcbiAgICB2YXIgdGFuZ2VudHMgPSBbXSwgYSA9ICgxIC0gdGVuc2lvbikgLyAyLCBwMCwgcDEgPSBwb2ludHNbMF0sIHAyID0gcG9pbnRzWzFdLCBpID0gMSwgbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHAwID0gcDE7XG4gICAgICBwMSA9IHAyO1xuICAgICAgcDIgPSBwb2ludHNbaV07XG4gICAgICB0YW5nZW50cy5wdXNoKFsgYSAqIChwMlswXSAtIHAwWzBdKSwgYSAqIChwMlsxXSAtIHAwWzFdKSBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhbmdlbnRzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQmFzaXMocG9pbnRzKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCAzKSByZXR1cm4gZDNfc3ZnX2xpbmVMaW5lYXIocG9pbnRzKTtcbiAgICB2YXIgaSA9IDEsIG4gPSBwb2ludHMubGVuZ3RoLCBwaSA9IHBvaW50c1swXSwgeDAgPSBwaVswXSwgeTAgPSBwaVsxXSwgcHggPSBbIHgwLCB4MCwgeDAsIChwaSA9IHBvaW50c1sxXSlbMF0gXSwgcHkgPSBbIHkwLCB5MCwgeTAsIHBpWzFdIF0sIHBhdGggPSBbIHgwLCBcIixcIiwgeTAsIFwiTFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHB4KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgcHkpIF07XG4gICAgcG9pbnRzLnB1c2gocG9pbnRzW24gLSAxXSk7XG4gICAgd2hpbGUgKCsraSA8PSBuKSB7XG4gICAgICBwaSA9IHBvaW50c1tpXTtcbiAgICAgIHB4LnNoaWZ0KCk7XG4gICAgICBweC5wdXNoKHBpWzBdKTtcbiAgICAgIHB5LnNoaWZ0KCk7XG4gICAgICBweS5wdXNoKHBpWzFdKTtcbiAgICAgIGQzX3N2Z19saW5lQmFzaXNCZXppZXIocGF0aCwgcHgsIHB5KTtcbiAgICB9XG4gICAgcG9pbnRzLnBvcCgpO1xuICAgIHBhdGgucHVzaChcIkxcIiwgcGkpO1xuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVCYXNpc09wZW4ocG9pbnRzKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCA0KSByZXR1cm4gZDNfc3ZnX2xpbmVMaW5lYXIocG9pbnRzKTtcbiAgICB2YXIgcGF0aCA9IFtdLCBpID0gLTEsIG4gPSBwb2ludHMubGVuZ3RoLCBwaSwgcHggPSBbIDAgXSwgcHkgPSBbIDAgXTtcbiAgICB3aGlsZSAoKytpIDwgMykge1xuICAgICAgcGkgPSBwb2ludHNbaV07XG4gICAgICBweC5wdXNoKHBpWzBdKTtcbiAgICAgIHB5LnB1c2gocGlbMV0pO1xuICAgIH1cbiAgICBwYXRoLnB1c2goZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweCkgKyBcIixcIiArIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgcHkpKTtcbiAgICAtLWk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHBpID0gcG9pbnRzW2ldO1xuICAgICAgcHguc2hpZnQoKTtcbiAgICAgIHB4LnB1c2gocGlbMF0pO1xuICAgICAgcHkuc2hpZnQoKTtcbiAgICAgIHB5LnB1c2gocGlbMV0pO1xuICAgICAgZDNfc3ZnX2xpbmVCYXNpc0JlemllcihwYXRoLCBweCwgcHkpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQmFzaXNDbG9zZWQocG9pbnRzKSB7XG4gICAgdmFyIHBhdGgsIGkgPSAtMSwgbiA9IHBvaW50cy5sZW5ndGgsIG0gPSBuICsgNCwgcGksIHB4ID0gW10sIHB5ID0gW107XG4gICAgd2hpbGUgKCsraSA8IDQpIHtcbiAgICAgIHBpID0gcG9pbnRzW2kgJSBuXTtcbiAgICAgIHB4LnB1c2gocGlbMF0pO1xuICAgICAgcHkucHVzaChwaVsxXSk7XG4gICAgfVxuICAgIHBhdGggPSBbIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgcHgpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweSkgXTtcbiAgICAtLWk7XG4gICAgd2hpbGUgKCsraSA8IG0pIHtcbiAgICAgIHBpID0gcG9pbnRzW2kgJSBuXTtcbiAgICAgIHB4LnNoaWZ0KCk7XG4gICAgICBweC5wdXNoKHBpWzBdKTtcbiAgICAgIHB5LnNoaWZ0KCk7XG4gICAgICBweS5wdXNoKHBpWzFdKTtcbiAgICAgIGQzX3N2Z19saW5lQmFzaXNCZXppZXIocGF0aCwgcHgsIHB5KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUJ1bmRsZShwb2ludHMsIHRlbnNpb24pIHtcbiAgICB2YXIgbiA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgIGlmIChuKSB7XG4gICAgICB2YXIgeDAgPSBwb2ludHNbMF1bMF0sIHkwID0gcG9pbnRzWzBdWzFdLCBkeCA9IHBvaW50c1tuXVswXSAtIHgwLCBkeSA9IHBvaW50c1tuXVsxXSAtIHkwLCBpID0gLTEsIHAsIHQ7XG4gICAgICB3aGlsZSAoKytpIDw9IG4pIHtcbiAgICAgICAgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgdCA9IGkgLyBuO1xuICAgICAgICBwWzBdID0gdGVuc2lvbiAqIHBbMF0gKyAoMSAtIHRlbnNpb24pICogKHgwICsgdCAqIGR4KTtcbiAgICAgICAgcFsxXSA9IHRlbnNpb24gKiBwWzFdICsgKDEgLSB0ZW5zaW9uKSAqICh5MCArIHQgKiBkeSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM19zdmdfbGluZUJhc2lzKHBvaW50cyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVEb3Q0KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG4gIH1cbiAgdmFyIGQzX3N2Z19saW5lQmFzaXNCZXppZXIxID0gWyAwLCAyIC8gMywgMSAvIDMsIDAgXSwgZDNfc3ZnX2xpbmVCYXNpc0JlemllcjIgPSBbIDAsIDEgLyAzLCAyIC8gMywgMCBdLCBkM19zdmdfbGluZUJhc2lzQmV6aWVyMyA9IFsgMCwgMSAvIDYsIDIgLyAzLCAxIC8gNiBdO1xuICBmdW5jdGlvbiBkM19zdmdfbGluZUJhc2lzQmV6aWVyKHBhdGgsIHgsIHkpIHtcbiAgICBwYXRoLnB1c2goXCJDXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMSwgeCksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjEsIHkpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIyLCB4KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMiwgeSksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHgpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCB5KSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVTbG9wZShwMCwgcDEpIHtcbiAgICByZXR1cm4gKHAxWzFdIC0gcDBbMV0pIC8gKHAxWzBdIC0gcDBbMF0pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lRmluaXRlRGlmZmVyZW5jZXMocG9pbnRzKSB7XG4gICAgdmFyIGkgPSAwLCBqID0gcG9pbnRzLmxlbmd0aCAtIDEsIG0gPSBbXSwgcDAgPSBwb2ludHNbMF0sIHAxID0gcG9pbnRzWzFdLCBkID0gbVswXSA9IGQzX3N2Z19saW5lU2xvcGUocDAsIHAxKTtcbiAgICB3aGlsZSAoKytpIDwgaikge1xuICAgICAgbVtpXSA9IChkICsgKGQgPSBkM19zdmdfbGluZVNsb3BlKHAwID0gcDEsIHAxID0gcG9pbnRzW2kgKyAxXSkpKSAvIDI7XG4gICAgfVxuICAgIG1baV0gPSBkO1xuICAgIHJldHVybiBtO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lTW9ub3RvbmVUYW5nZW50cyhwb2ludHMpIHtcbiAgICB2YXIgdGFuZ2VudHMgPSBbXSwgZCwgYSwgYiwgcywgbSA9IGQzX3N2Z19saW5lRmluaXRlRGlmZmVyZW5jZXMocG9pbnRzKSwgaSA9IC0xLCBqID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCsraSA8IGopIHtcbiAgICAgIGQgPSBkM19zdmdfbGluZVNsb3BlKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSk7XG4gICAgICBpZiAoYWJzKGQpIDwgzrUpIHtcbiAgICAgICAgbVtpXSA9IG1baSArIDFdID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGEgPSBtW2ldIC8gZDtcbiAgICAgICAgYiA9IG1baSArIDFdIC8gZDtcbiAgICAgICAgcyA9IGEgKiBhICsgYiAqIGI7XG4gICAgICAgIGlmIChzID4gOSkge1xuICAgICAgICAgIHMgPSBkICogMyAvIE1hdGguc3FydChzKTtcbiAgICAgICAgICBtW2ldID0gcyAqIGE7XG4gICAgICAgICAgbVtpICsgMV0gPSBzICogYjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8PSBqKSB7XG4gICAgICBzID0gKHBvaW50c1tNYXRoLm1pbihqLCBpICsgMSldWzBdIC0gcG9pbnRzW01hdGgubWF4KDAsIGkgLSAxKV1bMF0pIC8gKDYgKiAoMSArIG1baV0gKiBtW2ldKSk7XG4gICAgICB0YW5nZW50cy5wdXNoKFsgcyB8fCAwLCBtW2ldICogcyB8fCAwIF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFuZ2VudHM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVNb25vdG9uZShwb2ludHMpIHtcbiAgICByZXR1cm4gcG9pbnRzLmxlbmd0aCA8IDMgPyBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpIDogcG9pbnRzWzBdICsgZDNfc3ZnX2xpbmVIZXJtaXRlKHBvaW50cywgZDNfc3ZnX2xpbmVNb25vdG9uZVRhbmdlbnRzKHBvaW50cykpO1xuICB9XG4gIGQzLnN2Zy5saW5lLnJhZGlhbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsaW5lID0gZDNfc3ZnX2xpbmUoZDNfc3ZnX2xpbmVSYWRpYWwpO1xuICAgIGxpbmUucmFkaXVzID0gbGluZS54LCBkZWxldGUgbGluZS54O1xuICAgIGxpbmUuYW5nbGUgPSBsaW5lLnksIGRlbGV0ZSBsaW5lLnk7XG4gICAgcmV0dXJuIGxpbmU7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lUmFkaWFsKHBvaW50cykge1xuICAgIHZhciBwb2ludCwgaSA9IC0xLCBuID0gcG9pbnRzLmxlbmd0aCwgciwgYTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICByID0gcG9pbnRbMF07XG4gICAgICBhID0gcG9pbnRbMV0gLSBoYWxmz4A7XG4gICAgICBwb2ludFswXSA9IHIgKiBNYXRoLmNvcyhhKTtcbiAgICAgIHBvaW50WzFdID0gciAqIE1hdGguc2luKGEpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmVhKHByb2plY3Rpb24pIHtcbiAgICB2YXIgeDAgPSBkM19nZW9tX3BvaW50WCwgeDEgPSBkM19nZW9tX3BvaW50WCwgeTAgPSAwLCB5MSA9IGQzX2dlb21fcG9pbnRZLCBkZWZpbmVkID0gZDNfdHJ1ZSwgaW50ZXJwb2xhdGUgPSBkM19zdmdfbGluZUxpbmVhciwgaW50ZXJwb2xhdGVLZXkgPSBpbnRlcnBvbGF0ZS5rZXksIGludGVycG9sYXRlUmV2ZXJzZSA9IGludGVycG9sYXRlLCBMID0gXCJMXCIsIHRlbnNpb24gPSAuNztcbiAgICBmdW5jdGlvbiBhcmVhKGRhdGEpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IFtdLCBwb2ludHMwID0gW10sIHBvaW50czEgPSBbXSwgaSA9IC0xLCBuID0gZGF0YS5sZW5ndGgsIGQsIGZ4MCA9IGQzX2Z1bmN0b3IoeDApLCBmeTAgPSBkM19mdW5jdG9yKHkwKSwgZngxID0geDAgPT09IHgxID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfSA6IGQzX2Z1bmN0b3IoeDEpLCBmeTEgPSB5MCA9PT0geTEgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHk7XG4gICAgICB9IDogZDNfZnVuY3Rvcih5MSksIHgsIHk7XG4gICAgICBmdW5jdGlvbiBzZWdtZW50KCkge1xuICAgICAgICBzZWdtZW50cy5wdXNoKFwiTVwiLCBpbnRlcnBvbGF0ZShwcm9qZWN0aW9uKHBvaW50czEpLCB0ZW5zaW9uKSwgTCwgaW50ZXJwb2xhdGVSZXZlcnNlKHByb2plY3Rpb24ocG9pbnRzMC5yZXZlcnNlKCkpLCB0ZW5zaW9uKSwgXCJaXCIpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKGRlZmluZWQuY2FsbCh0aGlzLCBkID0gZGF0YVtpXSwgaSkpIHtcbiAgICAgICAgICBwb2ludHMwLnB1c2goWyB4ID0gK2Z4MC5jYWxsKHRoaXMsIGQsIGkpLCB5ID0gK2Z5MC5jYWxsKHRoaXMsIGQsIGkpIF0pO1xuICAgICAgICAgIHBvaW50czEucHVzaChbICtmeDEuY2FsbCh0aGlzLCBkLCBpKSwgK2Z5MS5jYWxsKHRoaXMsIGQsIGkpIF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHBvaW50czAubGVuZ3RoKSB7XG4gICAgICAgICAgc2VnbWVudCgpO1xuICAgICAgICAgIHBvaW50czAgPSBbXTtcbiAgICAgICAgICBwb2ludHMxID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb2ludHMwLmxlbmd0aCkgc2VnbWVudCgpO1xuICAgICAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA/IHNlZ21lbnRzLmpvaW4oXCJcIikgOiBudWxsO1xuICAgIH1cbiAgICBhcmVhLnggPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4MTtcbiAgICAgIHgwID0geDEgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLngwID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDA7XG4gICAgICB4MCA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEueDEgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4MTtcbiAgICAgIHgxID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS55ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTE7XG4gICAgICB5MCA9IHkxID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS55MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHkwO1xuICAgICAgeTAgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLnkxID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTE7XG4gICAgICB5MSA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRlZmluZWQ7XG4gICAgICBkZWZpbmVkID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGludGVycG9sYXRlS2V5O1xuICAgICAgaWYgKHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIpIGludGVycG9sYXRlS2V5ID0gaW50ZXJwb2xhdGUgPSBfOyBlbHNlIGludGVycG9sYXRlS2V5ID0gKGludGVycG9sYXRlID0gZDNfc3ZnX2xpbmVJbnRlcnBvbGF0b3JzLmdldChfKSB8fCBkM19zdmdfbGluZUxpbmVhcikua2V5O1xuICAgICAgaW50ZXJwb2xhdGVSZXZlcnNlID0gaW50ZXJwb2xhdGUucmV2ZXJzZSB8fCBpbnRlcnBvbGF0ZTtcbiAgICAgIEwgPSBpbnRlcnBvbGF0ZS5jbG9zZWQgPyBcIk1cIiA6IFwiTFwiO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLnRlbnNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0ZW5zaW9uO1xuICAgICAgdGVuc2lvbiA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIHJldHVybiBhcmVhO1xuICB9XG4gIGQzX3N2Z19saW5lU3RlcEJlZm9yZS5yZXZlcnNlID0gZDNfc3ZnX2xpbmVTdGVwQWZ0ZXI7XG4gIGQzX3N2Z19saW5lU3RlcEFmdGVyLnJldmVyc2UgPSBkM19zdmdfbGluZVN0ZXBCZWZvcmU7XG4gIGQzLnN2Zy5hcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3N2Z19hcmVhKGQzX2lkZW50aXR5KTtcbiAgfTtcbiAgZDMuc3ZnLmFyZWEucmFkaWFsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZWEgPSBkM19zdmdfYXJlYShkM19zdmdfbGluZVJhZGlhbCk7XG4gICAgYXJlYS5yYWRpdXMgPSBhcmVhLngsIGRlbGV0ZSBhcmVhLng7XG4gICAgYXJlYS5pbm5lclJhZGl1cyA9IGFyZWEueDAsIGRlbGV0ZSBhcmVhLngwO1xuICAgIGFyZWEub3V0ZXJSYWRpdXMgPSBhcmVhLngxLCBkZWxldGUgYXJlYS54MTtcbiAgICBhcmVhLmFuZ2xlID0gYXJlYS55LCBkZWxldGUgYXJlYS55O1xuICAgIGFyZWEuc3RhcnRBbmdsZSA9IGFyZWEueTAsIGRlbGV0ZSBhcmVhLnkwO1xuICAgIGFyZWEuZW5kQW5nbGUgPSBhcmVhLnkxLCBkZWxldGUgYXJlYS55MTtcbiAgICByZXR1cm4gYXJlYTtcbiAgfTtcbiAgZDMuc3ZnLmNob3JkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvdXJjZSA9IGQzX3NvdXJjZSwgdGFyZ2V0ID0gZDNfdGFyZ2V0LCByYWRpdXMgPSBkM19zdmdfY2hvcmRSYWRpdXMsIHN0YXJ0QW5nbGUgPSBkM19zdmdfYXJjU3RhcnRBbmdsZSwgZW5kQW5nbGUgPSBkM19zdmdfYXJjRW5kQW5nbGU7XG4gICAgZnVuY3Rpb24gY2hvcmQoZCwgaSkge1xuICAgICAgdmFyIHMgPSBzdWJncm91cCh0aGlzLCBzb3VyY2UsIGQsIGkpLCB0ID0gc3ViZ3JvdXAodGhpcywgdGFyZ2V0LCBkLCBpKTtcbiAgICAgIHJldHVybiBcIk1cIiArIHMucDAgKyBhcmMocy5yLCBzLnAxLCBzLmExIC0gcy5hMCkgKyAoZXF1YWxzKHMsIHQpID8gY3VydmUocy5yLCBzLnAxLCBzLnIsIHMucDApIDogY3VydmUocy5yLCBzLnAxLCB0LnIsIHQucDApICsgYXJjKHQuciwgdC5wMSwgdC5hMSAtIHQuYTApICsgY3VydmUodC5yLCB0LnAxLCBzLnIsIHMucDApKSArIFwiWlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdWJncm91cChzZWxmLCBmLCBkLCBpKSB7XG4gICAgICB2YXIgc3ViZ3JvdXAgPSBmLmNhbGwoc2VsZiwgZCwgaSksIHIgPSByYWRpdXMuY2FsbChzZWxmLCBzdWJncm91cCwgaSksIGEwID0gc3RhcnRBbmdsZS5jYWxsKHNlbGYsIHN1Ymdyb3VwLCBpKSAtIGhhbGbPgCwgYTEgPSBlbmRBbmdsZS5jYWxsKHNlbGYsIHN1Ymdyb3VwLCBpKSAtIGhhbGbPgDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHI6IHIsXG4gICAgICAgIGEwOiBhMCxcbiAgICAgICAgYTE6IGExLFxuICAgICAgICBwMDogWyByICogTWF0aC5jb3MoYTApLCByICogTWF0aC5zaW4oYTApIF0sXG4gICAgICAgIHAxOiBbIHIgKiBNYXRoLmNvcyhhMSksIHIgKiBNYXRoLnNpbihhMSkgXVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmEwID09IGIuYTAgJiYgYS5hMSA9PSBiLmExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmMociwgcCwgYSkge1xuICAgICAgcmV0dXJuIFwiQVwiICsgciArIFwiLFwiICsgciArIFwiIDAgXCIgKyArKGEgPiDPgCkgKyBcIiwxIFwiICsgcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3VydmUocjAsIHAwLCByMSwgcDEpIHtcbiAgICAgIHJldHVybiBcIlEgMCwwIFwiICsgcDE7XG4gICAgfVxuICAgIGNob3JkLnJhZGl1cyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhZGl1cztcbiAgICAgIHJhZGl1cyA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5zb3VyY2UgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3VyY2U7XG4gICAgICBzb3VyY2UgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQudGFyZ2V0ID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGFyZ2V0O1xuICAgICAgdGFyZ2V0ID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdGFydEFuZ2xlO1xuICAgICAgc3RhcnRBbmdsZSA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5lbmRBbmdsZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGVuZEFuZ2xlO1xuICAgICAgZW5kQW5nbGUgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgcmV0dXJuIGNob3JkO1xuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfY2hvcmRSYWRpdXMoZCkge1xuICAgIHJldHVybiBkLnJhZGl1cztcbiAgfVxuICBkMy5zdmcuZGlhZ29uYWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc291cmNlID0gZDNfc291cmNlLCB0YXJnZXQgPSBkM190YXJnZXQsIHByb2plY3Rpb24gPSBkM19zdmdfZGlhZ29uYWxQcm9qZWN0aW9uO1xuICAgIGZ1bmN0aW9uIGRpYWdvbmFsKGQsIGkpIHtcbiAgICAgIHZhciBwMCA9IHNvdXJjZS5jYWxsKHRoaXMsIGQsIGkpLCBwMyA9IHRhcmdldC5jYWxsKHRoaXMsIGQsIGkpLCBtID0gKHAwLnkgKyBwMy55KSAvIDIsIHAgPSBbIHAwLCB7XG4gICAgICAgIHg6IHAwLngsXG4gICAgICAgIHk6IG1cbiAgICAgIH0sIHtcbiAgICAgICAgeDogcDMueCxcbiAgICAgICAgeTogbVxuICAgICAgfSwgcDMgXTtcbiAgICAgIHAgPSBwLm1hcChwcm9qZWN0aW9uKTtcbiAgICAgIHJldHVybiBcIk1cIiArIHBbMF0gKyBcIkNcIiArIHBbMV0gKyBcIiBcIiArIHBbMl0gKyBcIiBcIiArIHBbM107XG4gICAgfVxuICAgIGRpYWdvbmFsLnNvdXJjZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvdXJjZTtcbiAgICAgIHNvdXJjZSA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gZGlhZ29uYWw7XG4gICAgfTtcbiAgICBkaWFnb25hbC50YXJnZXQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSBkM19mdW5jdG9yKHgpO1xuICAgICAgcmV0dXJuIGRpYWdvbmFsO1xuICAgIH07XG4gICAgZGlhZ29uYWwucHJvamVjdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByb2plY3Rpb247XG4gICAgICBwcm9qZWN0aW9uID0geDtcbiAgICAgIHJldHVybiBkaWFnb25hbDtcbiAgICB9O1xuICAgIHJldHVybiBkaWFnb25hbDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc3ZnX2RpYWdvbmFsUHJvamVjdGlvbihkKSB7XG4gICAgcmV0dXJuIFsgZC54LCBkLnkgXTtcbiAgfVxuICBkMy5zdmcuZGlhZ29uYWwucmFkaWFsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRpYWdvbmFsID0gZDMuc3ZnLmRpYWdvbmFsKCksIHByb2plY3Rpb24gPSBkM19zdmdfZGlhZ29uYWxQcm9qZWN0aW9uLCBwcm9qZWN0aW9uXyA9IGRpYWdvbmFsLnByb2plY3Rpb247XG4gICAgZGlhZ29uYWwucHJvamVjdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gcHJvamVjdGlvbl8oZDNfc3ZnX2RpYWdvbmFsUmFkaWFsUHJvamVjdGlvbihwcm9qZWN0aW9uID0geCkpIDogcHJvamVjdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBkaWFnb25hbDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc3ZnX2RpYWdvbmFsUmFkaWFsUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGQgPSBwcm9qZWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHIgPSBkWzBdLCBhID0gZFsxXSAtIGhhbGbPgDtcbiAgICAgIHJldHVybiBbIHIgKiBNYXRoLmNvcyhhKSwgciAqIE1hdGguc2luKGEpIF07XG4gICAgfTtcbiAgfVxuICBkMy5zdmcuc3ltYm9sID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHR5cGUgPSBkM19zdmdfc3ltYm9sVHlwZSwgc2l6ZSA9IGQzX3N2Z19zeW1ib2xTaXplO1xuICAgIGZ1bmN0aW9uIHN5bWJvbChkLCBpKSB7XG4gICAgICByZXR1cm4gKGQzX3N2Z19zeW1ib2xzLmdldCh0eXBlLmNhbGwodGhpcywgZCwgaSkpIHx8IGQzX3N2Z19zeW1ib2xDaXJjbGUpKHNpemUuY2FsbCh0aGlzLCBkLCBpKSk7XG4gICAgfVxuICAgIHN5bWJvbC50eXBlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdHlwZTtcbiAgICAgIHR5cGUgPSBkM19mdW5jdG9yKHgpO1xuICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICB9O1xuICAgIHN5bWJvbC5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSBkM19mdW5jdG9yKHgpO1xuICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICB9O1xuICAgIHJldHVybiBzeW1ib2w7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3N2Z19zeW1ib2xTaXplKCkge1xuICAgIHJldHVybiA2NDtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfc3ltYm9sVHlwZSgpIHtcbiAgICByZXR1cm4gXCJjaXJjbGVcIjtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfc3ltYm9sQ2lyY2xlKHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gz4ApO1xuICAgIHJldHVybiBcIk0wLFwiICsgciArIFwiQVwiICsgciArIFwiLFwiICsgciArIFwiIDAgMSwxIDAsXCIgKyAtciArIFwiQVwiICsgciArIFwiLFwiICsgciArIFwiIDAgMSwxIDAsXCIgKyByICsgXCJaXCI7XG4gIH1cbiAgdmFyIGQzX3N2Z19zeW1ib2xzID0gZDMubWFwKHtcbiAgICBjaXJjbGU6IGQzX3N2Z19zeW1ib2xDaXJjbGUsXG4gICAgY3Jvc3M6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyA1KSAvIDI7XG4gICAgICByZXR1cm4gXCJNXCIgKyAtMyAqIHIgKyBcIixcIiArIC1yICsgXCJIXCIgKyAtciArIFwiVlwiICsgLTMgKiByICsgXCJIXCIgKyByICsgXCJWXCIgKyAtciArIFwiSFwiICsgMyAqIHIgKyBcIlZcIiArIHIgKyBcIkhcIiArIHIgKyBcIlZcIiArIDMgKiByICsgXCJIXCIgKyAtciArIFwiVlwiICsgciArIFwiSFwiICsgLTMgKiByICsgXCJaXCI7XG4gICAgfSxcbiAgICBkaWFtb25kOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICB2YXIgcnkgPSBNYXRoLnNxcnQoc2l6ZSAvICgyICogZDNfc3ZnX3N5bWJvbFRhbjMwKSksIHJ4ID0gcnkgKiBkM19zdmdfc3ltYm9sVGFuMzA7XG4gICAgICByZXR1cm4gXCJNMCxcIiArIC1yeSArIFwiTFwiICsgcnggKyBcIiwwXCIgKyBcIiAwLFwiICsgcnkgKyBcIiBcIiArIC1yeCArIFwiLDBcIiArIFwiWlwiO1xuICAgIH0sXG4gICAgc3F1YXJlOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICB2YXIgciA9IE1hdGguc3FydChzaXplKSAvIDI7XG4gICAgICByZXR1cm4gXCJNXCIgKyAtciArIFwiLFwiICsgLXIgKyBcIkxcIiArIHIgKyBcIixcIiArIC1yICsgXCIgXCIgKyByICsgXCIsXCIgKyByICsgXCIgXCIgKyAtciArIFwiLFwiICsgciArIFwiWlwiO1xuICAgIH0sXG4gICAgXCJ0cmlhbmdsZS1kb3duXCI6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciByeCA9IE1hdGguc3FydChzaXplIC8gZDNfc3ZnX3N5bWJvbFNxcnQzKSwgcnkgPSByeCAqIGQzX3N2Z19zeW1ib2xTcXJ0MyAvIDI7XG4gICAgICByZXR1cm4gXCJNMCxcIiArIHJ5ICsgXCJMXCIgKyByeCArIFwiLFwiICsgLXJ5ICsgXCIgXCIgKyAtcnggKyBcIixcIiArIC1yeSArIFwiWlwiO1xuICAgIH0sXG4gICAgXCJ0cmlhbmdsZS11cFwiOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICB2YXIgcnggPSBNYXRoLnNxcnQoc2l6ZSAvIGQzX3N2Z19zeW1ib2xTcXJ0MyksIHJ5ID0gcnggKiBkM19zdmdfc3ltYm9sU3FydDMgLyAyO1xuICAgICAgcmV0dXJuIFwiTTAsXCIgKyAtcnkgKyBcIkxcIiArIHJ4ICsgXCIsXCIgKyByeSArIFwiIFwiICsgLXJ4ICsgXCIsXCIgKyByeSArIFwiWlwiO1xuICAgIH1cbiAgfSk7XG4gIGQzLnN2Zy5zeW1ib2xUeXBlcyA9IGQzX3N2Z19zeW1ib2xzLmtleXMoKTtcbiAgdmFyIGQzX3N2Z19zeW1ib2xTcXJ0MyA9IE1hdGguc3FydCgzKSwgZDNfc3ZnX3N5bWJvbFRhbjMwID0gTWF0aC50YW4oMzAgKiBkM19yYWRpYW5zKTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnRyYW5zaXRpb24gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGlkID0gZDNfdHJhbnNpdGlvbkluaGVyaXRJZCB8fCArK2QzX3RyYW5zaXRpb25JZCwgbnMgPSBkM190cmFuc2l0aW9uTmFtZXNwYWNlKG5hbWUpLCBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIG5vZGUsIHRyYW5zaXRpb24gPSBkM190cmFuc2l0aW9uSW5oZXJpdCB8fCB7XG4gICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgZWFzZTogZDNfZWFzZV9jdWJpY0luT3V0LFxuICAgICAgZGVsYXk6IDAsXG4gICAgICBkdXJhdGlvbjogMjUwXG4gICAgfTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IC0xLCBuID0gZ3JvdXAubGVuZ3RoOyArK2kgPCBuOyApIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgZDNfdHJhbnNpdGlvbk5vZGUobm9kZSwgaSwgbnMsIGlkLCB0cmFuc2l0aW9uKTtcbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb24oc3ViZ3JvdXBzLCBucywgaWQpO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuaW50ZXJydXB0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2gobmFtZSA9PSBudWxsID8gZDNfc2VsZWN0aW9uX2ludGVycnVwdCA6IGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHROUyhkM190cmFuc2l0aW9uTmFtZXNwYWNlKG5hbWUpKSk7XG4gIH07XG4gIHZhciBkM19zZWxlY3Rpb25faW50ZXJydXB0ID0gZDNfc2VsZWN0aW9uX2ludGVycnVwdE5TKGQzX3RyYW5zaXRpb25OYW1lc3BhY2UoKSk7XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHROUyhucykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsb2NrLCBhY3RpdmVJZCwgYWN0aXZlO1xuICAgICAgaWYgKChsb2NrID0gdGhpc1tuc10pICYmIChhY3RpdmUgPSBsb2NrW2FjdGl2ZUlkID0gbG9jay5hY3RpdmVdKSkge1xuICAgICAgICBhY3RpdmUudGltZXIuYyA9IG51bGw7XG4gICAgICAgIGFjdGl2ZS50aW1lci50ID0gTmFOO1xuICAgICAgICBpZiAoLS1sb2NrLmNvdW50KSBkZWxldGUgbG9ja1thY3RpdmVJZF07IGVsc2UgZGVsZXRlIHRoaXNbbnNdO1xuICAgICAgICBsb2NrLmFjdGl2ZSArPSAuNTtcbiAgICAgICAgYWN0aXZlLmV2ZW50ICYmIGFjdGl2ZS5ldmVudC5pbnRlcnJ1cHQuY2FsbCh0aGlzLCB0aGlzLl9fZGF0YV9fLCBhY3RpdmUuaW5kZXgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfdHJhbnNpdGlvbihncm91cHMsIG5zLCBpZCkge1xuICAgIGQzX3N1YmNsYXNzKGdyb3VwcywgZDNfdHJhbnNpdGlvblByb3RvdHlwZSk7XG4gICAgZ3JvdXBzLm5hbWVzcGFjZSA9IG5zO1xuICAgIGdyb3Vwcy5pZCA9IGlkO1xuICAgIHJldHVybiBncm91cHM7XG4gIH1cbiAgdmFyIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUgPSBbXSwgZDNfdHJhbnNpdGlvbklkID0gMCwgZDNfdHJhbnNpdGlvbkluaGVyaXRJZCwgZDNfdHJhbnNpdGlvbkluaGVyaXQ7XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuY2FsbCA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5jYWxsO1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmVtcHR5ID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLmVtcHR5O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLm5vZGUgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUubm9kZTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5zaXplID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLnNpemU7XG4gIGQzLnRyYW5zaXRpb24gPSBmdW5jdGlvbihzZWxlY3Rpb24sIG5hbWUpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uICYmIHNlbGVjdGlvbi50cmFuc2l0aW9uID8gZDNfdHJhbnNpdGlvbkluaGVyaXRJZCA/IHNlbGVjdGlvbi50cmFuc2l0aW9uKG5hbWUpIDogc2VsZWN0aW9uIDogZDMuc2VsZWN0aW9uKCkudHJhbnNpdGlvbihzZWxlY3Rpb24pO1xuICB9O1xuICBkMy50cmFuc2l0aW9uLnByb3RvdHlwZSA9IGQzX3RyYW5zaXRpb25Qcm90b3R5cGU7XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlLCBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIHN1Ym5vZGUsIG5vZGU7XG4gICAgc2VsZWN0b3IgPSBkM19zZWxlY3Rpb25fc2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3Rvci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKSkge1xuICAgICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgICAgZDNfdHJhbnNpdGlvbk5vZGUoc3Vibm9kZSwgaSwgbnMsIGlkLCBub2RlW25zXVtpZF0pO1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2goc3Vibm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbihzdWJncm91cHMsIG5zLCBpZCk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuc2VsZWN0QWxsID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlLCBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIHN1Ym5vZGVzLCBub2RlLCBzdWJub2RlLCB0cmFuc2l0aW9uO1xuICAgIHNlbGVjdG9yID0gZDNfc2VsZWN0aW9uX3NlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjsgKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICB0cmFuc2l0aW9uID0gbm9kZVtuc11baWRdO1xuICAgICAgICAgIHN1Ym5vZGVzID0gc2VsZWN0b3IuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKTtcbiAgICAgICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gLTEsIG8gPSBzdWJub2Rlcy5sZW5ndGg7ICsrayA8IG87ICkge1xuICAgICAgICAgICAgaWYgKHN1Ym5vZGUgPSBzdWJub2Rlc1trXSkgZDNfdHJhbnNpdGlvbk5vZGUoc3Vibm9kZSwgaywgbnMsIGlkLCB0cmFuc2l0aW9uKTtcbiAgICAgICAgICAgIHN1Ymdyb3VwLnB1c2goc3Vibm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uKHN1Ymdyb3VwcywgbnMsIGlkKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBncm91cCwgbm9kZTtcbiAgICBpZiAodHlwZW9mIGZpbHRlciAhPT0gXCJmdW5jdGlvblwiKSBmaWx0ZXIgPSBkM19zZWxlY3Rpb25fZmlsdGVyKGZpbHRlcik7XG4gICAgZm9yICh2YXIgaiA9IDAsIG0gPSB0aGlzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBmaWx0ZXIuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSkge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLm5hbWVzcGFjZSwgdGhpcy5pZCk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUudHdlZW4gPSBmdW5jdGlvbihuYW1lLCB0d2Vlbikge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gdGhpcy5ub2RlKClbbnNdW2lkXS50d2Vlbi5nZXQobmFtZSk7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIHR3ZWVuID09IG51bGwgPyBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0udHdlZW4ucmVtb3ZlKG5hbWUpO1xuICAgIH0gOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0udHdlZW4uc2V0KG5hbWUsIHR3ZWVuKTtcbiAgICB9KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdHJhbnNpdGlvbl90d2Vlbihncm91cHMsIG5hbWUsIHZhbHVlLCB0d2Vlbikge1xuICAgIHZhciBpZCA9IGdyb3Vwcy5pZCwgbnMgPSBncm91cHMubmFtZXNwYWNlO1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25fZWFjaChncm91cHMsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb24obm9kZSwgaSwgaikge1xuICAgICAgbm9kZVtuc11baWRdLnR3ZWVuLnNldChuYW1lLCB0d2Vlbih2YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKSk7XG4gICAgfSA6ICh2YWx1ZSA9IHR3ZWVuKHZhbHVlKSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZVtuc11baWRdLnR3ZWVuLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgfSkpO1xuICB9XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuYXR0ciA9IGZ1bmN0aW9uKG5hbWVOUywgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGZvciAodmFsdWUgaW4gbmFtZU5TKSB0aGlzLmF0dHIodmFsdWUsIG5hbWVOU1t2YWx1ZV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBpbnRlcnBvbGF0ZSA9IG5hbWVOUyA9PSBcInRyYW5zZm9ybVwiID8gZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm0gOiBkM19pbnRlcnBvbGF0ZSwgbmFtZSA9IGQzLm5zLnF1YWxpZnkobmFtZU5TKTtcbiAgICBmdW5jdGlvbiBhdHRyTnVsbCgpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyTnVsbE5TKCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0clR3ZWVuKGIpIHtcbiAgICAgIHJldHVybiBiID09IG51bGwgPyBhdHRyTnVsbCA6IChiICs9IFwiXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpLCBpO1xuICAgICAgICByZXR1cm4gYSAhPT0gYiAmJiAoaSA9IGludGVycG9sYXRlKGEsIGIpLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgaSh0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJUd2Vlbk5TKGIpIHtcbiAgICAgIHJldHVybiBiID09IG51bGwgPyBhdHRyTnVsbE5TIDogKGIgKz0gXCJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKSwgaTtcbiAgICAgICAgcmV0dXJuIGEgIT09IGIgJiYgKGkgPSBpbnRlcnBvbGF0ZShhLCBiKSwgZnVuY3Rpb24odCkge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCwgaSh0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uX3R3ZWVuKHRoaXMsIFwiYXR0ci5cIiArIG5hbWVOUywgdmFsdWUsIG5hbWUubG9jYWwgPyBhdHRyVHdlZW5OUyA6IGF0dHJUd2Vlbik7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuYXR0clR3ZWVuID0gZnVuY3Rpb24obmFtZU5TLCB0d2Vlbikge1xuICAgIHZhciBuYW1lID0gZDMubnMucXVhbGlmeShuYW1lTlMpO1xuICAgIGZ1bmN0aW9uIGF0dHJUd2VlbihkLCBpKSB7XG4gICAgICB2YXIgZiA9IHR3ZWVuLmNhbGwodGhpcywgZCwgaSwgdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSkpO1xuICAgICAgcmV0dXJuIGYgJiYgZnVuY3Rpb24odCkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCBmKHQpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJUd2Vlbk5TKGQsIGkpIHtcbiAgICAgIHZhciBmID0gdHdlZW4uY2FsbCh0aGlzLCBkLCBpLCB0aGlzLmdldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpKTtcbiAgICAgIHJldHVybiBmICYmIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsLCBmKHQpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnR3ZWVuKFwiYXR0ci5cIiArIG5hbWVOUywgbmFtZS5sb2NhbCA/IGF0dHJUd2Vlbk5TIDogYXR0clR3ZWVuKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobiA8IDMpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAobiA8IDIpIHZhbHVlID0gXCJcIjtcbiAgICAgICAgZm9yIChwcmlvcml0eSBpbiBuYW1lKSB0aGlzLnN0eWxlKHByaW9yaXR5LCBuYW1lW3ByaW9yaXR5XSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHByaW9yaXR5ID0gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3R5bGVOdWxsKCkge1xuICAgICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3R5bGVTdHJpbmcoYikge1xuICAgICAgcmV0dXJuIGIgPT0gbnVsbCA/IHN0eWxlTnVsbCA6IChiICs9IFwiXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYSA9IGQzX3dpbmRvdyh0aGlzKS5nZXRDb21wdXRlZFN0eWxlKHRoaXMsIG51bGwpLmdldFByb3BlcnR5VmFsdWUobmFtZSksIGk7XG4gICAgICAgIHJldHVybiBhICE9PSBiICYmIChpID0gZDNfaW50ZXJwb2xhdGUoYSwgYiksIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGkodCksIHByaW9yaXR5KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb25fdHdlZW4odGhpcywgXCJzdHlsZS5cIiArIG5hbWUsIHZhbHVlLCBzdHlsZVN0cmluZyk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuc3R5bGVUd2VlbiA9IGZ1bmN0aW9uKG5hbWUsIHR3ZWVuLCBwcmlvcml0eSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgcHJpb3JpdHkgPSBcIlwiO1xuICAgIGZ1bmN0aW9uIHN0eWxlVHdlZW4oZCwgaSkge1xuICAgICAgdmFyIGYgPSB0d2Vlbi5jYWxsKHRoaXMsIGQsIGksIGQzX3dpbmRvdyh0aGlzKS5nZXRDb21wdXRlZFN0eWxlKHRoaXMsIG51bGwpLmdldFByb3BlcnR5VmFsdWUobmFtZSkpO1xuICAgICAgcmV0dXJuIGYgJiYgZnVuY3Rpb24odCkge1xuICAgICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGYodCksIHByaW9yaXR5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnR3ZWVuKFwic3R5bGUuXCIgKyBuYW1lLCBzdHlsZVR3ZWVuKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbl90d2Vlbih0aGlzLCBcInRleHRcIiwgdmFsdWUsIGQzX3RyYW5zaXRpb25fdGV4dCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RyYW5zaXRpb25fdGV4dChiKSB7XG4gICAgaWYgKGIgPT0gbnVsbCkgYiA9IFwiXCI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50ZXh0Q29udGVudCA9IGI7XG4gICAgfTtcbiAgfVxuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBucyA9IHRoaXMubmFtZXNwYWNlO1xuICAgIHJldHVybiB0aGlzLmVhY2goXCJlbmQudHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwO1xuICAgICAgaWYgKHRoaXNbbnNdLmNvdW50IDwgMiAmJiAocCA9IHRoaXMucGFyZW50Tm9kZSkpIHAucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgfSk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZWFzZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHJldHVybiB0aGlzLm5vZGUoKVtuc11baWRdLmVhc2U7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB2YWx1ZSA9IGQzLmVhc2UuYXBwbHkoZDMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS5lYXNlID0gdmFsdWU7XG4gICAgfSk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSByZXR1cm4gdGhpcy5ub2RlKClbbnNdW2lkXS5kZWxheTtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2godGhpcywgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbihub2RlLCBpLCBqKSB7XG4gICAgICBub2RlW25zXVtpZF0uZGVsYXkgPSArdmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKTtcbiAgICB9IDogKHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0uZGVsYXkgPSB2YWx1ZTtcbiAgICB9KSk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSByZXR1cm4gdGhpcy5ub2RlKClbbnNdW2lkXS5kdXJhdGlvbjtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2godGhpcywgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbihub2RlLCBpLCBqKSB7XG4gICAgICBub2RlW25zXVtpZF0uZHVyYXRpb24gPSBNYXRoLm1heCgxLCB2YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKTtcbiAgICB9IDogKHZhbHVlID0gTWF0aC5tYXgoMSwgdmFsdWUpLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0uZHVyYXRpb24gPSB2YWx1ZTtcbiAgICB9KSk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHZhciBpbmhlcml0ID0gZDNfdHJhbnNpdGlvbkluaGVyaXQsIGluaGVyaXRJZCA9IGQzX3RyYW5zaXRpb25Jbmhlcml0SWQ7XG4gICAgICB0cnkge1xuICAgICAgICBkM190cmFuc2l0aW9uSW5oZXJpdElkID0gaWQ7XG4gICAgICAgIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIGZ1bmN0aW9uKG5vZGUsIGksIGopIHtcbiAgICAgICAgICBkM190cmFuc2l0aW9uSW5oZXJpdCA9IG5vZGVbbnNdW2lkXTtcbiAgICAgICAgICB0eXBlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaik7XG4gICAgICAgIH0pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZDNfdHJhbnNpdGlvbkluaGVyaXQgPSBpbmhlcml0O1xuICAgICAgICBkM190cmFuc2l0aW9uSW5oZXJpdElkID0gaW5oZXJpdElkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gbm9kZVtuc11baWRdO1xuICAgICAgICAodHJhbnNpdGlvbi5ldmVudCB8fCAodHJhbnNpdGlvbi5ldmVudCA9IGQzLmRpc3BhdGNoKFwic3RhcnRcIiwgXCJlbmRcIiwgXCJpbnRlcnJ1cHRcIikpKS5vbih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUudHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZDAgPSB0aGlzLmlkLCBpZDEgPSArK2QzX3RyYW5zaXRpb25JZCwgbnMgPSB0aGlzLm5hbWVzcGFjZSwgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBncm91cCwgbm9kZSwgdHJhbnNpdGlvbjtcbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IHRoaXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHRyYW5zaXRpb24gPSBub2RlW25zXVtpZDBdO1xuICAgICAgICAgIGQzX3RyYW5zaXRpb25Ob2RlKG5vZGUsIGksIG5zLCBpZDEsIHtcbiAgICAgICAgICAgIHRpbWU6IHRyYW5zaXRpb24udGltZSxcbiAgICAgICAgICAgIGVhc2U6IHRyYW5zaXRpb24uZWFzZSxcbiAgICAgICAgICAgIGRlbGF5OiB0cmFuc2l0aW9uLmRlbGF5ICsgdHJhbnNpdGlvbi5kdXJhdGlvbixcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0cmFuc2l0aW9uLmR1cmF0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb24oc3ViZ3JvdXBzLCBucywgaWQxKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdHJhbnNpdGlvbk5hbWVzcGFjZShuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgPT0gbnVsbCA/IFwiX190cmFuc2l0aW9uX19cIiA6IFwiX190cmFuc2l0aW9uX1wiICsgbmFtZSArIFwiX19cIjtcbiAgfVxuICBmdW5jdGlvbiBkM190cmFuc2l0aW9uTm9kZShub2RlLCBpLCBucywgaWQsIGluaGVyaXQpIHtcbiAgICB2YXIgbG9jayA9IG5vZGVbbnNdIHx8IChub2RlW25zXSA9IHtcbiAgICAgIGFjdGl2ZTogMCxcbiAgICAgIGNvdW50OiAwXG4gICAgfSksIHRyYW5zaXRpb24gPSBsb2NrW2lkXSwgdGltZSwgdGltZXIsIGR1cmF0aW9uLCBlYXNlLCB0d2VlbnM7XG4gICAgZnVuY3Rpb24gc2NoZWR1bGUoZWxhcHNlZCkge1xuICAgICAgdmFyIGRlbGF5ID0gdHJhbnNpdGlvbi5kZWxheTtcbiAgICAgIHRpbWVyLnQgPSBkZWxheSArIHRpbWU7XG4gICAgICBpZiAoZGVsYXkgPD0gZWxhcHNlZCkgcmV0dXJuIHN0YXJ0KGVsYXBzZWQgLSBkZWxheSk7XG4gICAgICB0aW1lci5jID0gc3RhcnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0KGVsYXBzZWQpIHtcbiAgICAgIHZhciBhY3RpdmVJZCA9IGxvY2suYWN0aXZlLCBhY3RpdmUgPSBsb2NrW2FjdGl2ZUlkXTtcbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgYWN0aXZlLnRpbWVyLmMgPSBudWxsO1xuICAgICAgICBhY3RpdmUudGltZXIudCA9IE5hTjtcbiAgICAgICAgLS1sb2NrLmNvdW50O1xuICAgICAgICBkZWxldGUgbG9ja1thY3RpdmVJZF07XG4gICAgICAgIGFjdGl2ZS5ldmVudCAmJiBhY3RpdmUuZXZlbnQuaW50ZXJydXB0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgYWN0aXZlLmluZGV4KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGNhbmNlbElkIGluIGxvY2spIHtcbiAgICAgICAgaWYgKCtjYW5jZWxJZCA8IGlkKSB7XG4gICAgICAgICAgdmFyIGNhbmNlbCA9IGxvY2tbY2FuY2VsSWRdO1xuICAgICAgICAgIGNhbmNlbC50aW1lci5jID0gbnVsbDtcbiAgICAgICAgICBjYW5jZWwudGltZXIudCA9IE5hTjtcbiAgICAgICAgICAtLWxvY2suY291bnQ7XG4gICAgICAgICAgZGVsZXRlIGxvY2tbY2FuY2VsSWRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aW1lci5jID0gdGljaztcbiAgICAgIGQzX3RpbWVyKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGltZXIuYyAmJiB0aWNrKGVsYXBzZWQgfHwgMSkpIHtcbiAgICAgICAgICB0aW1lci5jID0gbnVsbDtcbiAgICAgICAgICB0aW1lci50ID0gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSwgMCwgdGltZSk7XG4gICAgICBsb2NrLmFjdGl2ZSA9IGlkO1xuICAgICAgdHJhbnNpdGlvbi5ldmVudCAmJiB0cmFuc2l0aW9uLmV2ZW50LnN0YXJ0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSk7XG4gICAgICB0d2VlbnMgPSBbXTtcbiAgICAgIHRyYW5zaXRpb24udHdlZW4uZm9yRWFjaChmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9IHZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSkpIHtcbiAgICAgICAgICB0d2VlbnMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWFzZSA9IHRyYW5zaXRpb24uZWFzZTtcbiAgICAgIGR1cmF0aW9uID0gdHJhbnNpdGlvbi5kdXJhdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgICB2YXIgdCA9IGVsYXBzZWQgLyBkdXJhdGlvbiwgZSA9IGVhc2UodCksIG4gPSB0d2VlbnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgIHR3ZWVuc1stLW5dLmNhbGwobm9kZSwgZSk7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAxKSB7XG4gICAgICAgIHRyYW5zaXRpb24uZXZlbnQgJiYgdHJhbnNpdGlvbi5ldmVudC5lbmQuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpKTtcbiAgICAgICAgaWYgKC0tbG9jay5jb3VudCkgZGVsZXRlIGxvY2tbaWRdOyBlbHNlIGRlbGV0ZSBub2RlW25zXTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHJhbnNpdGlvbikge1xuICAgICAgdGltZSA9IGluaGVyaXQudGltZTtcbiAgICAgIHRpbWVyID0gZDNfdGltZXIoc2NoZWR1bGUsIDAsIHRpbWUpO1xuICAgICAgdHJhbnNpdGlvbiA9IGxvY2tbaWRdID0ge1xuICAgICAgICB0d2VlbjogbmV3IGQzX01hcCgpLFxuICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICB0aW1lcjogdGltZXIsXG4gICAgICAgIGRlbGF5OiBpbmhlcml0LmRlbGF5LFxuICAgICAgICBkdXJhdGlvbjogaW5oZXJpdC5kdXJhdGlvbixcbiAgICAgICAgZWFzZTogaW5oZXJpdC5lYXNlLFxuICAgICAgICBpbmRleDogaVxuICAgICAgfTtcbiAgICAgIGluaGVyaXQgPSBudWxsO1xuICAgICAgKytsb2NrLmNvdW50O1xuICAgIH1cbiAgfVxuICBkMy5zdmcuYXhpcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpLCBvcmllbnQgPSBkM19zdmdfYXhpc0RlZmF1bHRPcmllbnQsIGlubmVyVGlja1NpemUgPSA2LCBvdXRlclRpY2tTaXplID0gNiwgdGlja1BhZGRpbmcgPSAzLCB0aWNrQXJndW1lbnRzXyA9IFsgMTAgXSwgdGlja1ZhbHVlcyA9IG51bGwsIHRpY2tGb3JtYXRfO1xuICAgIGZ1bmN0aW9uIGF4aXMoZykge1xuICAgICAgZy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZyA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgdmFyIHNjYWxlMCA9IHRoaXMuX19jaGFydF9fIHx8IHNjYWxlLCBzY2FsZTEgPSB0aGlzLl9fY2hhcnRfXyA9IHNjYWxlLmNvcHkoKTtcbiAgICAgICAgdmFyIHRpY2tzID0gdGlja1ZhbHVlcyA9PSBudWxsID8gc2NhbGUxLnRpY2tzID8gc2NhbGUxLnRpY2tzLmFwcGx5KHNjYWxlMSwgdGlja0FyZ3VtZW50c18pIDogc2NhbGUxLmRvbWFpbigpIDogdGlja1ZhbHVlcywgdGlja0Zvcm1hdCA9IHRpY2tGb3JtYXRfID09IG51bGwgPyBzY2FsZTEudGlja0Zvcm1hdCA/IHNjYWxlMS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlMSwgdGlja0FyZ3VtZW50c18pIDogZDNfaWRlbnRpdHkgOiB0aWNrRm9ybWF0XywgdGljayA9IGcuc2VsZWN0QWxsKFwiLnRpY2tcIikuZGF0YSh0aWNrcywgc2NhbGUxKSwgdGlja0VudGVyID0gdGljay5lbnRlcigpLmluc2VydChcImdcIiwgXCIuZG9tYWluXCIpLmF0dHIoXCJjbGFzc1wiLCBcInRpY2tcIikuc3R5bGUoXCJvcGFjaXR5XCIsIM61KSwgdGlja0V4aXQgPSBkMy50cmFuc2l0aW9uKHRpY2suZXhpdCgpKS5zdHlsZShcIm9wYWNpdHlcIiwgzrUpLnJlbW92ZSgpLCB0aWNrVXBkYXRlID0gZDMudHJhbnNpdGlvbih0aWNrLm9yZGVyKCkpLnN0eWxlKFwib3BhY2l0eVwiLCAxKSwgdGlja1NwYWNpbmcgPSBNYXRoLm1heChpbm5lclRpY2tTaXplLCAwKSArIHRpY2tQYWRkaW5nLCB0aWNrVHJhbnNmb3JtO1xuICAgICAgICB2YXIgcmFuZ2UgPSBkM19zY2FsZVJhbmdlKHNjYWxlMSksIHBhdGggPSBnLnNlbGVjdEFsbChcIi5kb21haW5cIikuZGF0YShbIDAgXSksIHBhdGhVcGRhdGUgPSAocGF0aC5lbnRlcigpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImNsYXNzXCIsIFwiZG9tYWluXCIpLCBcbiAgICAgICAgZDMudHJhbnNpdGlvbihwYXRoKSk7XG4gICAgICAgIHRpY2tFbnRlci5hcHBlbmQoXCJsaW5lXCIpO1xuICAgICAgICB0aWNrRW50ZXIuYXBwZW5kKFwidGV4dFwiKTtcbiAgICAgICAgdmFyIGxpbmVFbnRlciA9IHRpY2tFbnRlci5zZWxlY3QoXCJsaW5lXCIpLCBsaW5lVXBkYXRlID0gdGlja1VwZGF0ZS5zZWxlY3QoXCJsaW5lXCIpLCB0ZXh0ID0gdGljay5zZWxlY3QoXCJ0ZXh0XCIpLnRleHQodGlja0Zvcm1hdCksIHRleHRFbnRlciA9IHRpY2tFbnRlci5zZWxlY3QoXCJ0ZXh0XCIpLCB0ZXh0VXBkYXRlID0gdGlja1VwZGF0ZS5zZWxlY3QoXCJ0ZXh0XCIpLCBzaWduID0gb3JpZW50ID09PSBcInRvcFwiIHx8IG9yaWVudCA9PT0gXCJsZWZ0XCIgPyAtMSA6IDEsIHgxLCB4MiwgeTEsIHkyO1xuICAgICAgICBpZiAob3JpZW50ID09PSBcImJvdHRvbVwiIHx8IG9yaWVudCA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgIHRpY2tUcmFuc2Zvcm0gPSBkM19zdmdfYXhpc1gsIHgxID0gXCJ4XCIsIHkxID0gXCJ5XCIsIHgyID0gXCJ4MlwiLCB5MiA9IFwieTJcIjtcbiAgICAgICAgICB0ZXh0LmF0dHIoXCJkeVwiLCBzaWduIDwgMCA/IFwiMGVtXCIgOiBcIi43MWVtXCIpLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIik7XG4gICAgICAgICAgcGF0aFVwZGF0ZS5hdHRyKFwiZFwiLCBcIk1cIiArIHJhbmdlWzBdICsgXCIsXCIgKyBzaWduICogb3V0ZXJUaWNrU2l6ZSArIFwiVjBIXCIgKyByYW5nZVsxXSArIFwiVlwiICsgc2lnbiAqIG91dGVyVGlja1NpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpY2tUcmFuc2Zvcm0gPSBkM19zdmdfYXhpc1ksIHgxID0gXCJ5XCIsIHkxID0gXCJ4XCIsIHgyID0gXCJ5MlwiLCB5MiA9IFwieDJcIjtcbiAgICAgICAgICB0ZXh0LmF0dHIoXCJkeVwiLCBcIi4zMmVtXCIpLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgc2lnbiA8IDAgPyBcImVuZFwiIDogXCJzdGFydFwiKTtcbiAgICAgICAgICBwYXRoVXBkYXRlLmF0dHIoXCJkXCIsIFwiTVwiICsgc2lnbiAqIG91dGVyVGlja1NpemUgKyBcIixcIiArIHJhbmdlWzBdICsgXCJIMFZcIiArIHJhbmdlWzFdICsgXCJIXCIgKyBzaWduICogb3V0ZXJUaWNrU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZUVudGVyLmF0dHIoeTIsIHNpZ24gKiBpbm5lclRpY2tTaXplKTtcbiAgICAgICAgdGV4dEVudGVyLmF0dHIoeTEsIHNpZ24gKiB0aWNrU3BhY2luZyk7XG4gICAgICAgIGxpbmVVcGRhdGUuYXR0cih4MiwgMCkuYXR0cih5Miwgc2lnbiAqIGlubmVyVGlja1NpemUpO1xuICAgICAgICB0ZXh0VXBkYXRlLmF0dHIoeDEsIDApLmF0dHIoeTEsIHNpZ24gKiB0aWNrU3BhY2luZyk7XG4gICAgICAgIGlmIChzY2FsZTEucmFuZ2VCYW5kKSB7XG4gICAgICAgICAgdmFyIHggPSBzY2FsZTEsIGR4ID0geC5yYW5nZUJhbmQoKSAvIDI7XG4gICAgICAgICAgc2NhbGUwID0gc2NhbGUxID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIHgoZCkgKyBkeDtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNjYWxlMC5yYW5nZUJhbmQpIHtcbiAgICAgICAgICBzY2FsZTAgPSBzY2FsZTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGlja0V4aXQuY2FsbCh0aWNrVHJhbnNmb3JtLCBzY2FsZTEsIHNjYWxlMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGlja0VudGVyLmNhbGwodGlja1RyYW5zZm9ybSwgc2NhbGUwLCBzY2FsZTEpO1xuICAgICAgICB0aWNrVXBkYXRlLmNhbGwodGlja1RyYW5zZm9ybSwgc2NhbGUxLCBzY2FsZTEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGF4aXMuc2NhbGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzY2FsZTtcbiAgICAgIHNjYWxlID0geDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy5vcmllbnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmllbnQ7XG4gICAgICBvcmllbnQgPSB4IGluIGQzX3N2Z19heGlzT3JpZW50cyA/IHggKyBcIlwiIDogZDNfc3ZnX2F4aXNEZWZhdWx0T3JpZW50O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLnRpY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrQXJndW1lbnRzXztcbiAgICAgIHRpY2tBcmd1bWVudHNfID0gZDNfYXJyYXkoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrVmFsdWVzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja1ZhbHVlcztcbiAgICAgIHRpY2tWYWx1ZXMgPSB4O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLnRpY2tGb3JtYXQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrRm9ybWF0XztcbiAgICAgIHRpY2tGb3JtYXRfID0geDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmICghbikgcmV0dXJuIGlubmVyVGlja1NpemU7XG4gICAgICBpbm5lclRpY2tTaXplID0gK3g7XG4gICAgICBvdXRlclRpY2tTaXplID0gK2FyZ3VtZW50c1tuIC0gMV07XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMuaW5uZXJUaWNrU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGlubmVyVGlja1NpemU7XG4gICAgICBpbm5lclRpY2tTaXplID0gK3g7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMub3V0ZXJUaWNrU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dGVyVGlja1NpemU7XG4gICAgICBvdXRlclRpY2tTaXplID0gK3g7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMudGlja1BhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrUGFkZGluZztcbiAgICAgIHRpY2tQYWRkaW5nID0gK3g7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMudGlja1N1YmRpdmlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggJiYgYXhpcztcbiAgICB9O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuICB2YXIgZDNfc3ZnX2F4aXNEZWZhdWx0T3JpZW50ID0gXCJib3R0b21cIiwgZDNfc3ZnX2F4aXNPcmllbnRzID0ge1xuICAgIHRvcDogMSxcbiAgICByaWdodDogMSxcbiAgICBib3R0b206IDEsXG4gICAgbGVmdDogMVxuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfYXhpc1goc2VsZWN0aW9uLCB4MCwgeDEpIHtcbiAgICBzZWxlY3Rpb24uYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICB2YXIgdjAgPSB4MChkKTtcbiAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIChpc0Zpbml0ZSh2MCkgPyB2MCA6IHgxKGQpKSArIFwiLDApXCI7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2F4aXNZKHNlbGVjdGlvbiwgeTAsIHkxKSB7XG4gICAgc2VsZWN0aW9uLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkge1xuICAgICAgdmFyIHYwID0geTAoZCk7XG4gICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoMCxcIiArIChpc0Zpbml0ZSh2MCkgPyB2MCA6IHkxKGQpKSArIFwiKVwiO1xuICAgIH0pO1xuICB9XG4gIGQzLnN2Zy5icnVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBldmVudCA9IGQzX2V2ZW50RGlzcGF0Y2goYnJ1c2gsIFwiYnJ1c2hzdGFydFwiLCBcImJydXNoXCIsIFwiYnJ1c2hlbmRcIiksIHggPSBudWxsLCB5ID0gbnVsbCwgeEV4dGVudCA9IFsgMCwgMCBdLCB5RXh0ZW50ID0gWyAwLCAwIF0sIHhFeHRlbnREb21haW4sIHlFeHRlbnREb21haW4sIHhDbGFtcCA9IHRydWUsIHlDbGFtcCA9IHRydWUsIHJlc2l6ZXMgPSBkM19zdmdfYnJ1c2hSZXNpemVzWzBdO1xuICAgIGZ1bmN0aW9uIGJydXNoKGcpIHtcbiAgICAgIGcuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGcgPSBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcImFsbFwiKS5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIikub24oXCJtb3VzZWRvd24uYnJ1c2hcIiwgYnJ1c2hzdGFydCkub24oXCJ0b3VjaHN0YXJ0LmJydXNoXCIsIGJydXNoc3RhcnQpO1xuICAgICAgICB2YXIgYmFja2dyb3VuZCA9IGcuc2VsZWN0QWxsKFwiLmJhY2tncm91bmRcIikuZGF0YShbIDAgXSk7XG4gICAgICAgIGJhY2tncm91bmQuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLCBcImJhY2tncm91bmRcIikuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpLnN0eWxlKFwiY3Vyc29yXCIsIFwiY3Jvc3NoYWlyXCIpO1xuICAgICAgICBnLnNlbGVjdEFsbChcIi5leHRlbnRcIikuZGF0YShbIDAgXSkuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLCBcImV4dGVudFwiKS5zdHlsZShcImN1cnNvclwiLCBcIm1vdmVcIik7XG4gICAgICAgIHZhciByZXNpemUgPSBnLnNlbGVjdEFsbChcIi5yZXNpemVcIikuZGF0YShyZXNpemVzLCBkM19pZGVudGl0eSk7XG4gICAgICAgIHJlc2l6ZS5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgIHJlc2l6ZS5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gXCJyZXNpemUgXCIgKyBkO1xuICAgICAgICB9KS5zdHlsZShcImN1cnNvclwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIGQzX3N2Z19icnVzaEN1cnNvcltkXTtcbiAgICAgICAgfSkuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwieFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIC9bZXddJC8udGVzdChkKSA/IC0zIDogbnVsbDtcbiAgICAgICAgfSkuYXR0cihcInlcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiAvXltuc10vLnRlc3QoZCkgPyAtMyA6IG51bGw7XG4gICAgICAgIH0pLmF0dHIoXCJ3aWR0aFwiLCA2KS5hdHRyKFwiaGVpZ2h0XCIsIDYpLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgcmVzaXplLnN0eWxlKFwiZGlzcGxheVwiLCBicnVzaC5lbXB0eSgpID8gXCJub25lXCIgOiBudWxsKTtcbiAgICAgICAgdmFyIGdVcGRhdGUgPSBkMy50cmFuc2l0aW9uKGcpLCBiYWNrZ3JvdW5kVXBkYXRlID0gZDMudHJhbnNpdGlvbihiYWNrZ3JvdW5kKSwgcmFuZ2U7XG4gICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgcmFuZ2UgPSBkM19zY2FsZVJhbmdlKHgpO1xuICAgICAgICAgIGJhY2tncm91bmRVcGRhdGUuYXR0cihcInhcIiwgcmFuZ2VbMF0pLmF0dHIoXCJ3aWR0aFwiLCByYW5nZVsxXSAtIHJhbmdlWzBdKTtcbiAgICAgICAgICByZWRyYXdYKGdVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5KSB7XG4gICAgICAgICAgcmFuZ2UgPSBkM19zY2FsZVJhbmdlKHkpO1xuICAgICAgICAgIGJhY2tncm91bmRVcGRhdGUuYXR0cihcInlcIiwgcmFuZ2VbMF0pLmF0dHIoXCJoZWlnaHRcIiwgcmFuZ2VbMV0gLSByYW5nZVswXSk7XG4gICAgICAgICAgcmVkcmF3WShnVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZWRyYXcoZ1VwZGF0ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgYnJ1c2guZXZlbnQgPSBmdW5jdGlvbihnKSB7XG4gICAgICBnLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBldmVudF8gPSBldmVudC5vZih0aGlzLCBhcmd1bWVudHMpLCBleHRlbnQxID0ge1xuICAgICAgICAgIHg6IHhFeHRlbnQsXG4gICAgICAgICAgeTogeUV4dGVudCxcbiAgICAgICAgICBpOiB4RXh0ZW50RG9tYWluLFxuICAgICAgICAgIGo6IHlFeHRlbnREb21haW5cbiAgICAgICAgfSwgZXh0ZW50MCA9IHRoaXMuX19jaGFydF9fIHx8IGV4dGVudDE7XG4gICAgICAgIHRoaXMuX19jaGFydF9fID0gZXh0ZW50MTtcbiAgICAgICAgaWYgKGQzX3RyYW5zaXRpb25Jbmhlcml0SWQpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmVhY2goXCJzdGFydC5icnVzaFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHhFeHRlbnREb21haW4gPSBleHRlbnQwLmk7XG4gICAgICAgICAgICB5RXh0ZW50RG9tYWluID0gZXh0ZW50MC5qO1xuICAgICAgICAgICAgeEV4dGVudCA9IGV4dGVudDAueDtcbiAgICAgICAgICAgIHlFeHRlbnQgPSBleHRlbnQwLnk7XG4gICAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgICB0eXBlOiBcImJydXNoc3RhcnRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkudHdlZW4oXCJicnVzaDpicnVzaFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB4aSA9IGQzX2ludGVycG9sYXRlQXJyYXkoeEV4dGVudCwgZXh0ZW50MS54KSwgeWkgPSBkM19pbnRlcnBvbGF0ZUFycmF5KHlFeHRlbnQsIGV4dGVudDEueSk7XG4gICAgICAgICAgICB4RXh0ZW50RG9tYWluID0geUV4dGVudERvbWFpbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICB4RXh0ZW50ID0gZXh0ZW50MS54ID0geGkodCk7XG4gICAgICAgICAgICAgIHlFeHRlbnQgPSBleHRlbnQxLnkgPSB5aSh0KTtcbiAgICAgICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJydXNoXCIsXG4gICAgICAgICAgICAgICAgbW9kZTogXCJyZXNpemVcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkuZWFjaChcImVuZC5icnVzaFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHhFeHRlbnREb21haW4gPSBleHRlbnQxLmk7XG4gICAgICAgICAgICB5RXh0ZW50RG9tYWluID0gZXh0ZW50MS5qO1xuICAgICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJicnVzaFwiLFxuICAgICAgICAgICAgICBtb2RlOiBcInJlc2l6ZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hlbmRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hzdGFydFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hcIixcbiAgICAgICAgICAgIG1vZGU6IFwicmVzaXplXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgdHlwZTogXCJicnVzaGVuZFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVkcmF3KGcpIHtcbiAgICAgIGcuc2VsZWN0QWxsKFwiLnJlc2l6ZVwiKS5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgeEV4dGVudFsrL2UkLy50ZXN0KGQpXSArIFwiLFwiICsgeUV4dGVudFsrL15zLy50ZXN0KGQpXSArIFwiKVwiO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZHJhd1goZykge1xuICAgICAgZy5zZWxlY3QoXCIuZXh0ZW50XCIpLmF0dHIoXCJ4XCIsIHhFeHRlbnRbMF0pO1xuICAgICAgZy5zZWxlY3RBbGwoXCIuZXh0ZW50LC5uPnJlY3QsLnM+cmVjdFwiKS5hdHRyKFwid2lkdGhcIiwgeEV4dGVudFsxXSAtIHhFeHRlbnRbMF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWRyYXdZKGcpIHtcbiAgICAgIGcuc2VsZWN0KFwiLmV4dGVudFwiKS5hdHRyKFwieVwiLCB5RXh0ZW50WzBdKTtcbiAgICAgIGcuc2VsZWN0QWxsKFwiLmV4dGVudCwuZT5yZWN0LC53PnJlY3RcIikuYXR0cihcImhlaWdodFwiLCB5RXh0ZW50WzFdIC0geUV4dGVudFswXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJydXNoc3RhcnQoKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcywgZXZlbnRUYXJnZXQgPSBkMy5zZWxlY3QoZDMuZXZlbnQudGFyZ2V0KSwgZXZlbnRfID0gZXZlbnQub2YodGFyZ2V0LCBhcmd1bWVudHMpLCBnID0gZDMuc2VsZWN0KHRhcmdldCksIHJlc2l6aW5nID0gZXZlbnRUYXJnZXQuZGF0dW0oKSwgcmVzaXppbmdYID0gIS9eKG58cykkLy50ZXN0KHJlc2l6aW5nKSAmJiB4LCByZXNpemluZ1kgPSAhL14oZXx3KSQvLnRlc3QocmVzaXppbmcpICYmIHksIGRyYWdnaW5nID0gZXZlbnRUYXJnZXQuY2xhc3NlZChcImV4dGVudFwiKSwgZHJhZ1Jlc3RvcmUgPSBkM19ldmVudF9kcmFnU3VwcHJlc3ModGFyZ2V0KSwgY2VudGVyLCBvcmlnaW4gPSBkMy5tb3VzZSh0YXJnZXQpLCBvZmZzZXQ7XG4gICAgICB2YXIgdyA9IGQzLnNlbGVjdChkM193aW5kb3codGFyZ2V0KSkub24oXCJrZXlkb3duLmJydXNoXCIsIGtleWRvd24pLm9uKFwia2V5dXAuYnJ1c2hcIiwga2V5dXApO1xuICAgICAgaWYgKGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICAgIHcub24oXCJ0b3VjaG1vdmUuYnJ1c2hcIiwgYnJ1c2htb3ZlKS5vbihcInRvdWNoZW5kLmJydXNoXCIsIGJydXNoZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHcub24oXCJtb3VzZW1vdmUuYnJ1c2hcIiwgYnJ1c2htb3ZlKS5vbihcIm1vdXNldXAuYnJ1c2hcIiwgYnJ1c2hlbmQpO1xuICAgICAgfVxuICAgICAgZy5pbnRlcnJ1cHQoKS5zZWxlY3RBbGwoXCIqXCIpLmludGVycnVwdCgpO1xuICAgICAgaWYgKGRyYWdnaW5nKSB7XG4gICAgICAgIG9yaWdpblswXSA9IHhFeHRlbnRbMF0gLSBvcmlnaW5bMF07XG4gICAgICAgIG9yaWdpblsxXSA9IHlFeHRlbnRbMF0gLSBvcmlnaW5bMV07XG4gICAgICB9IGVsc2UgaWYgKHJlc2l6aW5nKSB7XG4gICAgICAgIHZhciBleCA9ICsvdyQvLnRlc3QocmVzaXppbmcpLCBleSA9ICsvXm4vLnRlc3QocmVzaXppbmcpO1xuICAgICAgICBvZmZzZXQgPSBbIHhFeHRlbnRbMSAtIGV4XSAtIG9yaWdpblswXSwgeUV4dGVudFsxIC0gZXldIC0gb3JpZ2luWzFdIF07XG4gICAgICAgIG9yaWdpblswXSA9IHhFeHRlbnRbZXhdO1xuICAgICAgICBvcmlnaW5bMV0gPSB5RXh0ZW50W2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoZDMuZXZlbnQuYWx0S2V5KSBjZW50ZXIgPSBvcmlnaW4uc2xpY2UoKTtcbiAgICAgIGcuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIikuc2VsZWN0QWxsKFwiLnJlc2l6ZVwiKS5zdHlsZShcImRpc3BsYXlcIiwgbnVsbCk7XG4gICAgICBkMy5zZWxlY3QoXCJib2R5XCIpLnN0eWxlKFwiY3Vyc29yXCIsIGV2ZW50VGFyZ2V0LnN0eWxlKFwiY3Vyc29yXCIpKTtcbiAgICAgIGV2ZW50Xyh7XG4gICAgICAgIHR5cGU6IFwiYnJ1c2hzdGFydFwiXG4gICAgICB9KTtcbiAgICAgIGJydXNobW92ZSgpO1xuICAgICAgZnVuY3Rpb24ga2V5ZG93bigpIHtcbiAgICAgICAgaWYgKGQzLmV2ZW50LmtleUNvZGUgPT0gMzIpIHtcbiAgICAgICAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICAgICAgICBjZW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgb3JpZ2luWzBdIC09IHhFeHRlbnRbMV07XG4gICAgICAgICAgICBvcmlnaW5bMV0gLT0geUV4dGVudFsxXTtcbiAgICAgICAgICAgIGRyYWdnaW5nID0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBrZXl1cCgpIHtcbiAgICAgICAgaWYgKGQzLmV2ZW50LmtleUNvZGUgPT0gMzIgJiYgZHJhZ2dpbmcgPT0gMikge1xuICAgICAgICAgIG9yaWdpblswXSArPSB4RXh0ZW50WzFdO1xuICAgICAgICAgIG9yaWdpblsxXSArPSB5RXh0ZW50WzFdO1xuICAgICAgICAgIGRyYWdnaW5nID0gMDtcbiAgICAgICAgICBkM19ldmVudFByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJydXNobW92ZSgpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gZDMubW91c2UodGFyZ2V0KSwgbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgIHBvaW50WzBdICs9IG9mZnNldFswXTtcbiAgICAgICAgICBwb2ludFsxXSArPSBvZmZzZXRbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgICAgIGlmIChkMy5ldmVudC5hbHRLZXkpIHtcbiAgICAgICAgICAgIGlmICghY2VudGVyKSBjZW50ZXIgPSBbICh4RXh0ZW50WzBdICsgeEV4dGVudFsxXSkgLyAyLCAoeUV4dGVudFswXSArIHlFeHRlbnRbMV0pIC8gMiBdO1xuICAgICAgICAgICAgb3JpZ2luWzBdID0geEV4dGVudFsrKHBvaW50WzBdIDwgY2VudGVyWzBdKV07XG4gICAgICAgICAgICBvcmlnaW5bMV0gPSB5RXh0ZW50WysocG9pbnRbMV0gPCBjZW50ZXJbMV0pXTtcbiAgICAgICAgICB9IGVsc2UgY2VudGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzaXppbmdYICYmIG1vdmUxKHBvaW50LCB4LCAwKSkge1xuICAgICAgICAgIHJlZHJhd1goZyk7XG4gICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNpemluZ1kgJiYgbW92ZTEocG9pbnQsIHksIDEpKSB7XG4gICAgICAgICAgcmVkcmF3WShnKTtcbiAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdmVkKSB7XG4gICAgICAgICAgcmVkcmF3KGcpO1xuICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICB0eXBlOiBcImJydXNoXCIsXG4gICAgICAgICAgICBtb2RlOiBkcmFnZ2luZyA/IFwibW92ZVwiIDogXCJyZXNpemVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtb3ZlMShwb2ludCwgc2NhbGUsIGkpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gZDNfc2NhbGVSYW5nZShzY2FsZSksIHIwID0gcmFuZ2VbMF0sIHIxID0gcmFuZ2VbMV0sIHBvc2l0aW9uID0gb3JpZ2luW2ldLCBleHRlbnQgPSBpID8geUV4dGVudCA6IHhFeHRlbnQsIHNpemUgPSBleHRlbnRbMV0gLSBleHRlbnRbMF0sIG1pbiwgbWF4O1xuICAgICAgICBpZiAoZHJhZ2dpbmcpIHtcbiAgICAgICAgICByMCAtPSBwb3NpdGlvbjtcbiAgICAgICAgICByMSAtPSBzaXplICsgcG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgbWluID0gKGkgPyB5Q2xhbXAgOiB4Q2xhbXApID8gTWF0aC5tYXgocjAsIE1hdGgubWluKHIxLCBwb2ludFtpXSkpIDogcG9pbnRbaV07XG4gICAgICAgIGlmIChkcmFnZ2luZykge1xuICAgICAgICAgIG1heCA9IChtaW4gKz0gcG9zaXRpb24pICsgc2l6ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2VudGVyKSBwb3NpdGlvbiA9IE1hdGgubWF4KHIwLCBNYXRoLm1pbihyMSwgMiAqIGNlbnRlcltpXSAtIG1pbikpO1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA8IG1pbikge1xuICAgICAgICAgICAgbWF4ID0gbWluO1xuICAgICAgICAgICAgbWluID0gcG9zaXRpb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1heCA9IHBvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0ZW50WzBdICE9IG1pbiB8fCBleHRlbnRbMV0gIT0gbWF4KSB7XG4gICAgICAgICAgaWYgKGkpIHlFeHRlbnREb21haW4gPSBudWxsOyBlbHNlIHhFeHRlbnREb21haW4gPSBudWxsO1xuICAgICAgICAgIGV4dGVudFswXSA9IG1pbjtcbiAgICAgICAgICBleHRlbnRbMV0gPSBtYXg7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJydXNoZW5kKCkge1xuICAgICAgICBicnVzaG1vdmUoKTtcbiAgICAgICAgZy5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpLnNlbGVjdEFsbChcIi5yZXNpemVcIikuc3R5bGUoXCJkaXNwbGF5XCIsIGJydXNoLmVtcHR5KCkgPyBcIm5vbmVcIiA6IG51bGwpO1xuICAgICAgICBkMy5zZWxlY3QoXCJib2R5XCIpLnN0eWxlKFwiY3Vyc29yXCIsIG51bGwpO1xuICAgICAgICB3Lm9uKFwibW91c2Vtb3ZlLmJydXNoXCIsIG51bGwpLm9uKFwibW91c2V1cC5icnVzaFwiLCBudWxsKS5vbihcInRvdWNobW92ZS5icnVzaFwiLCBudWxsKS5vbihcInRvdWNoZW5kLmJydXNoXCIsIG51bGwpLm9uKFwia2V5ZG93bi5icnVzaFwiLCBudWxsKS5vbihcImtleXVwLmJydXNoXCIsIG51bGwpO1xuICAgICAgICBkcmFnUmVzdG9yZSgpO1xuICAgICAgICBldmVudF8oe1xuICAgICAgICAgIHR5cGU6IFwiYnJ1c2hlbmRcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJ1c2gueCA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHg7XG4gICAgICB4ID0gejtcbiAgICAgIHJlc2l6ZXMgPSBkM19zdmdfYnJ1c2hSZXNpemVzWyF4IDw8IDEgfCAheV07XG4gICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfTtcbiAgICBicnVzaC55ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTtcbiAgICAgIHkgPSB6O1xuICAgICAgcmVzaXplcyA9IGQzX3N2Z19icnVzaFJlc2l6ZXNbIXggPDwgMSB8ICF5XTtcbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9O1xuICAgIGJydXNoLmNsYW1wID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geCAmJiB5ID8gWyB4Q2xhbXAsIHlDbGFtcCBdIDogeCA/IHhDbGFtcCA6IHkgPyB5Q2xhbXAgOiBudWxsO1xuICAgICAgaWYgKHggJiYgeSkgeENsYW1wID0gISF6WzBdLCB5Q2xhbXAgPSAhIXpbMV07IGVsc2UgaWYgKHgpIHhDbGFtcCA9ICEhejsgZWxzZSBpZiAoeSkgeUNsYW1wID0gISF6O1xuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH07XG4gICAgYnJ1c2guZXh0ZW50ID0gZnVuY3Rpb24oeikge1xuICAgICAgdmFyIHgwLCB4MSwgeTAsIHkxLCB0O1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgaWYgKHhFeHRlbnREb21haW4pIHtcbiAgICAgICAgICAgIHgwID0geEV4dGVudERvbWFpblswXSwgeDEgPSB4RXh0ZW50RG9tYWluWzFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4MCA9IHhFeHRlbnRbMF0sIHgxID0geEV4dGVudFsxXTtcbiAgICAgICAgICAgIGlmICh4LmludmVydCkgeDAgPSB4LmludmVydCh4MCksIHgxID0geC5pbnZlcnQoeDEpO1xuICAgICAgICAgICAgaWYgKHgxIDwgeDApIHQgPSB4MCwgeDAgPSB4MSwgeDEgPSB0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoeSkge1xuICAgICAgICAgIGlmICh5RXh0ZW50RG9tYWluKSB7XG4gICAgICAgICAgICB5MCA9IHlFeHRlbnREb21haW5bMF0sIHkxID0geUV4dGVudERvbWFpblsxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeTAgPSB5RXh0ZW50WzBdLCB5MSA9IHlFeHRlbnRbMV07XG4gICAgICAgICAgICBpZiAoeS5pbnZlcnQpIHkwID0geS5pbnZlcnQoeTApLCB5MSA9IHkuaW52ZXJ0KHkxKTtcbiAgICAgICAgICAgIGlmICh5MSA8IHkwKSB0ID0geTAsIHkwID0geTEsIHkxID0gdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggJiYgeSA/IFsgWyB4MCwgeTAgXSwgWyB4MSwgeTEgXSBdIDogeCA/IFsgeDAsIHgxIF0gOiB5ICYmIFsgeTAsIHkxIF07XG4gICAgICB9XG4gICAgICBpZiAoeCkge1xuICAgICAgICB4MCA9IHpbMF0sIHgxID0gelsxXTtcbiAgICAgICAgaWYgKHkpIHgwID0geDBbMF0sIHgxID0geDFbMF07XG4gICAgICAgIHhFeHRlbnREb21haW4gPSBbIHgwLCB4MSBdO1xuICAgICAgICBpZiAoeC5pbnZlcnQpIHgwID0geCh4MCksIHgxID0geCh4MSk7XG4gICAgICAgIGlmICh4MSA8IHgwKSB0ID0geDAsIHgwID0geDEsIHgxID0gdDtcbiAgICAgICAgaWYgKHgwICE9IHhFeHRlbnRbMF0gfHwgeDEgIT0geEV4dGVudFsxXSkgeEV4dGVudCA9IFsgeDAsIHgxIF07XG4gICAgICB9XG4gICAgICBpZiAoeSkge1xuICAgICAgICB5MCA9IHpbMF0sIHkxID0gelsxXTtcbiAgICAgICAgaWYgKHgpIHkwID0geTBbMV0sIHkxID0geTFbMV07XG4gICAgICAgIHlFeHRlbnREb21haW4gPSBbIHkwLCB5MSBdO1xuICAgICAgICBpZiAoeS5pbnZlcnQpIHkwID0geSh5MCksIHkxID0geSh5MSk7XG4gICAgICAgIGlmICh5MSA8IHkwKSB0ID0geTAsIHkwID0geTEsIHkxID0gdDtcbiAgICAgICAgaWYgKHkwICE9IHlFeHRlbnRbMF0gfHwgeTEgIT0geUV4dGVudFsxXSkgeUV4dGVudCA9IFsgeTAsIHkxIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfTtcbiAgICBicnVzaC5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFicnVzaC5lbXB0eSgpKSB7XG4gICAgICAgIHhFeHRlbnQgPSBbIDAsIDAgXSwgeUV4dGVudCA9IFsgMCwgMCBdO1xuICAgICAgICB4RXh0ZW50RG9tYWluID0geUV4dGVudERvbWFpbiA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfTtcbiAgICBicnVzaC5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICEheCAmJiB4RXh0ZW50WzBdID09IHhFeHRlbnRbMV0gfHwgISF5ICYmIHlFeHRlbnRbMF0gPT0geUV4dGVudFsxXTtcbiAgICB9O1xuICAgIHJldHVybiBkMy5yZWJpbmQoYnJ1c2gsIGV2ZW50LCBcIm9uXCIpO1xuICB9O1xuICB2YXIgZDNfc3ZnX2JydXNoQ3Vyc29yID0ge1xuICAgIG46IFwibnMtcmVzaXplXCIsXG4gICAgZTogXCJldy1yZXNpemVcIixcbiAgICBzOiBcIm5zLXJlc2l6ZVwiLFxuICAgIHc6IFwiZXctcmVzaXplXCIsXG4gICAgbnc6IFwibndzZS1yZXNpemVcIixcbiAgICBuZTogXCJuZXN3LXJlc2l6ZVwiLFxuICAgIHNlOiBcIm53c2UtcmVzaXplXCIsXG4gICAgc3c6IFwibmVzdy1yZXNpemVcIlxuICB9O1xuICB2YXIgZDNfc3ZnX2JydXNoUmVzaXplcyA9IFsgWyBcIm5cIiwgXCJlXCIsIFwic1wiLCBcIndcIiwgXCJud1wiLCBcIm5lXCIsIFwic2VcIiwgXCJzd1wiIF0sIFsgXCJlXCIsIFwid1wiIF0sIFsgXCJuXCIsIFwic1wiIF0sIFtdIF07XG4gIHZhciBkM190aW1lX2Zvcm1hdCA9IGQzX3RpbWUuZm9ybWF0ID0gZDNfbG9jYWxlX2VuVVMudGltZUZvcm1hdDtcbiAgdmFyIGQzX3RpbWVfZm9ybWF0VXRjID0gZDNfdGltZV9mb3JtYXQudXRjO1xuICB2YXIgZDNfdGltZV9mb3JtYXRJc28gPSBkM190aW1lX2Zvcm1hdFV0YyhcIiVZLSVtLSVkVCVIOiVNOiVTLiVMWlwiKTtcbiAgZDNfdGltZV9mb3JtYXQuaXNvID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgJiYgK25ldyBEYXRlKFwiMjAwMC0wMS0wMVQwMDowMDowMC4wMDBaXCIpID8gZDNfdGltZV9mb3JtYXRJc29OYXRpdmUgOiBkM190aW1lX2Zvcm1hdElzbztcbiAgZnVuY3Rpb24gZDNfdGltZV9mb3JtYXRJc29OYXRpdmUoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7XG4gIH1cbiAgZDNfdGltZV9mb3JtYXRJc29OYXRpdmUucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZyk7XG4gICAgcmV0dXJuIGlzTmFOKGRhdGUpID8gbnVsbCA6IGRhdGU7XG4gIH07XG4gIGQzX3RpbWVfZm9ybWF0SXNvTmF0aXZlLnRvU3RyaW5nID0gZDNfdGltZV9mb3JtYXRJc28udG9TdHJpbmc7XG4gIGQzX3RpbWUuc2Vjb25kID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBkM19kYXRlKE1hdGguZmxvb3IoZGF0ZSAvIDFlMykgKiAxZTMpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyBNYXRoLmZsb29yKG9mZnNldCkgKiAxZTMpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0U2Vjb25kcygpO1xuICB9KTtcbiAgZDNfdGltZS5zZWNvbmRzID0gZDNfdGltZS5zZWNvbmQucmFuZ2U7XG4gIGQzX3RpbWUuc2Vjb25kcy51dGMgPSBkM190aW1lLnNlY29uZC51dGMucmFuZ2U7XG4gIGQzX3RpbWUubWludXRlID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBkM19kYXRlKE1hdGguZmxvb3IoZGF0ZSAvIDZlNCkgKiA2ZTQpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyBNYXRoLmZsb29yKG9mZnNldCkgKiA2ZTQpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0TWludXRlcygpO1xuICB9KTtcbiAgZDNfdGltZS5taW51dGVzID0gZDNfdGltZS5taW51dGUucmFuZ2U7XG4gIGQzX3RpbWUubWludXRlcy51dGMgPSBkM190aW1lLm1pbnV0ZS51dGMucmFuZ2U7XG4gIGQzX3RpbWUuaG91ciA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciB0aW1lem9uZSA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDYwO1xuICAgIHJldHVybiBuZXcgZDNfZGF0ZSgoTWF0aC5mbG9vcihkYXRlIC8gMzZlNSAtIHRpbWV6b25lKSArIHRpbWV6b25lKSAqIDM2ZTUpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyBNYXRoLmZsb29yKG9mZnNldCkgKiAzNmU1KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldEhvdXJzKCk7XG4gIH0pO1xuICBkM190aW1lLmhvdXJzID0gZDNfdGltZS5ob3VyLnJhbmdlO1xuICBkM190aW1lLmhvdXJzLnV0YyA9IGQzX3RpbWUuaG91ci51dGMucmFuZ2U7XG4gIGQzX3RpbWUubW9udGggPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlID0gZDNfdGltZS5kYXkoZGF0ZSk7XG4gICAgZGF0ZS5zZXREYXRlKDEpO1xuICAgIHJldHVybiBkYXRlO1xuICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSArIG9mZnNldCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRNb250aCgpO1xuICB9KTtcbiAgZDNfdGltZS5tb250aHMgPSBkM190aW1lLm1vbnRoLnJhbmdlO1xuICBkM190aW1lLm1vbnRocy51dGMgPSBkM190aW1lLm1vbnRoLnV0Yy5yYW5nZTtcbiAgZnVuY3Rpb24gZDNfdGltZV9zY2FsZShsaW5lYXIsIG1ldGhvZHMsIGZvcm1hdCkge1xuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiBsaW5lYXIoeCk7XG4gICAgfVxuICAgIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBkM190aW1lX3NjYWxlRGF0ZShsaW5lYXIuaW52ZXJ0KHgpKTtcbiAgICB9O1xuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxpbmVhci5kb21haW4oKS5tYXAoZDNfdGltZV9zY2FsZURhdGUpO1xuICAgICAgbGluZWFyLmRvbWFpbih4KTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHRpY2tNZXRob2QoZXh0ZW50LCBjb3VudCkge1xuICAgICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF0sIHRhcmdldCA9IHNwYW4gLyBjb3VudCwgaSA9IGQzLmJpc2VjdChkM190aW1lX3NjYWxlU3RlcHMsIHRhcmdldCk7XG4gICAgICByZXR1cm4gaSA9PSBkM190aW1lX3NjYWxlU3RlcHMubGVuZ3RoID8gWyBtZXRob2RzLnllYXIsIGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShleHRlbnQubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQgLyAzMTUzNmU2O1xuICAgICAgfSksIGNvdW50KVsyXSBdIDogIWkgPyBbIGQzX3RpbWVfc2NhbGVNaWxsaXNlY29uZHMsIGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShleHRlbnQsIGNvdW50KVsyXSBdIDogbWV0aG9kc1t0YXJnZXQgLyBkM190aW1lX3NjYWxlU3RlcHNbaSAtIDFdIDwgZDNfdGltZV9zY2FsZVN0ZXBzW2ldIC8gdGFyZ2V0ID8gaSAtIDEgOiBpXTtcbiAgICB9XG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGludGVydmFsLCBza2lwKSB7XG4gICAgICB2YXIgZG9tYWluID0gc2NhbGUuZG9tYWluKCksIGV4dGVudCA9IGQzX3NjYWxlRXh0ZW50KGRvbWFpbiksIG1ldGhvZCA9IGludGVydmFsID09IG51bGwgPyB0aWNrTWV0aG9kKGV4dGVudCwgMTApIDogdHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiICYmIHRpY2tNZXRob2QoZXh0ZW50LCBpbnRlcnZhbCk7XG4gICAgICBpZiAobWV0aG9kKSBpbnRlcnZhbCA9IG1ldGhvZFswXSwgc2tpcCA9IG1ldGhvZFsxXTtcbiAgICAgIGZ1bmN0aW9uIHNraXBwZWQoZGF0ZSkge1xuICAgICAgICByZXR1cm4gIWlzTmFOKGRhdGUpICYmICFpbnRlcnZhbC5yYW5nZShkYXRlLCBkM190aW1lX3NjYWxlRGF0ZSgrZGF0ZSArIDEpLCBza2lwKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NhbGUuZG9tYWluKGQzX3NjYWxlX25pY2UoZG9tYWluLCBza2lwID4gMSA/IHtcbiAgICAgICAgZmxvb3I6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICB3aGlsZSAoc2tpcHBlZChkYXRlID0gaW50ZXJ2YWwuZmxvb3IoZGF0ZSkpKSBkYXRlID0gZDNfdGltZV9zY2FsZURhdGUoZGF0ZSAtIDEpO1xuICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9LFxuICAgICAgICBjZWlsOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgd2hpbGUgKHNraXBwZWQoZGF0ZSA9IGludGVydmFsLmNlaWwoZGF0ZSkpKSBkYXRlID0gZDNfdGltZV9zY2FsZURhdGUoK2RhdGUgKyAxKTtcbiAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSA6IGludGVydmFsKSk7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGludGVydmFsLCBza2lwKSB7XG4gICAgICB2YXIgZXh0ZW50ID0gZDNfc2NhbGVFeHRlbnQoc2NhbGUuZG9tYWluKCkpLCBtZXRob2QgPSBpbnRlcnZhbCA9PSBudWxsID8gdGlja01ldGhvZChleHRlbnQsIDEwKSA6IHR5cGVvZiBpbnRlcnZhbCA9PT0gXCJudW1iZXJcIiA/IHRpY2tNZXRob2QoZXh0ZW50LCBpbnRlcnZhbCkgOiAhaW50ZXJ2YWwucmFuZ2UgJiYgWyB7XG4gICAgICAgIHJhbmdlOiBpbnRlcnZhbFxuICAgICAgfSwgc2tpcCBdO1xuICAgICAgaWYgKG1ldGhvZCkgaW50ZXJ2YWwgPSBtZXRob2RbMF0sIHNraXAgPSBtZXRob2RbMV07XG4gICAgICByZXR1cm4gaW50ZXJ2YWwucmFuZ2UoZXh0ZW50WzBdLCBkM190aW1lX3NjYWxlRGF0ZSgrZXh0ZW50WzFdICsgMSksIHNraXAgPCAxID8gMSA6IHNraXApO1xuICAgIH07XG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM190aW1lX3NjYWxlKGxpbmVhci5jb3B5KCksIG1ldGhvZHMsIGZvcm1hdCk7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyUmViaW5kKHNjYWxlLCBsaW5lYXIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfc2NhbGVEYXRlKHQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodCk7XG4gIH1cbiAgdmFyIGQzX3RpbWVfc2NhbGVTdGVwcyA9IFsgMWUzLCA1ZTMsIDE1ZTMsIDNlNCwgNmU0LCAzZTUsIDllNSwgMThlNSwgMzZlNSwgMTA4ZTUsIDIxNmU1LCA0MzJlNSwgODY0ZTUsIDE3MjhlNSwgNjA0OGU1LCAyNTkyZTYsIDc3NzZlNiwgMzE1MzZlNiBdO1xuICB2YXIgZDNfdGltZV9zY2FsZUxvY2FsTWV0aG9kcyA9IFsgWyBkM190aW1lLnNlY29uZCwgMSBdLCBbIGQzX3RpbWUuc2Vjb25kLCA1IF0sIFsgZDNfdGltZS5zZWNvbmQsIDE1IF0sIFsgZDNfdGltZS5zZWNvbmQsIDMwIF0sIFsgZDNfdGltZS5taW51dGUsIDEgXSwgWyBkM190aW1lLm1pbnV0ZSwgNSBdLCBbIGQzX3RpbWUubWludXRlLCAxNSBdLCBbIGQzX3RpbWUubWludXRlLCAzMCBdLCBbIGQzX3RpbWUuaG91ciwgMSBdLCBbIGQzX3RpbWUuaG91ciwgMyBdLCBbIGQzX3RpbWUuaG91ciwgNiBdLCBbIGQzX3RpbWUuaG91ciwgMTIgXSwgWyBkM190aW1lLmRheSwgMSBdLCBbIGQzX3RpbWUuZGF5LCAyIF0sIFsgZDNfdGltZS53ZWVrLCAxIF0sIFsgZDNfdGltZS5tb250aCwgMSBdLCBbIGQzX3RpbWUubW9udGgsIDMgXSwgWyBkM190aW1lLnllYXIsIDEgXSBdO1xuICB2YXIgZDNfdGltZV9zY2FsZUxvY2FsRm9ybWF0ID0gZDNfdGltZV9mb3JtYXQubXVsdGkoWyBbIFwiLiVMXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRNaWxsaXNlY29uZHMoKTtcbiAgfSBdLCBbIFwiOiVTXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRTZWNvbmRzKCk7XG4gIH0gXSwgWyBcIiVJOiVNXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRNaW51dGVzKCk7XG4gIH0gXSwgWyBcIiVJICVwXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRIb3VycygpO1xuICB9IF0sIFsgXCIlYSAlZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0RGF5KCkgJiYgZC5nZXREYXRlKCkgIT0gMTtcbiAgfSBdLCBbIFwiJWIgJWRcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldERhdGUoKSAhPSAxO1xuICB9IF0sIFsgXCIlQlwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0TW9udGgoKTtcbiAgfSBdLCBbIFwiJVlcIiwgZDNfdHJ1ZSBdIF0pO1xuICB2YXIgZDNfdGltZV9zY2FsZU1pbGxpc2Vjb25kcyA9IHtcbiAgICByYW5nZTogZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICAgIHJldHVybiBkMy5yYW5nZShNYXRoLmNlaWwoc3RhcnQgLyBzdGVwKSAqIHN0ZXAsICtzdG9wLCBzdGVwKS5tYXAoZDNfdGltZV9zY2FsZURhdGUpO1xuICAgIH0sXG4gICAgZmxvb3I6IGQzX2lkZW50aXR5LFxuICAgIGNlaWw6IGQzX2lkZW50aXR5XG4gIH07XG4gIGQzX3RpbWVfc2NhbGVMb2NhbE1ldGhvZHMueWVhciA9IGQzX3RpbWUueWVhcjtcbiAgZDNfdGltZS5zY2FsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM190aW1lX3NjYWxlKGQzLnNjYWxlLmxpbmVhcigpLCBkM190aW1lX3NjYWxlTG9jYWxNZXRob2RzLCBkM190aW1lX3NjYWxlTG9jYWxGb3JtYXQpO1xuICB9O1xuICB2YXIgZDNfdGltZV9zY2FsZVV0Y01ldGhvZHMgPSBkM190aW1lX3NjYWxlTG9jYWxNZXRob2RzLm1hcChmdW5jdGlvbihtKSB7XG4gICAgcmV0dXJuIFsgbVswXS51dGMsIG1bMV0gXTtcbiAgfSk7XG4gIHZhciBkM190aW1lX3NjYWxlVXRjRm9ybWF0ID0gZDNfdGltZV9mb3JtYXRVdGMubXVsdGkoWyBbIFwiLiVMXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgfSBdLCBbIFwiOiVTXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENTZWNvbmRzKCk7XG4gIH0gXSwgWyBcIiVJOiVNXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENNaW51dGVzKCk7XG4gIH0gXSwgWyBcIiVJICVwXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENIb3VycygpO1xuICB9IF0sIFsgXCIlYSAlZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDRGF5KCkgJiYgZC5nZXRVVENEYXRlKCkgIT0gMTtcbiAgfSBdLCBbIFwiJWIgJWRcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ0RhdGUoKSAhPSAxO1xuICB9IF0sIFsgXCIlQlwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDTW9udGgoKTtcbiAgfSBdLCBbIFwiJVlcIiwgZDNfdHJ1ZSBdIF0pO1xuICBkM190aW1lX3NjYWxlVXRjTWV0aG9kcy55ZWFyID0gZDNfdGltZS55ZWFyLnV0YztcbiAgZDNfdGltZS5zY2FsZS51dGMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfdGltZV9zY2FsZShkMy5zY2FsZS5saW5lYXIoKSwgZDNfdGltZV9zY2FsZVV0Y01ldGhvZHMsIGQzX3RpbWVfc2NhbGVVdGNGb3JtYXQpO1xuICB9O1xuICBkMy50ZXh0ID0gZDNfeGhyVHlwZShmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICB9KTtcbiAgZDMuanNvbiA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZDNfeGhyKHVybCwgXCJhcHBsaWNhdGlvbi9qc29uXCIsIGQzX2pzb24sIGNhbGxiYWNrKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfanNvbihyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICB9XG4gIGQzLmh0bWwgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGQzX3hocih1cmwsIFwidGV4dC9odG1sXCIsIGQzX2h0bWwsIGNhbGxiYWNrKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfaHRtbChyZXF1ZXN0KSB7XG4gICAgdmFyIHJhbmdlID0gZDNfZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZWxlY3ROb2RlKGQzX2RvY3VtZW50LmJvZHkpO1xuICAgIHJldHVybiByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICB9XG4gIGQzLnhtbCA9IGQzX3hoclR5cGUoZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHJldHVybiByZXF1ZXN0LnJlc3BvbnNlWE1MO1xuICB9KTtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB0aGlzLmQzID0gZDMsIGRlZmluZShkMyk7IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gZDM7IGVsc2UgdGhpcy5kMyA9IGQzO1xufSgpOyIsIi8qKlxuICoganF1ZXJ5LWNpcmNsZS1wcm9ncmVzcyAtIGpRdWVyeSBQbHVnaW4gdG8gZHJhdyBhbmltYXRlZCBjaXJjdWxhciBwcm9ncmVzcyBiYXJzOlxuICoge0BsaW5rIGh0dHA6Ly9rb3R0ZW5hdG9yLmdpdGh1Yi5pby9qcXVlcnktY2lyY2xlLXByb2dyZXNzL31cbiAqXG4gKiBAYXV0aG9yIFJvc3R5c2xhdiBCcnl6Z3Vub3YgPGtvdHRlbmF0b3JAZ21haWwuY29tPlxuICogQHZlcnNpb24gMS4yLjJcbiAqIEBsaWNlbmNlIE1JVFxuICogQHByZXNlcnZlXG4gKi9cbi8vIFVNRCBmYWN0b3J5IC0gaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL2QzMWJiNmVlNzA5ODcxNWUwMTlmNTJiZGZlMjdiM2U0YmZkMmI5N2UvdGVtcGxhdGVzL2pxdWVyeVBsdWdpbi5qc1xuLy8gVXNlcyBBTUQsIENvbW1vbkpTIG9yIGJyb3dzZXIgZ2xvYmFscyB0byBjcmVhdGUgYSBqUXVlcnkgcGx1Z2luLlxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRCAtIHJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGVcbiAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAvLyBOb2RlL0NvbW1vbkpTXG4gICAgdmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbiAgICBmYWN0b3J5KCQpO1xuICAgIG1vZHVsZS5leHBvcnRzID0gJDtcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICBmYWN0b3J5KGpRdWVyeSk7XG4gIH1cbn0pKGZ1bmN0aW9uKCQpIHtcbiAgLyoqXG4gICAqIElubmVyIGltcGxlbWVudGF0aW9uIG9mIHRoZSBjaXJjbGUgcHJvZ3Jlc3MgYmFyLlxuICAgKiBUaGUgY2xhc3MgaXMgbm90IGV4cG9zZWQgX3lldF8gYnV0IHlvdSBjYW4gY3JlYXRlIGFuIGluc3RhbmNlIHRocm91Z2ggalF1ZXJ5IG1ldGhvZCBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIC0gWW91IGNhbiBjdXN0b21pemUgYW55IGNsYXNzIG1lbWJlciAocHJvcGVydHkgb3IgbWV0aG9kKS5cbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBDaXJjbGVQcm9ncmVzc1xuICAgKi9cbiAgZnVuY3Rpb24gQ2lyY2xlUHJvZ3Jlc3MoY29uZmlnKSB7XG4gICAgdGhpcy5pbml0KGNvbmZpZyk7XG4gIH1cblxuICBDaXJjbGVQcm9ncmVzcy5wcm90b3R5cGUgPSB7XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gcHVibGljIG9wdGlvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgb25seSByZXF1aXJlZCBvcHRpb24uIEl0IHNob3VsZCBiZSBmcm9tIGAwLjBgIHRvIGAxLjBgLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4wXG4gICAgICovXG4gICAgdmFsdWU6IDAuMCxcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2YgdGhlIGNhbnZhcyBpbiBwaXhlbHMuXG4gICAgICogSXQncyBhIHNxdWFyZSBzbyB3ZSBuZWVkIG9ubHkgb25lIGRpbWVuc2lvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDEwMC4wXG4gICAgICovXG4gICAgc2l6ZTogMTAwLjAsXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsIGFuZ2xlIGZvciBgMC4wYCB2YWx1ZSBpbiByYWRpYW5zLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLU1hdGguUElcbiAgICAgKi9cbiAgICBzdGFydEFuZ2xlOiAtTWF0aC5QSSxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIHRoZSBhcmMgaW4gcGl4ZWxzLlxuICAgICAqIElmIGl0J3MgYCdhdXRvJ2AgLSB0aGUgdmFsdWUgaXMgY2FsY3VsYXRlZCBhcyBgW3RoaXMuc2l6ZV17QGxpbmsgQ2lyY2xlUHJvZ3Jlc3Mjc2l6ZX0gLyAxNGAuXG4gICAgICogQHR5cGUge251bWJlcnxzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ2F1dG8nXG4gICAgICovXG4gICAgdGhpY2tuZXNzOiAnYXV0bycsXG5cbiAgICAvKipcbiAgICAgKiBGaWxsIG9mIHRoZSBhcmMuIFlvdSBtYXkgc2V0IGl0IHRvOlxuICAgICAqXG4gICAgICogICAtIHNvbGlkIGNvbG9yOlxuICAgICAqICAgICAtIGAnIzNhZWFiYidgXG4gICAgICogICAgIC0gYHsgY29sb3I6ICcjM2FlYWJiJyB9YFxuICAgICAqICAgICAtIGB7IGNvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAuMyknIH1gXG4gICAgICogICAtIGxpbmVhciBncmFkaWVudCBfKGxlZnQgdG8gcmlnaHQpXzpcbiAgICAgKiAgICAgLSBgeyBncmFkaWVudDogWycjM2FlYWJiJywgJyNmZGQyNTAnXSwgZ3JhZGllbnRBbmdsZTogTWF0aC5QSSAvIDQgfWBcbiAgICAgKiAgICAgLSBgeyBncmFkaWVudDogWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddLCBncmFkaWVudERpcmVjdGlvbjogW3gwLCB5MCwgeDEsIHkxXSB9YFxuICAgICAqICAgICAtIGB7IGdyYWRpZW50OiBbW1wicmVkXCIsIC4yXSwgW1wiZ3JlZW5cIiwgLjNdLCBbXCJibHVlXCIsIC44XV0gfWBcbiAgICAgKiAgIC0gaW1hZ2U6XG4gICAgICogICAgIC0gYHsgaW1hZ2U6ICdodHRwOi8vaS5pbWd1ci5jb20vcFQwaTg5di5wbmcnIH1gXG4gICAgICogICAgIC0gYHsgaW1hZ2U6IGltYWdlT2JqZWN0IH1gXG4gICAgICogICAgIC0gYHsgY29sb3I6ICdsaW1lJywgaW1hZ2U6ICdodHRwOi8vaS5pbWd1ci5jb20vcFQwaTg5di5wbmcnIH1gIC1cbiAgICAgKiAgICAgICBjb2xvciBkaXNwbGF5ZWQgdW50aWwgdGhlIGltYWdlIGlzIGxvYWRlZFxuICAgICAqXG4gICAgICogQGRlZmF1bHQge2dyYWRpZW50OiBbJyMzYWVhYmInLCAnI2ZkZDI1MCddfVxuICAgICAqL1xuICAgIGZpbGw6IHtcbiAgICAgIGdyYWRpZW50OiBbJyMzYWVhYmInLCAnI2ZkZDI1MCddXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHRoZSBcImVtcHR5XCIgYXJjLiBPbmx5IGEgY29sb3IgZmlsbCBzdXBwb3J0ZWQgYnkgbm93LlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ3JnYmEoMCwgMCwgMCwgLjEpJ1xuICAgICAqL1xuICAgIGVtcHR5RmlsbDogJ3JnYmEoMCwgMCwgMCwgLjEpJyxcblxuICAgIC8qKlxuICAgICAqIGpRdWVyeSBBbmltYXRpb24gY29uZmlnLlxuICAgICAqIFlvdSBjYW4gcGFzcyBgZmFsc2VgIHRvIGRpc2FibGUgdGhlIGFuaW1hdGlvbi5cbiAgICAgKiBAc2VlIGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9hbmltYXRlL1xuICAgICAqIEB0eXBlIHtvYmplY3R8Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB7ZHVyYXRpb246IDEyMDAsIGVhc2luZzogJ2NpcmNsZVByb2dyZXNzRWFzaW5nJ31cbiAgICAgKi9cbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiAxMjAwLFxuICAgICAgZWFzaW5nOiAnY2lyY2xlUHJvZ3Jlc3NFYXNpbmcnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgYW5pbWF0aW9uIHN0YXJ0cyBhdCBgMC4wYCBhbmQgZW5kcyBhdCBzcGVjaWZpZWQgYHZhbHVlYC4gTGV0J3MgY2FsbCB0aGlzIF9kaXJlY3QgYW5pbWF0aW9uXy5cbiAgICAgKiBJZiB5b3Ugd2FudCB0byBtYWtlIF9yZXZlcnNlZCBhbmltYXRpb25fIC0gc2V0IGBhbmltYXRpb25TdGFydFZhbHVlOiAxLjBgLlxuICAgICAqIEFsc28geW91IG1heSBzcGVjaWZ5IGFueSBvdGhlciB2YWx1ZSBmcm9tIGAwLjBgIHRvIGAxLjBgLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4wXG4gICAgICovXG4gICAgYW5pbWF0aW9uU3RhcnRWYWx1ZTogMC4wLFxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZSBhbmltYXRpb24gYW5kIGFyYyBkcmF3LlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBhcmMgaXMgZmlsbGVkIGZyb20gYDAuMGAgdG8gYHZhbHVlYCwgX2Nsb2Nrd2lzZV8uXG4gICAgICogV2l0aCBgcmV2ZXJzZTogdHJ1ZWAgdGhlIGFyYyBpcyBmaWxsZWQgZnJvbSBgMS4wYCB0byBgdmFsdWVgLCBfY291bnRlci1jbG9ja3dpc2VfLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgcmV2ZXJzZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBBcmMgbGluZSBjYXA6IGAnYnV0dCdgLCBgJ3JvdW5kJ2Agb3IgYCdzcXVhcmUnYCAtXG4gICAgICogW3JlYWQgbW9yZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5saW5lQ2FwfS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdidXR0J1xuICAgICAqL1xuICAgIGxpbmVDYXA6ICdidXR0JyxcblxuICAgIC8qKlxuICAgICAqIENhbnZhcyBpbnNlcnRpb24gbW9kZTogYXBwZW5kIG9yIHByZXBlbmQgaXQgaW50byB0aGUgcGFyZW50IGVsZW1lbnQ/XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAncHJlcGVuZCdcbiAgICAgKi9cbiAgICBpbnNlcnRNb2RlOiAncHJlcGVuZCcsXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBwcm90ZWN0ZWQgcHJvcGVydGllcyBhbmQgbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKipcbiAgICAgKiBMaW5rIHRvIHtAbGluayBDaXJjbGVQcm9ncmVzc30gY29uc3RydWN0b3IuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yOiBDaXJjbGVQcm9ncmVzcyxcblxuICAgIC8qKlxuICAgICAqIENvbnRhaW5lciBlbGVtZW50LiBTaG91bGQgYmUgcGFzc2VkIGludG8gY29uc3RydWN0b3IgY29uZmlnLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7alF1ZXJ5fVxuICAgICAqL1xuICAgIGVsOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ2FudmFzIGVsZW1lbnQuIEF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGFuZCBwcmVwZW5kZWQgdG8gW3RoaXMuZWxde0BsaW5rIENpcmNsZVByb2dyZXNzI2VsfS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIGNhbnZhczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIDJELWNvbnRleHQgb2YgW3RoaXMuY2FudmFzXXtAbGluayBDaXJjbGVQcm9ncmVzcyNjYW52YXN9LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIGN0eDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFJhZGl1cyBvZiB0aGUgb3V0ZXIgY2lyY2xlLiBBdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgYXMgYFt0aGlzLnNpemVde0BsaW5rIENpcmNsZVByb2dyZXNzI3NpemV9IC8gMmAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgcmFkaXVzOiAwLjAsXG5cbiAgICAvKipcbiAgICAgKiBGaWxsIG9mIHRoZSBtYWluIGFyYy4gQXV0b21hdGljYWxseSBjYWxjdWxhdGVkLCBkZXBlbmRpbmcgb24gW3RoaXMuZmlsbF17QGxpbmsgQ2lyY2xlUHJvZ3Jlc3MjZmlsbH0gb3B0aW9uLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfENhbnZhc0dyYWRpZW50fENhbnZhc1BhdHRlcm59XG4gICAgICovXG4gICAgYXJjRmlsbDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIExhc3QgcmVuZGVyZWQgZnJhbWUgdmFsdWUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGFzdEZyYW1lVmFsdWU6IDAuMCxcblxuICAgIC8qKlxuICAgICAqIEluaXQvcmUtaW5pdCB0aGUgd2lkZ2V0LlxuICAgICAqXG4gICAgICogVGhyb3dzIGEgalF1ZXJ5IGV2ZW50OlxuICAgICAqXG4gICAgICogLSBgY2lyY2xlLWluaXRlZChqcUV2ZW50KWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSBZb3UgY2FuIGN1c3RvbWl6ZSBhbnkgY2xhc3MgbWVtYmVyIChwcm9wZXJ0eSBvciBtZXRob2QpLlxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgJC5leHRlbmQodGhpcywgY29uZmlnKTtcbiAgICAgIHRoaXMucmFkaXVzID0gdGhpcy5zaXplIC8gMjtcbiAgICAgIHRoaXMuaW5pdFdpZGdldCgpO1xuICAgICAgdGhpcy5pbml0RmlsbCgpO1xuICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICB0aGlzLmVsLnRyaWdnZXIoJ2NpcmNsZS1pbml0ZWQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBgPGNhbnZhcz5gLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbml0V2lkZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpXG4gICAgICAgIHRoaXMuY2FudmFzID0gJCgnPGNhbnZhcz4nKVt0aGlzLmluc2VydE1vZGUgPT0gJ3ByZXBlbmQnID8gJ3ByZXBlbmRUbycgOiAnYXBwZW5kVG8nXSh0aGlzLmVsKVswXTtcblxuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5zaXplO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuc2l6ZTtcbiAgICAgIHRoaXMuY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDEpIHtcbiAgICAgICAgdmFyIHNjYWxlQnkgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gY2FudmFzLnN0eWxlLmhlaWdodCA9IHRoaXMuc2l6ZSArICdweCc7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSB0aGlzLnNpemUgKiBzY2FsZUJ5O1xuICAgICAgICB0aGlzLmN0eC5zY2FsZShzY2FsZUJ5LCBzY2FsZUJ5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2V0cyBbdGhpcy5hcmNGaWxsXXtAbGluayBDaXJjbGVQcm9ncmVzcyNhcmNGaWxsfS5cbiAgICAgKiBJdCBjb3VsZCBkbyB0aGlzIGFzeW5jIChvbiBpbWFnZSBsb2FkKS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW5pdEZpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBmaWxsID0gdGhpcy5maWxsLFxuICAgICAgICBjdHggPSB0aGlzLmN0eCxcbiAgICAgICAgc2l6ZSA9IHRoaXMuc2l6ZTtcblxuICAgICAgaWYgKCFmaWxsKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBmaWxsIGlzIG5vdCBzcGVjaWZpZWQhXCIpO1xuXG4gICAgICBpZiAodHlwZW9mIGZpbGwgPT0gJ3N0cmluZycpXG4gICAgICAgIGZpbGwgPSB7Y29sb3I6IGZpbGx9O1xuXG4gICAgICBpZiAoZmlsbC5jb2xvcilcbiAgICAgICAgdGhpcy5hcmNGaWxsID0gZmlsbC5jb2xvcjtcblxuICAgICAgaWYgKGZpbGwuZ3JhZGllbnQpIHtcbiAgICAgICAgdmFyIGdyID0gZmlsbC5ncmFkaWVudDtcblxuICAgICAgICBpZiAoZ3IubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICB0aGlzLmFyY0ZpbGwgPSBnclswXTtcbiAgICAgICAgfSBlbHNlIGlmIChnci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdmFyIGdhID0gZmlsbC5ncmFkaWVudEFuZ2xlIHx8IDAsIC8vIGdyYWRpZW50IGRpcmVjdGlvbiBhbmdsZTsgMCBieSBkZWZhdWx0XG4gICAgICAgICAgICBnZCA9IGZpbGwuZ3JhZGllbnREaXJlY3Rpb24gfHwgW1xuICAgICAgICAgICAgICAgIHNpemUgLyAyICogKDEgLSBNYXRoLmNvcyhnYSkpLCAvLyB4MFxuICAgICAgICAgICAgICAgIHNpemUgLyAyICogKDEgKyBNYXRoLnNpbihnYSkpLCAvLyB5MFxuICAgICAgICAgICAgICAgIHNpemUgLyAyICogKDEgKyBNYXRoLmNvcyhnYSkpLCAvLyB4MVxuICAgICAgICAgICAgICAgIHNpemUgLyAyICogKDEgLSBNYXRoLnNpbihnYSkpICAvLyB5MVxuICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgdmFyIGxnID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50LmFwcGx5KGN0eCwgZ2QpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gZ3JbaV0sXG4gICAgICAgICAgICAgIHBvcyA9IGkgLyAoZ3IubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgICAgIGlmICgkLmlzQXJyYXkoY29sb3IpKSB7XG4gICAgICAgICAgICAgIHBvcyA9IGNvbG9yWzFdO1xuICAgICAgICAgICAgICBjb2xvciA9IGNvbG9yWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZy5hZGRDb2xvclN0b3AocG9zLCBjb2xvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5hcmNGaWxsID0gbGc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGwuaW1hZ2UpIHtcbiAgICAgICAgdmFyIGltZztcblxuICAgICAgICBpZiAoZmlsbC5pbWFnZSBpbnN0YW5jZW9mIEltYWdlKSB7XG4gICAgICAgICAgaW1nID0gZmlsbC5pbWFnZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICBpbWcuc3JjID0gZmlsbC5pbWFnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbWcuY29tcGxldGUpXG4gICAgICAgICAgc2V0SW1hZ2VGaWxsKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpbWcub25sb2FkID0gc2V0SW1hZ2VGaWxsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXRJbWFnZUZpbGwoKSB7XG4gICAgICAgIHZhciBiZyA9ICQoJzxjYW52YXM+JylbMF07XG4gICAgICAgIGJnLndpZHRoID0gc2VsZi5zaXplO1xuICAgICAgICBiZy5oZWlnaHQgPSBzZWxmLnNpemU7XG4gICAgICAgIGJnLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGltZywgMCwgMCwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgIHNlbGYuYXJjRmlsbCA9IHNlbGYuY3R4LmNyZWF0ZVBhdHRlcm4oYmcsICduby1yZXBlYXQnKTtcbiAgICAgICAgc2VsZi5kcmF3RnJhbWUoc2VsZi5sYXN0RnJhbWVWYWx1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhlIGNpcmNsZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5hbmltYXRpb24pXG4gICAgICAgIHRoaXMuZHJhd0FuaW1hdGVkKHRoaXMudmFsdWUpO1xuICAgICAgZWxzZVxuICAgICAgICB0aGlzLmRyYXdGcmFtZSh0aGlzLnZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhdyBhIHNpbmdsZSBhbmltYXRpb24gZnJhbWUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2IC0gRnJhbWUgdmFsdWUuXG4gICAgICovXG4gICAgZHJhd0ZyYW1lOiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLmxhc3RGcmFtZVZhbHVlID0gdjtcbiAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLnNpemUsIHRoaXMuc2l6ZSk7XG4gICAgICB0aGlzLmRyYXdFbXB0eUFyYyh2KTtcbiAgICAgIHRoaXMuZHJhd0FyYyh2KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhdyB0aGUgYXJjIChwYXJ0IG9mIHRoZSBjaXJjbGUpLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdiAtIEZyYW1lIHZhbHVlLlxuICAgICAqL1xuICAgIGRyYXdBcmM6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICh2ID09PSAwKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eCxcbiAgICAgICAgciA9IHRoaXMucmFkaXVzLFxuICAgICAgICB0ID0gdGhpcy5nZXRUaGlja25lc3MoKSxcbiAgICAgICAgYSA9IHRoaXMuc3RhcnRBbmdsZTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgaWYgKCF0aGlzLnJldmVyc2UpIHtcbiAgICAgICAgY3R4LmFyYyhyLCByLCByIC0gdCAvIDIsIGEsIGEgKyBNYXRoLlBJICogMiAqIHYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmFyYyhyLCByLCByIC0gdCAvIDIsIGEgLSBNYXRoLlBJICogMiAqIHYsIGEpO1xuICAgICAgfVxuXG4gICAgICBjdHgubGluZVdpZHRoID0gdDtcbiAgICAgIGN0eC5saW5lQ2FwID0gdGhpcy5saW5lQ2FwO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5hcmNGaWxsO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhdyB0aGUgX2VtcHR5IChiYWNrZ3JvdW5kKV8gYXJjIChwYXJ0IG9mIHRoZSBjaXJjbGUpLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdiAtIEZyYW1lIHZhbHVlLlxuICAgICAqL1xuICAgIGRyYXdFbXB0eUFyYzogZnVuY3Rpb24odikge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4LFxuICAgICAgICByID0gdGhpcy5yYWRpdXMsXG4gICAgICAgIHQgPSB0aGlzLmdldFRoaWNrbmVzcygpLFxuICAgICAgICBhID0gdGhpcy5zdGFydEFuZ2xlO1xuXG4gICAgICBpZiAodiA8IDEpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGlmICh2IDw9IDApIHtcbiAgICAgICAgICBjdHguYXJjKHIsIHIsIHIgLSB0IC8gMiwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGhpcy5yZXZlcnNlKSB7XG4gICAgICAgICAgICBjdHguYXJjKHIsIHIsIHIgLSB0IC8gMiwgYSArIE1hdGguUEkgKiAyICogdiwgYSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5hcmMociwgciwgciAtIHQgLyAyLCBhLCBhIC0gTWF0aC5QSSAqIDIgKiB2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHgubGluZVdpZHRoID0gdDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5lbXB0eUZpbGw7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZSB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgICAqXG4gICAgICogVGhyb3dzIDMgalF1ZXJ5IGV2ZW50czpcbiAgICAgKlxuICAgICAqIC0gYGNpcmNsZS1hbmltYXRpb24tc3RhcnQoanFFdmVudClgXG4gICAgICogLSBgY2lyY2xlLWFuaW1hdGlvbi1wcm9ncmVzcyhqcUV2ZW50LCBhbmltYXRpb25Qcm9ncmVzcywgc3RlcFZhbHVlKWAgLSBtdWx0aXBsZSBldmVudFxuICAgICAqICAgYW5pbWF0aW9uUHJvZ3Jlc3M6IGZyb20gYDAuMGAgdG8gYDEuMGA7IHN0ZXBWYWx1ZTogZnJvbSBgMC4wYCB0byBgdmFsdWVgXG4gICAgICogLSBgY2lyY2xlLWFuaW1hdGlvbi1lbmQoanFFdmVudClgXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHYgLSBGaW5hbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBkcmF3QW5pbWF0ZWQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgZWwgPSB0aGlzLmVsLFxuICAgICAgICBjYW52YXMgPSAkKHRoaXMuY2FudmFzKTtcblxuICAgICAgLy8gc3RvcCBwcmV2aW91cyBhbmltYXRpb24gYmVmb3JlIG5ldyBcInN0YXJ0XCIgZXZlbnQgaXMgdHJpZ2dlcmVkXG4gICAgICBjYW52YXMuc3RvcCh0cnVlLCBmYWxzZSk7XG4gICAgICBlbC50cmlnZ2VyKCdjaXJjbGUtYW5pbWF0aW9uLXN0YXJ0Jyk7XG5cbiAgICAgIGNhbnZhc1xuICAgICAgICAuY3NzKHthbmltYXRpb25Qcm9ncmVzczogMH0pXG4gICAgICAgIC5hbmltYXRlKHthbmltYXRpb25Qcm9ncmVzczogMX0sICQuZXh0ZW5kKHt9LCB0aGlzLmFuaW1hdGlvbiwge1xuICAgICAgICAgIHN0ZXA6IGZ1bmN0aW9uKGFuaW1hdGlvblByb2dyZXNzKSB7XG4gICAgICAgICAgICB2YXIgc3RlcFZhbHVlID0gc2VsZi5hbmltYXRpb25TdGFydFZhbHVlICogKDEgLSBhbmltYXRpb25Qcm9ncmVzcykgKyB2ICogYW5pbWF0aW9uUHJvZ3Jlc3M7XG4gICAgICAgICAgICBzZWxmLmRyYXdGcmFtZShzdGVwVmFsdWUpO1xuICAgICAgICAgICAgZWwudHJpZ2dlcignY2lyY2xlLWFuaW1hdGlvbi1wcm9ncmVzcycsIFthbmltYXRpb25Qcm9ncmVzcywgc3RlcFZhbHVlXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSlcbiAgICAgICAgLnByb21pc2UoKVxuICAgICAgICAuYWx3YXlzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIHRyaWdnZXIgb24gYm90aCBzdWNjZXNzZnVsICYgZmFpbHVyZSBhbmltYXRpb24gZW5kXG4gICAgICAgICAgZWwudHJpZ2dlcignY2lyY2xlLWFuaW1hdGlvbi1lbmQnKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2lyY2xlIHRoaWNrbmVzcy5cbiAgICAgKiBAc2VlIENpcmNsZVByb2dyZXNzI3RoaWNrbmVzc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFRoaWNrbmVzczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJC5pc051bWVyaWModGhpcy50aGlja25lc3MpID8gdGhpcy50aGlja25lc3MgOiB0aGlzLnNpemUgLyAxNDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgdmFsdWUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGN1cnJlbnQgdmFsdWUgKHdpdGggc21vb3RoIGFuaW1hdGlvbiB0cmFuc2l0aW9uKS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1ZhbHVlXG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5hbmltYXRpb24pXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhcnRWYWx1ZSA9IHRoaXMubGFzdEZyYW1lVmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLmRyYXcoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBJbml0aWF0aW5nIGpRdWVyeSBwbHVnaW4gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgJC5jaXJjbGVQcm9ncmVzcyA9IHtcbiAgICAvLyBEZWZhdWx0IG9wdGlvbnMgKHlvdSBtYXkgb3ZlcnJpZGUgdGhlbSlcbiAgICBkZWZhdWx0czogQ2lyY2xlUHJvZ3Jlc3MucHJvdG90eXBlXG4gIH07XG5cbiAgLy8gZWFzZS1pbi1vdXQtY3ViaWNcbiAgJC5lYXNpbmcuY2lyY2xlUHJvZ3Jlc3NFYXNpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPCAwLjUpIHtcbiAgICAgIHggPSAyICogeDtcbiAgICAgIHJldHVybiAwLjUgKiB4ICogeCAqIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAyIC0gMiAqIHg7XG4gICAgICByZXR1cm4gMSAtIDAuNSAqIHggKiB4ICogeDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIENpcmNsZVByb2dyZXNzfS5cbiAgICogUHJvZHVjZXMgW2luaXQgZXZlbnRde0BsaW5rIENpcmNsZVByb2dyZXNzI2luaXR9IGFuZCBbYW5pbWF0aW9uIGV2ZW50c117QGxpbmsgQ2lyY2xlUHJvZ3Jlc3MjZHJhd0FuaW1hdGVkfS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjb25maWdPckNvbW1hbmRdIC0gQ29uZmlnIG9iamVjdCBvciBjb21tYW5kIG5hbWUuXG4gICAqXG4gICAqIENvbmZpZyBleGFtcGxlICh5b3UgY2FuIHNwZWNpZnkgYW55IHtAbGluayBDaXJjbGVQcm9ncmVzc30gcHJvcGVydHkpOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB7IHZhbHVlOiAwLjc1LCBzaXplOiA1MCwgYW5pbWF0aW9uOiBmYWxzZSB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBDb21tYW5kczpcbiAgICpcbiAgICogYGBganNcbiAgICogZWwuY2lyY2xlUHJvZ3Jlc3MoJ3dpZGdldCcpOyAvLyBnZXQgdGhlIDxjYW52YXM+XG4gICAqIGVsLmNpcmNsZVByb2dyZXNzKCd2YWx1ZScpOyAvLyBnZXQgdGhlIHZhbHVlXG4gICAqIGVsLmNpcmNsZVByb2dyZXNzKCd2YWx1ZScsIG5ld1ZhbHVlKTsgLy8gdXBkYXRlIHRoZSB2YWx1ZVxuICAgKiBlbC5jaXJjbGVQcm9ncmVzcygncmVkcmF3Jyk7IC8vIHJlZHJhdyB0aGUgY2lyY2xlXG4gICAqIGVsLmNpcmNsZVByb2dyZXNzKCk7IC8vIHRoZSBzYW1lIGFzICdyZWRyYXcnXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1hbmRBcmd1bWVudF0gLSBTb21lIGNvbW1hbmRzIChsaWtlIGAndmFsdWUnYCkgbWF5IHJlcXVpcmUgYW4gYXJndW1lbnQuXG4gICAqIEBzZWUgQ2lyY2xlUHJvZ3Jlc3NcbiAgICogQGFsaWFzIFwiJCguLi4pLmNpcmNsZVByb2dyZXNzXCJcbiAgICovXG4gICQuZm4uY2lyY2xlUHJvZ3Jlc3MgPSBmdW5jdGlvbihjb25maWdPckNvbW1hbmQsIGNvbW1hbmRBcmd1bWVudCkge1xuICAgIHZhciBkYXRhTmFtZSA9ICdjaXJjbGUtcHJvZ3Jlc3MnLFxuICAgICAgZmlyc3RJbnN0YW5jZSA9IHRoaXMuZGF0YShkYXRhTmFtZSk7XG5cbiAgICBpZiAoY29uZmlnT3JDb21tYW5kID09ICd3aWRnZXQnKSB7XG4gICAgICBpZiAoIWZpcnN0SW5zdGFuY2UpXG4gICAgICAgIHRocm93IEVycm9yKCdDYWxsaW5nIFwid2lkZ2V0XCIgbWV0aG9kIG9uIG5vdCBpbml0aWFsaXplZCBpbnN0YW5jZSBpcyBmb3JiaWRkZW4nKTtcbiAgICAgIHJldHVybiBmaXJzdEluc3RhbmNlLmNhbnZhcztcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnT3JDb21tYW5kID09ICd2YWx1ZScpIHtcbiAgICAgIGlmICghZmlyc3RJbnN0YW5jZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0NhbGxpbmcgXCJ2YWx1ZVwiIG1ldGhvZCBvbiBub3QgaW5pdGlhbGl6ZWQgaW5zdGFuY2UgaXMgZm9yYmlkZGVuJyk7XG4gICAgICBpZiAodHlwZW9mIGNvbW1hbmRBcmd1bWVudCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmlyc3RJbnN0YW5jZS5nZXRWYWx1ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICQodGhpcykuZGF0YShkYXRhTmFtZSkuc2V0VmFsdWUobmV3VmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVsID0gJCh0aGlzKSxcbiAgICAgICAgaW5zdGFuY2UgPSBlbC5kYXRhKGRhdGFOYW1lKSxcbiAgICAgICAgY29uZmlnID0gJC5pc1BsYWluT2JqZWN0KGNvbmZpZ09yQ29tbWFuZCkgPyBjb25maWdPckNvbW1hbmQgOiB7fTtcblxuICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlLmluaXQoY29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbml0aWFsQ29uZmlnID0gJC5leHRlbmQoe30sIGVsLmRhdGEoKSk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbENvbmZpZy5maWxsID09ICdzdHJpbmcnKVxuICAgICAgICAgIGluaXRpYWxDb25maWcuZmlsbCA9IEpTT04ucGFyc2UoaW5pdGlhbENvbmZpZy5maWxsKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsQ29uZmlnLmFuaW1hdGlvbiA9PSAnc3RyaW5nJylcbiAgICAgICAgICBpbml0aWFsQ29uZmlnLmFuaW1hdGlvbiA9IEpTT04ucGFyc2UoaW5pdGlhbENvbmZpZy5hbmltYXRpb24pO1xuICAgICAgICBjb25maWcgPSAkLmV4dGVuZChpbml0aWFsQ29uZmlnLCBjb25maWcpO1xuICAgICAgICBjb25maWcuZWwgPSBlbDtcbiAgICAgICAgaW5zdGFuY2UgPSBuZXcgQ2lyY2xlUHJvZ3Jlc3MoY29uZmlnKTtcbiAgICAgICAgZWwuZGF0YShkYXRhTmFtZSwgaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSk7XG4iLCIvKipcbiAqIGpxdWVyeS5tYXNrLmpzXG4gKiBAdmVyc2lvbjogdjEuMTQuMTVcbiAqIEBhdXRob3I6IElnb3IgRXNjb2JhclxuICpcbiAqIENyZWF0ZWQgYnkgSWdvciBFc2NvYmFyIG9uIDIwMTItMDMtMTAuIFBsZWFzZSByZXBvcnQgYW55IGJ1ZyBhdCBnaXRodWIuY29tL2lnb3Jlc2NvYmFyL2pRdWVyeS1NYXNrLVBsdWdpblxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBJZ29yIEVzY29iYXIgaHR0cDovL2lnb3Jlc2NvYmFyLmNvbVxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiBqc2hpbnQgbGF4YnJlYWs6IHRydWUgKi9cbi8qIGpzaGludCBtYXhjb21wbGV4aXR5OjE3ICovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbi8vIFVNRCAoVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uKSBwYXR0ZXJucyBmb3IgSmF2YVNjcmlwdCBtb2R1bGVzIHRoYXQgd29yayBldmVyeXdoZXJlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci90ZW1wbGF0ZXMvanF1ZXJ5UGx1Z2luLmpzXG4oZnVuY3Rpb24gKGZhY3RvcnksIGpRdWVyeSwgWmVwdG8pIHtcblxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeShqUXVlcnkgfHwgWmVwdG8pO1xuICAgIH1cblxufShmdW5jdGlvbiAoJCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBNYXNrID0gZnVuY3Rpb24gKGVsLCBtYXNrLCBvcHRpb25zKSB7XG5cbiAgICAgICAgdmFyIHAgPSB7XG4gICAgICAgICAgICBpbnZhbGlkOiBbXSxcbiAgICAgICAgICAgIGdldENhcmV0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsID0gZWwuZ2V0KDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgZFNlbCA9IGRvY3VtZW50LnNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNTZWxTdGFydCA9IGN0cmwuc2VsZWN0aW9uU3RhcnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgU3VwcG9ydFxuICAgICAgICAgICAgICAgICAgICBpZiAoZFNlbCAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCdNU0lFIDEwJykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWwgPSBkU2VsLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWwubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtcC52YWwoKS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gc2VsLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggc3VwcG9ydFxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjU2VsU3RhcnQgfHwgY1NlbFN0YXJ0ID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGNTZWxTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRDYXJldDogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmlzKCc6Zm9jdXMnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlLCBjdHJsID0gZWwuZ2V0KDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94LCBXZWJLaXQsIGV0Yy4uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybC5zZXRTZWxlY3Rpb25SYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc2V0U2VsZWN0aW9uUmFuZ2UocG9zLCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gSUVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IGN0cmwuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICAgICAub24oJ2tleWRvd24ubWFzaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuZGF0YSgnbWFzay1rZXljb2RlJywgZS5rZXlDb2RlIHx8IGUud2hpY2gpO1xuICAgICAgICAgICAgICAgICAgICBlbC5kYXRhKCdtYXNrLXByZXZpdXMtdmFsdWUnLCBlbC52YWwoKSk7XG4gICAgICAgICAgICAgICAgICAgIGVsLmRhdGEoJ21hc2stcHJldml1cy1jYXJldC1wb3MnLCBwLmdldENhcmV0KCkpO1xuICAgICAgICAgICAgICAgICAgICBwLm1hc2tEaWdpdFBvc01hcE9sZCA9IHAubWFza0RpZ2l0UG9zTWFwO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCQuak1hc2tHbG9iYWxzLnVzZUlucHV0ID8gJ2lucHV0Lm1hc2snIDogJ2tleXVwLm1hc2snLCBwLmJlaGF2aW91cilcbiAgICAgICAgICAgICAgICAub24oJ3Bhc3RlLm1hc2sgZHJvcC5tYXNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5rZXlkb3duKCkua2V5dXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignY2hhbmdlLm1hc2snLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBlbC5kYXRhKCdjaGFuZ2VkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2JsdXIubWFzaycsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gcC52YWwoKSAmJiAhZWwuZGF0YSgnY2hhbmdlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbC5kYXRhKCdjaGFuZ2VkJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLy8gaXQncyB2ZXJ5IGltcG9ydGFudCB0aGF0IHRoaXMgY2FsbGJhY2sgcmVtYWlucyBpbiB0aGlzIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aGlzZSBvbGRWYWx1ZSBpdCdzIGdvaW5nIHRvIHdvcmsgYnVnZ3lcbiAgICAgICAgICAgICAgICAub24oJ2JsdXIubWFzaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHAudmFsKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3QgYWxsIHRleHQgb24gZm9jdXNcbiAgICAgICAgICAgICAgICAub24oJ2ZvY3VzLm1hc2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zZWxlY3RPbkZvY3VzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGUudGFyZ2V0KS5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLy8gY2xlYXIgdGhlIHZhbHVlIGlmIGl0IG5vdCBjb21wbGV0ZSB0aGUgbWFza1xuICAgICAgICAgICAgICAgIC5vbignZm9jdXNvdXQubWFzaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jbGVhcklmTm90TWF0Y2ggJiYgIXJlZ2V4TWFzay50ZXN0KHAudmFsKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHAudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UmVnZXhNYXNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFza0NodW5rcyA9IFtdLCB0cmFuc2xhdGlvbiwgcGF0dGVybiwgb3B0aW9uYWwsIHJlY3Vyc2l2ZSwgb1JlY3Vyc2l2ZSwgcjtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFzay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbiA9IGpNYXNrLnRyYW5zbGF0aW9uW21hc2suY2hhckF0KGkpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRpb24pIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IHRyYW5zbGF0aW9uLnBhdHRlcm4udG9TdHJpbmcoKS5yZXBsYWNlKC8uezF9JHxeLnsxfS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbCA9IHRyYW5zbGF0aW9uLm9wdGlvbmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlID0gdHJhbnNsYXRpb24ucmVjdXJzaXZlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza0NodW5rcy5wdXNoKG1hc2suY2hhckF0KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvUmVjdXJzaXZlID0ge2RpZ2l0OiBtYXNrLmNoYXJBdChpKSwgcGF0dGVybjogcGF0dGVybn07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tDaHVua3MucHVzaCghb3B0aW9uYWwgJiYgIXJlY3Vyc2l2ZSA/IHBhdHRlcm4gOiAocGF0dGVybiArICc/JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrQ2h1bmtzLnB1c2gobWFzay5jaGFyQXQoaSkucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgciA9IG1hc2tDaHVua3Muam9pbignJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAob1JlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICByID0gci5yZXBsYWNlKG5ldyBSZWdFeHAoJygnICsgb1JlY3Vyc2l2ZS5kaWdpdCArICcoLionICsgb1JlY3Vyc2l2ZS5kaWdpdCArICcpPyknKSwgJygkMSk/JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKG9SZWN1cnNpdmUuZGlnaXQsICdnJyksIG9SZWN1cnNpdmUucGF0dGVybik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveUV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZWwub2ZmKFsnaW5wdXQnLCAna2V5ZG93bicsICdrZXl1cCcsICdwYXN0ZScsICdkcm9wJywgJ2JsdXInLCAnZm9jdXNvdXQnLCAnJ10uam9pbignLm1hc2sgJykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIHZhciBpc0lucHV0ID0gZWwuaXMoJ2lucHV0JyksXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IGlzSW5wdXQgPyAndmFsJyA6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgcjtcblxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxbbWV0aG9kXSgpICE9PSB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbFttZXRob2RdKHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHIgPSBlbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByID0gZWxbbWV0aG9kXSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGN1bGF0ZUNhcmV0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYWwgPSBlbC5kYXRhKCdtYXNrLXByZXZpdXMtdmFsdWUnKSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsID0gcC5nZXRNYXNrZWQoKSxcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NOZXcgPSBwLmdldENhcmV0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFZhbCAhPT0gbmV3VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXJldFBvc09sZCA9IGVsLmRhdGEoJ21hc2stcHJldml1cy1jYXJldC1wb3MnKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsTCA9IG5ld1ZhbC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWxMID0gb2xkVmFsLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tEaWdpdHNCZWZvcmVDYXJldCA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrRGlnaXRzQWZ0ZXJDYXJldCA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrRGlnaXRzQmVmb3JlQ2FyZXRBbGwgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFza0RpZ2l0c0JlZm9yZUNhcmV0QWxsT2xkID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGNhcmV0UG9zTmV3OyBpIDwgbmV3VmFsTDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXAubWFza0RpZ2l0UG9zTWFwW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrRGlnaXRzQWZ0ZXJDYXJldCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gY2FyZXRQb3NOZXcgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwLm1hc2tEaWdpdFBvc01hcFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFza0RpZ2l0c0JlZm9yZUNhcmV0Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBjYXJldFBvc05ldyAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5tYXNrRGlnaXRQb3NNYXBbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrRGlnaXRzQmVmb3JlQ2FyZXRBbGwrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGNhcmV0UG9zT2xkIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLm1hc2tEaWdpdFBvc01hcE9sZFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tEaWdpdHNCZWZvcmVDYXJldEFsbE9sZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgZW5kIGtlZXAgaXQgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcmV0UG9zTmV3ID4gb2xkVmFsTCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zTmV3ID0gbmV3VmFsTCAqIDEwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNhcmV0UG9zT2xkID49IGNhcmV0UG9zTmV3ICYmIGNhcmV0UG9zT2xkICE9PSBvbGRWYWxMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXAubWFza0RpZ2l0UG9zTWFwT2xkW2NhcmV0UG9zTmV3XSkgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhcmV0UG9zID0gY2FyZXRQb3NOZXc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zTmV3IC09IG1hc2tEaWdpdHNCZWZvcmVDYXJldEFsbE9sZCAtIG1hc2tEaWdpdHNCZWZvcmVDYXJldEFsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NOZXcgLT0gbWFza0RpZ2l0c0JlZm9yZUNhcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5tYXNrRGlnaXRQb3NNYXBbY2FyZXRQb3NOZXddKSAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zTmV3ID0gY2FyZXRQb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjYXJldFBvc05ldyA+IGNhcmV0UG9zT2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc05ldyArPSBtYXNrRGlnaXRzQmVmb3JlQ2FyZXRBbGwgLSBtYXNrRGlnaXRzQmVmb3JlQ2FyZXRBbGxPbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc05ldyArPSBtYXNrRGlnaXRzQWZ0ZXJDYXJldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FyZXRQb3NOZXc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmVoYXZpb3VyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuICAgICAgICAgICAgICAgIHAuaW52YWxpZCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGtleUNvZGUgPSBlbC5kYXRhKCdtYXNrLWtleWNvZGUnKTtcblxuICAgICAgICAgICAgICAgIGlmICgkLmluQXJyYXkoa2V5Q29kZSwgak1hc2suYnlQYXNzS2V5cykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWwgPSBwLmdldE1hc2tlZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3MgPSBwLmdldENhcmV0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGNvbXBlbnNhdGlvbiB0byBkZXZpY2VzL2Jyb3dzZXJzIHRoYXQgZG9uJ3QgY29tcGVuc2F0ZVxuICAgICAgICAgICAgICAgICAgICAvLyBjYXJldCBwb3NpdGlvbmluZyB0aGUgcmlnaHQgd2F5XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcC5zZXRDYXJldChwLmNhbGN1bGF0ZUNhcmV0UG9zaXRpb24oKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sICQuak1hc2tHbG9iYWxzLmtleVN0cm9rZUNvbXBlbnNhdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgcC52YWwobmV3VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgcC5zZXRDYXJldChjYXJldFBvcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwLmNhbGxiYWNrcyhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0TWFza2VkOiBmdW5jdGlvbihza2lwTWFza0NoYXJzLCB2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmID0gW10sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsID09PSB1bmRlZmluZWQgPyBwLnZhbCgpIDogdmFsICsgJycsXG4gICAgICAgICAgICAgICAgICAgIG0gPSAwLCBtYXNrTGVuID0gbWFzay5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIHYgPSAwLCB2YWxMZW4gPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDEsIGFkZE1ldGhvZCA9ICdwdXNoJyxcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRQb3MgPSAtMSxcbiAgICAgICAgICAgICAgICAgICAgbWFza0RpZ2l0Q291bnQgPSAwLFxuICAgICAgICAgICAgICAgICAgICBtYXNrRGlnaXRQb3NBcnIgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdE1hc2tDaGFyLFxuICAgICAgICAgICAgICAgICAgICBjaGVjaztcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkTWV0aG9kID0gJ3Vuc2hpZnQnO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdE1hc2tDaGFyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbSA9IG1hc2tMZW4gLSAxO1xuICAgICAgICAgICAgICAgICAgICB2ID0gdmFsTGVuIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbSA+IC0xICYmIHYgPiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXN0TWFza0NoYXIgPSBtYXNrTGVuIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbSA8IG1hc2tMZW4gJiYgdiA8IHZhbExlbjtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbGFzdFVudHJhbnNsYXRlZE1hc2tDaGFyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjaGVjaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXNrRGlnaXQgPSBtYXNrLmNoYXJBdChtKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbERpZ2l0ID0gdmFsdWUuY2hhckF0KHYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb24gPSBqTWFzay50cmFuc2xhdGlvblttYXNrRGlnaXRdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbERpZ2l0Lm1hdGNoKHRyYW5zbGF0aW9uLnBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmW2FkZE1ldGhvZF0odmFsRGlnaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRpb24ucmVjdXJzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNldFBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0UG9zID0gbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtID09PSBsYXN0TWFza0NoYXIgJiYgbSAhPT0gcmVzZXRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSByZXNldFBvcyAtIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0TWFza0NoYXIgPT09IHJlc2V0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtIC09IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsRGlnaXQgPT09IGxhc3RVbnRyYW5zbGF0ZWRNYXNrQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoZWQgdGhlIGxhc3QgdW50cmFuc2xhdGVkIChyYXcpIG1hc2sgY2hhcmFjdGVyIHRoYXQgd2UgZW5jb3VudGVyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsaWtlbHkgYW4gaW5zZXJ0IG9mZnNldCB0aGUgbWFzayBjaGFyYWN0ZXIgZnJvbSB0aGUgbGFzdCBlbnRyeTsgZmFsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRocm91Z2ggYW5kIG9ubHkgaW5jcmVtZW50IHZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrRGlnaXRDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RVbnRyYW5zbGF0ZWRNYXNrQ2hhciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHJhbnNsYXRpb24ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2IC09IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHJhbnNsYXRpb24uZmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZbYWRkTWV0aG9kXSh0cmFuc2xhdGlvbi5mYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbSArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiAtPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwLmludmFsaWQucHVzaCh7cDogdiwgdjogdmFsRGlnaXQsIGU6IHRyYW5zbGF0aW9uLnBhdHRlcm59KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHYgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFza2lwTWFza0NoYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmW2FkZE1ldGhvZF0obWFza0RpZ2l0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbERpZ2l0ID09PSBtYXNrRGlnaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrRGlnaXRQb3NBcnIucHVzaCh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFVudHJhbnNsYXRlZE1hc2tDaGFyID0gbWFza0RpZ2l0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tEaWdpdFBvc0Fyci5wdXNoKHYgKyBtYXNrRGlnaXRDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza0RpZ2l0Q291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbSArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbGFzdE1hc2tDaGFyRGlnaXQgPSBtYXNrLmNoYXJBdChsYXN0TWFza0NoYXIpO1xuICAgICAgICAgICAgICAgIGlmIChtYXNrTGVuID09PSB2YWxMZW4gKyAxICYmICFqTWFzay50cmFuc2xhdGlvbltsYXN0TWFza0NoYXJEaWdpdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmLnB1c2gobGFzdE1hc2tDaGFyRGlnaXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBuZXdWYWwgPSBidWYuam9pbignJyk7XG4gICAgICAgICAgICAgICAgcC5tYXBNYXNrZGlnaXRQb3NpdGlvbnMobmV3VmFsLCBtYXNrRGlnaXRQb3NBcnIsIHZhbExlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1ZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXBNYXNrZGlnaXRQb3NpdGlvbnM6IGZ1bmN0aW9uKG5ld1ZhbCwgbWFza0RpZ2l0UG9zQXJyLCB2YWxMZW4pIHtcbiAgICAgICAgICAgICAgdmFyIG1hc2tEaWZmID0gb3B0aW9ucy5yZXZlcnNlID8gbmV3VmFsLmxlbmd0aCAtIHZhbExlbiA6IDA7XG4gICAgICAgICAgICAgIHAubWFza0RpZ2l0UG9zTWFwID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFza0RpZ2l0UG9zQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcC5tYXNrRGlnaXRQb3NNYXBbbWFza0RpZ2l0UG9zQXJyW2ldICsgbWFza0RpZmZdID0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGxiYWNrczogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gcC52YWwoKSxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHZhbCAhPT0gb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRBcmdzID0gW3ZhbCwgZSwgZWwsIG9wdGlvbnNdLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKG5hbWUsIGNyaXRlcmlhLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNbbmFtZV0gPT09ICdmdW5jdGlvbicgJiYgY3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW25hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soJ29uQ2hhbmdlJywgY2hhbmdlZCA9PT0gdHJ1ZSwgZGVmYXVsdEFyZ3MpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCdvbktleVByZXNzJywgY2hhbmdlZCA9PT0gdHJ1ZSwgZGVmYXVsdEFyZ3MpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCdvbkNvbXBsZXRlJywgdmFsLmxlbmd0aCA9PT0gbWFzay5sZW5ndGgsIGRlZmF1bHRBcmdzKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygnb25JbnZhbGlkJywgcC5pbnZhbGlkLmxlbmd0aCA+IDAsIFt2YWwsIGUsIGVsLCBwLmludmFsaWQsIG9wdGlvbnNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBlbCA9ICQoZWwpO1xuICAgICAgICB2YXIgak1hc2sgPSB0aGlzLCBvbGRWYWx1ZSA9IHAudmFsKCksIHJlZ2V4TWFzaztcblxuICAgICAgICBtYXNrID0gdHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicgPyBtYXNrKHAudmFsKCksIHVuZGVmaW5lZCwgZWwsICBvcHRpb25zKSA6IG1hc2s7XG5cbiAgICAgICAgLy8gcHVibGljIG1ldGhvZHNcbiAgICAgICAgak1hc2subWFzayA9IG1hc2s7XG4gICAgICAgIGpNYXNrLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBqTWFzay5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjYXJldCA9IHAuZ2V0Q2FyZXQoKTtcbiAgICAgICAgICAgIGlmIChqTWFzay5vcHRpb25zLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cigncGxhY2Vob2xkZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbC5kYXRhKCdtYXNrLW1heGxlbmd0aCcpKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cignbWF4bGVuZ3RoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLmRlc3Ryb3lFdmVudHMoKTtcbiAgICAgICAgICAgIHAudmFsKGpNYXNrLmdldENsZWFuVmFsKCkpO1xuICAgICAgICAgICAgcC5zZXRDYXJldChjYXJldCk7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZ2V0IHZhbHVlIHdpdGhvdXQgbWFza1xuICAgICAgICBqTWFzay5nZXRDbGVhblZhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICByZXR1cm4gcC5nZXRNYXNrZWQodHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZ2V0IG1hc2tlZCB2YWx1ZSB3aXRob3V0IHRoZSB2YWx1ZSBiZWluZyBpbiB0aGUgaW5wdXQgb3IgZWxlbWVudFxuICAgICAgICBqTWFzay5nZXRNYXNrZWRWYWwgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgcmV0dXJuIHAuZ2V0TWFza2VkKGZhbHNlLCB2YWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgak1hc2suaW5pdCA9IGZ1bmN0aW9uKG9ubHlNYXNrKSB7XG4gICAgICAgICAgICBvbmx5TWFzayA9IG9ubHlNYXNrIHx8IGZhbHNlO1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgIGpNYXNrLmNsZWFySWZOb3RNYXRjaCAgPSAkLmpNYXNrR2xvYmFscy5jbGVhcklmTm90TWF0Y2g7XG4gICAgICAgICAgICBqTWFzay5ieVBhc3NLZXlzICAgICAgID0gJC5qTWFza0dsb2JhbHMuYnlQYXNzS2V5cztcbiAgICAgICAgICAgIGpNYXNrLnRyYW5zbGF0aW9uICAgICAgPSAkLmV4dGVuZCh7fSwgJC5qTWFza0dsb2JhbHMudHJhbnNsYXRpb24sIG9wdGlvbnMudHJhbnNsYXRpb24pO1xuXG4gICAgICAgICAgICBqTWFzayA9ICQuZXh0ZW5kKHRydWUsIHt9LCBqTWFzaywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHJlZ2V4TWFzayA9IHAuZ2V0UmVnZXhNYXNrKCk7XG5cbiAgICAgICAgICAgIGlmIChvbmx5TWFzaykge1xuICAgICAgICAgICAgICAgIHAuZXZlbnRzKCk7XG4gICAgICAgICAgICAgICAgcC52YWwocC5nZXRNYXNrZWQoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmF0dHIoJ3BsYWNlaG9sZGVyJyAsIG9wdGlvbnMucGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5LCBvdGhlcndpc2UgaWYgdGhlIHVzZXIgc3VibWl0IHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgLy8gYW5kIHRoZW4gcHJlc3MgdGhlIFwiYmFja1wiIGJ1dHRvbiwgdGhlIGF1dG9jb21wbGV0ZSB3aWxsIGVyYXNlXG4gICAgICAgICAgICAgICAgLy8gdGhlIGRhdGEuIFdvcmtzIGZpbmUgb24gSUU5KywgRkYsIE9wZXJhLCBTYWZhcmkuXG4gICAgICAgICAgICAgICAgaWYgKGVsLmRhdGEoJ21hc2snKSkge1xuICAgICAgICAgICAgICAgICAgZWwuYXR0cignYXV0b2NvbXBsZXRlJywgJ29mZicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGRldGVjdCBpZiBpcyBuZWNlc3NhcnkgbGV0IHRoZSB1c2VyIHR5cGUgZnJlZWx5LlxuICAgICAgICAgICAgICAgIC8vIGZvciBpcyBhIGxvdCBmYXN0ZXIgdGhhbiBmb3JFYWNoLlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBtYXhsZW5ndGggPSB0cnVlOyBpIDwgbWFzay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSBqTWFzay50cmFuc2xhdGlvblttYXNrLmNoYXJBdChpKV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGlvbiAmJiB0cmFuc2xhdGlvbi5yZWN1cnNpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGxlbmd0aCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobWF4bGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmF0dHIoJ21heGxlbmd0aCcsIG1hc2subGVuZ3RoKS5kYXRhKCdtYXNrLW1heGxlbmd0aCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHAuZGVzdHJveUV2ZW50cygpO1xuICAgICAgICAgICAgICAgIHAuZXZlbnRzKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FyZXQgPSBwLmdldENhcmV0KCk7XG4gICAgICAgICAgICAgICAgcC52YWwocC5nZXRNYXNrZWQoKSk7XG4gICAgICAgICAgICAgICAgcC5zZXRDYXJldChjYXJldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgak1hc2suaW5pdCghZWwuaXMoJ2lucHV0JykpO1xuICAgIH07XG5cbiAgICAkLm1hc2tXYXRjaGVycyA9IHt9O1xuICAgIHZhciBIVE1MQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gJCh0aGlzKSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fSxcbiAgICAgICAgICAgIHByZWZpeCA9ICdkYXRhLW1hc2stJyxcbiAgICAgICAgICAgIG1hc2sgPSBpbnB1dC5hdHRyKCdkYXRhLW1hc2snKTtcblxuICAgICAgICBpZiAoaW5wdXQuYXR0cihwcmVmaXggKyAncmV2ZXJzZScpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnJldmVyc2UgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0LmF0dHIocHJlZml4ICsgJ2NsZWFyaWZub3RtYXRjaCcpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNsZWFySWZOb3RNYXRjaCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXQuYXR0cihwcmVmaXggKyAnc2VsZWN0b25mb2N1cycpID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgb3B0aW9ucy5zZWxlY3RPbkZvY3VzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub3RTYW1lTWFza09iamVjdChpbnB1dCwgbWFzaywgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5kYXRhKCdtYXNrJywgbmV3IE1hc2sodGhpcywgbWFzaywgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBub3RTYW1lTWFza09iamVjdCA9IGZ1bmN0aW9uKGZpZWxkLCBtYXNrLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgbWFza09iamVjdCA9ICQoZmllbGQpLmRhdGEoJ21hc2snKSxcbiAgICAgICAgICAgIHN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5LFxuICAgICAgICAgICAgdmFsdWUgPSAkKGZpZWxkKS52YWwoKSB8fCAkKGZpZWxkKS50ZXh0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBtYXNrID0gbWFzayh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIG1hc2tPYmplY3QgIT09ICdvYmplY3QnIHx8IHN0cmluZ2lmeShtYXNrT2JqZWN0Lm9wdGlvbnMpICE9PSBzdHJpbmdpZnkob3B0aW9ucykgfHwgbWFza09iamVjdC5tYXNrICE9PSBtYXNrO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH0sXG4gICAgZXZlbnRTdXBwb3J0ZWQgPSBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIGlzU3VwcG9ydGVkO1xuXG4gICAgICAgIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWU7XG4gICAgICAgIGlzU3VwcG9ydGVkID0gKGV2ZW50TmFtZSBpbiBlbCk7XG5cbiAgICAgICAgaWYgKCAhaXNTdXBwb3J0ZWQgKSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgICAgICAgICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgfVxuICAgICAgICBlbCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgIH07XG5cbiAgICAkLmZuLm1hc2sgPSBmdW5jdGlvbihtYXNrLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yLFxuICAgICAgICAgICAgZ2xvYmFscyA9ICQuak1hc2tHbG9iYWxzLFxuICAgICAgICAgICAgaW50ZXJ2YWwgPSBnbG9iYWxzLndhdGNoSW50ZXJ2YWwsXG4gICAgICAgICAgICB3YXRjaElucHV0cyA9IG9wdGlvbnMud2F0Y2hJbnB1dHMgfHwgZ2xvYmFscy53YXRjaElucHV0cyxcbiAgICAgICAgICAgIG1hc2tGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChub3RTYW1lTWFza09iamVjdCh0aGlzLCBtYXNrLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5kYXRhKCdtYXNrJywgbmV3IE1hc2sodGhpcywgbWFzaywgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgJCh0aGlzKS5lYWNoKG1hc2tGdW5jdGlvbik7XG5cbiAgICAgICAgaWYgKHNlbGVjdG9yICYmIHNlbGVjdG9yICE9PSAnJyAmJiB3YXRjaElucHV0cykge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCgkLm1hc2tXYXRjaGVyc1tzZWxlY3Rvcl0pO1xuICAgICAgICAgICAgJC5tYXNrV2F0Y2hlcnNbc2VsZWN0b3JdID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5maW5kKHNlbGVjdG9yKS5lYWNoKG1hc2tGdW5jdGlvbik7XG4gICAgICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgICQuZm4ubWFza2VkID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoJ21hc2snKS5nZXRNYXNrZWRWYWwodmFsKTtcbiAgICB9O1xuXG4gICAgJC5mbi51bm1hc2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCgkLm1hc2tXYXRjaGVyc1t0aGlzLnNlbGVjdG9yXSk7XG4gICAgICAgIGRlbGV0ZSAkLm1hc2tXYXRjaGVyc1t0aGlzLnNlbGVjdG9yXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkYXRhTWFzayA9ICQodGhpcykuZGF0YSgnbWFzaycpO1xuICAgICAgICAgICAgaWYgKGRhdGFNYXNrKSB7XG4gICAgICAgICAgICAgICAgZGF0YU1hc2sucmVtb3ZlKCkucmVtb3ZlRGF0YSgnbWFzaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJC5mbi5jbGVhblZhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhKCdtYXNrJykuZ2V0Q2xlYW5WYWwoKTtcbiAgICB9O1xuXG4gICAgJC5hcHBseURhdGFNYXNrID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvciB8fCAkLmpNYXNrR2xvYmFscy5tYXNrRWxlbWVudHM7XG4gICAgICAgIHZhciAkc2VsZWN0b3IgPSAoc2VsZWN0b3IgaW5zdGFuY2VvZiAkKSA/IHNlbGVjdG9yIDogJChzZWxlY3Rvcik7XG4gICAgICAgICRzZWxlY3Rvci5maWx0ZXIoJC5qTWFza0dsb2JhbHMuZGF0YU1hc2tBdHRyKS5lYWNoKEhUTUxBdHRyaWJ1dGVzKTtcbiAgICB9O1xuXG4gICAgdmFyIGdsb2JhbHMgPSB7XG4gICAgICAgIG1hc2tFbGVtZW50czogJ2lucHV0LHRkLHNwYW4sZGl2JyxcbiAgICAgICAgZGF0YU1hc2tBdHRyOiAnKltkYXRhLW1hc2tdJyxcbiAgICAgICAgZGF0YU1hc2s6IHRydWUsXG4gICAgICAgIHdhdGNoSW50ZXJ2YWw6IDMwMCxcbiAgICAgICAgd2F0Y2hJbnB1dHM6IHRydWUsXG4gICAgICAgIGtleVN0cm9rZUNvbXBlbnNhdGlvbjogMTAsXG4gICAgICAgIC8vIG9sZCB2ZXJzaW9ucyBvZiBjaHJvbWUgZG9udCB3b3JrIGdyZWF0IHdpdGggaW5wdXQgZXZlbnRcbiAgICAgICAgdXNlSW5wdXQ6ICEvQ2hyb21lXFwvWzItNF1bMC05XXxTYW1zdW5nQnJvd3Nlci8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgZXZlbnRTdXBwb3J0ZWQoJ2lucHV0JyksXG4gICAgICAgIHdhdGNoRGF0YU1hc2s6IGZhbHNlLFxuICAgICAgICBieVBhc3NLZXlzOiBbOSwgMTYsIDE3LCAxOCwgMzYsIDM3LCAzOCwgMzksIDQwLCA5MV0sXG4gICAgICAgIHRyYW5zbGF0aW9uOiB7XG4gICAgICAgICAgICAnMCc6IHtwYXR0ZXJuOiAvXFxkL30sXG4gICAgICAgICAgICAnOSc6IHtwYXR0ZXJuOiAvXFxkLywgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICAgICAgJyMnOiB7cGF0dGVybjogL1xcZC8sIHJlY3Vyc2l2ZTogdHJ1ZX0sXG4gICAgICAgICAgICAnQSc6IHtwYXR0ZXJuOiAvW2EtekEtWjAtOV0vfSxcbiAgICAgICAgICAgICdTJzoge3BhdHRlcm46IC9bYS16QS1aXS99XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC5qTWFza0dsb2JhbHMgPSAkLmpNYXNrR2xvYmFscyB8fCB7fTtcbiAgICBnbG9iYWxzID0gJC5qTWFza0dsb2JhbHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgZ2xvYmFscywgJC5qTWFza0dsb2JhbHMpO1xuXG4gICAgLy8gbG9va2luZyBmb3IgaW5wdXRzIHdpdGggZGF0YS1tYXNrIGF0dHJpYnV0ZVxuICAgIGlmIChnbG9iYWxzLmRhdGFNYXNrKSB7XG4gICAgICAgICQuYXBwbHlEYXRhTWFzaygpO1xuICAgIH1cblxuICAgIHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoJC5qTWFza0dsb2JhbHMud2F0Y2hEYXRhTWFzaykge1xuICAgICAgICAgICAgJC5hcHBseURhdGFNYXNrKCk7XG4gICAgICAgIH1cbiAgICB9LCBnbG9iYWxzLndhdGNoSW50ZXJ2YWwpO1xufSwgd2luZG93LmpRdWVyeSwgd2luZG93LlplcHRvKSk7XG4iLCIhZnVuY3Rpb24oJCl7dmFyIGFwaVBhcmFtcz17c2V0Ontjb2xvcnM6MSx2YWx1ZXM6MSxiYWNrZ3JvdW5kQ29sb3I6MSxzY2FsZUNvbG9yczoxLG5vcm1hbGl6ZUZ1bmN0aW9uOjEsZm9jdXM6MX0sZ2V0OntzZWxlY3RlZFJlZ2lvbnM6MSxzZWxlY3RlZE1hcmtlcnM6MSxtYXBPYmplY3Q6MSxyZWdpb25OYW1lOjF9fTskLmZuLnZlY3Rvck1hcD1mdW5jdGlvbihvcHRpb25zKXt2YXIgbWFwLG1ldGhvZE5hbWUsbWFwPXRoaXMuY2hpbGRyZW4oXCIuanZlY3Rvcm1hcC1jb250YWluZXJcIikuZGF0YShcIm1hcE9iamVjdFwiKTtpZihcImFkZE1hcFwiPT09b3B0aW9ucylqdm0uTWFwLm1hcHNbYXJndW1lbnRzWzFdXT1hcmd1bWVudHNbMl07ZWxzZXtpZigoXCJzZXRcIj09PW9wdGlvbnN8fFwiZ2V0XCI9PT1vcHRpb25zKSYmYXBpUGFyYW1zW29wdGlvbnNdW2FyZ3VtZW50c1sxXV0pcmV0dXJuIG1ldGhvZE5hbWU9YXJndW1lbnRzWzFdLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2FyZ3VtZW50c1sxXS5zdWJzdHIoMSksbWFwW29wdGlvbnMrbWV0aG9kTmFtZV0uYXBwbHkobWFwLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKSk7b3B0aW9ucz1vcHRpb25zfHx7fSxvcHRpb25zLmNvbnRhaW5lcj10aGlzLG1hcD1uZXcganZtLk1hcChvcHRpb25zKX1yZXR1cm4gdGhpc319KGpRdWVyeSksZnVuY3Rpb24oZmFjdG9yeSl7XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJqcXVlcnlcIl0sZmFjdG9yeSk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZmFjdG9yeTpmYWN0b3J5KGpRdWVyeSl9KGZ1bmN0aW9uKCQpe2Z1bmN0aW9uIGhhbmRsZXIoZXZlbnQpe3ZhciBvcmdFdmVudD1ldmVudHx8d2luZG93LmV2ZW50LGFyZ3M9c2xpY2UuY2FsbChhcmd1bWVudHMsMSksZGVsdGE9MCxkZWx0YVg9MCxkZWx0YVk9MCxhYnNEZWx0YT0wO2lmKGV2ZW50PSQuZXZlbnQuZml4KG9yZ0V2ZW50KSxldmVudC50eXBlPVwibW91c2V3aGVlbFwiLFwiZGV0YWlsXCJpbiBvcmdFdmVudCYmKGRlbHRhWT0tMSpvcmdFdmVudC5kZXRhaWwpLFwid2hlZWxEZWx0YVwiaW4gb3JnRXZlbnQmJihkZWx0YVk9b3JnRXZlbnQud2hlZWxEZWx0YSksXCJ3aGVlbERlbHRhWVwiaW4gb3JnRXZlbnQmJihkZWx0YVk9b3JnRXZlbnQud2hlZWxEZWx0YVkpLFwid2hlZWxEZWx0YVhcImluIG9yZ0V2ZW50JiYoZGVsdGFYPS0xKm9yZ0V2ZW50LndoZWVsRGVsdGFYKSxcImF4aXNcImluIG9yZ0V2ZW50JiZvcmdFdmVudC5heGlzPT09b3JnRXZlbnQuSE9SSVpPTlRBTF9BWElTJiYoZGVsdGFYPS0xKmRlbHRhWSxkZWx0YVk9MCksZGVsdGE9MD09PWRlbHRhWT9kZWx0YVg6ZGVsdGFZLFwiZGVsdGFZXCJpbiBvcmdFdmVudCYmKGRlbHRhWT0tMSpvcmdFdmVudC5kZWx0YVksZGVsdGE9ZGVsdGFZKSxcImRlbHRhWFwiaW4gb3JnRXZlbnQmJihkZWx0YVg9b3JnRXZlbnQuZGVsdGFYLDA9PT1kZWx0YVkmJihkZWx0YT0tMSpkZWx0YVgpKSwwIT09ZGVsdGFZfHwwIT09ZGVsdGFYKXtpZigxPT09b3JnRXZlbnQuZGVsdGFNb2RlKXt2YXIgbGluZUhlaWdodD0kLmRhdGEodGhpcyxcIm1vdXNld2hlZWwtbGluZS1oZWlnaHRcIik7ZGVsdGEqPWxpbmVIZWlnaHQsZGVsdGFZKj1saW5lSGVpZ2h0LGRlbHRhWCo9bGluZUhlaWdodH1lbHNlIGlmKDI9PT1vcmdFdmVudC5kZWx0YU1vZGUpe3ZhciBwYWdlSGVpZ2h0PSQuZGF0YSh0aGlzLFwibW91c2V3aGVlbC1wYWdlLWhlaWdodFwiKTtkZWx0YSo9cGFnZUhlaWdodCxkZWx0YVkqPXBhZ2VIZWlnaHQsZGVsdGFYKj1wYWdlSGVpZ2h0fXJldHVybiBhYnNEZWx0YT1NYXRoLm1heChNYXRoLmFicyhkZWx0YVkpLE1hdGguYWJzKGRlbHRhWCkpLCghbG93ZXN0RGVsdGF8fGxvd2VzdERlbHRhPmFic0RlbHRhKSYmKGxvd2VzdERlbHRhPWFic0RlbHRhLHNob3VsZEFkanVzdE9sZERlbHRhcyhvcmdFdmVudCxhYnNEZWx0YSkmJihsb3dlc3REZWx0YS89NDApKSxzaG91bGRBZGp1c3RPbGREZWx0YXMob3JnRXZlbnQsYWJzRGVsdGEpJiYoZGVsdGEvPTQwLGRlbHRhWC89NDAsZGVsdGFZLz00MCksZGVsdGE9TWF0aFtkZWx0YT49MT9cImZsb29yXCI6XCJjZWlsXCJdKGRlbHRhL2xvd2VzdERlbHRhKSxkZWx0YVg9TWF0aFtkZWx0YVg+PTE/XCJmbG9vclwiOlwiY2VpbFwiXShkZWx0YVgvbG93ZXN0RGVsdGEpLGRlbHRhWT1NYXRoW2RlbHRhWT49MT9cImZsb29yXCI6XCJjZWlsXCJdKGRlbHRhWS9sb3dlc3REZWx0YSksZXZlbnQuZGVsdGFYPWRlbHRhWCxldmVudC5kZWx0YVk9ZGVsdGFZLGV2ZW50LmRlbHRhRmFjdG9yPWxvd2VzdERlbHRhLGV2ZW50LmRlbHRhTW9kZT0wLGFyZ3MudW5zaGlmdChldmVudCxkZWx0YSxkZWx0YVgsZGVsdGFZKSxudWxsTG93ZXN0RGVsdGFUaW1lb3V0JiZjbGVhclRpbWVvdXQobnVsbExvd2VzdERlbHRhVGltZW91dCksbnVsbExvd2VzdERlbHRhVGltZW91dD1zZXRUaW1lb3V0KG51bGxMb3dlc3REZWx0YSwyMDApLCgkLmV2ZW50LmRpc3BhdGNofHwkLmV2ZW50LmhhbmRsZSkuYXBwbHkodGhpcyxhcmdzKX19ZnVuY3Rpb24gbnVsbExvd2VzdERlbHRhKCl7bG93ZXN0RGVsdGE9bnVsbH1mdW5jdGlvbiBzaG91bGRBZGp1c3RPbGREZWx0YXMob3JnRXZlbnQsYWJzRGVsdGEpe3JldHVybiBzcGVjaWFsLnNldHRpbmdzLmFkanVzdE9sZERlbHRhcyYmXCJtb3VzZXdoZWVsXCI9PT1vcmdFdmVudC50eXBlJiZhYnNEZWx0YSUxMjA9PT0wfXZhciBudWxsTG93ZXN0RGVsdGFUaW1lb3V0LGxvd2VzdERlbHRhLHRvRml4PVtcIndoZWVsXCIsXCJtb3VzZXdoZWVsXCIsXCJET01Nb3VzZVNjcm9sbFwiLFwiTW96TW91c2VQaXhlbFNjcm9sbFwiXSx0b0JpbmQ9XCJvbndoZWVsXCJpbiBkb2N1bWVudHx8ZG9jdW1lbnQuZG9jdW1lbnRNb2RlPj05P1tcIndoZWVsXCJdOltcIm1vdXNld2hlZWxcIixcIkRvbU1vdXNlU2Nyb2xsXCIsXCJNb3pNb3VzZVBpeGVsU2Nyb2xsXCJdLHNsaWNlPUFycmF5LnByb3RvdHlwZS5zbGljZTtpZigkLmV2ZW50LmZpeEhvb2tzKWZvcih2YXIgaT10b0ZpeC5sZW5ndGg7aTspJC5ldmVudC5maXhIb29rc1t0b0ZpeFstLWldXT0kLmV2ZW50Lm1vdXNlSG9va3M7dmFyIHNwZWNpYWw9JC5ldmVudC5zcGVjaWFsLm1vdXNld2hlZWw9e3ZlcnNpb246XCIzLjEuOVwiLHNldHVwOmZ1bmN0aW9uKCl7aWYodGhpcy5hZGRFdmVudExpc3RlbmVyKWZvcih2YXIgaT10b0JpbmQubGVuZ3RoO2k7KXRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0b0JpbmRbLS1pXSxoYW5kbGVyLCExKTtlbHNlIHRoaXMub25tb3VzZXdoZWVsPWhhbmRsZXI7JC5kYXRhKHRoaXMsXCJtb3VzZXdoZWVsLWxpbmUtaGVpZ2h0XCIsc3BlY2lhbC5nZXRMaW5lSGVpZ2h0KHRoaXMpKSwkLmRhdGEodGhpcyxcIm1vdXNld2hlZWwtcGFnZS1oZWlnaHRcIixzcGVjaWFsLmdldFBhZ2VIZWlnaHQodGhpcykpfSx0ZWFyZG93bjpmdW5jdGlvbigpe2lmKHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcilmb3IodmFyIGk9dG9CaW5kLmxlbmd0aDtpOyl0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodG9CaW5kWy0taV0saGFuZGxlciwhMSk7ZWxzZSB0aGlzLm9ubW91c2V3aGVlbD1udWxsfSxnZXRMaW5lSGVpZ2h0OmZ1bmN0aW9uKGVsZW0pe3JldHVybiBwYXJzZUludCgkKGVsZW0pW1wib2Zmc2V0UGFyZW50XCJpbiAkLmZuP1wib2Zmc2V0UGFyZW50XCI6XCJwYXJlbnRcIl0oKS5jc3MoXCJmb250U2l6ZVwiKSwxMCl9LGdldFBhZ2VIZWlnaHQ6ZnVuY3Rpb24oZWxlbSl7cmV0dXJuICQoZWxlbSkuaGVpZ2h0KCl9LHNldHRpbmdzOnthZGp1c3RPbGREZWx0YXM6ITB9fTskLmZuLmV4dGVuZCh7bW91c2V3aGVlbDpmdW5jdGlvbihmbil7cmV0dXJuIGZuP3RoaXMuYmluZChcIm1vdXNld2hlZWxcIixmbik6dGhpcy50cmlnZ2VyKFwibW91c2V3aGVlbFwiKX0sdW5tb3VzZXdoZWVsOmZ1bmN0aW9uKGZuKXtyZXR1cm4gdGhpcy51bmJpbmQoXCJtb3VzZXdoZWVsXCIsZm4pfX0pfSk7dmFyIGp2bT17aW5oZXJpdHM6ZnVuY3Rpb24oY2hpbGQscGFyZW50KXtmdW5jdGlvbiB0ZW1wKCl7fXRlbXAucHJvdG90eXBlPXBhcmVudC5wcm90b3R5cGUsY2hpbGQucHJvdG90eXBlPW5ldyB0ZW1wLGNoaWxkLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1jaGlsZCxjaGlsZC5wYXJlbnRDbGFzcz1wYXJlbnR9LG1peGluOmZ1bmN0aW9uKHRhcmdldCxzb3VyY2Upe3ZhciBwcm9wO2Zvcihwcm9wIGluIHNvdXJjZS5wcm90b3R5cGUpc291cmNlLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSYmKHRhcmdldC5wcm90b3R5cGVbcHJvcF09c291cmNlLnByb3RvdHlwZVtwcm9wXSl9LG1pbjpmdW5jdGlvbih2YWx1ZXMpe3ZhciBpLG1pbj1OdW1iZXIuTUFYX1ZBTFVFO2lmKHZhbHVlcyBpbnN0YW5jZW9mIEFycmF5KWZvcihpPTA7aTx2YWx1ZXMubGVuZ3RoO2krKyl2YWx1ZXNbaV08bWluJiYobWluPXZhbHVlc1tpXSk7ZWxzZSBmb3IoaSBpbiB2YWx1ZXMpdmFsdWVzW2ldPG1pbiYmKG1pbj12YWx1ZXNbaV0pO3JldHVybiBtaW59LG1heDpmdW5jdGlvbih2YWx1ZXMpe3ZhciBpLG1heD1OdW1iZXIuTUlOX1ZBTFVFO2lmKHZhbHVlcyBpbnN0YW5jZW9mIEFycmF5KWZvcihpPTA7aTx2YWx1ZXMubGVuZ3RoO2krKyl2YWx1ZXNbaV0+bWF4JiYobWF4PXZhbHVlc1tpXSk7ZWxzZSBmb3IoaSBpbiB2YWx1ZXMpdmFsdWVzW2ldPm1heCYmKG1heD12YWx1ZXNbaV0pO3JldHVybiBtYXh9LGtleXM6ZnVuY3Rpb24ob2JqZWN0KXt2YXIga2V5LGtleXM9W107Zm9yKGtleSBpbiBvYmplY3Qpa2V5cy5wdXNoKGtleSk7cmV0dXJuIGtleXN9LHZhbHVlczpmdW5jdGlvbihvYmplY3Qpe3ZhciBrZXksaSx2YWx1ZXM9W107Zm9yKGk9MDtpPGFyZ3VtZW50cy5sZW5ndGg7aSsrKXtvYmplY3Q9YXJndW1lbnRzW2ldO2ZvcihrZXkgaW4gb2JqZWN0KXZhbHVlcy5wdXNoKG9iamVjdFtrZXldKX1yZXR1cm4gdmFsdWVzfSx3aGVuSW1hZ2VMb2FkZWQ6ZnVuY3Rpb24odXJsKXt2YXIgZGVmZXJyZWQ9bmV3IGp2bS4kLkRlZmVycmVkLGltZz1qdm0uJChcIjxpbWcvPlwiKTtyZXR1cm4gaW1nLmVycm9yKGZ1bmN0aW9uKCl7ZGVmZXJyZWQucmVqZWN0KCl9KS5sb2FkKGZ1bmN0aW9uKCl7ZGVmZXJyZWQucmVzb2x2ZShpbWcpfSksaW1nLmF0dHIoXCJzcmNcIix1cmwpLGRlZmVycmVkfSxpc0ltYWdlVXJsOmZ1bmN0aW9uKHMpe3JldHVybi9cXC5cXHd7Myw0fSQvLnRlc3Qocyl9fTtqdm0uJD1qUXVlcnksQXJyYXkucHJvdG90eXBlLmluZGV4T2Z8fChBcnJheS5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbihzZWFyY2hFbGVtZW50LGZyb21JbmRleCl7dmFyIGs7aWYobnVsbD09dGhpcyl0aHJvdyBuZXcgVHlwZUVycm9yKCdcInRoaXNcIiBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyk7dmFyIE89T2JqZWN0KHRoaXMpLGxlbj1PLmxlbmd0aD4+PjA7aWYoMD09PWxlbilyZXR1cm4tMTt2YXIgbj0rZnJvbUluZGV4fHwwO2lmKE1hdGguYWJzKG4pPT09MS8wJiYobj0wKSxuPj1sZW4pcmV0dXJuLTE7Zm9yKGs9TWF0aC5tYXgobj49MD9uOmxlbi1NYXRoLmFicyhuKSwwKTtsZW4+azspe2lmKGsgaW4gTyYmT1trXT09PXNlYXJjaEVsZW1lbnQpcmV0dXJuIGs7aysrfXJldHVybi0xfSksanZtLkFic3RyYWN0RWxlbWVudD1mdW5jdGlvbihuYW1lLGNvbmZpZyl7dGhpcy5ub2RlPXRoaXMuY3JlYXRlRWxlbWVudChuYW1lKSx0aGlzLm5hbWU9bmFtZSx0aGlzLnByb3BlcnRpZXM9e30sY29uZmlnJiZ0aGlzLnNldChjb25maWcpfSxqdm0uQWJzdHJhY3RFbGVtZW50LnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24ocHJvcGVydHksdmFsdWUpe3ZhciBrZXk7aWYoXCJvYmplY3RcIj09dHlwZW9mIHByb3BlcnR5KWZvcihrZXkgaW4gcHJvcGVydHkpdGhpcy5wcm9wZXJ0aWVzW2tleV09cHJvcGVydHlba2V5XSx0aGlzLmFwcGx5QXR0cihrZXkscHJvcGVydHlba2V5XSk7ZWxzZSB0aGlzLnByb3BlcnRpZXNbcHJvcGVydHldPXZhbHVlLHRoaXMuYXBwbHlBdHRyKHByb3BlcnR5LHZhbHVlKX0sanZtLkFic3RyYWN0RWxlbWVudC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHByb3BlcnR5KXtyZXR1cm4gdGhpcy5wcm9wZXJ0aWVzW3Byb3BlcnR5XX0sanZtLkFic3RyYWN0RWxlbWVudC5wcm90b3R5cGUuYXBwbHlBdHRyPWZ1bmN0aW9uKHByb3BlcnR5LHZhbHVlKXt0aGlzLm5vZGUuc2V0QXR0cmlidXRlKHByb3BlcnR5LHZhbHVlKX0sanZtLkFic3RyYWN0RWxlbWVudC5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7anZtLiQodGhpcy5ub2RlKS5yZW1vdmUoKX0sanZtLkFic3RyYWN0Q2FudmFzRWxlbWVudD1mdW5jdGlvbihjb250YWluZXIsd2lkdGgsaGVpZ2h0KXt0aGlzLmNvbnRhaW5lcj1jb250YWluZXIsdGhpcy5zZXRTaXplKHdpZHRoLGhlaWdodCksdGhpcy5yb290RWxlbWVudD1uZXcganZtW3RoaXMuY2xhc3NQcmVmaXgrXCJHcm91cEVsZW1lbnRcIl0sdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMucm9vdEVsZW1lbnQubm9kZSksdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKX0sanZtLkFic3RyYWN0Q2FudmFzRWxlbWVudC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGVsZW1lbnQsZ3JvdXApe2dyb3VwPWdyb3VwfHx0aGlzLnJvb3RFbGVtZW50LGdyb3VwLmFkZChlbGVtZW50KSxlbGVtZW50LmNhbnZhcz10aGlzfSxqdm0uQWJzdHJhY3RDYW52YXNFbGVtZW50LnByb3RvdHlwZS5hZGRQYXRoPWZ1bmN0aW9uKGNvbmZpZyxzdHlsZSxncm91cCl7dmFyIGVsPW5ldyBqdm1bdGhpcy5jbGFzc1ByZWZpeCtcIlBhdGhFbGVtZW50XCJdKGNvbmZpZyxzdHlsZSk7cmV0dXJuIHRoaXMuYWRkKGVsLGdyb3VwKSxlbH0sanZtLkFic3RyYWN0Q2FudmFzRWxlbWVudC5wcm90b3R5cGUuYWRkQ2lyY2xlPWZ1bmN0aW9uKGNvbmZpZyxzdHlsZSxncm91cCl7dmFyIGVsPW5ldyBqdm1bdGhpcy5jbGFzc1ByZWZpeCtcIkNpcmNsZUVsZW1lbnRcIl0oY29uZmlnLHN0eWxlKTtyZXR1cm4gdGhpcy5hZGQoZWwsZ3JvdXApLGVsfSxqdm0uQWJzdHJhY3RDYW52YXNFbGVtZW50LnByb3RvdHlwZS5hZGRJbWFnZT1mdW5jdGlvbihjb25maWcsc3R5bGUsZ3JvdXApe3ZhciBlbD1uZXcganZtW3RoaXMuY2xhc3NQcmVmaXgrXCJJbWFnZUVsZW1lbnRcIl0oY29uZmlnLHN0eWxlKTtyZXR1cm4gdGhpcy5hZGQoZWwsZ3JvdXApLGVsfSxqdm0uQWJzdHJhY3RDYW52YXNFbGVtZW50LnByb3RvdHlwZS5hZGRUZXh0PWZ1bmN0aW9uKGNvbmZpZyxzdHlsZSxncm91cCl7dmFyIGVsPW5ldyBqdm1bdGhpcy5jbGFzc1ByZWZpeCtcIlRleHRFbGVtZW50XCJdKGNvbmZpZyxzdHlsZSk7cmV0dXJuIHRoaXMuYWRkKGVsLGdyb3VwKSxlbH0sanZtLkFic3RyYWN0Q2FudmFzRWxlbWVudC5wcm90b3R5cGUuYWRkR3JvdXA9ZnVuY3Rpb24ocGFyZW50R3JvdXApe3ZhciBlbD1uZXcganZtW3RoaXMuY2xhc3NQcmVmaXgrXCJHcm91cEVsZW1lbnRcIl07cmV0dXJuIHBhcmVudEdyb3VwP3BhcmVudEdyb3VwLm5vZGUuYXBwZW5kQ2hpbGQoZWwubm9kZSk6dGhpcy5ub2RlLmFwcGVuZENoaWxkKGVsLm5vZGUpLGVsLmNhbnZhcz10aGlzLGVsfSxqdm0uQWJzdHJhY3RTaGFwZUVsZW1lbnQ9ZnVuY3Rpb24obmFtZSxjb25maWcsc3R5bGUpe3RoaXMuc3R5bGU9c3R5bGV8fHt9LHRoaXMuc3R5bGUuY3VycmVudD10aGlzLnN0eWxlLmN1cnJlbnR8fHt9LHRoaXMuaXNIb3ZlcmVkPSExLHRoaXMuaXNTZWxlY3RlZD0hMSx0aGlzLnVwZGF0ZVN0eWxlKCl9LGp2bS5BYnN0cmFjdFNoYXBlRWxlbWVudC5wcm90b3R5cGUuc2V0U3R5bGU9ZnVuY3Rpb24ocHJvcGVydHksdmFsdWUpe3ZhciBzdHlsZXM9e307XCJvYmplY3RcIj09dHlwZW9mIHByb3BlcnR5P3N0eWxlcz1wcm9wZXJ0eTpzdHlsZXNbcHJvcGVydHldPXZhbHVlLGp2bS4kLmV4dGVuZCh0aGlzLnN0eWxlLmN1cnJlbnQsc3R5bGVzKSx0aGlzLnVwZGF0ZVN0eWxlKCl9LGp2bS5BYnN0cmFjdFNoYXBlRWxlbWVudC5wcm90b3R5cGUudXBkYXRlU3R5bGU9ZnVuY3Rpb24oKXt2YXIgYXR0cnM9e307anZtLkFic3RyYWN0U2hhcGVFbGVtZW50Lm1lcmdlU3R5bGVzKGF0dHJzLHRoaXMuc3R5bGUuaW5pdGlhbCksanZtLkFic3RyYWN0U2hhcGVFbGVtZW50Lm1lcmdlU3R5bGVzKGF0dHJzLHRoaXMuc3R5bGUuY3VycmVudCksdGhpcy5pc0hvdmVyZWQmJmp2bS5BYnN0cmFjdFNoYXBlRWxlbWVudC5tZXJnZVN0eWxlcyhhdHRycyx0aGlzLnN0eWxlLmhvdmVyKSx0aGlzLmlzU2VsZWN0ZWQmJihqdm0uQWJzdHJhY3RTaGFwZUVsZW1lbnQubWVyZ2VTdHlsZXMoYXR0cnMsdGhpcy5zdHlsZS5zZWxlY3RlZCksdGhpcy5pc0hvdmVyZWQmJmp2bS5BYnN0cmFjdFNoYXBlRWxlbWVudC5tZXJnZVN0eWxlcyhhdHRycyx0aGlzLnN0eWxlLnNlbGVjdGVkSG92ZXIpKSx0aGlzLnNldChhdHRycyl9LGp2bS5BYnN0cmFjdFNoYXBlRWxlbWVudC5tZXJnZVN0eWxlcz1mdW5jdGlvbihzdHlsZXMsbmV3U3R5bGVzKXt2YXIga2V5O25ld1N0eWxlcz1uZXdTdHlsZXN8fHt9O2ZvcihrZXkgaW4gbmV3U3R5bGVzKW51bGw9PT1uZXdTdHlsZXNba2V5XT9kZWxldGUgc3R5bGVzW2tleV06c3R5bGVzW2tleV09bmV3U3R5bGVzW2tleV19LGp2bS5TVkdFbGVtZW50PWZ1bmN0aW9uKCl7anZtLlNWR0VsZW1lbnQucGFyZW50Q2xhc3MuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxqdm0uaW5oZXJpdHMoanZtLlNWR0VsZW1lbnQsanZtLkFic3RyYWN0RWxlbWVudCksanZtLlNWR0VsZW1lbnQuc3ZnbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLGp2bS5TVkdFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50PWZ1bmN0aW9uKHRhZ05hbWUpe3JldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoanZtLlNWR0VsZW1lbnQuc3ZnbnMsdGFnTmFtZSl9LGp2bS5TVkdFbGVtZW50LnByb3RvdHlwZS5hZGRDbGFzcz1mdW5jdGlvbihjbGFzc05hbWUpe3RoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLGNsYXNzTmFtZSl9LGp2bS5TVkdFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50Q3RyPWZ1bmN0aW9uKGN0cil7cmV0dXJuIGp2bVtcIlNWR1wiK2N0cl19LGp2bS5TVkdFbGVtZW50LnByb3RvdHlwZS5nZXRCQm94PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZS5nZXRCQm94KCl9LGp2bS5TVkdHcm91cEVsZW1lbnQ9ZnVuY3Rpb24oKXtqdm0uU1ZHR3JvdXBFbGVtZW50LnBhcmVudENsYXNzLmNhbGwodGhpcyxcImdcIil9LGp2bS5pbmhlcml0cyhqdm0uU1ZHR3JvdXBFbGVtZW50LGp2bS5TVkdFbGVtZW50KSxqdm0uU1ZHR3JvdXBFbGVtZW50LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oZWxlbWVudCl7dGhpcy5ub2RlLmFwcGVuZENoaWxkKGVsZW1lbnQubm9kZSl9LGp2bS5TVkdDYW52YXNFbGVtZW50PWZ1bmN0aW9uKCl7dGhpcy5jbGFzc1ByZWZpeD1cIlNWR1wiLGp2bS5TVkdDYW52YXNFbGVtZW50LnBhcmVudENsYXNzLmNhbGwodGhpcyxcInN2Z1wiKSx0aGlzLmRlZnNFbGVtZW50PW5ldyBqdm0uU1ZHRWxlbWVudChcImRlZnNcIiksdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuZGVmc0VsZW1lbnQubm9kZSksanZtLkFic3RyYWN0Q2FudmFzRWxlbWVudC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGp2bS5pbmhlcml0cyhqdm0uU1ZHQ2FudmFzRWxlbWVudCxqdm0uU1ZHRWxlbWVudCksanZtLm1peGluKGp2bS5TVkdDYW52YXNFbGVtZW50LGp2bS5BYnN0cmFjdENhbnZhc0VsZW1lbnQpLGp2bS5TVkdDYW52YXNFbGVtZW50LnByb3RvdHlwZS5zZXRTaXplPWZ1bmN0aW9uKHdpZHRoLGhlaWdodCl7dGhpcy53aWR0aD13aWR0aCx0aGlzLmhlaWdodD1oZWlnaHQsdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsd2lkdGgpLHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIixoZWlnaHQpfSxqdm0uU1ZHQ2FudmFzRWxlbWVudC5wcm90b3R5cGUuYXBwbHlUcmFuc2Zvcm1QYXJhbXM9ZnVuY3Rpb24oc2NhbGUsdHJhbnNYLHRyYW5zWSl7dGhpcy5zY2FsZT1zY2FsZSx0aGlzLnRyYW5zWD10cmFuc1gsdGhpcy50cmFuc1k9dHJhbnNZLHRoaXMucm9vdEVsZW1lbnQubm9kZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIixcInNjYWxlKFwiK3NjYWxlK1wiKSB0cmFuc2xhdGUoXCIrdHJhbnNYK1wiLCBcIit0cmFuc1krXCIpXCIpfSxqdm0uU1ZHU2hhcGVFbGVtZW50PWZ1bmN0aW9uKG5hbWUsY29uZmlnKXtqdm0uU1ZHU2hhcGVFbGVtZW50LnBhcmVudENsYXNzLmNhbGwodGhpcyxuYW1lLGNvbmZpZyksanZtLkFic3RyYWN0U2hhcGVFbGVtZW50LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sanZtLmluaGVyaXRzKGp2bS5TVkdTaGFwZUVsZW1lbnQsanZtLlNWR0VsZW1lbnQpLGp2bS5taXhpbihqdm0uU1ZHU2hhcGVFbGVtZW50LGp2bS5BYnN0cmFjdFNoYXBlRWxlbWVudCksanZtLlNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuYXBwbHlBdHRyPWZ1bmN0aW9uKGF0dHIsdmFsdWUpe3ZhciBwYXR0ZXJuRWwsaW1hZ2VFbCx0aGF0PXRoaXM7XCJmaWxsXCI9PT1hdHRyJiZqdm0uaXNJbWFnZVVybCh2YWx1ZSk/anZtLlNWR1NoYXBlRWxlbWVudC5pbWFnZXNbdmFsdWVdP3RoaXMuYXBwbHlBdHRyKFwiZmlsbFwiLFwidXJsKCNpbWFnZVwiK2p2bS5TVkdTaGFwZUVsZW1lbnQuaW1hZ2VzW3ZhbHVlXStcIilcIik6anZtLndoZW5JbWFnZUxvYWRlZCh2YWx1ZSkudGhlbihmdW5jdGlvbihpbWcpe2ltYWdlRWw9bmV3IGp2bS5TVkdFbGVtZW50KFwiaW1hZ2VcIiksaW1hZ2VFbC5ub2RlLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFwiaHJlZlwiLHZhbHVlKSxpbWFnZUVsLmFwcGx5QXR0cihcInhcIixcIjBcIiksaW1hZ2VFbC5hcHBseUF0dHIoXCJ5XCIsXCIwXCIpLGltYWdlRWwuYXBwbHlBdHRyKFwid2lkdGhcIixpbWdbMF0ud2lkdGgpLGltYWdlRWwuYXBwbHlBdHRyKFwiaGVpZ2h0XCIsaW1nWzBdLmhlaWdodCkscGF0dGVybkVsPW5ldyBqdm0uU1ZHRWxlbWVudChcInBhdHRlcm5cIikscGF0dGVybkVsLmFwcGx5QXR0cihcImlkXCIsXCJpbWFnZVwiK2p2bS5TVkdTaGFwZUVsZW1lbnQuaW1hZ2VDb3VudGVyKSxwYXR0ZXJuRWwuYXBwbHlBdHRyKFwieFwiLDApLHBhdHRlcm5FbC5hcHBseUF0dHIoXCJ5XCIsMCkscGF0dGVybkVsLmFwcGx5QXR0cihcIndpZHRoXCIsaW1nWzBdLndpZHRoLzIpLHBhdHRlcm5FbC5hcHBseUF0dHIoXCJoZWlnaHRcIixpbWdbMF0uaGVpZ2h0LzIpLHBhdHRlcm5FbC5hcHBseUF0dHIoXCJ2aWV3Qm94XCIsXCIwIDAgXCIraW1nWzBdLndpZHRoK1wiIFwiK2ltZ1swXS5oZWlnaHQpLHBhdHRlcm5FbC5hcHBseUF0dHIoXCJwYXR0ZXJuVW5pdHNcIixcInVzZXJTcGFjZU9uVXNlXCIpLHBhdHRlcm5FbC5ub2RlLmFwcGVuZENoaWxkKGltYWdlRWwubm9kZSksdGhhdC5jYW52YXMuZGVmc0VsZW1lbnQubm9kZS5hcHBlbmRDaGlsZChwYXR0ZXJuRWwubm9kZSksanZtLlNWR1NoYXBlRWxlbWVudC5pbWFnZXNbdmFsdWVdPWp2bS5TVkdTaGFwZUVsZW1lbnQuaW1hZ2VDb3VudGVyKyssdGhhdC5hcHBseUF0dHIoXCJmaWxsXCIsXCJ1cmwoI2ltYWdlXCIranZtLlNWR1NoYXBlRWxlbWVudC5pbWFnZXNbdmFsdWVdK1wiKVwiKX0pOmp2bS5TVkdTaGFwZUVsZW1lbnQucGFyZW50Q2xhc3MucHJvdG90eXBlLmFwcGx5QXR0ci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGp2bS5TVkdTaGFwZUVsZW1lbnQuaW1hZ2VDb3VudGVyPTEsanZtLlNWR1NoYXBlRWxlbWVudC5pbWFnZXM9e30sanZtLlNWR1BhdGhFbGVtZW50PWZ1bmN0aW9uKGNvbmZpZyxzdHlsZSl7anZtLlNWR1BhdGhFbGVtZW50LnBhcmVudENsYXNzLmNhbGwodGhpcyxcInBhdGhcIixjb25maWcsc3R5bGUpLHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJmaWxsLXJ1bGVcIixcImV2ZW5vZGRcIil9LGp2bS5pbmhlcml0cyhqdm0uU1ZHUGF0aEVsZW1lbnQsanZtLlNWR1NoYXBlRWxlbWVudCksanZtLlNWR0NpcmNsZUVsZW1lbnQ9ZnVuY3Rpb24oY29uZmlnLHN0eWxlKXtqdm0uU1ZHQ2lyY2xlRWxlbWVudC5wYXJlbnRDbGFzcy5jYWxsKHRoaXMsXCJjaXJjbGVcIixjb25maWcsc3R5bGUpfSxqdm0uaW5oZXJpdHMoanZtLlNWR0NpcmNsZUVsZW1lbnQsanZtLlNWR1NoYXBlRWxlbWVudCksanZtLlNWR0ltYWdlRWxlbWVudD1mdW5jdGlvbihjb25maWcsc3R5bGUpe2p2bS5TVkdJbWFnZUVsZW1lbnQucGFyZW50Q2xhc3MuY2FsbCh0aGlzLFwiaW1hZ2VcIixjb25maWcsc3R5bGUpfSxqdm0uaW5oZXJpdHMoanZtLlNWR0ltYWdlRWxlbWVudCxqdm0uU1ZHU2hhcGVFbGVtZW50KSxqdm0uU1ZHSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5hcHBseUF0dHI9ZnVuY3Rpb24oYXR0cix2YWx1ZSl7dmFyIHRoYXQ9dGhpcztcImltYWdlXCI9PWF0dHI/anZtLndoZW5JbWFnZUxvYWRlZCh2YWx1ZSkudGhlbihmdW5jdGlvbihpbWcpe3RoYXQubm9kZS5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcImhyZWZcIix2YWx1ZSksdGhhdC53aWR0aD1pbWdbMF0ud2lkdGgsdGhhdC5oZWlnaHQ9aW1nWzBdLmhlaWdodCx0aGF0LmFwcGx5QXR0cihcIndpZHRoXCIsdGhhdC53aWR0aCksdGhhdC5hcHBseUF0dHIoXCJoZWlnaHRcIix0aGF0LmhlaWdodCksdGhhdC5hcHBseUF0dHIoXCJ4XCIsdGhhdC5jeC10aGF0LndpZHRoLzIpLHRoYXQuYXBwbHlBdHRyKFwieVwiLHRoYXQuY3ktdGhhdC5oZWlnaHQvMiksanZtLiQodGhhdC5ub2RlKS50cmlnZ2VyKFwiaW1hZ2Vsb2FkZWRcIixbaW1nXSl9KTpcImN4XCI9PWF0dHI/KHRoaXMuY3g9dmFsdWUsdGhpcy53aWR0aCYmdGhpcy5hcHBseUF0dHIoXCJ4XCIsdmFsdWUtdGhpcy53aWR0aC8yKSk6XCJjeVwiPT1hdHRyPyh0aGlzLmN5PXZhbHVlLHRoaXMuaGVpZ2h0JiZ0aGlzLmFwcGx5QXR0cihcInlcIix2YWx1ZS10aGlzLmhlaWdodC8yKSk6anZtLlNWR0ltYWdlRWxlbWVudC5wYXJlbnRDbGFzcy5wcm90b3R5cGUuYXBwbHlBdHRyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sanZtLlNWR1RleHRFbGVtZW50PWZ1bmN0aW9uKGNvbmZpZyxzdHlsZSl7anZtLlNWR1RleHRFbGVtZW50LnBhcmVudENsYXNzLmNhbGwodGhpcyxcInRleHRcIixjb25maWcsc3R5bGUpfSxqdm0uaW5oZXJpdHMoanZtLlNWR1RleHRFbGVtZW50LGp2bS5TVkdTaGFwZUVsZW1lbnQpLGp2bS5TVkdUZXh0RWxlbWVudC5wcm90b3R5cGUuYXBwbHlBdHRyPWZ1bmN0aW9uKGF0dHIsdmFsdWUpe1widGV4dFwiPT09YXR0cj90aGlzLm5vZGUudGV4dENvbnRlbnQ9dmFsdWU6anZtLlNWR1RleHRFbGVtZW50LnBhcmVudENsYXNzLnByb3RvdHlwZS5hcHBseUF0dHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxqdm0uVk1MRWxlbWVudD1mdW5jdGlvbigpe2p2bS5WTUxFbGVtZW50LlZNTEluaXRpYWxpemVkfHxqdm0uVk1MRWxlbWVudC5pbml0aWFsaXplVk1MKCksanZtLlZNTEVsZW1lbnQucGFyZW50Q2xhc3MuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxqdm0uaW5oZXJpdHMoanZtLlZNTEVsZW1lbnQsanZtLkFic3RyYWN0RWxlbWVudCksanZtLlZNTEVsZW1lbnQuVk1MSW5pdGlhbGl6ZWQ9ITEsanZtLlZNTEVsZW1lbnQuaW5pdGlhbGl6ZVZNTD1mdW5jdGlvbigpe3RyeXtkb2N1bWVudC5uYW1lc3BhY2VzLnJ2bWx8fGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKFwicnZtbFwiLFwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWxcIiksanZtLlZNTEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQ9ZnVuY3Rpb24odGFnTmFtZSl7cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCI8cnZtbDpcIit0YWdOYW1lKycgY2xhc3M9XCJydm1sXCI+Jyl9fWNhdGNoKGUpe2p2bS5WTUxFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50PWZ1bmN0aW9uKHRhZ05hbWUpe3JldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiPFwiK3RhZ05hbWUrJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sXCIgY2xhc3M9XCJydm1sXCI+Jyl9fWRvY3VtZW50LmNyZWF0ZVN0eWxlU2hlZXQoKS5hZGRSdWxlKFwiLnJ2bWxcIixcImJlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpXCIpLGp2bS5WTUxFbGVtZW50LlZNTEluaXRpYWxpemVkPSEwfSxqdm0uVk1MRWxlbWVudC5wcm90b3R5cGUuZ2V0RWxlbWVudEN0cj1mdW5jdGlvbihjdHIpe3JldHVybiBqdm1bXCJWTUxcIitjdHJdfSxqdm0uVk1MRWxlbWVudC5wcm90b3R5cGUuYWRkQ2xhc3M9ZnVuY3Rpb24oY2xhc3NOYW1lKXtqdm0uJCh0aGlzLm5vZGUpLmFkZENsYXNzKGNsYXNzTmFtZSl9LGp2bS5WTUxFbGVtZW50LnByb3RvdHlwZS5hcHBseUF0dHI9ZnVuY3Rpb24oYXR0cix2YWx1ZSl7dGhpcy5ub2RlW2F0dHJdPXZhbHVlfSxqdm0uVk1MRWxlbWVudC5wcm90b3R5cGUuZ2V0QkJveD1mdW5jdGlvbigpe3ZhciBub2RlPWp2bS4kKHRoaXMubm9kZSk7cmV0dXJue3g6bm9kZS5wb3NpdGlvbigpLmxlZnQvdGhpcy5jYW52YXMuc2NhbGUseTpub2RlLnBvc2l0aW9uKCkudG9wL3RoaXMuY2FudmFzLnNjYWxlLHdpZHRoOm5vZGUud2lkdGgoKS90aGlzLmNhbnZhcy5zY2FsZSxoZWlnaHQ6bm9kZS5oZWlnaHQoKS90aGlzLmNhbnZhcy5zY2FsZX19LGp2bS5WTUxHcm91cEVsZW1lbnQ9ZnVuY3Rpb24oKXtqdm0uVk1MR3JvdXBFbGVtZW50LnBhcmVudENsYXNzLmNhbGwodGhpcyxcImdyb3VwXCIpLHRoaXMubm9kZS5zdHlsZS5sZWZ0PVwiMHB4XCIsdGhpcy5ub2RlLnN0eWxlLnRvcD1cIjBweFwiLHRoaXMubm9kZS5jb29yZG9yaWdpbj1cIjAgMFwifSxqdm0uaW5oZXJpdHMoanZtLlZNTEdyb3VwRWxlbWVudCxqdm0uVk1MRWxlbWVudCksanZtLlZNTEdyb3VwRWxlbWVudC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGVsZW1lbnQpe3RoaXMubm9kZS5hcHBlbmRDaGlsZChlbGVtZW50Lm5vZGUpfSxqdm0uVk1MQ2FudmFzRWxlbWVudD1mdW5jdGlvbigpe3RoaXMuY2xhc3NQcmVmaXg9XCJWTUxcIixqdm0uVk1MQ2FudmFzRWxlbWVudC5wYXJlbnRDbGFzcy5jYWxsKHRoaXMsXCJncm91cFwiKSxqdm0uQWJzdHJhY3RDYW52YXNFbGVtZW50LmFwcGx5KHRoaXMsYXJndW1lbnRzKSx0aGlzLm5vZGUuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwifSxqdm0uaW5oZXJpdHMoanZtLlZNTENhbnZhc0VsZW1lbnQsanZtLlZNTEVsZW1lbnQpLGp2bS5taXhpbihqdm0uVk1MQ2FudmFzRWxlbWVudCxqdm0uQWJzdHJhY3RDYW52YXNFbGVtZW50KSxqdm0uVk1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUuc2V0U2l6ZT1mdW5jdGlvbih3aWR0aCxoZWlnaHQpe3ZhciBwYXRocyxncm91cHMsaSxsO2lmKHRoaXMud2lkdGg9d2lkdGgsdGhpcy5oZWlnaHQ9aGVpZ2h0LHRoaXMubm9kZS5zdHlsZS53aWR0aD13aWR0aCtcInB4XCIsdGhpcy5ub2RlLnN0eWxlLmhlaWdodD1oZWlnaHQrXCJweFwiLHRoaXMubm9kZS5jb29yZHNpemU9d2lkdGgrXCIgXCIraGVpZ2h0LHRoaXMubm9kZS5jb29yZG9yaWdpbj1cIjAgMFwiLHRoaXMucm9vdEVsZW1lbnQpe2ZvcihwYXRocz10aGlzLnJvb3RFbGVtZW50Lm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzaGFwZVwiKSxpPTAsbD1wYXRocy5sZW5ndGg7bD5pO2krKylwYXRoc1tpXS5jb29yZHNpemU9d2lkdGgrXCIgXCIraGVpZ2h0LHBhdGhzW2ldLnN0eWxlLndpZHRoPXdpZHRoK1wicHhcIixwYXRoc1tpXS5zdHlsZS5oZWlnaHQ9aGVpZ2h0K1wicHhcIjtmb3IoZ3JvdXBzPXRoaXMubm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImdyb3VwXCIpLGk9MCxsPWdyb3Vwcy5sZW5ndGg7bD5pO2krKylncm91cHNbaV0uY29vcmRzaXplPXdpZHRoK1wiIFwiK2hlaWdodCxncm91cHNbaV0uc3R5bGUud2lkdGg9d2lkdGgrXCJweFwiLGdyb3Vwc1tpXS5zdHlsZS5oZWlnaHQ9aGVpZ2h0K1wicHhcIn19LGp2bS5WTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZS5hcHBseVRyYW5zZm9ybVBhcmFtcz1mdW5jdGlvbihzY2FsZSx0cmFuc1gsdHJhbnNZKXt0aGlzLnNjYWxlPXNjYWxlLHRoaXMudHJhbnNYPXRyYW5zWCx0aGlzLnRyYW5zWT10cmFuc1ksdGhpcy5yb290RWxlbWVudC5ub2RlLmNvb3Jkb3JpZ2luPXRoaXMud2lkdGgtdHJhbnNYLXRoaXMud2lkdGgvMTAwK1wiLFwiKyh0aGlzLmhlaWdodC10cmFuc1ktdGhpcy5oZWlnaHQvMTAwKSx0aGlzLnJvb3RFbGVtZW50Lm5vZGUuY29vcmRzaXplPXRoaXMud2lkdGgvc2NhbGUrXCIsXCIrdGhpcy5oZWlnaHQvc2NhbGV9LGp2bS5WTUxTaGFwZUVsZW1lbnQ9ZnVuY3Rpb24obmFtZSxjb25maWcpe2p2bS5WTUxTaGFwZUVsZW1lbnQucGFyZW50Q2xhc3MuY2FsbCh0aGlzLG5hbWUsY29uZmlnKSx0aGlzLmZpbGxFbGVtZW50PW5ldyBqdm0uVk1MRWxlbWVudChcImZpbGxcIiksdGhpcy5zdHJva2VFbGVtZW50PW5ldyBqdm0uVk1MRWxlbWVudChcInN0cm9rZVwiKSx0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5maWxsRWxlbWVudC5ub2RlKSx0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5zdHJva2VFbGVtZW50Lm5vZGUpLHRoaXMubm9kZS5zdHJva2VkPSExLGp2bS5BYnN0cmFjdFNoYXBlRWxlbWVudC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGp2bS5pbmhlcml0cyhqdm0uVk1MU2hhcGVFbGVtZW50LGp2bS5WTUxFbGVtZW50KSxqdm0ubWl4aW4oanZtLlZNTFNoYXBlRWxlbWVudCxqdm0uQWJzdHJhY3RTaGFwZUVsZW1lbnQpLGp2bS5WTUxTaGFwZUVsZW1lbnQucHJvdG90eXBlLmFwcGx5QXR0cj1mdW5jdGlvbihhdHRyLHZhbHVlKXtzd2l0Y2goYXR0cil7Y2FzZVwiZmlsbFwiOnRoaXMubm9kZS5maWxsY29sb3I9dmFsdWU7YnJlYWs7Y2FzZVwiZmlsbC1vcGFjaXR5XCI6dGhpcy5maWxsRWxlbWVudC5ub2RlLm9wYWNpdHk9TWF0aC5yb3VuZCgxMDAqdmFsdWUpK1wiJVwiO2JyZWFrO2Nhc2VcInN0cm9rZVwiOnRoaXMubm9kZS5zdHJva2VkPVwibm9uZVwiPT09dmFsdWU/ITE6ITAsdGhpcy5ub2RlLnN0cm9rZWNvbG9yPXZhbHVlO2JyZWFrO2Nhc2VcInN0cm9rZS1vcGFjaXR5XCI6dGhpcy5zdHJva2VFbGVtZW50Lm5vZGUub3BhY2l0eT1NYXRoLnJvdW5kKDEwMCp2YWx1ZSkrXCIlXCI7YnJlYWs7Y2FzZVwic3Ryb2tlLXdpZHRoXCI6dGhpcy5ub2RlLnN0cm9rZWQ9MD09PXBhcnNlSW50KHZhbHVlLDEwKT8hMTohMCx0aGlzLm5vZGUuc3Ryb2tld2VpZ2h0PXZhbHVlO2JyZWFrO2Nhc2VcImRcIjp0aGlzLm5vZGUucGF0aD1qdm0uVk1MUGF0aEVsZW1lbnQucGF0aFN2Z1RvVm1sKHZhbHVlKTticmVhaztkZWZhdWx0Omp2bS5WTUxTaGFwZUVsZW1lbnQucGFyZW50Q2xhc3MucHJvdG90eXBlLmFwcGx5QXR0ci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSxqdm0uVk1MUGF0aEVsZW1lbnQ9ZnVuY3Rpb24oY29uZmlnLHN0eWxlKXt2YXIgc2NhbGU9bmV3IGp2bS5WTUxFbGVtZW50KFwic2tld1wiKTtqdm0uVk1MUGF0aEVsZW1lbnQucGFyZW50Q2xhc3MuY2FsbCh0aGlzLFwic2hhcGVcIixjb25maWcsc3R5bGUpLHRoaXMubm9kZS5jb29yZG9yaWdpbj1cIjAgMFwiLHNjYWxlLm5vZGUub249ITAsc2NhbGUubm9kZS5tYXRyaXg9XCIwLjAxLDAsMCwwLjAxLDAsMFwiLHNjYWxlLm5vZGUub2Zmc2V0PVwiMCwwXCIsdGhpcy5ub2RlLmFwcGVuZENoaWxkKHNjYWxlLm5vZGUpfSxqdm0uaW5oZXJpdHMoanZtLlZNTFBhdGhFbGVtZW50LGp2bS5WTUxTaGFwZUVsZW1lbnQpLGp2bS5WTUxQYXRoRWxlbWVudC5wcm90b3R5cGUuYXBwbHlBdHRyPWZ1bmN0aW9uKGF0dHIsdmFsdWUpe1wiZFwiPT09YXR0cj90aGlzLm5vZGUucGF0aD1qdm0uVk1MUGF0aEVsZW1lbnQucGF0aFN2Z1RvVm1sKHZhbHVlKTpqdm0uVk1MU2hhcGVFbGVtZW50LnByb3RvdHlwZS5hcHBseUF0dHIuY2FsbCh0aGlzLGF0dHIsdmFsdWUpfSxqdm0uVk1MUGF0aEVsZW1lbnQucGF0aFN2Z1RvVm1sPWZ1bmN0aW9uKHBhdGgpe3ZhciBjdHJseCxjdHJseSxjeD0wLGN5PTA7cmV0dXJuIHBhdGg9cGF0aC5yZXBsYWNlKC8oLT9cXGQrKWUoLT9cXGQrKS9nLFwiMFwiKSxwYXRoLnJlcGxhY2UoLyhbTW1MbEhoVnZDY1NzXSlcXHMqKCg/Oi0/XFxkKig/OlxcLlxcZCspP1xccyosP1xccyopKykvZyxmdW5jdGlvbihzZWdtZW50LGxldHRlcixjb29yZHMpe2Nvb3Jkcz1jb29yZHMucmVwbGFjZSgvKFxcZCktL2csXCIkMSwtXCIpLnJlcGxhY2UoL15cXHMrL2csXCJcIikucmVwbGFjZSgvXFxzKyQvZyxcIlwiKS5yZXBsYWNlKC9cXHMrL2csXCIsXCIpLnNwbGl0KFwiLFwiKSxjb29yZHNbMF18fGNvb3Jkcy5zaGlmdCgpO2Zvcih2YXIgaT0wLGw9Y29vcmRzLmxlbmd0aDtsPmk7aSsrKWNvb3Jkc1tpXT1NYXRoLnJvdW5kKDEwMCpjb29yZHNbaV0pO3N3aXRjaChsZXR0ZXIpe2Nhc2VcIm1cIjpyZXR1cm4gY3grPWNvb3Jkc1swXSxjeSs9Y29vcmRzWzFdLFwidFwiK2Nvb3Jkcy5qb2luKFwiLFwiKTtjYXNlXCJNXCI6cmV0dXJuIGN4PWNvb3Jkc1swXSxjeT1jb29yZHNbMV0sXCJtXCIrY29vcmRzLmpvaW4oXCIsXCIpO2Nhc2VcImxcIjpyZXR1cm4gY3grPWNvb3Jkc1swXSxjeSs9Y29vcmRzWzFdLFwiclwiK2Nvb3Jkcy5qb2luKFwiLFwiKTtjYXNlXCJMXCI6cmV0dXJuIGN4PWNvb3Jkc1swXSxjeT1jb29yZHNbMV0sXCJsXCIrY29vcmRzLmpvaW4oXCIsXCIpO2Nhc2VcImhcIjpyZXR1cm4gY3grPWNvb3Jkc1swXSxcInJcIitjb29yZHNbMF0rXCIsMFwiO2Nhc2VcIkhcIjpyZXR1cm4gY3g9Y29vcmRzWzBdLFwibFwiK2N4K1wiLFwiK2N5O2Nhc2VcInZcIjpyZXR1cm4gY3krPWNvb3Jkc1swXSxcInIwLFwiK2Nvb3Jkc1swXTtjYXNlXCJWXCI6cmV0dXJuIGN5PWNvb3Jkc1swXSxcImxcIitjeCtcIixcIitjeTtjYXNlXCJjXCI6cmV0dXJuIGN0cmx4PWN4K2Nvb3Jkc1tjb29yZHMubGVuZ3RoLTRdLGN0cmx5PWN5K2Nvb3Jkc1tjb29yZHMubGVuZ3RoLTNdLGN4Kz1jb29yZHNbY29vcmRzLmxlbmd0aC0yXSxjeSs9Y29vcmRzW2Nvb3Jkcy5sZW5ndGgtMV0sXCJ2XCIrY29vcmRzLmpvaW4oXCIsXCIpO2Nhc2VcIkNcIjpyZXR1cm4gY3RybHg9Y29vcmRzW2Nvb3Jkcy5sZW5ndGgtNF0sY3RybHk9Y29vcmRzW2Nvb3Jkcy5sZW5ndGgtM10sY3g9Y29vcmRzW2Nvb3Jkcy5sZW5ndGgtMl0sY3k9Y29vcmRzW2Nvb3Jkcy5sZW5ndGgtMV0sXCJjXCIrY29vcmRzLmpvaW4oXCIsXCIpO2Nhc2VcInNcIjpyZXR1cm4gY29vcmRzLnVuc2hpZnQoY3ktY3RybHkpLGNvb3Jkcy51bnNoaWZ0KGN4LWN0cmx4KSxjdHJseD1jeCtjb29yZHNbY29vcmRzLmxlbmd0aC00XSxjdHJseT1jeStjb29yZHNbY29vcmRzLmxlbmd0aC0zXSxjeCs9Y29vcmRzW2Nvb3Jkcy5sZW5ndGgtMl0sY3krPWNvb3Jkc1tjb29yZHMubGVuZ3RoLTFdLFwidlwiK2Nvb3Jkcy5qb2luKFwiLFwiKTtjYXNlXCJTXCI6cmV0dXJuIGNvb3Jkcy51bnNoaWZ0KGN5K2N5LWN0cmx5KSxjb29yZHMudW5zaGlmdChjeCtjeC1jdHJseCksY3RybHg9Y29vcmRzW2Nvb3Jkcy5sZW5ndGgtNF0sY3RybHk9Y29vcmRzW2Nvb3Jkcy5sZW5ndGgtM10sY3g9Y29vcmRzW2Nvb3Jkcy5sZW5ndGgtMl0sY3k9Y29vcmRzW2Nvb3Jkcy5sZW5ndGgtMV0sXCJjXCIrY29vcmRzLmpvaW4oXCIsXCIpfXJldHVyblwiXCJ9KS5yZXBsYWNlKC96L2csXCJlXCIpfSxqdm0uVk1MQ2lyY2xlRWxlbWVudD1mdW5jdGlvbihjb25maWcsc3R5bGUpe2p2bS5WTUxDaXJjbGVFbGVtZW50LnBhcmVudENsYXNzLmNhbGwodGhpcyxcIm92YWxcIixjb25maWcsc3R5bGUpfSxqdm0uaW5oZXJpdHMoanZtLlZNTENpcmNsZUVsZW1lbnQsanZtLlZNTFNoYXBlRWxlbWVudCksanZtLlZNTENpcmNsZUVsZW1lbnQucHJvdG90eXBlLmFwcGx5QXR0cj1mdW5jdGlvbihhdHRyLHZhbHVlKXtzd2l0Y2goYXR0cil7Y2FzZVwiclwiOnRoaXMubm9kZS5zdHlsZS53aWR0aD0yKnZhbHVlK1wicHhcIix0aGlzLm5vZGUuc3R5bGUuaGVpZ2h0PTIqdmFsdWUrXCJweFwiLHRoaXMuYXBwbHlBdHRyKFwiY3hcIix0aGlzLmdldChcImN4XCIpfHwwKSx0aGlzLmFwcGx5QXR0cihcImN5XCIsdGhpcy5nZXQoXCJjeVwiKXx8MCk7YnJlYWs7Y2FzZVwiY3hcIjppZighdmFsdWUpcmV0dXJuO3RoaXMubm9kZS5zdHlsZS5sZWZ0PXZhbHVlLSh0aGlzLmdldChcInJcIil8fDApK1wicHhcIjticmVhaztjYXNlXCJjeVwiOmlmKCF2YWx1ZSlyZXR1cm47dGhpcy5ub2RlLnN0eWxlLnRvcD12YWx1ZS0odGhpcy5nZXQoXCJyXCIpfHwwKStcInB4XCI7YnJlYWs7ZGVmYXVsdDpqdm0uVk1MQ2lyY2xlRWxlbWVudC5wYXJlbnRDbGFzcy5wcm90b3R5cGUuYXBwbHlBdHRyLmNhbGwodGhpcyxhdHRyLHZhbHVlKX19LGp2bS5WZWN0b3JDYW52YXM9ZnVuY3Rpb24oY29udGFpbmVyLHdpZHRoLGhlaWdodCl7cmV0dXJuIHRoaXMubW9kZT13aW5kb3cuU1ZHQW5nbGU/XCJzdmdcIjpcInZtbFwiLHRoaXMuaW1wbD1cInN2Z1wiPT10aGlzLm1vZGU/bmV3IGp2bS5TVkdDYW52YXNFbGVtZW50KGNvbnRhaW5lcix3aWR0aCxoZWlnaHQpOm5ldyBqdm0uVk1MQ2FudmFzRWxlbWVudChjb250YWluZXIsd2lkdGgsaGVpZ2h0KSx0aGlzLmltcGwubW9kZT10aGlzLm1vZGUsdGhpcy5pbXBsfSxqdm0uU2ltcGxlU2NhbGU9ZnVuY3Rpb24oc2NhbGUpe3RoaXMuc2NhbGU9c2NhbGV9LGp2bS5TaW1wbGVTY2FsZS5wcm90b3R5cGUuZ2V0VmFsdWU9ZnVuY3Rpb24odmFsdWUpe3JldHVybiB2YWx1ZX0sanZtLk9yZGluYWxTY2FsZT1mdW5jdGlvbihzY2FsZSl7dGhpcy5zY2FsZT1zY2FsZX0sanZtLk9yZGluYWxTY2FsZS5wcm90b3R5cGUuZ2V0VmFsdWU9ZnVuY3Rpb24odmFsdWUpe3JldHVybiB0aGlzLnNjYWxlW3ZhbHVlXX0sanZtLk9yZGluYWxTY2FsZS5wcm90b3R5cGUuZ2V0VGlja3M9ZnVuY3Rpb24oKXt2YXIga2V5LHRpY2tzPVtdO2ZvcihrZXkgaW4gdGhpcy5zY2FsZSl0aWNrcy5wdXNoKHtsYWJlbDprZXksdmFsdWU6dGhpcy5zY2FsZVtrZXldfSk7cmV0dXJuIHRpY2tzfSxqdm0uTnVtZXJpY1NjYWxlPWZ1bmN0aW9uKHNjYWxlLG5vcm1hbGl6ZUZ1bmN0aW9uLG1pblZhbHVlLG1heFZhbHVlKXt0aGlzLnNjYWxlPVtdLG5vcm1hbGl6ZUZ1bmN0aW9uPW5vcm1hbGl6ZUZ1bmN0aW9ufHxcImxpbmVhclwiLHNjYWxlJiZ0aGlzLnNldFNjYWxlKHNjYWxlKSxub3JtYWxpemVGdW5jdGlvbiYmdGhpcy5zZXROb3JtYWxpemVGdW5jdGlvbihub3JtYWxpemVGdW5jdGlvbiksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1pblZhbHVlJiZ0aGlzLnNldE1pbihtaW5WYWx1ZSksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1heFZhbHVlJiZ0aGlzLnNldE1heChtYXhWYWx1ZSl9LGp2bS5OdW1lcmljU2NhbGUucHJvdG90eXBlPXtzZXRNaW46ZnVuY3Rpb24obWluKXt0aGlzLmNsZWFyTWluVmFsdWU9bWluLHRoaXMubWluVmFsdWU9XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5ub3JtYWxpemU/dGhpcy5ub3JtYWxpemUobWluKTptaW59LHNldE1heDpmdW5jdGlvbihtYXgpe3RoaXMuY2xlYXJNYXhWYWx1ZT1tYXgsdGhpcy5tYXhWYWx1ZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm5vcm1hbGl6ZT90aGlzLm5vcm1hbGl6ZShtYXgpOm1heH0sc2V0U2NhbGU6ZnVuY3Rpb24oc2NhbGUpe3ZhciBpO2Zvcih0aGlzLnNjYWxlPVtdLGk9MDtpPHNjYWxlLmxlbmd0aDtpKyspdGhpcy5zY2FsZVtpXT1bc2NhbGVbaV1dfSxzZXROb3JtYWxpemVGdW5jdGlvbjpmdW5jdGlvbihmKXtcInBvbHlub21pYWxcIj09PWY/dGhpcy5ub3JtYWxpemU9ZnVuY3Rpb24odmFsdWUpe3JldHVybiBNYXRoLnBvdyh2YWx1ZSwuMil9OlwibGluZWFyXCI9PT1mP2RlbGV0ZSB0aGlzLm5vcm1hbGl6ZTp0aGlzLm5vcm1hbGl6ZT1mLHRoaXMuc2V0TWluKHRoaXMuY2xlYXJNaW5WYWx1ZSksdGhpcy5zZXRNYXgodGhpcy5jbGVhck1heFZhbHVlKX0sZ2V0VmFsdWU6ZnVuY3Rpb24odmFsdWUpe3ZhciBsLGMsbGVuZ3RoZXM9W10sZnVsbExlbmd0aD0wLGk9MDtmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5ub3JtYWxpemUmJih2YWx1ZT10aGlzLm5vcm1hbGl6ZSh2YWx1ZSkpLGk9MDtpPHRoaXMuc2NhbGUubGVuZ3RoLTE7aSsrKWw9dGhpcy52ZWN0b3JMZW5ndGgodGhpcy52ZWN0b3JTdWJ0cmFjdCh0aGlzLnNjYWxlW2krMV0sdGhpcy5zY2FsZVtpXSkpLGxlbmd0aGVzLnB1c2gobCksZnVsbExlbmd0aCs9bDtmb3IoYz0odGhpcy5tYXhWYWx1ZS10aGlzLm1pblZhbHVlKS9mdWxsTGVuZ3RoLGk9MDtpPGxlbmd0aGVzLmxlbmd0aDtpKyspbGVuZ3RoZXNbaV0qPWM7Zm9yKGk9MCx2YWx1ZS09dGhpcy5taW5WYWx1ZTt2YWx1ZS1sZW5ndGhlc1tpXT49MDspdmFsdWUtPWxlbmd0aGVzW2ldLGkrKztyZXR1cm4gdmFsdWU9dGhpcy52ZWN0b3JUb051bShpPT10aGlzLnNjYWxlLmxlbmd0aC0xP3RoaXMuc2NhbGVbaV06dGhpcy52ZWN0b3JBZGQodGhpcy5zY2FsZVtpXSx0aGlzLnZlY3Rvck11bHQodGhpcy52ZWN0b3JTdWJ0cmFjdCh0aGlzLnNjYWxlW2krMV0sdGhpcy5zY2FsZVtpXSksdmFsdWUvbGVuZ3RoZXNbaV0pKSl9LHZlY3RvclRvTnVtOmZ1bmN0aW9uKHZlY3Rvcil7dmFyIGksbnVtPTA7Zm9yKGk9MDtpPHZlY3Rvci5sZW5ndGg7aSsrKW51bSs9TWF0aC5yb3VuZCh2ZWN0b3JbaV0pKk1hdGgucG93KDI1Nix2ZWN0b3IubGVuZ3RoLWktMSk7cmV0dXJuIG51bX0sdmVjdG9yU3VidHJhY3Q6ZnVuY3Rpb24odmVjdG9yMSx2ZWN0b3IyKXt2YXIgaSx2ZWN0b3I9W107Zm9yKGk9MDtpPHZlY3RvcjEubGVuZ3RoO2krKyl2ZWN0b3JbaV09dmVjdG9yMVtpXS12ZWN0b3IyW2ldO3JldHVybiB2ZWN0b3J9LHZlY3RvckFkZDpmdW5jdGlvbih2ZWN0b3IxLHZlY3RvcjIpe3ZhciBpLHZlY3Rvcj1bXTtmb3IoaT0wO2k8dmVjdG9yMS5sZW5ndGg7aSsrKXZlY3RvcltpXT12ZWN0b3IxW2ldK3ZlY3RvcjJbaV07cmV0dXJuIHZlY3Rvcn0sdmVjdG9yTXVsdDpmdW5jdGlvbih2ZWN0b3IsbnVtKXt2YXIgaSxyZXN1bHQ9W107Zm9yKGk9MDtpPHZlY3Rvci5sZW5ndGg7aSsrKXJlc3VsdFtpXT12ZWN0b3JbaV0qbnVtO3JldHVybiByZXN1bHR9LHZlY3Rvckxlbmd0aDpmdW5jdGlvbih2ZWN0b3Ipe3ZhciBpLHJlc3VsdD0wO2ZvcihpPTA7aTx2ZWN0b3IubGVuZ3RoO2krKylyZXN1bHQrPXZlY3RvcltpXSp2ZWN0b3JbaV07cmV0dXJuIE1hdGguc3FydChyZXN1bHQpfSxnZXRUaWNrczpmdW5jdGlvbigpe3ZhciB0aWNrLHYsbT01LGV4dGVudD1bdGhpcy5jbGVhck1pblZhbHVlLHRoaXMuY2xlYXJNYXhWYWx1ZV0sc3Bhbj1leHRlbnRbMV0tZXh0ZW50WzBdLHN0ZXA9TWF0aC5wb3coMTAsTWF0aC5mbG9vcihNYXRoLmxvZyhzcGFuL20pL01hdGguTE4xMCkpLGVycj1tL3NwYW4qc3RlcCx0aWNrcz1bXTtmb3IoLjE1Pj1lcnI/c3RlcCo9MTA6LjM1Pj1lcnI/c3RlcCo9NTouNzU+PWVyciYmKHN0ZXAqPTIpLGV4dGVudFswXT1NYXRoLmZsb29yKGV4dGVudFswXS9zdGVwKSpzdGVwLGV4dGVudFsxXT1NYXRoLmNlaWwoZXh0ZW50WzFdL3N0ZXApKnN0ZXAsdGljaz1leHRlbnRbMF07dGljazw9ZXh0ZW50WzFdOyl2PXRpY2s9PWV4dGVudFswXT90aGlzLmNsZWFyTWluVmFsdWU6dGljaz09ZXh0ZW50WzFdP3RoaXMuY2xlYXJNYXhWYWx1ZTp0aWNrLHRpY2tzLnB1c2goe2xhYmVsOnRpY2ssdmFsdWU6dGhpcy5nZXRWYWx1ZSh2KX0pLHRpY2srPXN0ZXA7cmV0dXJuIHRpY2tzfX0sanZtLkNvbG9yU2NhbGU9ZnVuY3Rpb24oKXtqdm0uQ29sb3JTY2FsZS5wYXJlbnRDbGFzcy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGp2bS5pbmhlcml0cyhqdm0uQ29sb3JTY2FsZSxqdm0uTnVtZXJpY1NjYWxlKSxqdm0uQ29sb3JTY2FsZS5wcm90b3R5cGUuc2V0U2NhbGU9ZnVuY3Rpb24oc2NhbGUpe3ZhciBpO2ZvcihpPTA7aTxzY2FsZS5sZW5ndGg7aSsrKXRoaXMuc2NhbGVbaV09anZtLkNvbG9yU2NhbGUucmdiVG9BcnJheShzY2FsZVtpXSl9LGp2bS5Db2xvclNjYWxlLnByb3RvdHlwZS5nZXRWYWx1ZT1mdW5jdGlvbih2YWx1ZSl7cmV0dXJuIGp2bS5Db2xvclNjYWxlLm51bVRvUmdiKGp2bS5Db2xvclNjYWxlLnBhcmVudENsYXNzLnByb3RvdHlwZS5nZXRWYWx1ZS5jYWxsKHRoaXMsdmFsdWUpKX0sanZtLkNvbG9yU2NhbGUuYXJyYXlUb1JnYj1mdW5jdGlvbihhcil7dmFyIGQsaSxyZ2I9XCIjXCI7Zm9yKGk9MDtpPGFyLmxlbmd0aDtpKyspZD1hcltpXS50b1N0cmluZygxNikscmdiKz0xPT1kLmxlbmd0aD9cIjBcIitkOmQ7cmV0dXJuIHJnYn0sanZtLkNvbG9yU2NhbGUubnVtVG9SZ2I9ZnVuY3Rpb24obnVtKXtmb3IobnVtPW51bS50b1N0cmluZygxNik7bnVtLmxlbmd0aDw2OyludW09XCIwXCIrbnVtO3JldHVyblwiI1wiK251bX0sanZtLkNvbG9yU2NhbGUucmdiVG9BcnJheT1mdW5jdGlvbihyZ2Ipe3JldHVybiByZ2I9cmdiLnN1YnN0cigxKSxbcGFyc2VJbnQocmdiLnN1YnN0cigwLDIpLDE2KSxwYXJzZUludChyZ2Iuc3Vic3RyKDIsMiksMTYpLHBhcnNlSW50KHJnYi5zdWJzdHIoNCwyKSwxNildfSxqdm0uTGVnZW5kPWZ1bmN0aW9uKHBhcmFtcyl7dGhpcy5wYXJhbXM9cGFyYW1zfHx7fSx0aGlzLm1hcD10aGlzLnBhcmFtcy5tYXAsdGhpcy5zZXJpZXM9dGhpcy5wYXJhbXMuc2VyaWVzLHRoaXMuYm9keT1qdm0uJChcIjxkaXYvPlwiKSx0aGlzLmJvZHkuYWRkQ2xhc3MoXCJqdmVjdG9ybWFwLWxlZ2VuZFwiKSx0aGlzLnBhcmFtcy5jc3NDbGFzcyYmdGhpcy5ib2R5LmFkZENsYXNzKHRoaXMucGFyYW1zLmNzc0NsYXNzKSxwYXJhbXMudmVydGljYWw/dGhpcy5tYXAubGVnZW5kQ250VmVydGljYWwuYXBwZW5kKHRoaXMuYm9keSk6dGhpcy5tYXAubGVnZW5kQ250SG9yaXpvbnRhbC5hcHBlbmQodGhpcy5ib2R5KSx0aGlzLnJlbmRlcigpfSxqdm0uTGVnZW5kLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXt2YXIgaSx0aWNrLHNhbXBsZSxsYWJlbCx0aWNrcz10aGlzLnNlcmllcy5zY2FsZS5nZXRUaWNrcygpLGlubmVyPWp2bS4kKFwiPGRpdi8+XCIpLmFkZENsYXNzKFwianZlY3Rvcm1hcC1sZWdlbmQtaW5uZXJcIik7Zm9yKHRoaXMuYm9keS5odG1sKFwiXCIpLHRoaXMucGFyYW1zLnRpdGxlJiZ0aGlzLmJvZHkuYXBwZW5kKGp2bS4kKFwiPGRpdi8+XCIpLmFkZENsYXNzKFwianZlY3Rvcm1hcC1sZWdlbmQtdGl0bGVcIikuaHRtbCh0aGlzLnBhcmFtcy50aXRsZSkpLHRoaXMuYm9keS5hcHBlbmQoaW5uZXIpLGk9MDtpPHRpY2tzLmxlbmd0aDtpKyspe3N3aXRjaCh0aWNrPWp2bS4kKFwiPGRpdi8+XCIpLmFkZENsYXNzKFwianZlY3Rvcm1hcC1sZWdlbmQtdGlja1wiKSxzYW1wbGU9anZtLiQoXCI8ZGl2Lz5cIikuYWRkQ2xhc3MoXCJqdmVjdG9ybWFwLWxlZ2VuZC10aWNrLXNhbXBsZVwiKSx0aGlzLnNlcmllcy5wYXJhbXMuYXR0cmlidXRlKXtjYXNlXCJmaWxsXCI6anZtLmlzSW1hZ2VVcmwodGlja3NbaV0udmFsdWUpP3NhbXBsZS5jc3MoXCJiYWNrZ3JvdW5kXCIsXCJ1cmwoXCIrdGlja3NbaV0udmFsdWUrXCIpXCIpOnNhbXBsZS5jc3MoXCJiYWNrZ3JvdW5kXCIsdGlja3NbaV0udmFsdWUpO2JyZWFrO2Nhc2VcInN0cm9rZVwiOnNhbXBsZS5jc3MoXCJiYWNrZ3JvdW5kXCIsdGlja3NbaV0udmFsdWUpO2JyZWFrO2Nhc2VcImltYWdlXCI6c2FtcGxlLmNzcyhcImJhY2tncm91bmRcIixcInVybChcIit0aWNrc1tpXS52YWx1ZStcIikgbm8tcmVwZWF0IGNlbnRlciBjZW50ZXJcIik7YnJlYWs7Y2FzZVwiclwiOmp2bS4kKFwiPGRpdi8+XCIpLmNzcyh7XCJib3JkZXItcmFkaXVzXCI6dGlja3NbaV0udmFsdWUsYm9yZGVyOnRoaXMubWFwLnBhcmFtcy5tYXJrZXJTdHlsZS5pbml0aWFsW1wic3Ryb2tlLXdpZHRoXCJdK1wicHggXCIrdGhpcy5tYXAucGFyYW1zLm1hcmtlclN0eWxlLmluaXRpYWwuc3Ryb2tlK1wiIHNvbGlkXCIsd2lkdGg6Mip0aWNrc1tpXS52YWx1ZStcInB4XCIsaGVpZ2h0OjIqdGlja3NbaV0udmFsdWUrXCJweFwiLGJhY2tncm91bmQ6dGhpcy5tYXAucGFyYW1zLm1hcmtlclN0eWxlLmluaXRpYWwuZmlsbH0pLmFwcGVuZFRvKHNhbXBsZSl9dGljay5hcHBlbmQoc2FtcGxlKSxsYWJlbD10aWNrc1tpXS5sYWJlbCx0aGlzLnBhcmFtcy5sYWJlbFJlbmRlciYmKGxhYmVsPXRoaXMucGFyYW1zLmxhYmVsUmVuZGVyKGxhYmVsKSksdGljay5hcHBlbmQoanZtLiQoXCI8ZGl2PlwiK2xhYmVsK1wiIDwvZGl2PlwiKS5hZGRDbGFzcyhcImp2ZWN0b3JtYXAtbGVnZW5kLXRpY2stdGV4dFwiKSksaW5uZXIuYXBwZW5kKHRpY2spfWlubmVyLmFwcGVuZChqdm0uJChcIjxkaXYvPlwiKS5jc3MoXCJjbGVhclwiLFwiYm90aFwiKSl9LGp2bS5EYXRhU2VyaWVzPWZ1bmN0aW9uKHBhcmFtcyxlbGVtZW50cyxtYXApe3ZhciBzY2FsZUNvbnN0cnVjdG9yO3BhcmFtcz1wYXJhbXN8fHt9LHBhcmFtcy5hdHRyaWJ1dGU9cGFyYW1zLmF0dHJpYnV0ZXx8XCJmaWxsXCIsdGhpcy5lbGVtZW50cz1lbGVtZW50cyx0aGlzLnBhcmFtcz1wYXJhbXMsdGhpcy5tYXA9bWFwLHBhcmFtcy5hdHRyaWJ1dGVzJiZ0aGlzLnNldEF0dHJpYnV0ZXMocGFyYW1zLmF0dHJpYnV0ZXMpLGp2bS4kLmlzQXJyYXkocGFyYW1zLnNjYWxlKT8oc2NhbGVDb25zdHJ1Y3Rvcj1cImZpbGxcIj09PXBhcmFtcy5hdHRyaWJ1dGV8fFwic3Ryb2tlXCI9PT1wYXJhbXMuYXR0cmlidXRlP2p2bS5Db2xvclNjYWxlOmp2bS5OdW1lcmljU2NhbGUsdGhpcy5zY2FsZT1uZXcgc2NhbGVDb25zdHJ1Y3RvcihwYXJhbXMuc2NhbGUscGFyYW1zLm5vcm1hbGl6ZUZ1bmN0aW9uLHBhcmFtcy5taW4scGFyYW1zLm1heCkpOnRoaXMuc2NhbGU9cGFyYW1zLnNjYWxlP25ldyBqdm0uT3JkaW5hbFNjYWxlKHBhcmFtcy5zY2FsZSk6bmV3IGp2bS5TaW1wbGVTY2FsZShwYXJhbXMuc2NhbGUpLHRoaXMudmFsdWVzPXBhcmFtcy52YWx1ZXN8fHt9LHRoaXMuc2V0VmFsdWVzKHRoaXMudmFsdWVzKSx0aGlzLnBhcmFtcy5sZWdlbmQmJih0aGlzLmxlZ2VuZD1uZXcganZtLkxlZ2VuZCgkLmV4dGVuZCh7bWFwOnRoaXMubWFwLHNlcmllczp0aGlzfSx0aGlzLnBhcmFtcy5sZWdlbmQpKSl9LGp2bS5EYXRhU2VyaWVzLnByb3RvdHlwZT17c2V0QXR0cmlidXRlczpmdW5jdGlvbihrZXksYXR0cil7dmFyIGNvZGUsYXR0cnM9a2V5O2lmKFwic3RyaW5nXCI9PXR5cGVvZiBrZXkpdGhpcy5lbGVtZW50c1trZXldJiZ0aGlzLmVsZW1lbnRzW2tleV0uc2V0U3R5bGUodGhpcy5wYXJhbXMuYXR0cmlidXRlLGF0dHIpO2Vsc2UgZm9yKGNvZGUgaW4gYXR0cnMpdGhpcy5lbGVtZW50c1tjb2RlXSYmdGhpcy5lbGVtZW50c1tjb2RlXS5lbGVtZW50LnNldFN0eWxlKHRoaXMucGFyYW1zLmF0dHJpYnV0ZSxhdHRyc1tjb2RlXSl9LHNldFZhbHVlczpmdW5jdGlvbih2YWx1ZXMpe3ZhciB2YWwsY2MsbWF4PS1OdW1iZXIuTUFYX1ZBTFVFLG1pbj1OdW1iZXIuTUFYX1ZBTFVFLGF0dHJzPXt9O2lmKHRoaXMuc2NhbGUgaW5zdGFuY2VvZiBqdm0uT3JkaW5hbFNjYWxlfHx0aGlzLnNjYWxlIGluc3RhbmNlb2YganZtLlNpbXBsZVNjYWxlKWZvcihjYyBpbiB2YWx1ZXMpYXR0cnNbY2NdPXZhbHVlc1tjY10/dGhpcy5zY2FsZS5nZXRWYWx1ZSh2YWx1ZXNbY2NdKTp0aGlzLmVsZW1lbnRzW2NjXS5lbGVtZW50LnN0eWxlLmluaXRpYWxbdGhpcy5wYXJhbXMuYXR0cmlidXRlXTtlbHNle2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiB0aGlzLnBhcmFtcy5taW58fFwidW5kZWZpbmVkXCI9PXR5cGVvZiB0aGlzLnBhcmFtcy5tYXgpZm9yKGNjIGluIHZhbHVlcyl2YWw9cGFyc2VGbG9hdCh2YWx1ZXNbY2NdKSx2YWw+bWF4JiYobWF4PXZhbCksbWluPnZhbCYmKG1pbj12YWwpO1widW5kZWZpbmVkXCI9PXR5cGVvZiB0aGlzLnBhcmFtcy5taW4/KHRoaXMuc2NhbGUuc2V0TWluKG1pbiksdGhpcy5wYXJhbXMubWluPW1pbik6dGhpcy5zY2FsZS5zZXRNaW4odGhpcy5wYXJhbXMubWluKSxcInVuZGVmaW5lZFwiPT10eXBlb2YgdGhpcy5wYXJhbXMubWF4Pyh0aGlzLnNjYWxlLnNldE1heChtYXgpLHRoaXMucGFyYW1zLm1heD1tYXgpOnRoaXMuc2NhbGUuc2V0TWF4KHRoaXMucGFyYW1zLm1heCk7Zm9yKGNjIGluIHZhbHVlcylcImluZGV4T2ZcIiE9Y2MmJih2YWw9cGFyc2VGbG9hdCh2YWx1ZXNbY2NdKSxhdHRyc1tjY109aXNOYU4odmFsKT90aGlzLmVsZW1lbnRzW2NjXS5lbGVtZW50LnN0eWxlLmluaXRpYWxbdGhpcy5wYXJhbXMuYXR0cmlidXRlXTp0aGlzLnNjYWxlLmdldFZhbHVlKHZhbCkpfXRoaXMuc2V0QXR0cmlidXRlcyhhdHRycyksanZtLiQuZXh0ZW5kKHRoaXMudmFsdWVzLHZhbHVlcyl9LGNsZWFyOmZ1bmN0aW9uKCl7dmFyIGtleSxhdHRycz17fTtmb3Ioa2V5IGluIHRoaXMudmFsdWVzKXRoaXMuZWxlbWVudHNba2V5XSYmKGF0dHJzW2tleV09dGhpcy5lbGVtZW50c1trZXldLmVsZW1lbnQuc2hhcGUuc3R5bGUuaW5pdGlhbFt0aGlzLnBhcmFtcy5hdHRyaWJ1dGVdKTt0aGlzLnNldEF0dHJpYnV0ZXMoYXR0cnMpLHRoaXMudmFsdWVzPXt9fSxzZXRTY2FsZTpmdW5jdGlvbihzY2FsZSl7dGhpcy5zY2FsZS5zZXRTY2FsZShzY2FsZSksdGhpcy52YWx1ZXMmJnRoaXMuc2V0VmFsdWVzKHRoaXMudmFsdWVzKX0sc2V0Tm9ybWFsaXplRnVuY3Rpb246ZnVuY3Rpb24oZil7dGhpcy5zY2FsZS5zZXROb3JtYWxpemVGdW5jdGlvbihmKSx0aGlzLnZhbHVlcyYmdGhpcy5zZXRWYWx1ZXModGhpcy52YWx1ZXMpfX0sanZtLlByb2o9e2RlZ1JhZDoxODAvTWF0aC5QSSxyYWREZWc6TWF0aC5QSS8xODAscmFkaXVzOjYzODEzNzIsc2duOmZ1bmN0aW9uKG4pe3JldHVybiBuPjA/MTowPm4/LTE6bn0sbWlsbDpmdW5jdGlvbihsYXQsbG5nLGMpe3JldHVybnt4OnRoaXMucmFkaXVzKihsbmctYykqdGhpcy5yYWREZWcseTotdGhpcy5yYWRpdXMqTWF0aC5sb2coTWF0aC50YW4oKDQ1Ky40KmxhdCkqdGhpcy5yYWREZWcpKS8uOH19LG1pbGxfaW52OmZ1bmN0aW9uKHgseSxjKXtyZXR1cm57bGF0OigyLjUqTWF0aC5hdGFuKE1hdGguZXhwKC44KnkvdGhpcy5yYWRpdXMpKS01Kk1hdGguUEkvOCkqdGhpcy5kZWdSYWQsbG5nOihjKnRoaXMucmFkRGVnK3gvdGhpcy5yYWRpdXMpKnRoaXMuZGVnUmFkfX0sbWVyYzpmdW5jdGlvbihsYXQsbG5nLGMpe3JldHVybnt4OnRoaXMucmFkaXVzKihsbmctYykqdGhpcy5yYWREZWcseTotdGhpcy5yYWRpdXMqTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSS80K2xhdCpNYXRoLlBJLzM2MCkpfX0sbWVyY19pbnY6ZnVuY3Rpb24oeCx5LGMpe3JldHVybntsYXQ6KDIqTWF0aC5hdGFuKE1hdGguZXhwKHkvdGhpcy5yYWRpdXMpKS1NYXRoLlBJLzIpKnRoaXMuZGVnUmFkLGxuZzooYyp0aGlzLnJhZERlZyt4L3RoaXMucmFkaXVzKSp0aGlzLmRlZ1JhZH19LGFlYTpmdW5jdGlvbihsYXQsbG5nLGMpe3ZhciBmaTA9MCxsYW1iZGEwPWMqdGhpcy5yYWREZWcsZmkxPTI5LjUqdGhpcy5yYWREZWcsZmkyPTQ1LjUqdGhpcy5yYWREZWcsZmk9bGF0KnRoaXMucmFkRGVnLGxhbWJkYT1sbmcqdGhpcy5yYWREZWcsbj0oTWF0aC5zaW4oZmkxKStNYXRoLnNpbihmaTIpKS8yLEM9TWF0aC5jb3MoZmkxKSpNYXRoLmNvcyhmaTEpKzIqbipNYXRoLnNpbihmaTEpLHRoZXRhPW4qKGxhbWJkYS1sYW1iZGEwKSxybz1NYXRoLnNxcnQoQy0yKm4qTWF0aC5zaW4oZmkpKS9uLHJvMD1NYXRoLnNxcnQoQy0yKm4qTWF0aC5zaW4oZmkwKSkvbjtyZXR1cm57eDpybypNYXRoLnNpbih0aGV0YSkqdGhpcy5yYWRpdXMseTotKHJvMC1ybypNYXRoLmNvcyh0aGV0YSkpKnRoaXMucmFkaXVzfX0sYWVhX2ludjpmdW5jdGlvbih4Q29vcmQseUNvb3JkLGMpe3ZhciB4PXhDb29yZC90aGlzLnJhZGl1cyx5PXlDb29yZC90aGlzLnJhZGl1cyxmaTA9MCxsYW1iZGEwPWMqdGhpcy5yYWREZWcsZmkxPTI5LjUqdGhpcy5yYWREZWcsZmkyPTQ1LjUqdGhpcy5yYWREZWcsbj0oTWF0aC5zaW4oZmkxKStNYXRoLnNpbihmaTIpKS8yLEM9TWF0aC5jb3MoZmkxKSpNYXRoLmNvcyhmaTEpKzIqbipNYXRoLnNpbihmaTEpLHJvMD1NYXRoLnNxcnQoQy0yKm4qTWF0aC5zaW4oZmkwKSkvbixybz1NYXRoLnNxcnQoeCp4KyhybzAteSkqKHJvMC15KSksdGhldGE9TWF0aC5hdGFuKHgvKHJvMC15KSk7cmV0dXJue2xhdDpNYXRoLmFzaW4oKEMtcm8qcm8qbipuKS8oMipuKSkqdGhpcy5kZWdSYWQsbG5nOihsYW1iZGEwK3RoZXRhL24pKnRoaXMuZGVnUmFkfX0sbGNjOmZ1bmN0aW9uKGxhdCxsbmcsYyl7dmFyIGZpMD0wLGxhbWJkYTA9Yyp0aGlzLnJhZERlZyxsYW1iZGE9bG5nKnRoaXMucmFkRGVnLGZpMT0zMyp0aGlzLnJhZERlZyxmaTI9NDUqdGhpcy5yYWREZWcsZmk9bGF0KnRoaXMucmFkRGVnLG49TWF0aC5sb2coTWF0aC5jb3MoZmkxKSooMS9NYXRoLmNvcyhmaTIpKSkvTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSS80K2ZpMi8yKSooMS9NYXRoLnRhbihNYXRoLlBJLzQrZmkxLzIpKSksRj1NYXRoLmNvcyhmaTEpKk1hdGgucG93KE1hdGgudGFuKE1hdGguUEkvNCtmaTEvMiksbikvbixybz1GKk1hdGgucG93KDEvTWF0aC50YW4oTWF0aC5QSS80K2ZpLzIpLG4pLHJvMD1GKk1hdGgucG93KDEvTWF0aC50YW4oTWF0aC5QSS80K2ZpMC8yKSxuKTtyZXR1cm57eDpybypNYXRoLnNpbihuKihsYW1iZGEtbGFtYmRhMCkpKnRoaXMucmFkaXVzLHk6LShybzAtcm8qTWF0aC5jb3MobioobGFtYmRhLWxhbWJkYTApKSkqdGhpcy5yYWRpdXN9fSxsY2NfaW52OmZ1bmN0aW9uKHhDb29yZCx5Q29vcmQsYyl7dmFyIHg9eENvb3JkL3RoaXMucmFkaXVzLHk9eUNvb3JkL3RoaXMucmFkaXVzLGZpMD0wLGxhbWJkYTA9Yyp0aGlzLnJhZERlZyxmaTE9MzMqdGhpcy5yYWREZWcsZmkyPTQ1KnRoaXMucmFkRGVnLG49TWF0aC5sb2coTWF0aC5jb3MoZmkxKSooMS9NYXRoLmNvcyhmaTIpKSkvTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSS80K2ZpMi8yKSooMS9NYXRoLnRhbihNYXRoLlBJLzQrZmkxLzIpKSksRj1NYXRoLmNvcyhmaTEpKk1hdGgucG93KE1hdGgudGFuKE1hdGguUEkvNCtmaTEvMiksbikvbixybzA9RipNYXRoLnBvdygxL01hdGgudGFuKE1hdGguUEkvNCtmaTAvMiksbikscm89dGhpcy5zZ24obikqTWF0aC5zcXJ0KHgqeCsocm8wLXkpKihybzAteSkpLHRoZXRhPU1hdGguYXRhbih4LyhybzAteSkpO3JldHVybntsYXQ6KDIqTWF0aC5hdGFuKE1hdGgucG93KEYvcm8sMS9uKSktTWF0aC5QSS8yKSp0aGlzLmRlZ1JhZCxsbmc6KGxhbWJkYTArdGhldGEvbikqdGhpcy5kZWdSYWR9fX0sanZtLk1hcE9iamVjdD1mdW5jdGlvbigpe30sanZtLk1hcE9iamVjdC5wcm90b3R5cGUuZ2V0TGFiZWxUZXh0PWZ1bmN0aW9uKGtleSl7dmFyIHRleHQ7cmV0dXJuIHRleHQ9dGhpcy5jb25maWcubGFiZWw/XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5jb25maWcubGFiZWwucmVuZGVyP3RoaXMuY29uZmlnLmxhYmVsLnJlbmRlcihrZXkpOmtleTpudWxsfSxqdm0uTWFwT2JqZWN0LnByb3RvdHlwZS5nZXRMYWJlbE9mZnNldHM9ZnVuY3Rpb24oa2V5KXt2YXIgb2Zmc2V0cztyZXR1cm4gdGhpcy5jb25maWcubGFiZWwmJihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLmNvbmZpZy5sYWJlbC5vZmZzZXRzP29mZnNldHM9dGhpcy5jb25maWcubGFiZWwub2Zmc2V0cyhrZXkpOlwib2JqZWN0XCI9PXR5cGVvZiB0aGlzLmNvbmZpZy5sYWJlbC5vZmZzZXRzJiYob2Zmc2V0cz10aGlzLmNvbmZpZy5sYWJlbC5vZmZzZXRzW2tleV0pKSxvZmZzZXRzfHxbMCwwXX0sanZtLk1hcE9iamVjdC5wcm90b3R5cGUuc2V0SG92ZXJlZD1mdW5jdGlvbihpc0hvdmVyZWQpe3RoaXMuaXNIb3ZlcmVkIT09aXNIb3ZlcmVkJiYodGhpcy5pc0hvdmVyZWQ9aXNIb3ZlcmVkLHRoaXMuc2hhcGUuaXNIb3ZlcmVkPWlzSG92ZXJlZCx0aGlzLnNoYXBlLnVwZGF0ZVN0eWxlKCksdGhpcy5sYWJlbCYmKHRoaXMubGFiZWwuaXNIb3ZlcmVkPWlzSG92ZXJlZCx0aGlzLmxhYmVsLnVwZGF0ZVN0eWxlKCkpKX0sanZtLk1hcE9iamVjdC5wcm90b3R5cGUuc2V0U2VsZWN0ZWQ9ZnVuY3Rpb24oaXNTZWxlY3RlZCl7dGhpcy5pc1NlbGVjdGVkIT09aXNTZWxlY3RlZCYmKHRoaXMuaXNTZWxlY3RlZD1pc1NlbGVjdGVkLHRoaXMuc2hhcGUuaXNTZWxlY3RlZD1pc1NlbGVjdGVkLHRoaXMuc2hhcGUudXBkYXRlU3R5bGUoKSx0aGlzLmxhYmVsJiYodGhpcy5sYWJlbC5pc1NlbGVjdGVkPWlzU2VsZWN0ZWQsdGhpcy5sYWJlbC51cGRhdGVTdHlsZSgpKSxqdm0uJCh0aGlzLnNoYXBlKS50cmlnZ2VyKFwic2VsZWN0ZWRcIixbaXNTZWxlY3RlZF0pKX0sanZtLk1hcE9iamVjdC5wcm90b3R5cGUuc2V0U3R5bGU9ZnVuY3Rpb24oKXt0aGlzLnNoYXBlLnNldFN0eWxlLmFwcGx5KHRoaXMuc2hhcGUsYXJndW1lbnRzKX0sanZtLk1hcE9iamVjdC5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7dGhpcy5zaGFwZS5yZW1vdmUoKSx0aGlzLmxhYmVsJiZ0aGlzLmxhYmVsLnJlbW92ZSgpfSxqdm0uUmVnaW9uPWZ1bmN0aW9uKGNvbmZpZyl7dmFyIGJib3gsdGV4dCxvZmZzZXRzO3RoaXMuY29uZmlnPWNvbmZpZyx0aGlzLm1hcD10aGlzLmNvbmZpZy5tYXAsdGhpcy5zaGFwZT1jb25maWcuY2FudmFzLmFkZFBhdGgoe2Q6Y29uZmlnLnBhdGgsXCJkYXRhLWNvZGVcIjpjb25maWcuY29kZX0sY29uZmlnLnN0eWxlLGNvbmZpZy5jYW52YXMucm9vdEVsZW1lbnQpLHRoaXMuc2hhcGUuYWRkQ2xhc3MoXCJqdmVjdG9ybWFwLXJlZ2lvbiBqdmVjdG9ybWFwLWVsZW1lbnRcIiksYmJveD10aGlzLnNoYXBlLmdldEJCb3goKSx0ZXh0PXRoaXMuZ2V0TGFiZWxUZXh0KGNvbmZpZy5jb2RlKSxcbnRoaXMuY29uZmlnLmxhYmVsJiZ0ZXh0JiYob2Zmc2V0cz10aGlzLmdldExhYmVsT2Zmc2V0cyhjb25maWcuY29kZSksdGhpcy5sYWJlbFg9YmJveC54K2Jib3gud2lkdGgvMitvZmZzZXRzWzBdLHRoaXMubGFiZWxZPWJib3gueStiYm94LmhlaWdodC8yK29mZnNldHNbMV0sdGhpcy5sYWJlbD1jb25maWcuY2FudmFzLmFkZFRleHQoe3RleHQ6dGV4dCxcInRleHQtYW5jaG9yXCI6XCJtaWRkbGVcIixcImFsaWdubWVudC1iYXNlbGluZVwiOlwiY2VudHJhbFwiLHg6dGhpcy5sYWJlbFgseTp0aGlzLmxhYmVsWSxcImRhdGEtY29kZVwiOmNvbmZpZy5jb2RlfSxjb25maWcubGFiZWxTdHlsZSxjb25maWcubGFiZWxzR3JvdXApLHRoaXMubGFiZWwuYWRkQ2xhc3MoXCJqdmVjdG9ybWFwLXJlZ2lvbiBqdmVjdG9ybWFwLWVsZW1lbnRcIikpfSxqdm0uaW5oZXJpdHMoanZtLlJlZ2lvbixqdm0uTWFwT2JqZWN0KSxqdm0uUmVnaW9uLnByb3RvdHlwZS51cGRhdGVMYWJlbFBvc2l0aW9uPWZ1bmN0aW9uKCl7dGhpcy5sYWJlbCYmdGhpcy5sYWJlbC5zZXQoe3g6dGhpcy5sYWJlbFgqdGhpcy5tYXAuc2NhbGUrdGhpcy5tYXAudHJhbnNYKnRoaXMubWFwLnNjYWxlLHk6dGhpcy5sYWJlbFkqdGhpcy5tYXAuc2NhbGUrdGhpcy5tYXAudHJhbnNZKnRoaXMubWFwLnNjYWxlfSl9LGp2bS5NYXJrZXI9ZnVuY3Rpb24oY29uZmlnKXt2YXIgdGV4dDt0aGlzLmNvbmZpZz1jb25maWcsdGhpcy5tYXA9dGhpcy5jb25maWcubWFwLHRoaXMuaXNJbWFnZT0hIXRoaXMuY29uZmlnLnN0eWxlLmluaXRpYWwuaW1hZ2UsdGhpcy5jcmVhdGVTaGFwZSgpLHRleHQ9dGhpcy5nZXRMYWJlbFRleHQoY29uZmlnLmluZGV4KSx0aGlzLmNvbmZpZy5sYWJlbCYmdGV4dCYmKHRoaXMub2Zmc2V0cz10aGlzLmdldExhYmVsT2Zmc2V0cyhjb25maWcuaW5kZXgpLHRoaXMubGFiZWxYPWNvbmZpZy5jeC90aGlzLm1hcC5zY2FsZS10aGlzLm1hcC50cmFuc1gsdGhpcy5sYWJlbFk9Y29uZmlnLmN5L3RoaXMubWFwLnNjYWxlLXRoaXMubWFwLnRyYW5zWSx0aGlzLmxhYmVsPWNvbmZpZy5jYW52YXMuYWRkVGV4dCh7dGV4dDp0ZXh0LFwiZGF0YS1pbmRleFwiOmNvbmZpZy5pbmRleCxkeTpcIjAuNmV4XCIseDp0aGlzLmxhYmVsWCx5OnRoaXMubGFiZWxZfSxjb25maWcubGFiZWxTdHlsZSxjb25maWcubGFiZWxzR3JvdXApLHRoaXMubGFiZWwuYWRkQ2xhc3MoXCJqdmVjdG9ybWFwLW1hcmtlciBqdmVjdG9ybWFwLWVsZW1lbnRcIikpfSxqdm0uaW5oZXJpdHMoanZtLk1hcmtlcixqdm0uTWFwT2JqZWN0KSxqdm0uTWFya2VyLnByb3RvdHlwZS5jcmVhdGVTaGFwZT1mdW5jdGlvbigpe3ZhciB0aGF0PXRoaXM7dGhpcy5zaGFwZSYmdGhpcy5zaGFwZS5yZW1vdmUoKSx0aGlzLnNoYXBlPXRoaXMuY29uZmlnLmNhbnZhc1t0aGlzLmlzSW1hZ2U/XCJhZGRJbWFnZVwiOlwiYWRkQ2lyY2xlXCJdKHtcImRhdGEtaW5kZXhcIjp0aGlzLmNvbmZpZy5pbmRleCxjeDp0aGlzLmNvbmZpZy5jeCxjeTp0aGlzLmNvbmZpZy5jeX0sdGhpcy5jb25maWcuc3R5bGUsdGhpcy5jb25maWcuZ3JvdXApLHRoaXMuc2hhcGUuYWRkQ2xhc3MoXCJqdmVjdG9ybWFwLW1hcmtlciBqdmVjdG9ybWFwLWVsZW1lbnRcIiksdGhpcy5pc0ltYWdlJiZqdm0uJCh0aGlzLnNoYXBlLm5vZGUpLm9uKFwiaW1hZ2Vsb2FkZWRcIixmdW5jdGlvbigpe3RoYXQudXBkYXRlTGFiZWxQb3NpdGlvbigpfSl9LGp2bS5NYXJrZXIucHJvdG90eXBlLnVwZGF0ZUxhYmVsUG9zaXRpb249ZnVuY3Rpb24oKXt0aGlzLmxhYmVsJiZ0aGlzLmxhYmVsLnNldCh7eDp0aGlzLmxhYmVsWCp0aGlzLm1hcC5zY2FsZSt0aGlzLm9mZnNldHNbMF0rdGhpcy5tYXAudHJhbnNYKnRoaXMubWFwLnNjYWxlKzUrKHRoaXMuaXNJbWFnZT8odGhpcy5zaGFwZS53aWR0aHx8MCkvMjp0aGlzLnNoYXBlLnByb3BlcnRpZXMucikseTp0aGlzLmxhYmVsWSp0aGlzLm1hcC5zY2FsZSt0aGlzLm1hcC50cmFuc1kqdGhpcy5tYXAuc2NhbGUrdGhpcy5vZmZzZXRzWzFdfSl9LGp2bS5NYXJrZXIucHJvdG90eXBlLnNldFN0eWxlPWZ1bmN0aW9uKHByb3BlcnR5KXt2YXIgaXNJbWFnZTtqdm0uTWFya2VyLnBhcmVudENsYXNzLnByb3RvdHlwZS5zZXRTdHlsZS5hcHBseSh0aGlzLGFyZ3VtZW50cyksXCJyXCI9PT1wcm9wZXJ0eSYmdGhpcy51cGRhdGVMYWJlbFBvc2l0aW9uKCksaXNJbWFnZT0hIXRoaXMuc2hhcGUuZ2V0KFwiaW1hZ2VcIiksaXNJbWFnZSE9dGhpcy5pc0ltYWdlJiYodGhpcy5pc0ltYWdlPWlzSW1hZ2UsdGhpcy5jb25maWcuc3R5bGU9anZtLiQuZXh0ZW5kKCEwLHt9LHRoaXMuc2hhcGUuc3R5bGUpLHRoaXMuY3JlYXRlU2hhcGUoKSl9LGp2bS5NYXA9ZnVuY3Rpb24ocGFyYW1zKXt2YXIgZSxtYXA9dGhpcztpZih0aGlzLnBhcmFtcz1qdm0uJC5leHRlbmQoITAse30sanZtLk1hcC5kZWZhdWx0UGFyYW1zLHBhcmFtcyksIWp2bS5NYXAubWFwc1t0aGlzLnBhcmFtcy5tYXBdKXRocm93IG5ldyBFcnJvcihcIkF0dGVtcHQgdG8gdXNlIG1hcCB3aGljaCB3YXMgbm90IGxvYWRlZDogXCIrdGhpcy5wYXJhbXMubWFwKTt0aGlzLm1hcERhdGE9anZtLk1hcC5tYXBzW3RoaXMucGFyYW1zLm1hcF0sdGhpcy5tYXJrZXJzPXt9LHRoaXMucmVnaW9ucz17fSx0aGlzLnJlZ2lvbnNDb2xvcnM9e30sdGhpcy5yZWdpb25zRGF0YT17fSx0aGlzLmNvbnRhaW5lcj1qdm0uJChcIjxkaXY+XCIpLmFkZENsYXNzKFwianZlY3Rvcm1hcC1jb250YWluZXJcIiksdGhpcy5wYXJhbXMuY29udGFpbmVyJiZ0aGlzLnBhcmFtcy5jb250YWluZXIuYXBwZW5kKHRoaXMuY29udGFpbmVyKSx0aGlzLmNvbnRhaW5lci5kYXRhKFwibWFwT2JqZWN0XCIsdGhpcyksdGhpcy5kZWZhdWx0V2lkdGg9dGhpcy5tYXBEYXRhLndpZHRoLHRoaXMuZGVmYXVsdEhlaWdodD10aGlzLm1hcERhdGEuaGVpZ2h0LHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKHRoaXMucGFyYW1zLmJhY2tncm91bmRDb2xvciksdGhpcy5vblJlc2l6ZT1mdW5jdGlvbigpe21hcC51cGRhdGVTaXplKCl9LGp2bS4kKHdpbmRvdykucmVzaXplKHRoaXMub25SZXNpemUpO2ZvcihlIGluIGp2bS5NYXAuYXBpRXZlbnRzKXRoaXMucGFyYW1zW2VdJiZ0aGlzLmNvbnRhaW5lci5iaW5kKGp2bS5NYXAuYXBpRXZlbnRzW2VdK1wiLmp2ZWN0b3JtYXBcIix0aGlzLnBhcmFtc1tlXSk7dGhpcy5jYW52YXM9bmV3IGp2bS5WZWN0b3JDYW52YXModGhpcy5jb250YWluZXJbMF0sdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5wYXJhbXMuYmluZFRvdWNoRXZlbnRzJiYoXCJvbnRvdWNoc3RhcnRcImluIHdpbmRvd3x8d2luZG93LkRvY3VtZW50VG91Y2gmJmRvY3VtZW50IGluc3RhbmNlb2YgRG9jdW1lbnRUb3VjaD90aGlzLmJpbmRDb250YWluZXJUb3VjaEV2ZW50cygpOndpbmRvdy5NU0dlc3R1cmUmJnRoaXMuYmluZENvbnRhaW5lclBvaW50ZXJFdmVudHMoKSksdGhpcy5iaW5kQ29udGFpbmVyRXZlbnRzKCksdGhpcy5iaW5kRWxlbWVudEV2ZW50cygpLHRoaXMuY3JlYXRlVGlwKCksdGhpcy5wYXJhbXMuem9vbUJ1dHRvbnMmJnRoaXMuYmluZFpvb21CdXR0b25zKCksdGhpcy5jcmVhdGVSZWdpb25zKCksdGhpcy5jcmVhdGVNYXJrZXJzKHRoaXMucGFyYW1zLm1hcmtlcnN8fHt9KSx0aGlzLnVwZGF0ZVNpemUoKSx0aGlzLnBhcmFtcy5mb2N1c09uJiYoXCJzdHJpbmdcIj09dHlwZW9mIHRoaXMucGFyYW1zLmZvY3VzT24/dGhpcy5wYXJhbXMuZm9jdXNPbj17cmVnaW9uOnRoaXMucGFyYW1zLmZvY3VzT259Omp2bS4kLmlzQXJyYXkodGhpcy5wYXJhbXMuZm9jdXNPbikmJih0aGlzLnBhcmFtcy5mb2N1c09uPXtyZWdpb25zOnRoaXMucGFyYW1zLmZvY3VzT259KSx0aGlzLnNldEZvY3VzKHRoaXMucGFyYW1zLmZvY3VzT24pKSx0aGlzLnBhcmFtcy5zZWxlY3RlZFJlZ2lvbnMmJnRoaXMuc2V0U2VsZWN0ZWRSZWdpb25zKHRoaXMucGFyYW1zLnNlbGVjdGVkUmVnaW9ucyksdGhpcy5wYXJhbXMuc2VsZWN0ZWRNYXJrZXJzJiZ0aGlzLnNldFNlbGVjdGVkTWFya2Vycyh0aGlzLnBhcmFtcy5zZWxlY3RlZE1hcmtlcnMpLHRoaXMubGVnZW5kQ250SG9yaXpvbnRhbD1qdm0uJChcIjxkaXYvPlwiKS5hZGRDbGFzcyhcImp2ZWN0b3JtYXAtbGVnZW5kLWNudCBqdmVjdG9ybWFwLWxlZ2VuZC1jbnQtaFwiKSx0aGlzLmxlZ2VuZENudFZlcnRpY2FsPWp2bS4kKFwiPGRpdi8+XCIpLmFkZENsYXNzKFwianZlY3Rvcm1hcC1sZWdlbmQtY250IGp2ZWN0b3JtYXAtbGVnZW5kLWNudC12XCIpLHRoaXMuY29udGFpbmVyLmFwcGVuZCh0aGlzLmxlZ2VuZENudEhvcml6b250YWwpLHRoaXMuY29udGFpbmVyLmFwcGVuZCh0aGlzLmxlZ2VuZENudFZlcnRpY2FsKSx0aGlzLnBhcmFtcy5zZXJpZXMmJnRoaXMuY3JlYXRlU2VyaWVzKCl9LGp2bS5NYXAucHJvdG90eXBlPXt0cmFuc1g6MCx0cmFuc1k6MCxzY2FsZToxLGJhc2VUcmFuc1g6MCxiYXNlVHJhbnNZOjAsYmFzZVNjYWxlOjEsd2lkdGg6MCxoZWlnaHQ6MCxzZXRCYWNrZ3JvdW5kQ29sb3I6ZnVuY3Rpb24oYmFja2dyb3VuZENvbG9yKXt0aGlzLmNvbnRhaW5lci5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsYmFja2dyb3VuZENvbG9yKX0scmVzaXplOmZ1bmN0aW9uKCl7dmFyIGN1ckJhc2VTY2FsZT10aGlzLmJhc2VTY2FsZTt0aGlzLndpZHRoL3RoaXMuaGVpZ2h0PnRoaXMuZGVmYXVsdFdpZHRoL3RoaXMuZGVmYXVsdEhlaWdodD8odGhpcy5iYXNlU2NhbGU9dGhpcy5oZWlnaHQvdGhpcy5kZWZhdWx0SGVpZ2h0LHRoaXMuYmFzZVRyYW5zWD1NYXRoLmFicyh0aGlzLndpZHRoLXRoaXMuZGVmYXVsdFdpZHRoKnRoaXMuYmFzZVNjYWxlKS8oMip0aGlzLmJhc2VTY2FsZSkpOih0aGlzLmJhc2VTY2FsZT10aGlzLndpZHRoL3RoaXMuZGVmYXVsdFdpZHRoLHRoaXMuYmFzZVRyYW5zWT1NYXRoLmFicyh0aGlzLmhlaWdodC10aGlzLmRlZmF1bHRIZWlnaHQqdGhpcy5iYXNlU2NhbGUpLygyKnRoaXMuYmFzZVNjYWxlKSksdGhpcy5zY2FsZSo9dGhpcy5iYXNlU2NhbGUvY3VyQmFzZVNjYWxlLHRoaXMudHJhbnNYKj10aGlzLmJhc2VTY2FsZS9jdXJCYXNlU2NhbGUsdGhpcy50cmFuc1kqPXRoaXMuYmFzZVNjYWxlL2N1ckJhc2VTY2FsZX0sdXBkYXRlU2l6ZTpmdW5jdGlvbigpe3RoaXMud2lkdGg9dGhpcy5jb250YWluZXIud2lkdGgoKSx0aGlzLmhlaWdodD10aGlzLmNvbnRhaW5lci5oZWlnaHQoKSx0aGlzLnJlc2l6ZSgpLHRoaXMuY2FudmFzLnNldFNpemUodGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5hcHBseVRyYW5zZm9ybSgpfSxyZXNldDpmdW5jdGlvbigpe3ZhciBrZXksaTtmb3Ioa2V5IGluIHRoaXMuc2VyaWVzKWZvcihpPTA7aTx0aGlzLnNlcmllc1trZXldLmxlbmd0aDtpKyspdGhpcy5zZXJpZXNba2V5XVtpXS5jbGVhcigpO3RoaXMuc2NhbGU9dGhpcy5iYXNlU2NhbGUsdGhpcy50cmFuc1g9dGhpcy5iYXNlVHJhbnNYLHRoaXMudHJhbnNZPXRoaXMuYmFzZVRyYW5zWSx0aGlzLmFwcGx5VHJhbnNmb3JtKCl9LGFwcGx5VHJhbnNmb3JtOmZ1bmN0aW9uKCl7dmFyIG1heFRyYW5zWCxtYXhUcmFuc1ksbWluVHJhbnNYLG1pblRyYW5zWTt0aGlzLmRlZmF1bHRXaWR0aCp0aGlzLnNjYWxlPD10aGlzLndpZHRoPyhtYXhUcmFuc1g9KHRoaXMud2lkdGgtdGhpcy5kZWZhdWx0V2lkdGgqdGhpcy5zY2FsZSkvKDIqdGhpcy5zY2FsZSksbWluVHJhbnNYPSh0aGlzLndpZHRoLXRoaXMuZGVmYXVsdFdpZHRoKnRoaXMuc2NhbGUpLygyKnRoaXMuc2NhbGUpKToobWF4VHJhbnNYPTAsbWluVHJhbnNYPSh0aGlzLndpZHRoLXRoaXMuZGVmYXVsdFdpZHRoKnRoaXMuc2NhbGUpL3RoaXMuc2NhbGUpLHRoaXMuZGVmYXVsdEhlaWdodCp0aGlzLnNjYWxlPD10aGlzLmhlaWdodD8obWF4VHJhbnNZPSh0aGlzLmhlaWdodC10aGlzLmRlZmF1bHRIZWlnaHQqdGhpcy5zY2FsZSkvKDIqdGhpcy5zY2FsZSksbWluVHJhbnNZPSh0aGlzLmhlaWdodC10aGlzLmRlZmF1bHRIZWlnaHQqdGhpcy5zY2FsZSkvKDIqdGhpcy5zY2FsZSkpOihtYXhUcmFuc1k9MCxtaW5UcmFuc1k9KHRoaXMuaGVpZ2h0LXRoaXMuZGVmYXVsdEhlaWdodCp0aGlzLnNjYWxlKS90aGlzLnNjYWxlKSx0aGlzLnRyYW5zWT5tYXhUcmFuc1k/dGhpcy50cmFuc1k9bWF4VHJhbnNZOnRoaXMudHJhbnNZPG1pblRyYW5zWSYmKHRoaXMudHJhbnNZPW1pblRyYW5zWSksdGhpcy50cmFuc1g+bWF4VHJhbnNYP3RoaXMudHJhbnNYPW1heFRyYW5zWDp0aGlzLnRyYW5zWDxtaW5UcmFuc1gmJih0aGlzLnRyYW5zWD1taW5UcmFuc1gpLHRoaXMuY2FudmFzLmFwcGx5VHJhbnNmb3JtUGFyYW1zKHRoaXMuc2NhbGUsdGhpcy50cmFuc1gsdGhpcy50cmFuc1kpLHRoaXMubWFya2VycyYmdGhpcy5yZXBvc2l0aW9uTWFya2VycygpLHRoaXMucmVwb3NpdGlvbkxhYmVscygpLHRoaXMuY29udGFpbmVyLnRyaWdnZXIoXCJ2aWV3cG9ydENoYW5nZVwiLFt0aGlzLnNjYWxlL3RoaXMuYmFzZVNjYWxlLHRoaXMudHJhbnNYLHRoaXMudHJhbnNZXSl9LGJpbmRDb250YWluZXJFdmVudHM6ZnVuY3Rpb24oKXt2YXIgb2xkUGFnZVgsb2xkUGFnZVksbW91c2VEb3duPSExLG1hcD10aGlzO3RoaXMucGFyYW1zLnBhbk9uRHJhZyYmKHRoaXMuY29udGFpbmVyLm1vdXNlbW92ZShmdW5jdGlvbihlKXtyZXR1cm4gbW91c2VEb3duJiYobWFwLnRyYW5zWC09KG9sZFBhZ2VYLWUucGFnZVgpL21hcC5zY2FsZSxtYXAudHJhbnNZLT0ob2xkUGFnZVktZS5wYWdlWSkvbWFwLnNjYWxlLG1hcC5hcHBseVRyYW5zZm9ybSgpLG9sZFBhZ2VYPWUucGFnZVgsb2xkUGFnZVk9ZS5wYWdlWSksITF9KS5tb3VzZWRvd24oZnVuY3Rpb24oZSl7cmV0dXJuIG1vdXNlRG93bj0hMCxvbGRQYWdlWD1lLnBhZ2VYLG9sZFBhZ2VZPWUucGFnZVksITF9KSx0aGlzLm9uQ29udGFpbmVyTW91c2VVcD1mdW5jdGlvbigpe21vdXNlRG93bj0hMX0sanZtLiQoXCJib2R5XCIpLm1vdXNldXAodGhpcy5vbkNvbnRhaW5lck1vdXNlVXApKSx0aGlzLnBhcmFtcy56b29tT25TY3JvbGwmJnRoaXMuY29udGFpbmVyLm1vdXNld2hlZWwoZnVuY3Rpb24oZXZlbnQpe3ZhciBvZmZzZXQ9anZtLiQobWFwLmNvbnRhaW5lcikub2Zmc2V0KCksY2VudGVyWD1ldmVudC5wYWdlWC1vZmZzZXQubGVmdCxjZW50ZXJZPWV2ZW50LnBhZ2VZLW9mZnNldC50b3Asem9vbVN0ZXA9TWF0aC5wb3coMSttYXAucGFyYW1zLnpvb21PblNjcm9sbFNwZWVkLzFlMyxldmVudC5kZWx0YUZhY3RvcipldmVudC5kZWx0YVkpO21hcC50aXAuaGlkZSgpLG1hcC5zZXRTY2FsZShtYXAuc2NhbGUqem9vbVN0ZXAsY2VudGVyWCxjZW50ZXJZKSxldmVudC5wcmV2ZW50RGVmYXVsdCgpfSl9LGJpbmRDb250YWluZXJUb3VjaEV2ZW50czpmdW5jdGlvbigpe3ZhciB0b3VjaFN0YXJ0U2NhbGUsdG91Y2hTdGFydERpc3RhbmNlLHRvdWNoWCx0b3VjaFksY2VudGVyVG91Y2hYLGNlbnRlclRvdWNoWSxsYXN0VG91Y2hlc0xlbmd0aCxtYXA9dGhpcyxoYW5kbGVUb3VjaEV2ZW50PWZ1bmN0aW9uKGUpe3ZhciBvZmZzZXQsc2NhbGUsdHJhbnNYT2xkLHRyYW5zWU9sZCx0b3VjaGVzPWUub3JpZ2luYWxFdmVudC50b3VjaGVzO1widG91Y2hzdGFydFwiPT1lLnR5cGUmJihsYXN0VG91Y2hlc0xlbmd0aD0wKSwxPT10b3VjaGVzLmxlbmd0aD8oMT09bGFzdFRvdWNoZXNMZW5ndGgmJih0cmFuc1hPbGQ9bWFwLnRyYW5zWCx0cmFuc1lPbGQ9bWFwLnRyYW5zWSxtYXAudHJhbnNYLT0odG91Y2hYLXRvdWNoZXNbMF0ucGFnZVgpL21hcC5zY2FsZSxtYXAudHJhbnNZLT0odG91Y2hZLXRvdWNoZXNbMF0ucGFnZVkpL21hcC5zY2FsZSxtYXAuYXBwbHlUcmFuc2Zvcm0oKSxtYXAudGlwLmhpZGUoKSwodHJhbnNYT2xkIT1tYXAudHJhbnNYfHx0cmFuc1lPbGQhPW1hcC50cmFuc1kpJiZlLnByZXZlbnREZWZhdWx0KCkpLHRvdWNoWD10b3VjaGVzWzBdLnBhZ2VYLHRvdWNoWT10b3VjaGVzWzBdLnBhZ2VZKToyPT10b3VjaGVzLmxlbmd0aCYmKDI9PWxhc3RUb3VjaGVzTGVuZ3RoPyhzY2FsZT1NYXRoLnNxcnQoTWF0aC5wb3codG91Y2hlc1swXS5wYWdlWC10b3VjaGVzWzFdLnBhZ2VYLDIpK01hdGgucG93KHRvdWNoZXNbMF0ucGFnZVktdG91Y2hlc1sxXS5wYWdlWSwyKSkvdG91Y2hTdGFydERpc3RhbmNlLG1hcC5zZXRTY2FsZSh0b3VjaFN0YXJ0U2NhbGUqc2NhbGUsY2VudGVyVG91Y2hYLGNlbnRlclRvdWNoWSksbWFwLnRpcC5oaWRlKCksZS5wcmV2ZW50RGVmYXVsdCgpKToob2Zmc2V0PWp2bS4kKG1hcC5jb250YWluZXIpLm9mZnNldCgpLGNlbnRlclRvdWNoWD10b3VjaGVzWzBdLnBhZ2VYPnRvdWNoZXNbMV0ucGFnZVg/dG91Y2hlc1sxXS5wYWdlWCsodG91Y2hlc1swXS5wYWdlWC10b3VjaGVzWzFdLnBhZ2VYKS8yOnRvdWNoZXNbMF0ucGFnZVgrKHRvdWNoZXNbMV0ucGFnZVgtdG91Y2hlc1swXS5wYWdlWCkvMixjZW50ZXJUb3VjaFk9dG91Y2hlc1swXS5wYWdlWT50b3VjaGVzWzFdLnBhZ2VZP3RvdWNoZXNbMV0ucGFnZVkrKHRvdWNoZXNbMF0ucGFnZVktdG91Y2hlc1sxXS5wYWdlWSkvMjp0b3VjaGVzWzBdLnBhZ2VZKyh0b3VjaGVzWzFdLnBhZ2VZLXRvdWNoZXNbMF0ucGFnZVkpLzIsY2VudGVyVG91Y2hYLT1vZmZzZXQubGVmdCxjZW50ZXJUb3VjaFktPW9mZnNldC50b3AsdG91Y2hTdGFydFNjYWxlPW1hcC5zY2FsZSx0b3VjaFN0YXJ0RGlzdGFuY2U9TWF0aC5zcXJ0KE1hdGgucG93KHRvdWNoZXNbMF0ucGFnZVgtdG91Y2hlc1sxXS5wYWdlWCwyKStNYXRoLnBvdyh0b3VjaGVzWzBdLnBhZ2VZLXRvdWNoZXNbMV0ucGFnZVksMikpKSksbGFzdFRvdWNoZXNMZW5ndGg9dG91Y2hlcy5sZW5ndGh9O2p2bS4kKHRoaXMuY29udGFpbmVyKS5iaW5kKFwidG91Y2hzdGFydFwiLGhhbmRsZVRvdWNoRXZlbnQpLGp2bS4kKHRoaXMuY29udGFpbmVyKS5iaW5kKFwidG91Y2htb3ZlXCIsaGFuZGxlVG91Y2hFdmVudCl9LGJpbmRDb250YWluZXJQb2ludGVyRXZlbnRzOmZ1bmN0aW9uKCl7dmFyIG1hcD10aGlzLGdlc3R1cmU9bmV3IE1TR2VzdHVyZSxlbGVtZW50PXRoaXMuY29udGFpbmVyWzBdLGhhbmRsZVBvaW50ZXJEb3duRXZlbnQ9ZnVuY3Rpb24oZSl7Z2VzdHVyZS5hZGRQb2ludGVyKGUucG9pbnRlcklkKX0saGFuZGxlR2VzdHVyZUV2ZW50PWZ1bmN0aW9uKGUpe3ZhciB0cmFuc1hPbGQsdHJhbnNZT2xkOygwIT1lLnRyYW5zbGF0aW9uWHx8MCE9ZS50cmFuc2xhdGlvblkpJiYodHJhbnNYT2xkPW1hcC50cmFuc1gsdHJhbnNZT2xkPW1hcC50cmFuc1ksbWFwLnRyYW5zWCs9ZS50cmFuc2xhdGlvblgvbWFwLnNjYWxlLG1hcC50cmFuc1krPWUudHJhbnNsYXRpb25ZL21hcC5zY2FsZSxtYXAuYXBwbHlUcmFuc2Zvcm0oKSxtYXAudGlwLmhpZGUoKSwodHJhbnNYT2xkIT1tYXAudHJhbnNYfHx0cmFuc1lPbGQhPW1hcC50cmFuc1kpJiZlLnByZXZlbnREZWZhdWx0KCkpLDEhPWUuc2NhbGUmJihtYXAuc2V0U2NhbGUobWFwLnNjYWxlKmUuc2NhbGUsZS5vZmZzZXRYLGUub2Zmc2V0WSksbWFwLnRpcC5oaWRlKCksZS5wcmV2ZW50RGVmYXVsdCgpKX07Z2VzdHVyZS50YXJnZXQ9ZWxlbWVudCxlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJNU0dlc3R1cmVDaGFuZ2VcIixoYW5kbGVHZXN0dXJlRXZlbnQsITEpLGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsaGFuZGxlUG9pbnRlckRvd25FdmVudCwhMSl9LGJpbmRFbGVtZW50RXZlbnRzOmZ1bmN0aW9uKCl7dmFyIHBhZ2VYLHBhZ2VZLG1vdXNlTW92ZWQsbWFwPXRoaXM7dGhpcy5jb250YWluZXIubW91c2Vtb3ZlKGZ1bmN0aW9uKGUpe01hdGguYWJzKHBhZ2VYLWUucGFnZVgpK01hdGguYWJzKHBhZ2VZLWUucGFnZVkpPjImJihtb3VzZU1vdmVkPSEwKX0pLHRoaXMuY29udGFpbmVyLmRlbGVnYXRlKFwiW2NsYXNzfj0nanZlY3Rvcm1hcC1lbGVtZW50J11cIixcIm1vdXNlb3ZlciBtb3VzZW91dFwiLGZ1bmN0aW9uKGUpe3ZhciBiYXNlVmFsPWp2bS4kKHRoaXMpLmF0dHIoXCJjbGFzc1wiKS5iYXNlVmFsfHxqdm0uJCh0aGlzKS5hdHRyKFwiY2xhc3NcIiksdHlwZT0tMT09PWJhc2VWYWwuaW5kZXhPZihcImp2ZWN0b3JtYXAtcmVnaW9uXCIpP1wibWFya2VyXCI6XCJyZWdpb25cIixjb2RlPWp2bS4kKHRoaXMpLmF0dHIoXCJyZWdpb25cIj09dHlwZT9cImRhdGEtY29kZVwiOlwiZGF0YS1pbmRleFwiKSxlbGVtZW50PVwicmVnaW9uXCI9PXR5cGU/bWFwLnJlZ2lvbnNbY29kZV0uZWxlbWVudDptYXAubWFya2Vyc1tjb2RlXS5lbGVtZW50LHRpcFRleHQ9XCJyZWdpb25cIj09dHlwZT9tYXAubWFwRGF0YS5wYXRoc1tjb2RlXS5uYW1lOm1hcC5tYXJrZXJzW2NvZGVdLmNvbmZpZy5uYW1lfHxcIlwiLHRpcFNob3dFdmVudD1qdm0uJC5FdmVudCh0eXBlK1wiVGlwU2hvdy5qdmVjdG9ybWFwXCIpLG92ZXJFdmVudD1qdm0uJC5FdmVudCh0eXBlK1wiT3Zlci5qdmVjdG9ybWFwXCIpO1wibW91c2VvdmVyXCI9PWUudHlwZT8obWFwLmNvbnRhaW5lci50cmlnZ2VyKG92ZXJFdmVudCxbY29kZV0pLG92ZXJFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8ZWxlbWVudC5zZXRIb3ZlcmVkKCEwKSxtYXAudGlwLnRleHQodGlwVGV4dCksbWFwLmNvbnRhaW5lci50cmlnZ2VyKHRpcFNob3dFdmVudCxbbWFwLnRpcCxjb2RlXSksdGlwU2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpfHwobWFwLnRpcC5zaG93KCksbWFwLnRpcFdpZHRoPW1hcC50aXAud2lkdGgoKSxtYXAudGlwSGVpZ2h0PW1hcC50aXAuaGVpZ2h0KCkpKTooZWxlbWVudC5zZXRIb3ZlcmVkKCExKSxtYXAudGlwLmhpZGUoKSxtYXAuY29udGFpbmVyLnRyaWdnZXIodHlwZStcIk91dC5qdmVjdG9ybWFwXCIsW2NvZGVdKSl9KSx0aGlzLmNvbnRhaW5lci5kZWxlZ2F0ZShcIltjbGFzc349J2p2ZWN0b3JtYXAtZWxlbWVudCddXCIsXCJtb3VzZWRvd25cIixmdW5jdGlvbihlKXtwYWdlWD1lLnBhZ2VYLHBhZ2VZPWUucGFnZVksbW91c2VNb3ZlZD0hMX0pLHRoaXMuY29udGFpbmVyLmRlbGVnYXRlKFwiW2NsYXNzfj0nanZlY3Rvcm1hcC1lbGVtZW50J11cIixcIm1vdXNldXBcIixmdW5jdGlvbigpe3ZhciBiYXNlVmFsPWp2bS4kKHRoaXMpLmF0dHIoXCJjbGFzc1wiKS5iYXNlVmFsP2p2bS4kKHRoaXMpLmF0dHIoXCJjbGFzc1wiKS5iYXNlVmFsOmp2bS4kKHRoaXMpLmF0dHIoXCJjbGFzc1wiKSx0eXBlPS0xPT09YmFzZVZhbC5pbmRleE9mKFwianZlY3Rvcm1hcC1yZWdpb25cIik/XCJtYXJrZXJcIjpcInJlZ2lvblwiLGNvZGU9anZtLiQodGhpcykuYXR0cihcInJlZ2lvblwiPT10eXBlP1wiZGF0YS1jb2RlXCI6XCJkYXRhLWluZGV4XCIpLGNsaWNrRXZlbnQ9anZtLiQuRXZlbnQodHlwZStcIkNsaWNrLmp2ZWN0b3JtYXBcIiksZWxlbWVudD1cInJlZ2lvblwiPT10eXBlP21hcC5yZWdpb25zW2NvZGVdLmVsZW1lbnQ6bWFwLm1hcmtlcnNbY29kZV0uZWxlbWVudDttb3VzZU1vdmVkfHwobWFwLmNvbnRhaW5lci50cmlnZ2VyKGNsaWNrRXZlbnQsW2NvZGVdKSwoXCJyZWdpb25cIj09PXR5cGUmJm1hcC5wYXJhbXMucmVnaW9uc1NlbGVjdGFibGV8fFwibWFya2VyXCI9PT10eXBlJiZtYXAucGFyYW1zLm1hcmtlcnNTZWxlY3RhYmxlKSYmKGNsaWNrRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCl8fChtYXAucGFyYW1zW3R5cGUrXCJzU2VsZWN0YWJsZU9uZVwiXSYmbWFwLmNsZWFyU2VsZWN0ZWQodHlwZStcInNcIiksZWxlbWVudC5zZXRTZWxlY3RlZCghZWxlbWVudC5pc1NlbGVjdGVkKSkpKX0pfSxiaW5kWm9vbUJ1dHRvbnM6ZnVuY3Rpb24oKXt2YXIgbWFwPXRoaXM7anZtLiQoXCI8ZGl2Lz5cIikuYWRkQ2xhc3MoXCJqdmVjdG9ybWFwLXpvb21pblwiKS50ZXh0KFwiK1wiKS5hcHBlbmRUbyh0aGlzLmNvbnRhaW5lciksanZtLiQoXCI8ZGl2Lz5cIikuYWRkQ2xhc3MoXCJqdmVjdG9ybWFwLXpvb21vdXRcIikuaHRtbChcIiYjeDIyMTI7XCIpLmFwcGVuZFRvKHRoaXMuY29udGFpbmVyKSx0aGlzLmNvbnRhaW5lci5maW5kKFwiLmp2ZWN0b3JtYXAtem9vbWluXCIpLmNsaWNrKGZ1bmN0aW9uKCl7bWFwLnNldFNjYWxlKG1hcC5zY2FsZSptYXAucGFyYW1zLnpvb21TdGVwLG1hcC53aWR0aC8yLG1hcC5oZWlnaHQvMiwhMSxtYXAucGFyYW1zLnpvb21BbmltYXRlKX0pLHRoaXMuY29udGFpbmVyLmZpbmQoXCIuanZlY3Rvcm1hcC16b29tb3V0XCIpLmNsaWNrKGZ1bmN0aW9uKCl7bWFwLnNldFNjYWxlKG1hcC5zY2FsZS9tYXAucGFyYW1zLnpvb21TdGVwLG1hcC53aWR0aC8yLG1hcC5oZWlnaHQvMiwhMSxtYXAucGFyYW1zLnpvb21BbmltYXRlKX0pfSxjcmVhdGVUaXA6ZnVuY3Rpb24oKXt2YXIgbWFwPXRoaXM7dGhpcy50aXA9anZtLiQoXCI8ZGl2Lz5cIikuYWRkQ2xhc3MoXCJqdmVjdG9ybWFwLXRpcFwiKS5hcHBlbmRUbyhqdm0uJChcImJvZHlcIikpLHRoaXMuY29udGFpbmVyLm1vdXNlbW92ZShmdW5jdGlvbihlKXt2YXIgbGVmdD1lLnBhZ2VYLTE1LW1hcC50aXBXaWR0aCx0b3A9ZS5wYWdlWS0xNS1tYXAudGlwSGVpZ2h0OzU+bGVmdCYmKGxlZnQ9ZS5wYWdlWCsxNSksNT50b3AmJih0b3A9ZS5wYWdlWSsxNSksbWFwLnRpcC5jc3Moe2xlZnQ6bGVmdCx0b3A6dG9wfSl9KX0sc2V0U2NhbGU6ZnVuY3Rpb24oc2NhbGUsYW5jaG9yWCxhbmNob3JZLGlzQ2VudGVyZWQsYW5pbWF0ZSl7dmFyIGludGVydmFsLHNjYWxlU3RhcnQsc2NhbGVEaWZmLHRyYW5zWFN0YXJ0LHRyYW5zWERpZmYsdHJhbnNZU3RhcnQsdHJhbnNZRGlmZix0cmFuc1gsdHJhbnNZLHZpZXdwb3J0Q2hhbmdlRXZlbnQ9anZtLiQuRXZlbnQoXCJ6b29tLmp2ZWN0b3JtYXBcIiksdGhhdD10aGlzLGk9MCxjb3VudD1NYXRoLmFicyhNYXRoLnJvdW5kKDYwKihzY2FsZS10aGlzLnNjYWxlKS9NYXRoLm1heChzY2FsZSx0aGlzLnNjYWxlKSkpLGRlZmVycmVkPW5ldyBqdm0uJC5EZWZlcnJlZDtyZXR1cm4gc2NhbGU+dGhpcy5wYXJhbXMuem9vbU1heCp0aGlzLmJhc2VTY2FsZT9zY2FsZT10aGlzLnBhcmFtcy56b29tTWF4KnRoaXMuYmFzZVNjYWxlOnNjYWxlPHRoaXMucGFyYW1zLnpvb21NaW4qdGhpcy5iYXNlU2NhbGUmJihzY2FsZT10aGlzLnBhcmFtcy56b29tTWluKnRoaXMuYmFzZVNjYWxlKSxcInVuZGVmaW5lZFwiIT10eXBlb2YgYW5jaG9yWCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGFuY2hvclkmJih6b29tU3RlcD1zY2FsZS90aGlzLnNjYWxlLGlzQ2VudGVyZWQ/KHRyYW5zWD1hbmNob3JYK3RoaXMuZGVmYXVsdFdpZHRoKih0aGlzLndpZHRoLyh0aGlzLmRlZmF1bHRXaWR0aCpzY2FsZSkpLzIsdHJhbnNZPWFuY2hvclkrdGhpcy5kZWZhdWx0SGVpZ2h0Kih0aGlzLmhlaWdodC8odGhpcy5kZWZhdWx0SGVpZ2h0KnNjYWxlKSkvMik6KHRyYW5zWD10aGlzLnRyYW5zWC0oem9vbVN0ZXAtMSkvc2NhbGUqYW5jaG9yWCx0cmFuc1k9dGhpcy50cmFuc1ktKHpvb21TdGVwLTEpL3NjYWxlKmFuY2hvclkpKSxhbmltYXRlJiZjb3VudD4wPyhzY2FsZVN0YXJ0PXRoaXMuc2NhbGUsc2NhbGVEaWZmPShzY2FsZS1zY2FsZVN0YXJ0KS9jb3VudCx0cmFuc1hTdGFydD10aGlzLnRyYW5zWCp0aGlzLnNjYWxlLHRyYW5zWVN0YXJ0PXRoaXMudHJhbnNZKnRoaXMuc2NhbGUsdHJhbnNYRGlmZj0odHJhbnNYKnNjYWxlLXRyYW5zWFN0YXJ0KS9jb3VudCx0cmFuc1lEaWZmPSh0cmFuc1kqc2NhbGUtdHJhbnNZU3RhcnQpL2NvdW50LGludGVydmFsPXNldEludGVydmFsKGZ1bmN0aW9uKCl7aSs9MSx0aGF0LnNjYWxlPXNjYWxlU3RhcnQrc2NhbGVEaWZmKmksdGhhdC50cmFuc1g9KHRyYW5zWFN0YXJ0K3RyYW5zWERpZmYqaSkvdGhhdC5zY2FsZSx0aGF0LnRyYW5zWT0odHJhbnNZU3RhcnQrdHJhbnNZRGlmZippKS90aGF0LnNjYWxlLHRoYXQuYXBwbHlUcmFuc2Zvcm0oKSxpPT1jb3VudCYmKGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpLHRoYXQuY29udGFpbmVyLnRyaWdnZXIodmlld3BvcnRDaGFuZ2VFdmVudCxbc2NhbGUvdGhhdC5iYXNlU2NhbGVdKSxkZWZlcnJlZC5yZXNvbHZlKCkpfSwxMCkpOih0aGlzLnRyYW5zWD10cmFuc1gsdGhpcy50cmFuc1k9dHJhbnNZLHRoaXMuc2NhbGU9c2NhbGUsdGhpcy5hcHBseVRyYW5zZm9ybSgpLHRoaXMuY29udGFpbmVyLnRyaWdnZXIodmlld3BvcnRDaGFuZ2VFdmVudCxbc2NhbGUvdGhpcy5iYXNlU2NhbGVdKSxkZWZlcnJlZC5yZXNvbHZlKCkpLGRlZmVycmVkfSxzZXRGb2N1czpmdW5jdGlvbihjb25maWcpe3ZhciBiYm94LGl0ZW1CYm94LG5ld0Jib3gsY29kZXMsaSxwb2ludDtpZihjb25maWc9Y29uZmlnfHx7fSxjb25maWcucmVnaW9uP2NvZGVzPVtjb25maWcucmVnaW9uXTpjb25maWcucmVnaW9ucyYmKGNvZGVzPWNvbmZpZy5yZWdpb25zKSxjb2Rlcyl7Zm9yKGk9MDtpPGNvZGVzLmxlbmd0aDtpKyspdGhpcy5yZWdpb25zW2NvZGVzW2ldXSYmKGl0ZW1CYm94PXRoaXMucmVnaW9uc1tjb2Rlc1tpXV0uZWxlbWVudC5zaGFwZS5nZXRCQm94KCksaXRlbUJib3gmJihcInVuZGVmaW5lZFwiPT10eXBlb2YgYmJveD9iYm94PWl0ZW1CYm94OihuZXdCYm94PXt4Ok1hdGgubWluKGJib3gueCxpdGVtQmJveC54KSx5Ok1hdGgubWluKGJib3gueSxpdGVtQmJveC55KSx3aWR0aDpNYXRoLm1heChiYm94LngrYmJveC53aWR0aCxpdGVtQmJveC54K2l0ZW1CYm94LndpZHRoKS1NYXRoLm1pbihiYm94LngsaXRlbUJib3gueCksaGVpZ2h0Ok1hdGgubWF4KGJib3gueStiYm94LmhlaWdodCxpdGVtQmJveC55K2l0ZW1CYm94LmhlaWdodCktTWF0aC5taW4oYmJveC55LGl0ZW1CYm94LnkpfSxiYm94PW5ld0Jib3gpKSk7cmV0dXJuIHRoaXMuc2V0U2NhbGUoTWF0aC5taW4odGhpcy53aWR0aC9iYm94LndpZHRoLHRoaXMuaGVpZ2h0L2Jib3guaGVpZ2h0KSwtKGJib3gueCtiYm94LndpZHRoLzIpLC0oYmJveC55K2Jib3guaGVpZ2h0LzIpLCEwLGNvbmZpZy5hbmltYXRlKX1yZXR1cm4gY29uZmlnLmxhdCYmY29uZmlnLmxuZz8ocG9pbnQ9dGhpcy5sYXRMbmdUb1BvaW50KGNvbmZpZy5sYXQsY29uZmlnLmxuZyksY29uZmlnLng9dGhpcy50cmFuc1gtcG9pbnQueC90aGlzLnNjYWxlLGNvbmZpZy55PXRoaXMudHJhbnNZLXBvaW50LnkvdGhpcy5zY2FsZSk6Y29uZmlnLngmJmNvbmZpZy55JiYoY29uZmlnLngqPS10aGlzLmRlZmF1bHRXaWR0aCxjb25maWcueSo9LXRoaXMuZGVmYXVsdEhlaWdodCksdGhpcy5zZXRTY2FsZShjb25maWcuc2NhbGUqdGhpcy5iYXNlU2NhbGUsY29uZmlnLngsY29uZmlnLnksITAsY29uZmlnLmFuaW1hdGUpfSxnZXRTZWxlY3RlZDpmdW5jdGlvbih0eXBlKXt2YXIga2V5LHNlbGVjdGVkPVtdO2ZvcihrZXkgaW4gdGhpc1t0eXBlXSl0aGlzW3R5cGVdW2tleV0uZWxlbWVudC5pc1NlbGVjdGVkJiZzZWxlY3RlZC5wdXNoKGtleSk7cmV0dXJuIHNlbGVjdGVkfSxnZXRTZWxlY3RlZFJlZ2lvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRTZWxlY3RlZChcInJlZ2lvbnNcIil9LGdldFNlbGVjdGVkTWFya2VyczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFNlbGVjdGVkKFwibWFya2Vyc1wiKX0sc2V0U2VsZWN0ZWQ6ZnVuY3Rpb24odHlwZSxrZXlzKXt2YXIgaTtpZihcIm9iamVjdFwiIT10eXBlb2Yga2V5cyYmKGtleXM9W2tleXNdKSxqdm0uJC5pc0FycmF5KGtleXMpKWZvcihpPTA7aTxrZXlzLmxlbmd0aDtpKyspdGhpc1t0eXBlXVtrZXlzW2ldXS5lbGVtZW50LnNldFNlbGVjdGVkKCEwKTtlbHNlIGZvcihpIGluIGtleXMpdGhpc1t0eXBlXVtpXS5lbGVtZW50LnNldFNlbGVjdGVkKCEha2V5c1tpXSl9LHNldFNlbGVjdGVkUmVnaW9uczpmdW5jdGlvbihrZXlzKXt0aGlzLnNldFNlbGVjdGVkKFwicmVnaW9uc1wiLGtleXMpfSxzZXRTZWxlY3RlZE1hcmtlcnM6ZnVuY3Rpb24oa2V5cyl7dGhpcy5zZXRTZWxlY3RlZChcIm1hcmtlcnNcIixrZXlzKX0sY2xlYXJTZWxlY3RlZDpmdW5jdGlvbih0eXBlKXt2YXIgaSxzZWxlY3Q9e30sc2VsZWN0ZWQ9dGhpcy5nZXRTZWxlY3RlZCh0eXBlKTtmb3IoaT0wO2k8c2VsZWN0ZWQubGVuZ3RoO2krKylzZWxlY3Rbc2VsZWN0ZWRbaV1dPSExO3RoaXMuc2V0U2VsZWN0ZWQodHlwZSxzZWxlY3QpfSxjbGVhclNlbGVjdGVkUmVnaW9uczpmdW5jdGlvbigpe3RoaXMuY2xlYXJTZWxlY3RlZChcInJlZ2lvbnNcIil9LGNsZWFyU2VsZWN0ZWRNYXJrZXJzOmZ1bmN0aW9uKCl7dGhpcy5jbGVhclNlbGVjdGVkKFwibWFya2Vyc1wiKX0sZ2V0TWFwT2JqZWN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LGdldFJlZ2lvbk5hbWU6ZnVuY3Rpb24oY29kZSl7cmV0dXJuIHRoaXMubWFwRGF0YS5wYXRoc1tjb2RlXS5uYW1lfSxjcmVhdGVSZWdpb25zOmZ1bmN0aW9uKCl7dmFyIGtleSxyZWdpb24sbWFwPXRoaXM7dGhpcy5yZWdpb25MYWJlbHNHcm91cD10aGlzLnJlZ2lvbkxhYmVsc0dyb3VwfHx0aGlzLmNhbnZhcy5hZGRHcm91cCgpO2ZvcihrZXkgaW4gdGhpcy5tYXBEYXRhLnBhdGhzKXJlZ2lvbj1uZXcganZtLlJlZ2lvbih7bWFwOnRoaXMscGF0aDp0aGlzLm1hcERhdGEucGF0aHNba2V5XS5wYXRoLGNvZGU6a2V5LHN0eWxlOmp2bS4kLmV4dGVuZCghMCx7fSx0aGlzLnBhcmFtcy5yZWdpb25TdHlsZSksbGFiZWxTdHlsZTpqdm0uJC5leHRlbmQoITAse30sdGhpcy5wYXJhbXMucmVnaW9uTGFiZWxTdHlsZSksY2FudmFzOnRoaXMuY2FudmFzLGxhYmVsc0dyb3VwOnRoaXMucmVnaW9uTGFiZWxzR3JvdXAsbGFiZWw6XCJ2bWxcIiE9dGhpcy5jYW52YXMubW9kZT90aGlzLnBhcmFtcy5sYWJlbHMmJnRoaXMucGFyYW1zLmxhYmVscy5yZWdpb25zOm51bGx9KSxqdm0uJChyZWdpb24uc2hhcGUpLmJpbmQoXCJzZWxlY3RlZFwiLGZ1bmN0aW9uKGUsaXNTZWxlY3RlZCl7bWFwLmNvbnRhaW5lci50cmlnZ2VyKFwicmVnaW9uU2VsZWN0ZWQuanZlY3Rvcm1hcFwiLFtqdm0uJCh0aGlzLm5vZGUpLmF0dHIoXCJkYXRhLWNvZGVcIiksaXNTZWxlY3RlZCxtYXAuZ2V0U2VsZWN0ZWRSZWdpb25zKCldKX0pLHRoaXMucmVnaW9uc1trZXldPXtlbGVtZW50OnJlZ2lvbixjb25maWc6dGhpcy5tYXBEYXRhLnBhdGhzW2tleV19fSxjcmVhdGVNYXJrZXJzOmZ1bmN0aW9uKG1hcmtlcnMpe3ZhciBpLG1hcmtlcixwb2ludCxtYXJrZXJDb25maWcsbWFya2Vyc0FycmF5LG1hcD10aGlzO2lmKHRoaXMubWFya2Vyc0dyb3VwPXRoaXMubWFya2Vyc0dyb3VwfHx0aGlzLmNhbnZhcy5hZGRHcm91cCgpLHRoaXMubWFya2VyTGFiZWxzR3JvdXA9dGhpcy5tYXJrZXJMYWJlbHNHcm91cHx8dGhpcy5jYW52YXMuYWRkR3JvdXAoKSxqdm0uJC5pc0FycmF5KG1hcmtlcnMpKWZvcihtYXJrZXJzQXJyYXk9bWFya2Vycy5zbGljZSgpLG1hcmtlcnM9e30saT0wO2k8bWFya2Vyc0FycmF5Lmxlbmd0aDtpKyspbWFya2Vyc1tpXT1tYXJrZXJzQXJyYXlbaV07Zm9yKGkgaW4gbWFya2VycyltYXJrZXJDb25maWc9bWFya2Vyc1tpXWluc3RhbmNlb2YgQXJyYXk/e2xhdExuZzptYXJrZXJzW2ldfTptYXJrZXJzW2ldLHBvaW50PXRoaXMuZ2V0TWFya2VyUG9zaXRpb24obWFya2VyQ29uZmlnKSxwb2ludCE9PSExJiYobWFya2VyPW5ldyBqdm0uTWFya2VyKHttYXA6dGhpcyxzdHlsZTpqdm0uJC5leHRlbmQoITAse30sdGhpcy5wYXJhbXMubWFya2VyU3R5bGUse2luaXRpYWw6bWFya2VyQ29uZmlnLnN0eWxlfHx7fX0pLGxhYmVsU3R5bGU6anZtLiQuZXh0ZW5kKCEwLHt9LHRoaXMucGFyYW1zLm1hcmtlckxhYmVsU3R5bGUpLGluZGV4OmksY3g6cG9pbnQueCxjeTpwb2ludC55LGdyb3VwOnRoaXMubWFya2Vyc0dyb3VwLGNhbnZhczp0aGlzLmNhbnZhcyxsYWJlbHNHcm91cDp0aGlzLm1hcmtlckxhYmVsc0dyb3VwLGxhYmVsOlwidm1sXCIhPXRoaXMuY2FudmFzLm1vZGU/dGhpcy5wYXJhbXMubGFiZWxzJiZ0aGlzLnBhcmFtcy5sYWJlbHMubWFya2VyczpudWxsfSksanZtLiQobWFya2VyLnNoYXBlKS5iaW5kKFwic2VsZWN0ZWRcIixmdW5jdGlvbihlLGlzU2VsZWN0ZWQpe21hcC5jb250YWluZXIudHJpZ2dlcihcIm1hcmtlclNlbGVjdGVkLmp2ZWN0b3JtYXBcIixbanZtLiQodGhpcy5ub2RlKS5hdHRyKFwiZGF0YS1pbmRleFwiKSxpc1NlbGVjdGVkLG1hcC5nZXRTZWxlY3RlZE1hcmtlcnMoKV0pfSksdGhpcy5tYXJrZXJzW2ldJiZ0aGlzLnJlbW92ZU1hcmtlcnMoW2ldKSx0aGlzLm1hcmtlcnNbaV09e2VsZW1lbnQ6bWFya2VyLGNvbmZpZzptYXJrZXJDb25maWd9KX0scmVwb3NpdGlvbk1hcmtlcnM6ZnVuY3Rpb24oKXt2YXIgaSxwb2ludDtmb3IoaSBpbiB0aGlzLm1hcmtlcnMpcG9pbnQ9dGhpcy5nZXRNYXJrZXJQb3NpdGlvbih0aGlzLm1hcmtlcnNbaV0uY29uZmlnKSxwb2ludCE9PSExJiZ0aGlzLm1hcmtlcnNbaV0uZWxlbWVudC5zZXRTdHlsZSh7Y3g6cG9pbnQueCxjeTpwb2ludC55fSl9LHJlcG9zaXRpb25MYWJlbHM6ZnVuY3Rpb24oKXt2YXIga2V5O2ZvcihrZXkgaW4gdGhpcy5yZWdpb25zKXRoaXMucmVnaW9uc1trZXldLmVsZW1lbnQudXBkYXRlTGFiZWxQb3NpdGlvbigpO2ZvcihrZXkgaW4gdGhpcy5tYXJrZXJzKXRoaXMubWFya2Vyc1trZXldLmVsZW1lbnQudXBkYXRlTGFiZWxQb3NpdGlvbigpfSxnZXRNYXJrZXJQb3NpdGlvbjpmdW5jdGlvbihtYXJrZXJDb25maWcpe3JldHVybiBqdm0uTWFwLm1hcHNbdGhpcy5wYXJhbXMubWFwXS5wcm9qZWN0aW9uP3RoaXMubGF0TG5nVG9Qb2ludC5hcHBseSh0aGlzLG1hcmtlckNvbmZpZy5sYXRMbmd8fFswLDBdKTp7eDptYXJrZXJDb25maWcuY29vcmRzWzBdKnRoaXMuc2NhbGUrdGhpcy50cmFuc1gqdGhpcy5zY2FsZSx5Om1hcmtlckNvbmZpZy5jb29yZHNbMV0qdGhpcy5zY2FsZSt0aGlzLnRyYW5zWSp0aGlzLnNjYWxlfX0sYWRkTWFya2VyOmZ1bmN0aW9uKGtleSxtYXJrZXIsc2VyaWVzRGF0YSl7dmFyIHZhbHVlcyxpLG1hcmtlcnM9e30sZGF0YT1bXSxzZXJpZXNEYXRhPXNlcmllc0RhdGF8fFtdO2ZvcihtYXJrZXJzW2tleV09bWFya2VyLGk9MDtpPHNlcmllc0RhdGEubGVuZ3RoO2krKyl2YWx1ZXM9e30sXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlcmllc0RhdGFbaV0mJih2YWx1ZXNba2V5XT1zZXJpZXNEYXRhW2ldKSxkYXRhLnB1c2godmFsdWVzKTt0aGlzLmFkZE1hcmtlcnMobWFya2VycyxkYXRhKX0sYWRkTWFya2VyczpmdW5jdGlvbihtYXJrZXJzLHNlcmllc0RhdGEpe3ZhciBpO2ZvcihzZXJpZXNEYXRhPXNlcmllc0RhdGF8fFtdLHRoaXMuY3JlYXRlTWFya2VycyhtYXJrZXJzKSxpPTA7aTxzZXJpZXNEYXRhLmxlbmd0aDtpKyspdGhpcy5zZXJpZXMubWFya2Vyc1tpXS5zZXRWYWx1ZXMoc2VyaWVzRGF0YVtpXXx8e30pfSxyZW1vdmVNYXJrZXJzOmZ1bmN0aW9uKG1hcmtlcnMpe3ZhciBpO2ZvcihpPTA7aTxtYXJrZXJzLmxlbmd0aDtpKyspdGhpcy5tYXJrZXJzW21hcmtlcnNbaV1dLmVsZW1lbnQucmVtb3ZlKCksZGVsZXRlIHRoaXMubWFya2Vyc1ttYXJrZXJzW2ldXX0scmVtb3ZlQWxsTWFya2VyczpmdW5jdGlvbigpe3ZhciBpLG1hcmtlcnM9W107Zm9yKGkgaW4gdGhpcy5tYXJrZXJzKW1hcmtlcnMucHVzaChpKTt0aGlzLnJlbW92ZU1hcmtlcnMobWFya2Vycyl9LGxhdExuZ1RvUG9pbnQ6ZnVuY3Rpb24obGF0LGxuZyl7dmFyIHBvaW50LGluc2V0LGJib3gscHJvaj1qdm0uTWFwLm1hcHNbdGhpcy5wYXJhbXMubWFwXS5wcm9qZWN0aW9uLGNlbnRyYWxNZXJpZGlhbj1wcm9qLmNlbnRyYWxNZXJpZGlhbjtyZXR1cm4tMTgwK2NlbnRyYWxNZXJpZGlhbj5sbmcmJihsbmcrPTM2MCkscG9pbnQ9anZtLlByb2pbcHJvai50eXBlXShsYXQsbG5nLGNlbnRyYWxNZXJpZGlhbiksaW5zZXQ9dGhpcy5nZXRJbnNldEZvclBvaW50KHBvaW50LngscG9pbnQueSksaW5zZXQ/KGJib3g9aW5zZXQuYmJveCxwb2ludC54PShwb2ludC54LWJib3hbMF0ueCkvKGJib3hbMV0ueC1iYm94WzBdLngpKmluc2V0LndpZHRoKnRoaXMuc2NhbGUscG9pbnQueT0ocG9pbnQueS1iYm94WzBdLnkpLyhiYm94WzFdLnktYmJveFswXS55KSppbnNldC5oZWlnaHQqdGhpcy5zY2FsZSx7eDpwb2ludC54K3RoaXMudHJhbnNYKnRoaXMuc2NhbGUraW5zZXQubGVmdCp0aGlzLnNjYWxlLHk6cG9pbnQueSt0aGlzLnRyYW5zWSp0aGlzLnNjYWxlK2luc2V0LnRvcCp0aGlzLnNjYWxlfSk6ITF9LHBvaW50VG9MYXRMbmc6ZnVuY3Rpb24oeCx5KXt2YXIgaSxpbnNldCxiYm94LG54LG55LHByb2o9anZtLk1hcC5tYXBzW3RoaXMucGFyYW1zLm1hcF0ucHJvamVjdGlvbixjZW50cmFsTWVyaWRpYW49cHJvai5jZW50cmFsTWVyaWRpYW4saW5zZXRzPWp2bS5NYXAubWFwc1t0aGlzLnBhcmFtcy5tYXBdLmluc2V0cztmb3IoaT0wO2k8aW5zZXRzLmxlbmd0aDtpKyspaWYoaW5zZXQ9aW5zZXRzW2ldLGJib3g9aW5zZXQuYmJveCxueD14LSh0aGlzLnRyYW5zWCp0aGlzLnNjYWxlK2luc2V0LmxlZnQqdGhpcy5zY2FsZSksbnk9eS0odGhpcy50cmFuc1kqdGhpcy5zY2FsZStpbnNldC50b3AqdGhpcy5zY2FsZSksbng9bngvKGluc2V0LndpZHRoKnRoaXMuc2NhbGUpKihiYm94WzFdLngtYmJveFswXS54KStiYm94WzBdLngsbnk9bnkvKGluc2V0LmhlaWdodCp0aGlzLnNjYWxlKSooYmJveFsxXS55LWJib3hbMF0ueSkrYmJveFswXS55LG54PmJib3hbMF0ueCYmbng8YmJveFsxXS54JiZueT5iYm94WzBdLnkmJm55PGJib3hbMV0ueSlyZXR1cm4ganZtLlByb2pbcHJvai50eXBlK1wiX2ludlwiXShueCwtbnksY2VudHJhbE1lcmlkaWFuKTtyZXR1cm4hMX0sZ2V0SW5zZXRGb3JQb2ludDpmdW5jdGlvbih4LHkpe3ZhciBpLGJib3gsaW5zZXRzPWp2bS5NYXAubWFwc1t0aGlzLnBhcmFtcy5tYXBdLmluc2V0cztmb3IoaT0wO2k8aW5zZXRzLmxlbmd0aDtpKyspaWYoYmJveD1pbnNldHNbaV0uYmJveCx4PmJib3hbMF0ueCYmeDxiYm94WzFdLngmJnk+YmJveFswXS55JiZ5PGJib3hbMV0ueSlyZXR1cm4gaW5zZXRzW2ldfSxjcmVhdGVTZXJpZXM6ZnVuY3Rpb24oKXt2YXIgaSxrZXk7dGhpcy5zZXJpZXM9e21hcmtlcnM6W10scmVnaW9uczpbXX07Zm9yKGtleSBpbiB0aGlzLnBhcmFtcy5zZXJpZXMpZm9yKGk9MDtpPHRoaXMucGFyYW1zLnNlcmllc1trZXldLmxlbmd0aDtpKyspdGhpcy5zZXJpZXNba2V5XVtpXT1uZXcganZtLkRhdGFTZXJpZXModGhpcy5wYXJhbXMuc2VyaWVzW2tleV1baV0sdGhpc1trZXldLHRoaXMpfSxyZW1vdmU6ZnVuY3Rpb24oKXt0aGlzLnRpcC5yZW1vdmUoKSx0aGlzLmNvbnRhaW5lci5yZW1vdmUoKSxqdm0uJCh3aW5kb3cpLnVuYmluZChcInJlc2l6ZVwiLHRoaXMub25SZXNpemUpLGp2bS4kKFwiYm9keVwiKS51bmJpbmQoXCJtb3VzZXVwXCIsdGhpcy5vbkNvbnRhaW5lck1vdXNlVXApfX0sanZtLk1hcC5tYXBzPXt9LGp2bS5NYXAuZGVmYXVsdFBhcmFtcz17bWFwOlwid29ybGRfbWlsbF9lblwiLGJhY2tncm91bmRDb2xvcjpcIiM1MDUwNTBcIix6b29tQnV0dG9uczohMCx6b29tT25TY3JvbGw6ITAsem9vbU9uU2Nyb2xsU3BlZWQ6MyxwYW5PbkRyYWc6ITAsem9vbU1heDo4LHpvb21NaW46MSx6b29tU3RlcDoxLjYsem9vbUFuaW1hdGU6ITAscmVnaW9uc1NlbGVjdGFibGU6ITEsbWFya2Vyc1NlbGVjdGFibGU6ITEsYmluZFRvdWNoRXZlbnRzOiEwLHJlZ2lvblN0eWxlOntpbml0aWFsOntmaWxsOlwid2hpdGVcIixcImZpbGwtb3BhY2l0eVwiOjEsc3Ryb2tlOlwibm9uZVwiLFwic3Ryb2tlLXdpZHRoXCI6MCxcInN0cm9rZS1vcGFjaXR5XCI6MX0saG92ZXI6e1wiZmlsbC1vcGFjaXR5XCI6LjgsY3Vyc29yOlwicG9pbnRlclwifSxzZWxlY3RlZDp7ZmlsbDpcInllbGxvd1wifSxzZWxlY3RlZEhvdmVyOnt9fSxyZWdpb25MYWJlbFN0eWxlOntpbml0aWFsOntcImZvbnQtZmFtaWx5XCI6XCJWZXJkYW5hXCIsXCJmb250LXNpemVcIjpcIjEyXCIsXCJmb250LXdlaWdodFwiOlwiYm9sZFwiLGN1cnNvcjpcImRlZmF1bHRcIixmaWxsOlwiYmxhY2tcIn0saG92ZXI6e2N1cnNvcjpcInBvaW50ZXJcIn19LG1hcmtlclN0eWxlOntpbml0aWFsOntmaWxsOlwiZ3JleVwiLHN0cm9rZTpcIiM1MDUwNTBcIixcImZpbGwtb3BhY2l0eVwiOjEsXCJzdHJva2Utd2lkdGhcIjoxLFwic3Ryb2tlLW9wYWNpdHlcIjoxLHI6NX0saG92ZXI6e3N0cm9rZTpcImJsYWNrXCIsXCJzdHJva2Utd2lkdGhcIjoyLGN1cnNvcjpcInBvaW50ZXJcIn0sc2VsZWN0ZWQ6e2ZpbGw6XCJibHVlXCJ9LHNlbGVjdGVkSG92ZXI6e319LG1hcmtlckxhYmVsU3R5bGU6e2luaXRpYWw6e1wiZm9udC1mYW1pbHlcIjpcIlZlcmRhbmFcIixcImZvbnQtc2l6ZVwiOlwiMTJcIixcImZvbnQtd2VpZ2h0XCI6XCJib2xkXCIsY3Vyc29yOlwiZGVmYXVsdFwiLGZpbGw6XCJibGFja1wifSxob3Zlcjp7Y3Vyc29yOlwicG9pbnRlclwifX19LGp2bS5NYXAuYXBpRXZlbnRzPXtvblJlZ2lvblRpcFNob3c6XCJyZWdpb25UaXBTaG93XCIsb25SZWdpb25PdmVyOlwicmVnaW9uT3ZlclwiLG9uUmVnaW9uT3V0OlwicmVnaW9uT3V0XCIsb25SZWdpb25DbGljazpcInJlZ2lvbkNsaWNrXCIsb25SZWdpb25TZWxlY3RlZDpcInJlZ2lvblNlbGVjdGVkXCIsb25NYXJrZXJUaXBTaG93OlwibWFya2VyVGlwU2hvd1wiLG9uTWFya2VyT3ZlcjpcIm1hcmtlck92ZXJcIixvbk1hcmtlck91dDpcIm1hcmtlck91dFwiLG9uTWFya2VyQ2xpY2s6XCJtYXJrZXJDbGlja1wiLG9uTWFya2VyU2VsZWN0ZWQ6XCJtYXJrZXJTZWxlY3RlZFwiLG9uVmlld3BvcnRDaGFuZ2U6XCJ2aWV3cG9ydENoYW5nZVwifSxqdm0uTXVsdGlNYXA9ZnVuY3Rpb24ocGFyYW1zKXt2YXIgdGhhdD10aGlzO3RoaXMubWFwcz17fSx0aGlzLnBhcmFtcz1qdm0uJC5leHRlbmQoITAse30sanZtLk11bHRpTWFwLmRlZmF1bHRQYXJhbXMscGFyYW1zKSx0aGlzLnBhcmFtcy5tYXhMZXZlbD10aGlzLnBhcmFtcy5tYXhMZXZlbHx8TnVtYmVyLk1BWF9WQUxVRSx0aGlzLnBhcmFtcy5tYWluPXRoaXMucGFyYW1zLm1haW58fHt9LHRoaXMucGFyYW1zLm1haW4ubXVsdGlNYXBMZXZlbD0wLHRoaXMuaGlzdG9yeT1bdGhpcy5hZGRNYXAodGhpcy5wYXJhbXMubWFpbi5tYXAsdGhpcy5wYXJhbXMubWFpbildLHRoaXMuZGVmYXVsdFByb2plY3Rpb249dGhpcy5oaXN0b3J5WzBdLm1hcERhdGEucHJvamVjdGlvbi50eXBlLHRoaXMubWFwc0xvYWRlZD17fSx0aGlzLnBhcmFtcy5jb250YWluZXIuY3NzKHtwb3NpdGlvbjpcInJlbGF0aXZlXCJ9KSx0aGlzLmJhY2tCdXR0b249anZtLiQoXCI8ZGl2Lz5cIikuYWRkQ2xhc3MoXCJqdmVjdG9ybWFwLWdvYmFja1wiKS50ZXh0KFwiQmFja1wiKS5hcHBlbmRUbyh0aGlzLnBhcmFtcy5jb250YWluZXIpLHRoaXMuYmFja0J1dHRvbi5oaWRlKCksdGhpcy5iYWNrQnV0dG9uLmNsaWNrKGZ1bmN0aW9uKCl7dGhhdC5nb0JhY2soKX0pLHRoaXMuc3Bpbm5lcj1qdm0uJChcIjxkaXYvPlwiKS5hZGRDbGFzcyhcImp2ZWN0b3JtYXAtc3Bpbm5lclwiKS5hcHBlbmRUbyh0aGlzLnBhcmFtcy5jb250YWluZXIpLHRoaXMuc3Bpbm5lci5oaWRlKCl9LGp2bS5NdWx0aU1hcC5wcm90b3R5cGU9e2FkZE1hcDpmdW5jdGlvbihuYW1lLGNvbmZpZyl7dmFyIGNudD1qdm0uJChcIjxkaXYvPlwiKS5jc3Moe3dpZHRoOlwiMTAwJVwiLGhlaWdodDpcIjEwMCVcIn0pO3JldHVybiB0aGlzLnBhcmFtcy5jb250YWluZXIuYXBwZW5kKGNudCksdGhpcy5tYXBzW25hbWVdPW5ldyBqdm0uTWFwKGp2bS4kLmV4dGVuZChjb25maWcse2NvbnRhaW5lcjpjbnR9KSksdGhpcy5wYXJhbXMubWF4TGV2ZWw+Y29uZmlnLm11bHRpTWFwTGV2ZWwmJnRoaXMubWFwc1tuYW1lXS5jb250YWluZXIub24oXCJyZWdpb25DbGljay5qdmVjdG9ybWFwXCIse3Njb3BlOnRoaXN9LGZ1bmN0aW9uKGUsY29kZSl7dmFyIG11bHRpbWFwPWUuZGF0YS5zY29wZSxtYXBOYW1lPW11bHRpbWFwLnBhcmFtcy5tYXBOYW1lQnlDb2RlKGNvZGUsbXVsdGltYXApO211bHRpbWFwLmRyaWxsRG93blByb21pc2UmJlwicGVuZGluZ1wiPT09bXVsdGltYXAuZHJpbGxEb3duUHJvbWlzZS5zdGF0ZSgpfHxtdWx0aW1hcC5kcmlsbERvd24obWFwTmFtZSxjb2RlKX0pLHRoaXMubWFwc1tuYW1lXX0sZG93bmxvYWRNYXA6ZnVuY3Rpb24oY29kZSl7dmFyIHRoYXQ9dGhpcyxkZWZlcnJlZD1qdm0uJC5EZWZlcnJlZCgpO3JldHVybiB0aGlzLm1hcHNMb2FkZWRbY29kZV0/ZGVmZXJyZWQucmVzb2x2ZSgpOmp2bS4kLmdldCh0aGlzLnBhcmFtcy5tYXBVcmxCeUNvZGUoY29kZSx0aGlzKSkudGhlbihmdW5jdGlvbigpe3RoYXQubWFwc0xvYWRlZFtjb2RlXT0hMCxkZWZlcnJlZC5yZXNvbHZlKCl9LGZ1bmN0aW9uKCl7ZGVmZXJyZWQucmVqZWN0KCl9KSxkZWZlcnJlZH0sZHJpbGxEb3duOmZ1bmN0aW9uKG5hbWUsY29kZSl7dmFyIGN1cnJlbnRNYXA9dGhpcy5oaXN0b3J5W3RoaXMuaGlzdG9yeS5sZW5ndGgtMV0sdGhhdD10aGlzLGZvY3VzUHJvbWlzZT1jdXJyZW50TWFwLnNldEZvY3VzKHtyZWdpb246Y29kZSxhbmltYXRlOiEwfSksZG93bmxvYWRQcm9taXNlPXRoaXMuZG93bmxvYWRNYXAoY29kZSk7Zm9jdXNQcm9taXNlLnRoZW4oZnVuY3Rpb24oKXtcInBlbmRpbmdcIj09PWRvd25sb2FkUHJvbWlzZS5zdGF0ZSgpJiZ0aGF0LnNwaW5uZXIuc2hvdygpfSksZG93bmxvYWRQcm9taXNlLmFsd2F5cyhmdW5jdGlvbigpe3RoYXQuc3Bpbm5lci5oaWRlKCl9KSx0aGlzLmRyaWxsRG93blByb21pc2U9anZtLiQud2hlbihkb3dubG9hZFByb21pc2UsZm9jdXNQcm9taXNlKSx0aGlzLmRyaWxsRG93blByb21pc2UudGhlbihmdW5jdGlvbigpe2N1cnJlbnRNYXAucGFyYW1zLmNvbnRhaW5lci5oaWRlKCksdGhhdC5tYXBzW25hbWVdP3RoYXQubWFwc1tuYW1lXS5wYXJhbXMuY29udGFpbmVyLnNob3coKTp0aGF0LmFkZE1hcChuYW1lLHttYXA6bmFtZSxtdWx0aU1hcExldmVsOmN1cnJlbnRNYXAucGFyYW1zLm11bHRpTWFwTGV2ZWwrMX0pLHRoYXQuaGlzdG9yeS5wdXNoKHRoYXQubWFwc1tuYW1lXSksdGhhdC5iYWNrQnV0dG9uLnNob3coKX0pfSxnb0JhY2s6ZnVuY3Rpb24oKXt2YXIgY3VycmVudE1hcD10aGlzLmhpc3RvcnkucG9wKCkscHJldk1hcD10aGlzLmhpc3RvcnlbdGhpcy5oaXN0b3J5Lmxlbmd0aC0xXSx0aGF0PXRoaXM7Y3VycmVudE1hcC5zZXRGb2N1cyh7c2NhbGU6MSx4Oi41LHk6LjUsYW5pbWF0ZTohMH0pLnRoZW4oZnVuY3Rpb24oKXtjdXJyZW50TWFwLnBhcmFtcy5jb250YWluZXIuaGlkZSgpLHByZXZNYXAucGFyYW1zLmNvbnRhaW5lci5zaG93KCkscHJldk1hcC51cGRhdGVTaXplKCksMT09PXRoYXQuaGlzdG9yeS5sZW5ndGgmJnRoYXQuYmFja0J1dHRvbi5oaWRlKCkscHJldk1hcC5zZXRGb2N1cyh7c2NhbGU6MSx4Oi41LHk6LjUsYW5pbWF0ZTohMH0pfSl9fSxqdm0uTXVsdGlNYXAuZGVmYXVsdFBhcmFtcz17bWFwTmFtZUJ5Q29kZTpmdW5jdGlvbihjb2RlLG11bHRpTWFwKXtyZXR1cm4gY29kZS50b0xvd2VyQ2FzZSgpK1wiX1wiK211bHRpTWFwLmRlZmF1bHRQcm9qZWN0aW9uK1wiX2VuXCJ9LG1hcFVybEJ5Q29kZTpmdW5jdGlvbihjb2RlLG11bHRpTWFwKXtyZXR1cm5cImpxdWVyeS1qdmVjdG9ybWFwLWRhdGEtXCIrY29kZS50b0xvd2VyQ2FzZSgpK1wiLVwiK211bHRpTWFwLmRlZmF1bHRQcm9qZWN0aW9uK1wiLWVuLmpzXCJ9fTsiLCIvKipcbiAqIG1pY3JvcGx1Z2luLmpzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgQnJpYW4gUmVhdmlzICYgY29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXNcbiAqIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBhdXRob3IgQnJpYW4gUmVhdmlzIDxicmlhbkB0aGlyZHJvdXRlLmNvbT5cbiAqL1xuXG4oZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0ZGVmaW5lKGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHR9IGVsc2Uge1xuXHRcdHJvb3QuTWljcm9QbHVnaW4gPSBmYWN0b3J5KCk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG5cdHZhciBNaWNyb1BsdWdpbiA9IHt9O1xuXG5cdE1pY3JvUGx1Z2luLm1peGluID0gZnVuY3Rpb24oSW50ZXJmYWNlKSB7XG5cdFx0SW50ZXJmYWNlLnBsdWdpbnMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemVzIHRoZSBsaXN0ZWQgcGx1Z2lucyAod2l0aCBvcHRpb25zKS5cblx0XHQgKiBBY2NlcHRhYmxlIGZvcm1hdHM6XG5cdFx0ICpcblx0XHQgKiBMaXN0ICh3aXRob3V0IG9wdGlvbnMpOlxuXHRcdCAqICAgWydhJywgJ2InLCAnYyddXG5cdFx0ICpcblx0XHQgKiBMaXN0ICh3aXRoIG9wdGlvbnMpOlxuXHRcdCAqICAgW3snbmFtZSc6ICdhJywgb3B0aW9uczoge319LCB7J25hbWUnOiAnYicsIG9wdGlvbnM6IHt9fV1cblx0XHQgKlxuXHRcdCAqIEhhc2ggKHdpdGggb3B0aW9ucyk6XG5cdFx0ICogICB7J2EnOiB7IC4uLiB9LCAnYic6IHsgLi4uIH0sICdjJzogeyAuLi4gfX1cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IHBsdWdpbnNcblx0XHQgKi9cblx0XHRJbnRlcmZhY2UucHJvdG90eXBlLmluaXRpYWxpemVQbHVnaW5zID0gZnVuY3Rpb24ocGx1Z2lucykge1xuXHRcdFx0dmFyIGksIG4sIGtleTtcblx0XHRcdHZhciBzZWxmICA9IHRoaXM7XG5cdFx0XHR2YXIgcXVldWUgPSBbXTtcblxuXHRcdFx0c2VsZi5wbHVnaW5zID0ge1xuXHRcdFx0XHRuYW1lcyAgICAgOiBbXSxcblx0XHRcdFx0c2V0dGluZ3MgIDoge30sXG5cdFx0XHRcdHJlcXVlc3RlZCA6IHt9LFxuXHRcdFx0XHRsb2FkZWQgICAgOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKHV0aWxzLmlzQXJyYXkocGx1Z2lucykpIHtcblx0XHRcdFx0Zm9yIChpID0gMCwgbiA9IHBsdWdpbnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBwbHVnaW5zW2ldID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaChwbHVnaW5zW2ldKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5wbHVnaW5zLnNldHRpbmdzW3BsdWdpbnNbaV0ubmFtZV0gPSBwbHVnaW5zW2ldLm9wdGlvbnM7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKHBsdWdpbnNbaV0ubmFtZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHBsdWdpbnMpIHtcblx0XHRcdFx0Zm9yIChrZXkgaW4gcGx1Z2lucykge1xuXHRcdFx0XHRcdGlmIChwbHVnaW5zLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRcdHNlbGYucGx1Z2lucy5zZXR0aW5nc1trZXldID0gcGx1Z2luc1trZXldO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR3aGlsZSAocXVldWUubGVuZ3RoKSB7XG5cdFx0XHRcdHNlbGYucmVxdWlyZShxdWV1ZS5zaGlmdCgpKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0SW50ZXJmYWNlLnByb3RvdHlwZS5sb2FkUGx1Z2luID0gZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dmFyIHNlbGYgICAgPSB0aGlzO1xuXHRcdFx0dmFyIHBsdWdpbnMgPSBzZWxmLnBsdWdpbnM7XG5cdFx0XHR2YXIgcGx1Z2luICA9IEludGVyZmFjZS5wbHVnaW5zW25hbWVdO1xuXG5cdFx0XHRpZiAoIUludGVyZmFjZS5wbHVnaW5zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgXCInICsgIG5hbWUgKyAnXCIgcGx1Z2luJyk7XG5cdFx0XHR9XG5cblx0XHRcdHBsdWdpbnMucmVxdWVzdGVkW25hbWVdID0gdHJ1ZTtcblx0XHRcdHBsdWdpbnMubG9hZGVkW25hbWVdID0gcGx1Z2luLmZuLmFwcGx5KHNlbGYsIFtzZWxmLnBsdWdpbnMuc2V0dGluZ3NbbmFtZV0gfHwge31dKTtcblx0XHRcdHBsdWdpbnMubmFtZXMucHVzaChuYW1lKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZXMgYSBwbHVnaW4uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHRcdCAqL1xuXHRcdEludGVyZmFjZS5wcm90b3R5cGUucmVxdWlyZSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBwbHVnaW5zID0gc2VsZi5wbHVnaW5zO1xuXG5cdFx0XHRpZiAoIXNlbGYucGx1Z2lucy5sb2FkZWQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdFx0aWYgKHBsdWdpbnMucmVxdWVzdGVkW25hbWVdKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQbHVnaW4gaGFzIGNpcmN1bGFyIGRlcGVuZGVuY3kgKFwiJyArIG5hbWUgKyAnXCIpJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5sb2FkUGx1Z2luKG5hbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcGx1Z2lucy5sb2FkZWRbbmFtZV07XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlZ2lzdGVycyBhIHBsdWdpbi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cblx0XHQgKi9cblx0XHRJbnRlcmZhY2UuZGVmaW5lID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcblx0XHRcdEludGVyZmFjZS5wbHVnaW5zW25hbWVdID0ge1xuXHRcdFx0XHQnbmFtZScgOiBuYW1lLFxuXHRcdFx0XHQnZm4nICAgOiBmblxuXHRcdFx0fTtcblx0XHR9O1xuXHR9O1xuXG5cdHZhciB1dGlscyA9IHtcblx0XHRpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHZBcmcpIHtcblx0XHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodkFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBNaWNyb1BsdWdpbjtcbn0pKTsiLCIvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjE0LjNcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmVkZXJpY28gWml2b2xvIGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxudmFyIGxvbmdlclRpbWVvdXRCcm93c2VycyA9IFsnRWRnZScsICdUcmlkZW50JywgJ0ZpcmVmb3gnXTtcbnZhciB0aW1lb3V0RHVyYXRpb24gPSAwO1xuZm9yICh2YXIgaSA9IDA7IGkgPCBsb25nZXJUaW1lb3V0QnJvd3NlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgaWYgKGlzQnJvd3NlciAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YobG9uZ2VyVGltZW91dEJyb3dzZXJzW2ldKSA+PSAwKSB7XG4gICAgdGltZW91dER1cmF0aW9uID0gMTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHdpbmRvdy5Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgZm4oKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG52YXIgc3VwcG9ydHNNaWNyb1Rhc2tzID0gaXNCcm93c2VyICYmIHdpbmRvdy5Qcm9taXNlO1xuXG4vKipcbiogQ3JlYXRlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBtZXRob2QsIHRoYXQncyBhc3luY2hyb25vdXNseSBkZWZlcnJlZFxuKiBidXQgY2FsbGVkIGluIHRoZSBtaW5pbXVtIHRpbWUgcG9zc2libGUuXG4qXG4qIEBtZXRob2RcbiogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuKiBAcmV0dXJucyB7RnVuY3Rpb259XG4qL1xudmFyIGRlYm91bmNlID0gc3VwcG9ydHNNaWNyb1Rhc2tzID8gbWljcm90YXNrRGVib3VuY2UgOiB0YXNrRGVib3VuY2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QW55fSBmdW5jdGlvblRvQ2hlY2sgLSB2YXJpYWJsZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgcmV0dXJuIHByb3BlcnR5ID8gY3NzW3Byb3BlcnR5XSA6IGNzcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnROb2RlIG9yIHRoZSBob3N0IG9mIHRoZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGxpbmcgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBzY3JvbGwgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFJldHVybiBib2R5LCBgZ2V0U2Nyb2xsYCB3aWxsIHRha2UgY2FyZSB0byBnZXQgdGhlIGNvcnJlY3QgYHNjcm9sbFRvcGAgZnJvbSBpdFxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIHN3aXRjaCAoZWxlbWVudC5ub2RlTmFtZSkge1xuICAgIGNhc2UgJ0hUTUwnOlxuICAgIGNhc2UgJ0JPRFknOlxuICAgICAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICByZXR1cm4gZWxlbWVudC5ib2R5O1xuICB9XG5cbiAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG5cbiAgdmFyIF9nZXRTdHlsZUNvbXB1dGVkUHJvcCA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1k7XG5cbiAgaWYgKC8oYXV0b3xzY3JvbGx8b3ZlcmxheSkvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG52YXIgaXNJRTExID0gaXNCcm93c2VyICYmICEhKHdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUpO1xudmFyIGlzSUUxMCA9IGlzQnJvd3NlciAmJiAvTVNJRSAxMC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge051bWJlcn0gdmVyc2lvbiB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGlzSUVcbiAqL1xuZnVuY3Rpb24gaXNJRSh2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uID09PSAxMSkge1xuICAgIHJldHVybiBpc0lFMTE7XG4gIH1cbiAgaWYgKHZlcnNpb24gPT09IDEwKSB7XG4gICAgcmV0dXJuIGlzSUUxMDtcbiAgfVxuICByZXR1cm4gaXNJRTExIHx8IGlzSUUxMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvZmZzZXQgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICB2YXIgbm9PZmZzZXRQYXJlbnQgPSBpc0lFKDEwKSA/IGRvY3VtZW50LmJvZHkgOiBudWxsO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgLy8gU2tpcCBoaWRkZW4gZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhbiBvZmZzZXRQYXJlbnRcbiAgd2hpbGUgKG9mZnNldFBhcmVudCA9PT0gbm9PZmZzZXRQYXJlbnQgJiYgZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSAoZWxlbWVudCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5vZmZzZXRQYXJlbnQ7XG4gIH1cblxuICB2YXIgbm9kZU5hbWUgPSBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50Lm5vZGVOYW1lO1xuXG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBURCBvciBUQUJMRSBpbiBjYXNlXG4gIC8vIG5vIG9mZnNldFBhcmVudCBpcyBwcmVzZW50LCBJIGhhdGUgdGhpcyBqb2IuLi5cbiAgaWYgKFsnVEQnLCAnVEFCTEUnXS5pbmRleE9mKG9mZnNldFBhcmVudC5ub2RlTmFtZSkgIT09IC0xICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbm9kZU5hbWUgPT09ICdIVE1MJyB8fCBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIHJvb3Qgbm9kZSAoZG9jdW1lbnQsIHNoYWRvd0RPTSByb290KSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcm9vdCBub2RlXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldFJvb3Qobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBvZmZzZXQgcGFyZW50IGNvbW1vbiB0byB0aGUgdHdvIHByb3ZpZGVkIG5vZGVzXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQxXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQyXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gY29tbW9uIG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZWxlbWVudDIpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudDEgfHwgIWVsZW1lbnQxLm5vZGVUeXBlIHx8ICFlbGVtZW50MiB8fCAhZWxlbWVudDIubm9kZVR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gSGVyZSB3ZSBtYWtlIHN1cmUgdG8gZ2l2ZSBhcyBcInN0YXJ0XCIgdGhlIGVsZW1lbnQgdGhhdCBjb21lcyBmaXJzdCBpbiB0aGUgRE9NXG4gIHZhciBvcmRlciA9IGVsZW1lbnQxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICB2YXIgc3RhcnQgPSBvcmRlciA/IGVsZW1lbnQxIDogZWxlbWVudDI7XG4gIHZhciBlbmQgPSBvcmRlciA/IGVsZW1lbnQyIDogZWxlbWVudDE7XG5cbiAgLy8gR2V0IGNvbW1vbiBhbmNlc3RvciBjb250YWluZXJcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQsIDApO1xuICByYW5nZS5zZXRFbmQoZW5kLCAwKTtcbiAgdmFyIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgLy8gQm90aCBub2RlcyBhcmUgaW5zaWRlICNkb2N1bWVudFxuXG4gIGlmIChlbGVtZW50MSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgJiYgZWxlbWVudDIgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIHx8IHN0YXJ0LmNvbnRhaW5zKGVuZCkpIHtcbiAgICBpZiAoaXNPZmZzZXRDb250YWluZXIoY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChjb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBvbmUgb2YgdGhlIG5vZGVzIGlzIGluc2lkZSBzaGFkb3dET00sIGZpbmQgd2hpY2ggb25lXG4gIHZhciBlbGVtZW50MXJvb3QgPSBnZXRSb290KGVsZW1lbnQxKTtcbiAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDFyb290Lmhvc3QsIGVsZW1lbnQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGxlZnRgXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbChlbGVtZW50KSB7XG4gIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndG9wJztcblxuICB2YXIgdXBwZXJTaWRlID0gc2lkZSA9PT0gJ3RvcCcgPyAnc2Nyb2xsVG9wJyA6ICdzY3JvbGxMZWZ0JztcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgaHRtbDtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRbdXBwZXJTaWRlXTtcbn1cblxuLypcbiAqIFN1bSBvciBzdWJ0cmFjdCB0aGUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIChsZWZ0IGFuZCB0b3ApIGZyb20gYSBnaXZlbiByZWN0IG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgLSBSZWN0IG9iamVjdCB5b3Ugd2FudCB0byBjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHBhcmFtIHtCb29sZWFufSBzdWJ0cmFjdCAtIHNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHN1YnRyYWN0IHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY3QgLSBUaGUgbW9kaWZpZXIgcmVjdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVNjcm9sbChyZWN0LCBlbGVtZW50KSB7XG4gIHZhciBzdWJ0cmFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gIHZhciBtb2RpZmllciA9IHN1YnRyYWN0ID8gLTEgOiAxO1xuICByZWN0LnRvcCArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZXR1cm4gcmVjdDtcbn1cblxuLypcbiAqIEhlbHBlciB0byBkZXRlY3QgYm9yZGVycyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXG4gKiBSZXN1bHQgb2YgYGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eWAgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIC0gYHhgIG9yIGB5YFxuICogQHJldHVybiB7bnVtYmVyfSBib3JkZXJzIC0gVGhlIGJvcmRlcnMgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpc1xuICovXG5cbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcywgYXhpcykge1xuICB2YXIgc2lkZUEgPSBheGlzID09PSAneCcgPyAnTGVmdCcgOiAnVG9wJztcbiAgdmFyIHNpZGVCID0gc2lkZUEgPT09ICdMZWZ0JyA/ICdSaWdodCcgOiAnQm90dG9tJztcblxuICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQSArICdXaWR0aCddLCAxMCkgKyBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVCICsgJ1dpZHRoJ10sIDEwKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZShheGlzLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSB7XG4gIHJldHVybiBNYXRoLm1heChib2R5WydvZmZzZXQnICsgYXhpc10sIGJvZHlbJ3Njcm9sbCcgKyBheGlzXSwgaHRtbFsnY2xpZW50JyArIGF4aXNdLCBodG1sWydvZmZzZXQnICsgYXhpc10sIGh0bWxbJ3Njcm9sbCcgKyBheGlzXSwgaXNJRSgxMCkgPyBodG1sWydvZmZzZXQnICsgYXhpc10gKyBjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ1RvcCcgOiAnTGVmdCcpXSArIGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCcpXSA6IDApO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTaXplcygpIHtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBpc0lFKDEwKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICB9O1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG9mZnNldHMsIHtcbiAgICByaWdodDogb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aCxcbiAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gY2xpZW50IHJlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSB7fTtcblxuICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAvLyBUaGlzIGlzbid0IHJlcHJvZHVjaWJsZSBpbiBJRTEwIGNvbXBhdGliaWxpdHkgbW9kZSBvZiBJRTExXG4gIHRyeSB7XG4gICAgaWYgKGlzSUUoMTApKSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICB3aWR0aDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgfTtcblxuICAvLyBzdWJ0cmFjdCBzY3JvbGxiYXIgc2l6ZSBmcm9tIHNpemVzXG4gIHZhciBzaXplcyA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJyA/IGdldFdpbmRvd1NpemVzKCkgOiB7fTtcbiAgdmFyIHdpZHRoID0gc2l6ZXMud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCB8fCByZXN1bHQucmlnaHQgLSByZXN1bHQubGVmdDtcbiAgdmFyIGhlaWdodCA9IHNpemVzLmhlaWdodCB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCByZXN1bHQuYm90dG9tIC0gcmVzdWx0LnRvcDtcblxuICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIHZhciB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgdmVydFNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd5Jyk7XG5cbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3QocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBpc0lFMTAgPSBpc0lFKDEwKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG5cbiAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICB2YXIgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCwgMTApO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG5cbiAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIHBhcmVudCBpcyBmaXhlZCwgd2UgbXVzdCBpZ25vcmUgbmVnYXRpdmUgc2Nyb2xsIGluIG9mZnNldCBjYWxjXG4gIGlmIChmaXhlZFBvc2l0aW9uICYmIHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcGFyZW50UmVjdC50b3AgPSBNYXRoLm1heChwYXJlbnRSZWN0LnRvcCwgMCk7XG4gICAgcGFyZW50UmVjdC5sZWZ0ID0gTWF0aC5tYXgocGFyZW50UmVjdC5sZWZ0LCAwKTtcbiAgfVxuICB2YXIgb2Zmc2V0cyA9IGdldENsaWVudFJlY3Qoe1xuICAgIHRvcDogY2hpbGRyZW5SZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wIC0gYm9yZGVyVG9wV2lkdGgsXG4gICAgbGVmdDogY2hpbGRyZW5SZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQgLSBib3JkZXJMZWZ0V2lkdGgsXG4gICAgd2lkdGg6IGNoaWxkcmVuUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IGNoaWxkcmVuUmVjdC5oZWlnaHRcbiAgfSk7XG4gIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gMDtcblxuICAvLyBTdWJ0cmFjdCBtYXJnaW5zIG9mIGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGl0J3MgYmVpbmcgdXNlZCBhcyBwYXJlbnRcbiAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gIC8vIHRoZSBib3ggb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgaW4gdGhlIG90aGVyIGNhc2VzIG5vdC5cbiAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCwgMTApO1xuICAgIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCwgMTApO1xuXG4gICAgb2Zmc2V0cy50b3AgLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5ib3R0b20gLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5sZWZ0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG4gICAgb2Zmc2V0cy5yaWdodCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuXG4gICAgLy8gQXR0YWNoIG1hcmdpblRvcCBhbmQgbWFyZ2luTGVmdCBiZWNhdXNlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3ZSBtYXkgbmVlZCB0aGVtXG4gICAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gbWFyZ2luTGVmdDtcbiAgfVxuXG4gIGlmIChpc0lFMTAgJiYgIWZpeGVkUG9zaXRpb24gPyBwYXJlbnQuY29udGFpbnMoc2Nyb2xsUGFyZW50KSA6IHBhcmVudCA9PT0gc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgb2Zmc2V0cyA9IGluY2x1ZGVTY3JvbGwob2Zmc2V0cywgcGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUoZWxlbWVudCkge1xuICB2YXIgZXhjbHVkZVNjcm9sbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KGh0bWwuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcblxuICB2YXIgc2Nyb2xsVG9wID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCkgOiAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwsICdsZWZ0JykgOiAwO1xuXG4gIHZhciBvZmZzZXQgPSB7XG4gICAgdG9wOiBzY3JvbGxUb3AgLSByZWxhdGl2ZU9mZnNldC50b3AgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5Ub3AsXG4gICAgbGVmdDogc2Nyb2xsTGVmdCAtIHJlbGF0aXZlT2Zmc2V0LmxlZnQgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5MZWZ0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KG9mZnNldCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvIFwiaXNGaXhlZD9cIlxuICovXG5mdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IHBhcmVudCBvZiBhbiBlbGVtZW50IHRoYXQgaGFzIGEgdHJhbnNmb3JtZWQgcHJvcGVydHkgZGVmaW5lZFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gZmlyc3QgdHJhbnNmb3JtZWQgcGFyZW50IG9yIGRvY3VtZW50RWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudEVsZW1lbnQgfHwgaXNJRSgpKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICB2YXIgZWwgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIHdoaWxlIChlbCAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWwsICd0cmFuc2Zvcm0nKSA9PT0gJ25vbmUnKSB7XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBlbCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZml4ZWRQb3NpdGlvbiAtIElzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuXG4gIHZhciBib3VuZGFyaWVzID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcblxuICAvLyBIYW5kbGUgdmlld3BvcnQgY2FzZVxuICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICBib3VuZGFyaWVzID0gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gSGFuZGxlIG90aGVyIGNhc2VzIGJhc2VkIG9uIERPTSBlbGVtZW50IHVzZWQgYXMgYm91bmRhcmllc1xuICAgIHZhciBib3VuZGFyaWVzTm9kZSA9IHZvaWQgMDtcbiAgICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKHJlZmVyZW5jZSkpO1xuICAgICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRzID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGJvdW5kYXJpZXNOb2RlLCBvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgdmFyIF9nZXRXaW5kb3dTaXplcyA9IGdldFdpbmRvd1NpemVzKCksXG4gICAgICAgICAgaGVpZ2h0ID0gX2dldFdpbmRvd1NpemVzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcblxuICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gaGVpZ2h0ICsgb2Zmc2V0cy50b3A7XG4gICAgICBib3VuZGFyaWVzLmxlZnQgKz0gb2Zmc2V0cy5sZWZ0IC0gb2Zmc2V0cy5tYXJnaW5MZWZ0O1xuICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgYWxsIHRoZSBvdGhlciBET00gZWxlbWVudHMsIHRoaXMgb25lIGlzIGdvb2RcbiAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nc1xuICBib3VuZGFyaWVzLmxlZnQgKz0gcGFkZGluZztcbiAgYm91bmRhcmllcy50b3AgKz0gcGFkZGluZztcbiAgYm91bmRhcmllcy5yaWdodCAtPSBwYWRkaW5nO1xuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBwYWRkaW5nO1xuXG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuXG5mdW5jdGlvbiBnZXRBcmVhKF9yZWYpIHtcbiAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuXG4gIHJldHVybiB3aWR0aCAqIGhlaWdodDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBgYXV0b2AgcGxhY2VtZW50IHRvIHRoZSBwbGFjZW1lbnQgd2l0aCBtb3JlXG4gKiBhdmFpbGFibGUgc3BhY2UuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIHJlZlJlY3QsIHBvcHBlciwgcmVmZXJlbmNlLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcblxuICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgdmFyIHJlY3RzID0ge1xuICAgIHRvcDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZlJlY3QudG9wIC0gYm91bmRhcmllcy50b3BcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB3aWR0aDogcmVmUmVjdC5sZWZ0IC0gYm91bmRhcmllcy5sZWZ0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH1cbiAgfTtcblxuICB2YXIgc29ydGVkQXJlYXMgPSBPYmplY3Qua2V5cyhyZWN0cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBrZXlcbiAgICB9LCByZWN0c1trZXldLCB7XG4gICAgICBhcmVhOiBnZXRBcmVhKHJlY3RzW2tleV0pXG4gICAgfSk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hcmVhIC0gYS5hcmVhO1xuICB9KTtcblxuICB2YXIgZmlsdGVyZWRBcmVhcyA9IHNvcnRlZEFyZWFzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHJldHVybiB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHQ7XG4gIH0pO1xuXG4gIHZhciBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMCA/IGZpbHRlcmVkQXJlYXNbMF0ua2V5IDogc29ydGVkQXJlYXNbMF0ua2V5O1xuXG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtFbGVtZW50fSBmaXhlZFBvc2l0aW9uIC0gaXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgdmFyIGNvbW1vbk9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcbiAgcmV0dXJuIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShyZWZlcmVuY2UsIGNvbW1vbk9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvdXRlciBzaXplcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCAob2Zmc2V0IHNpemUgKyBtYXJnaW5zKVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJTaXplcyhlbGVtZW50KSB7XG4gIHZhciBzdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Cb3R0b20pO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQpICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luUmlnaHQpO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoICsgeSxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgeFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICB2YXIgaGFzaCA9IHsgbGVmdDogJ3JpZ2h0JywgcmlnaHQ6ICdsZWZ0JywgYm90dG9tOiAndG9wJywgdG9wOiAnYm90dG9tJyB9O1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSBDU1MgcG9zaXRpb24gdGhlIFBvcHBlciB3aWxsIGdldCBhcHBsaWVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzIC0gdGhlIHJlZmVyZW5jZSBvZmZzZXRzICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGFjZW1lbnQgLSBvbmUgb2YgdGhlIHZhbGlkIHBsYWNlbWVudCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wcGVyT2Zmc2V0cyhwb3BwZXIsIHJlZmVyZW5jZU9mZnNldHMsIHBsYWNlbWVudCkge1xuICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICAvLyBHZXQgcG9wcGVyIG5vZGUgc2l6ZXNcbiAgdmFyIHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHtcbiAgICB3aWR0aDogcG9wcGVyUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHBvcHBlclJlY3QuaGVpZ2h0XG4gIH07XG5cbiAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICB2YXIgaXNIb3JpeiA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBtYWluU2lkZSA9IGlzSG9yaXogPyAndG9wJyA6ICdsZWZ0JztcbiAgdmFyIHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzZWNvbmRhcnlNZWFzdXJlbWVudCA9ICFpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIHBvcHBlck9mZnNldHNbbWFpblNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1ttYWluU2lkZV0gKyByZWZlcmVuY2VPZmZzZXRzW21lYXN1cmVtZW50XSAvIDIgLSBwb3BwZXJSZWN0W21lYXN1cmVtZW50XSAvIDI7XG4gIGlmIChwbGFjZW1lbnQgPT09IHNlY29uZGFyeVNpZGUpIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSAtIHBvcHBlclJlY3Rbc2Vjb25kYXJ5TWVhc3VyZW1lbnRdO1xuICB9IGVsc2Uge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW2dldE9wcG9zaXRlUGxhY2VtZW50KHNlY29uZGFyeVNpZGUpXTtcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPZmZzZXRzO1xufVxuXG4vKipcbiAqIE1pbWljcyB0aGUgYGZpbmRgIG1ldGhvZCBvZiBBcnJheVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kKGFyciwgY2hlY2spIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kIGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICByZXR1cm4gYXJyLmZpbmQoY2hlY2spO1xuICB9XG5cbiAgLy8gdXNlIGBmaWx0ZXJgIHRvIG9idGFpbiB0aGUgc2FtZSBiZWhhdmlvciBvZiBgZmluZGBcbiAgcmV0dXJuIGFyci5maWx0ZXIoY2hlY2spWzBdO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBwcm9wLCB2YWx1ZSkge1xuICAvLyB1c2UgbmF0aXZlIGZpbmRJbmRleCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChmdW5jdGlvbiAoY3VyKSB7XG4gICAgICByZXR1cm4gY3VyW3Byb3BdID09PSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHVzZSBgZmluZGAgKyBgaW5kZXhPZmAgaWYgYGZpbmRJbmRleGAgaXNuJ3Qgc3VwcG9ydGVkXG4gIHZhciBtYXRjaCA9IGZpbmQoYXJyLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9ialtwcm9wXSA9PT0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gYXJyLmluZGV4T2YobWF0Y2gpO1xufVxuXG4vKipcbiAqIExvb3AgdHJvdWdoIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBhbmQgcnVuIHRoZW0gaW4gb3JkZXIsXG4gKiBlYWNoIG9mIHRoZW0gd2lsbCB0aGVuIGVkaXQgdGhlIGRhdGEgb2JqZWN0LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRzIC0gT3B0aW9uYWwgbW9kaWZpZXIgbmFtZSB1c2VkIGFzIHN0b3BwZXJcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fVxuICovXG5mdW5jdGlvbiBydW5Nb2RpZmllcnMobW9kaWZpZXJzLCBkYXRhLCBlbmRzKSB7XG4gIHZhciBtb2RpZmllcnNUb1J1biA9IGVuZHMgPT09IHVuZGVmaW5lZCA/IG1vZGlmaWVycyA6IG1vZGlmaWVycy5zbGljZSgwLCBmaW5kSW5kZXgobW9kaWZpZXJzLCAnbmFtZScsIGVuZHMpKTtcblxuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmIChtb2RpZmllclsnZnVuY3Rpb24nXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgdmFyIGZuID0gbW9kaWZpZXJbJ2Z1bmN0aW9uJ10gfHwgbW9kaWZpZXIuZm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgaWYgKG1vZGlmaWVyLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIG9mZnNldHMgdG8gbWFrZSB0aGVtIGEgY29tcGxldGUgY2xpZW50UmVjdCBvYmplY3RcbiAgICAgIC8vIHdlIGRvIHRoaXMgYmVmb3JlIGVhY2ggbW9kaWZpZXIgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBvbmUgZG9lc24ndFxuICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG4gICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucmVmZXJlbmNlKTtcblxuICAgICAgZGF0YSA9IGZuKGRhdGEsIG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nXG4gKiB0aGUgbmV3IHN0eWxlLjxiciAvPlxuICogUHJlZmVyIGBzY2hlZHVsZVVwZGF0ZWAgb3ZlciBgdXBkYXRlYCBiZWNhdXNlIG9mIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgLy8gaWYgcG9wcGVyIGlzIGRlc3Ryb3llZCwgZG9uJ3QgcGVyZm9ybSBhbnkgZnVydGhlciB1cGRhdGVcbiAgaWYgKHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IHtcbiAgICBpbnN0YW5jZTogdGhpcyxcbiAgICBzdHlsZXM6IHt9LFxuICAgIGFycm93U3R5bGVzOiB7fSxcbiAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICBmbGlwcGVkOiBmYWxzZSxcbiAgICBvZmZzZXRzOiB7fVxuICB9O1xuXG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyh0aGlzLnN0YXRlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudCh0aGlzLm9wdGlvbnMucGxhY2VtZW50LCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIC8vIHN0b3JlIHRoZSBjb21wdXRlZCBwbGFjZW1lbnQgaW5zaWRlIGBvcmlnaW5hbFBsYWNlbWVudGBcbiAgZGF0YS5vcmlnaW5hbFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuXG4gIGRhdGEucG9zaXRpb25GaXhlZCA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkO1xuXG4gIC8vIGNvbXB1dGUgdGhlIHBvcHBlciBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRQb3BwZXJPZmZzZXRzKHRoaXMucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlci5wb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZSc7XG5cbiAgLy8gcnVuIHRoZSBtb2RpZmllcnNcbiAgZGF0YSA9IHJ1bk1vZGlmaWVycyh0aGlzLm1vZGlmaWVycywgZGF0YSk7XG5cbiAgLy8gdGhlIGZpcnN0IGB1cGRhdGVgIHdpbGwgY2FsbCBgb25DcmVhdGVgIGNhbGxiYWNrXG4gIC8vIHRoZSBvdGhlciBvbmVzIHdpbGwgY2FsbCBgb25VcGRhdGVgIGNhbGxiYWNrXG4gIGlmICghdGhpcy5zdGF0ZS5pc0NyZWF0ZWQpIHtcbiAgICB0aGlzLnN0YXRlLmlzQ3JlYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzLCBtb2RpZmllck5hbWUpIHtcbiAgcmV0dXJuIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIGVuYWJsZWQgPSBfcmVmLmVuYWJsZWQ7XG4gICAgcmV0dXJuIGVuYWJsZWQgJiYgbmFtZSA9PT0gbW9kaWZpZXJOYW1lO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByZWZpeGVkIHN1cHBvcnRlZCBwcm9wZXJ0eSBuYW1lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHkgKGNhbWVsQ2FzZSlcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWZpeGVkIHByb3BlcnR5IChjYW1lbENhc2Ugb3IgUGFzY2FsQ2FzZSwgZGVwZW5kaW5nIG9uIHRoZSB2ZW5kb3IgcHJlZml4KVxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUocHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gIHZhciB1cHBlclByb3AgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgdmFyIHRvQ2hlY2sgPSBwcmVmaXggPyAnJyArIHByZWZpeCArIHVwcGVyUHJvcCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBEZXN0cm95IHRoZSBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXR5IGFza2VkIGZvciB0aGUgZGVsZXRpb24gb24gZGVzdHJveVxuICAvLyBkbyBub3QgdXNlIGByZW1vdmVgIGJlY2F1c2UgSUUxMSBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICB0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge1dpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KGVsZW1lbnQpIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IHNjcm9sbFBhcmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogc2Nyb2xsUGFyZW50O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICBpZiAoIWlzQm9keSkge1xuICAgIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhnZXRTY3JvbGxQYXJlbnQodGFyZ2V0LnBhcmVudE5vZGUpLCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpO1xuICB9XG4gIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIG9wdGlvbnMsIHN0YXRlLCB1cGRhdGVCb3VuZCkge1xuICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gdXBkYXRlQm91bmQ7XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHZhciBzY3JvbGxFbGVtZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHJlZmVyZW5jZSk7XG4gIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxFbGVtZW50LCAnc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQsIHN0YXRlLnNjcm9sbFBhcmVudHMpO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIG9uVXBkYXRlIGNhbGxiYWNrIGFueW1vcmUsXG4gKiB1bmxlc3MgeW91IGNhbGwgYHVwZGF0ZWAgbWV0aG9kIG1hbnVhbGx5LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgICB0aGlzLnN0YXRlID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMuc3RhdGUpO1xuICB9XG59XG5cbi8qKlxuICogVGVsbHMgaWYgYSBnaXZlbiBpbnB1dCBpcyBhIG51bWJlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHsqfSBpbnB1dCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuIG4gIT09ICcnICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHN0eWxlIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB1bml0ID0gJyc7XG4gICAgLy8gYWRkIHVuaXQgaWYgdGhlIHZhbHVlIGlzIG51bWVyaWMgYW5kIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAgaWYgKFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLmluZGV4T2YocHJvcCkgIT09IC0xICYmIGlzTnVtZXJpYyhzdHlsZXNbcHJvcF0pKSB7XG4gICAgICB1bml0ID0gJ3B4JztcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXSArIHVuaXQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGVzIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5zdHlsZXMgLSBMaXN0IG9mIHN0eWxlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLmF0dHJpYnV0ZXMgLSBMaXN0IG9mIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2FtZSBkYXRhIG9iamVjdFxuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlKGRhdGEpIHtcbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuc3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gaW4gdGhpcyB3YXkgd2UgY2FuIG1ha2UgdGhlIDNyZCBwYXJ0eSBtb2RpZmllcnMgYWRkIGN1c3RvbSBzdHlsZXMgdG8gaXRcbiAgLy8gQmUgYXdhcmUsIG1vZGlmaWVycyBjb3VsZCBvdmVycmlkZSB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoZSBwcmV2aW91c1xuICAvLyBsaW5lcyBvZiB0aGlzIG1vZGlmaWVyIVxuICBzZXRTdHlsZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuc3R5bGVzKTtcblxuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5hdHRyaWJ1dGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gdGhleSB3aWxsIGJlIHNldCBhcyBIVE1MIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgc2V0QXR0cmlidXRlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgZGVmaW5lZCBhbmQgYXJyb3dTdHlsZXMgaGFzIHNvbWUgcHJvcGVydGllc1xuICBpZiAoZGF0YS5hcnJvd0VsZW1lbnQgJiYgT2JqZWN0LmtleXMoZGF0YS5hcnJvd1N0eWxlcykubGVuZ3RoKSB7XG4gICAgc2V0U3R5bGVzKGRhdGEuYXJyb3dFbGVtZW50LCBkYXRhLmFycm93U3R5bGVzKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gKiB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyIG1hcmdpbnMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBnZXQgdGhlXG4gKiBjb3JyZWN0IHBvcHBlciBvZmZzZXRzLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUG9wcGVyLmpzIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZU9uTG9hZChyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBzdGF0ZSkge1xuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgdmFyIHJlZmVyZW5jZU9mZnNldHMgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgdmFyIHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KG9wdGlvbnMucGxhY2VtZW50LCByZWZlcmVuY2VPZmZzZXRzLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHBsYWNlbWVudCk7XG5cbiAgLy8gQXBwbHkgYHBvc2l0aW9uYCB0byBwb3BwZXIgYmVmb3JlIGFueXRoaW5nIGVsc2UgYmVjYXVzZVxuICAvLyB3aXRob3V0IHRoZSBwb3NpdGlvbiBhcHBsaWVkIHdlIGNhbid0IGd1YXJhbnRlZSBjb3JyZWN0IGNvbXB1dGF0aW9uc1xuICBzZXRTdHlsZXMocG9wcGVyLCB7IHBvc2l0aW9uOiBvcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJyB9KTtcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVN0eWxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIHggPSBvcHRpb25zLngsXG4gICAgICB5ID0gb3B0aW9ucy55O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICAvLyBSZW1vdmUgdGhpcyBsZWdhY3kgc3VwcG9ydCBpbiBQb3BwZXIuanMgdjJcblxuICB2YXIgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlJztcbiAgfSkuZ3B1QWNjZWxlcmF0aW9uO1xuICBpZiAobGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBncHVBY2NlbGVyYXRpb25gIG9wdGlvbiBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllciBhbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBQb3BwZXIuanMhJyk7XG4gIH1cbiAgdmFyIGdwdUFjY2VsZXJhdGlvbiA9IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkID8gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIDogb3B0aW9ucy5ncHVBY2NlbGVyYXRpb247XG5cbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBvZmZzZXRQYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG5cbiAgLy8gU3R5bGVzXG4gIHZhciBzdHlsZXMgPSB7XG4gICAgcG9zaXRpb246IHBvcHBlci5wb3NpdGlvblxuICB9O1xuXG4gIC8vIEF2b2lkIGJsdXJyeSB0ZXh0IGJ5IHVzaW5nIGZ1bGwgcGl4ZWwgaW50ZWdlcnMuXG4gIC8vIEZvciBwaXhlbC1wZXJmZWN0IHBvc2l0aW9uaW5nLCB0b3AvYm90dG9tIHByZWZlcnMgcm91bmRlZFxuICAvLyB2YWx1ZXMsIHdoaWxlIGxlZnQvcmlnaHQgcHJlZmVycyBmbG9vcmVkIHZhbHVlcy5cbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgbGVmdDogTWF0aC5mbG9vcihwb3BwZXIubGVmdCksXG4gICAgdG9wOiBNYXRoLnJvdW5kKHBvcHBlci50b3ApLFxuICAgIGJvdHRvbTogTWF0aC5yb3VuZChwb3BwZXIuYm90dG9tKSxcbiAgICByaWdodDogTWF0aC5mbG9vcihwb3BwZXIucmlnaHQpXG4gIH07XG5cbiAgdmFyIHNpZGVBID0geCA9PT0gJ2JvdHRvbScgPyAndG9wJyA6ICdib3R0b20nO1xuICB2YXIgc2lkZUIgPSB5ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcblxuICAvLyBpZiBncHVBY2NlbGVyYXRpb24gaXMgc2V0IHRvIGB0cnVlYCBhbmQgdHJhbnNmb3JtIGlzIHN1cHBvcnRlZCxcbiAgLy8gIHdlIHVzZSBgdHJhbnNsYXRlM2RgIHRvIGFwcGx5IHRoZSBwb3NpdGlvbiB0byB0aGUgcG9wcGVyIHdlXG4gIC8vIGF1dG9tYXRpY2FsbHkgdXNlIHRoZSBzdXBwb3J0ZWQgcHJlZml4ZWQgdmVyc2lvbiBpZiBuZWVkZWRcbiAgdmFyIHByZWZpeGVkUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuXG4gIC8vIG5vdywgbGV0J3MgbWFrZSBhIHN0ZXAgYmFjayBhbmQgbG9vayBhdCB0aGlzIGNvZGUgY2xvc2VseSAod3RmPylcbiAgLy8gSWYgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHBlciBncm93cyBvbmNlIGl0J3MgYmVlbiBwb3NpdGlvbmVkLCBpdFxuICAvLyBtYXkgaGFwcGVuIHRoYXQgdGhlIHBvcHBlciBnZXRzIG1pc3BsYWNlZCBiZWNhdXNlIG9mIHRoZSBuZXcgY29udGVudFxuICAvLyBvdmVyZmxvd2luZyBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVG8gYXZvaWQgdGhpcyBwcm9ibGVtLCB3ZSBwcm92aWRlIHR3byBvcHRpb25zICh4IGFuZCB5KSwgd2hpY2ggYWxsb3dcbiAgLy8gdGhlIGNvbnN1bWVyIHRvIGRlZmluZSB0aGUgb2Zmc2V0IG9yaWdpbi5cbiAgLy8gSWYgd2UgcG9zaXRpb24gYSBwb3BwZXIgb24gdG9wIG9mIGEgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIGNhbiBzZXRcbiAgLy8gYHhgIHRvIGB0b3BgIHRvIG1ha2UgdGhlIHBvcHBlciBncm93IHRvd2FyZHMgaXRzIHRvcCBpbnN0ZWFkIG9mXG4gIC8vIGl0cyBib3R0b20uXG4gIHZhciBsZWZ0ID0gdm9pZCAwLFxuICAgICAgdG9wID0gdm9pZCAwO1xuICBpZiAoc2lkZUEgPT09ICdib3R0b20nKSB7XG4gICAgdG9wID0gLW9mZnNldFBhcmVudFJlY3QuaGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gb2Zmc2V0cy50b3A7XG4gIH1cbiAgaWYgKHNpZGVCID09PSAncmlnaHQnKSB7XG4gICAgbGVmdCA9IC1vZmZzZXRQYXJlbnRSZWN0LndpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gb2Zmc2V0cy5sZWZ0O1xuICB9XG4gIGlmIChncHVBY2NlbGVyYXRpb24gJiYgcHJlZml4ZWRQcm9wZXJ0eSkge1xuICAgIHN0eWxlc1twcmVmaXhlZFByb3BlcnR5XSA9ICd0cmFuc2xhdGUzZCgnICsgbGVmdCArICdweCwgJyArIHRvcCArICdweCwgMCknO1xuICAgIHN0eWxlc1tzaWRlQV0gPSAwO1xuICAgIHN0eWxlc1tzaWRlQl0gPSAwO1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3Rod2VyaXNlLCB3ZSB1c2UgdGhlIHN0YW5kYXJkIGB0b3BgLCBgbGVmdGAsIGBib3R0b21gIGFuZCBgcmlnaHRgIHByb3BlcnRpZXNcbiAgICB2YXIgaW52ZXJ0VG9wID0gc2lkZUEgPT09ICdib3R0b20nID8gLTEgOiAxO1xuICAgIHZhciBpbnZlcnRMZWZ0ID0gc2lkZUIgPT09ICdyaWdodCcgPyAtMSA6IDE7XG4gICAgc3R5bGVzW3NpZGVBXSA9IHRvcCAqIGludmVydFRvcDtcbiAgICBzdHlsZXNbc2lkZUJdID0gbGVmdCAqIGludmVydExlZnQ7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSBzaWRlQSArICcsICcgKyBzaWRlQjtcbiAgfVxuXG4gIC8vIEF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ3gtcGxhY2VtZW50JzogZGF0YS5wbGFjZW1lbnRcbiAgfTtcblxuICAvLyBVcGRhdGUgYGRhdGFgIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgYXJyb3dTdHlsZXNcbiAgZGF0YS5hdHRyaWJ1dGVzID0gX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIGRhdGEuYXR0cmlidXRlcyk7XG4gIGRhdGEuc3R5bGVzID0gX2V4dGVuZHMoe30sIHN0eWxlcywgZGF0YS5zdHlsZXMpO1xuICBkYXRhLmFycm93U3R5bGVzID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5hcnJvdywgZGF0YS5hcnJvd1N0eWxlcyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgZGVwZW5kcyBmcm9tIGFub3RoZXIgb25lLjxiciAvPlxuICogSXQgY2hlY2tzIGlmIHRoZSBuZWVkZWQgbW9kaWZpZXIgaXMgbGlzdGVkIGFuZCBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzIC0gbGlzdCBvZiBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0aW5nTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RlZE5hbWUgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJSZXF1aXJlZChtb2RpZmllcnMsIHJlcXVlc3RpbmdOYW1lLCByZXF1ZXN0ZWROYW1lKSB7XG4gIHZhciByZXF1ZXN0aW5nID0gZmluZChtb2RpZmllcnMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgPT09IHJlcXVlc3RpbmdOYW1lO1xuICB9KTtcblxuICB2YXIgaXNSZXF1aXJlZCA9ICEhcmVxdWVzdGluZyAmJiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJiBtb2RpZmllci5lbmFibGVkICYmIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlcjtcbiAgfSk7XG5cbiAgaWYgKCFpc1JlcXVpcmVkKSB7XG4gICAgdmFyIF9yZXF1ZXN0aW5nID0gJ2AnICsgcmVxdWVzdGluZ05hbWUgKyAnYCc7XG4gICAgdmFyIHJlcXVlc3RlZCA9ICdgJyArIHJlcXVlc3RlZE5hbWUgKyAnYCc7XG4gICAgY29uc29sZS53YXJuKHJlcXVlc3RlZCArICcgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgJyArIF9yZXF1ZXN0aW5nICsgJyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICcgKyBfcmVxdWVzdGluZyArICchJyk7XG4gIH1cbiAgcmV0dXJuIGlzUmVxdWlyZWQ7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBhcnJvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzJGFycm93O1xuXG4gIC8vIGFycm93IGRlcGVuZHMgb24ga2VlcFRvZ2V0aGVyIGluIG9yZGVyIHRvIHdvcmtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdhcnJvdycsICdrZWVwVG9nZXRoZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGFycm93RWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgYSBzdHJpbmcsIHN1cHBvc2UgaXQncyBhIENTUyBzZWxlY3RvclxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgbm90IGZvdW5kLCBkb24ndCBydW4gdGhlIG1vZGlmaWVyXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgYXJyb3dFbGVtZW50IGlzbid0IGEgcXVlcnkgc2VsZWN0b3Igd2UgbXVzdCBjaGVjayB0aGF0IHRoZVxuICAgIC8vIHByb3ZpZGVkIERPTSBub2RlIGlzIGNoaWxkIG9mIGl0cyBwb3BwZXIgbm9kZVxuICAgIGlmICghZGF0YS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNpZGVDYXBpdGFsaXplZCA9IGlzVmVydGljYWwgPyAnVG9wJyA6ICdMZWZ0JztcbiAgdmFyIHNpZGUgPSBzaWRlQ2FwaXRhbGl6ZWQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGFsdFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICB2YXIgYXJyb3dFbGVtZW50U2l6ZSA9IGdldE91dGVyU2l6ZXMoYXJyb3dFbGVtZW50KVtsZW5dO1xuXG4gIC8vXG4gIC8vIGV4dGVuZHMga2VlcFRvZ2V0aGVyIGJlaGF2aW9yIG1ha2luZyBzdXJlIHRoZSBwb3BwZXIgYW5kIGl0c1xuICAvLyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1Y3Rpb25cbiAgLy9cblxuICAvLyB0b3AvbGVmdCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUgPCBwb3BwZXJbc2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC09IHBvcHBlcltzaWRlXSAtIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUpO1xuICB9XG4gIC8vIGJvdHRvbS9yaWdodCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplID4gcG9wcGVyW29wU2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdICs9IHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgLSBwb3BwZXJbb3BTaWRlXTtcbiAgfVxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcblxuICAvLyBjb21wdXRlIGNlbnRlciBvZiB0aGUgcG9wcGVyXG4gIHZhciBjZW50ZXIgPSByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbGVuXSAvIDIgLSBhcnJvd0VsZW1lbnRTaXplIC8gMjtcblxuICAvLyBDb21wdXRlIHRoZSBzaWRlVmFsdWUgdXNpbmcgdGhlIHVwZGF0ZWQgcG9wcGVyIG9mZnNldHNcbiAgLy8gdGFrZSBwb3BwZXIgbWFyZ2luIGluIGFjY291bnQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHRoaXMgaW5mbyBhdmFpbGFibGVcbiAgdmFyIGNzcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBwb3BwZXJNYXJnaW5TaWRlID0gcGFyc2VGbG9hdChjc3NbJ21hcmdpbicgKyBzaWRlQ2FwaXRhbGl6ZWRdLCAxMCk7XG4gIHZhciBwb3BwZXJCb3JkZXJTaWRlID0gcGFyc2VGbG9hdChjc3NbJ2JvcmRlcicgKyBzaWRlQ2FwaXRhbGl6ZWQgKyAnV2lkdGgnXSwgMTApO1xuICB2YXIgc2lkZVZhbHVlID0gY2VudGVyIC0gZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtIHBvcHBlck1hcmdpblNpZGUgLSBwb3BwZXJCb3JkZXJTaWRlO1xuXG4gIC8vIHByZXZlbnQgYXJyb3dFbGVtZW50IGZyb20gYmVpbmcgcGxhY2VkIG5vdCBjb250aWd1b3VzbHkgdG8gaXRzIHBvcHBlclxuICBzaWRlVmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihwb3BwZXJbbGVuXSAtIGFycm93RWxlbWVudFNpemUsIHNpZGVWYWx1ZSksIDApO1xuXG4gIGRhdGEuYXJyb3dFbGVtZW50ID0gYXJyb3dFbGVtZW50O1xuICBkYXRhLm9mZnNldHMuYXJyb3cgPSAoX2RhdGEkb2Zmc2V0cyRhcnJvdyA9IHt9LCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBzaWRlLCBNYXRoLnJvdW5kKHNpZGVWYWx1ZSkpLCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBhbHRTaWRlLCAnJyksIF9kYXRhJG9mZnNldHMkYXJyb3cpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IHZhcmlhdGlvbiBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IHZhcmlhdGlvblxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbikge1xuICBpZiAodmFyaWF0aW9uID09PSAnZW5kJykge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9IGVsc2UgaWYgKHZhcmlhdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgIHJldHVybiAnZW5kJztcbiAgfVxuICByZXR1cm4gdmFyaWF0aW9uO1xufVxuXG4vKipcbiAqIExpc3Qgb2YgYWNjZXB0ZWQgcGxhY2VtZW50cyB0byB1c2UgYXMgdmFsdWVzIG9mIHRoZSBgcGxhY2VtZW50YCBvcHRpb24uPGJyIC8+XG4gKiBWYWxpZCBwbGFjZW1lbnRzIGFyZTpcbiAqIC0gYGF1dG9gXG4gKiAtIGB0b3BgXG4gKiAtIGByaWdodGBcbiAqIC0gYGJvdHRvbWBcbiAqIC0gYGxlZnRgXG4gKlxuICogRWFjaCBwbGFjZW1lbnQgY2FuIGhhdmUgYSB2YXJpYXRpb24gZnJvbSB0aGlzIGxpc3Q6XG4gKiAtIGAtc3RhcnRgXG4gKiAtIGAtZW5kYFxuICpcbiAqIFZhcmlhdGlvbnMgYXJlIGludGVycHJldGVkIGVhc2lseSBpZiB5b3UgdGhpbmsgb2YgdGhlbSBhcyB0aGUgbGVmdCB0byByaWdodFxuICogd3JpdHRlbiBsYW5ndWFnZXMuIEhvcml6b250YWxseSAoYHRvcGAgYW5kIGBib3R0b21gKSwgYHN0YXJ0YCBpcyBsZWZ0IGFuZCBgZW5kYFxuICogaXMgcmlnaHQuPGJyIC8+XG4gKiBWZXJ0aWNhbGx5IChgbGVmdGAgYW5kIGByaWdodGApLCBgc3RhcnRgIGlzIHRvcCBhbmQgYGVuZGAgaXMgYm90dG9tLlxuICpcbiAqIFNvbWUgdmFsaWQgZXhhbXBsZXMgYXJlOlxuICogLSBgdG9wLWVuZGAgKG9uIHRvcCBvZiByZWZlcmVuY2UsIHJpZ2h0IGFsaWduZWQpXG4gKiAtIGByaWdodC1zdGFydGAgKG9uIHJpZ2h0IG9mIHJlZmVyZW5jZSwgdG9wIGFsaWduZWQpXG4gKiAtIGBib3R0b21gIChvbiBib3R0b20sIGNlbnRlcmVkKVxuICogLSBgYXV0by1yaWdodGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIHBsYWNlbWVudHMgPSBbJ2F1dG8tc3RhcnQnLCAnYXV0bycsICdhdXRvLWVuZCcsICd0b3Atc3RhcnQnLCAndG9wJywgJ3RvcC1lbmQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQnLCAncmlnaHQtZW5kJywgJ2JvdHRvbS1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdsZWZ0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnXTtcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG52YXIgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHBsYWNlbWVudCwgcmV0dXJucyBhbGwgdGhlIHN1YnNlcXVlbnQgcGxhY2VtZW50c1xuICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCAtIEEgdmFsaWQgcGxhY2VtZW50IChpdCBhY2NlcHRzIHZhcmlhdGlvbnMpXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IGNvdW50ZXIgLSBTZXQgdG8gdHJ1ZSB0byB3YWxrIHRoZSBwbGFjZW1lbnRzIGNvdW50ZXJjbG9ja3dpc2VcbiAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICovXG5mdW5jdGlvbiBjbG9ja3dpc2UocGxhY2VtZW50KSB7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaW5kZXggPSB2YWxpZFBsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpO1xuICB2YXIgYXJyID0gdmFsaWRQbGFjZW1lbnRzLnNsaWNlKGluZGV4ICsgMSkuY29uY2F0KHZhbGlkUGxhY2VtZW50cy5zbGljZSgwLCBpbmRleCkpO1xuICByZXR1cm4gY291bnRlciA/IGFyci5yZXZlcnNlKCkgOiBhcnI7XG59XG5cbnZhciBCRUhBVklPUlMgPSB7XG4gIEZMSVA6ICdmbGlwJyxcbiAgQ0xPQ0tXSVNFOiAnY2xvY2t3aXNlJyxcbiAgQ09VTlRFUkNMT0NLV0lTRTogJ2NvdW50ZXJjbG9ja3dpc2UnXG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gZmxpcChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGlmIGBpbm5lcmAgbW9kaWZpZXIgaXMgZW5hYmxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBgZmxpcGAgbW9kaWZpZXJcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaW5uZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGEuZmxpcHBlZCAmJiBkYXRhLnBsYWNlbWVudCA9PT0gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgIC8vIHNlZW1zIGxpa2UgZmxpcCBpcyB0cnlpbmcgdG8gbG9vcCwgcHJvYmFibHkgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIG9uIGFueSBvZiB0aGUgZmxpcHBhYmxlIHNpZGVzXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzFdIHx8ICcnO1xuXG4gIHZhciBmbGlwT3JkZXIgPSBbXTtcblxuICBzd2l0Y2ggKG9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBjYXNlIEJFSEFWSU9SUy5GTElQOlxuICAgICAgZmxpcE9yZGVyID0gW3BsYWNlbWVudCwgcGxhY2VtZW50T3Bwb3NpdGVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DT1VOVEVSQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZmxpcE9yZGVyID0gb3B0aW9ucy5iZWhhdmlvcjtcbiAgfVxuXG4gIGZsaXBPcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwLCBpbmRleCkge1xuICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgICB2YXIgcmVmT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICAvLyB1c2luZyBmbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBvdmVybGFwc1JlZiA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IocmVmT2Zmc2V0cy5sZWZ0KSB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKHJlZk9mZnNldHMucmlnaHQpIHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IocmVmT2Zmc2V0cy50b3ApIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IocmVmT2Zmc2V0cy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0xlZnQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IoYm91bmRhcmllcy5sZWZ0KTtcbiAgICB2YXIgb3ZlcmZsb3dzUmlnaHQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKGJvdW5kYXJpZXMucmlnaHQpO1xuICAgIHZhciBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgdmFyIG92ZXJmbG93c0JvdHRvbSA9IGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKGJvdW5kYXJpZXMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NCb3VuZGFyaWVzID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBvdmVyZmxvd3NUb3AgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBvdmVyZmxvd3NCb3R0b207XG5cbiAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb24gPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnMgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0xlZnQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1JpZ2h0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NUb3AgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NCb3R0b20pO1xuXG4gICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMgfHwgZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgLy8gdGhpcyBib29sZWFuIHRvIGRldGVjdCBhbnkgZmxpcCBsb29wXG4gICAgICBkYXRhLmZsaXBwZWQgPSB0cnVlO1xuXG4gICAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcykge1xuICAgICAgICBwbGFjZW1lbnQgPSBmbGlwT3JkZXJbaW5kZXggKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgdmFyaWF0aW9uID0gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5wbGFjZW1lbnQgPSBwbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xuXG4gICAgICAvLyB0aGlzIG9iamVjdCBjb250YWlucyBgcG9zaXRpb25gLCB3ZSB3YW50IHRvIHByZXNlcnZlIGl0IGFsb25nIHdpdGhcbiAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHByb3BlcnR5IHdlIG1heSBhZGQgaW4gdGhlIGZ1dHVyZVxuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMucG9wcGVyLCBnZXRQb3BwZXJPZmZzZXRzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCkpO1xuXG4gICAgICBkYXRhID0gcnVuTW9kaWZpZXJzKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBkYXRhLCAnZmxpcCcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24ga2VlcFRvZ2V0aGVyKGRhdGEpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdyaWdodCcgOiAnYm90dG9tJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICBpZiAocG9wcGVyW3NpZGVdIDwgZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pIC0gcG9wcGVyW21lYXN1cmVtZW50XTtcbiAgfVxuICBpZiAocG9wcGVyW29wU2lkZV0gPiBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW3NpZGVdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdmFsdWUgKyB1bml0IGludG8gYSBweCB2YWx1ZSBudW1iZXJcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzdHIgLSBWYWx1ZSArIHVuaXQgc3RyaW5nXG4gKiBAYXJndW1lbnQge1N0cmluZ30gbWVhc3VyZW1lbnQgLSBgaGVpZ2h0YCBvciBgd2lkdGhgXG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICogVmFsdWUgaW4gcGl4ZWxzLCBvciBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdmFsdWVzIHdlcmUgZXh0cmFjdGVkXG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cykge1xuICAvLyBzZXBhcmF0ZSB2YWx1ZSBmcm9tIHVuaXRcbiAgdmFyIHNwbGl0ID0gc3RyLm1hdGNoKC8oKD86XFwtfFxcKyk/XFxkKlxcLj9cXGQqKSguKikvKTtcbiAgdmFyIHZhbHVlID0gK3NwbGl0WzFdO1xuICB2YXIgdW5pdCA9IHNwbGl0WzJdO1xuXG4gIC8vIElmIGl0J3Mgbm90IGEgbnVtYmVyIGl0J3MgYW4gb3BlcmF0b3IsIEkgZ3Vlc3NcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBpZiAodW5pdC5pbmRleE9mKCclJykgPT09IDApIHtcbiAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgIGNhc2UgJyVwJzpcbiAgICAgICAgZWxlbWVudCA9IHBvcHBlck9mZnNldHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJSc6XG4gICAgICBjYXNlICclcic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbGVtZW50ID0gcmVmZXJlbmNlT2Zmc2V0cztcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3ZoJyB8fCB1bml0ID09PSAndncnKSB7XG4gICAgLy8gaWYgaXMgYSB2aCBvciB2dywgd2UgY2FsY3VsYXRlIHRoZSBzaXplIGJhc2VkIG9uIHRoZSB2aWV3cG9ydFxuICAgIHZhciBzaXplID0gdm9pZCAwO1xuICAgIGlmICh1bml0ID09PSAndmgnKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpcyBhbiBleHBsaWNpdCBwaXhlbCB1bml0LCB3ZSBnZXQgcmlkIG9mIHRoZSB1bml0IGFuZCBrZWVwIHRoZSB2YWx1ZVxuICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBgb2Zmc2V0YCBzdHJpbmcgdG8gZXh0cmFwb2xhdGUgYHhgIGFuZCBgeWAgbnVtZXJpYyBvZmZzZXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICogQHJldHVybnMge0FycmF5fSBhIHR3byBjZWxscyBhcnJheSB3aXRoIHggYW5kIHkgb2Zmc2V0cyBpbiBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cywgYmFzZVBsYWNlbWVudCkge1xuICB2YXIgb2Zmc2V0cyA9IFswLCAwXTtcblxuICAvLyBVc2UgaGVpZ2h0IGlmIHBsYWNlbWVudCBpcyBsZWZ0IG9yIHJpZ2h0IGFuZCBpbmRleCBpcyAwIG90aGVyd2lzZSB1c2Ugd2lkdGhcbiAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAvLyB3aWxsIHVzZSB0aGUgb3RoZXIgb25lXG4gIHZhciB1c2VIZWlnaHQgPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAvLyBTcGxpdCB0aGUgb2Zmc2V0IHN0cmluZyB0byBvYnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHNcbiAgLy8gVGhlIHJlZ2V4IGFkZHJlc3NlcyB2YWx1ZXMgd2l0aCB0aGUgcGx1cyBvciBtaW51cyBzaWduIGluIGZyb250ICgrMTAsIC0yMCwgZXRjKVxuICB2YXIgZnJhZ21lbnRzID0gb2Zmc2V0LnNwbGl0KC8oXFwrfFxcLSkvKS5tYXAoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy50cmltKCk7XG4gIH0pO1xuXG4gIC8vIERldGVjdCBpZiB0aGUgb2Zmc2V0IHN0cmluZyBjb250YWlucyBhIHBhaXIgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIG9uZVxuICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICB2YXIgZGl2aWRlciA9IGZyYWdtZW50cy5pbmRleE9mKGZpbmQoZnJhZ21lbnRzLCBmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnNlYXJjaCgvLHxcXHMvKSAhPT0gLTE7XG4gIH0pKTtcblxuICBpZiAoZnJhZ21lbnRzW2RpdmlkZXJdICYmIGZyYWdtZW50c1tkaXZpZGVyXS5pbmRleE9mKCcsJykgPT09IC0xKSB7XG4gICAgY29uc29sZS53YXJuKCdPZmZzZXRzIHNlcGFyYXRlZCBieSB3aGl0ZSBzcGFjZShzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIGEgY29tbWEgKCwpIGluc3RlYWQuJyk7XG4gIH1cblxuICAvLyBJZiBkaXZpZGVyIGlzIGZvdW5kLCB3ZSBkaXZpZGUgdGhlIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kcyB0byBkaXZpZGVcbiAgLy8gdGhlbSBieSBvZnNldCBYIGFuZCBZLlxuICB2YXIgc3BsaXRSZWdleCA9IC9cXHMqLFxccyp8XFxzKy87XG4gIHZhciBvcHMgPSBkaXZpZGVyICE9PSAtMSA/IFtmcmFnbWVudHMuc2xpY2UoMCwgZGl2aWRlcikuY29uY2F0KFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMF1dKSwgW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVsxXV0uY29uY2F0KGZyYWdtZW50cy5zbGljZShkaXZpZGVyICsgMSkpXSA6IFtmcmFnbWVudHNdO1xuXG4gIC8vIENvbnZlcnQgdGhlIHZhbHVlcyB3aXRoIHVuaXRzIHRvIGFic29sdXRlIHBpeGVscyB0byBhbGxvdyBvdXIgY29tcHV0YXRpb25zXG4gIG9wcyA9IG9wcy5tYXAoZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIC8vIE1vc3Qgb2YgdGhlIHVuaXRzIHJlbHkgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwb3BwZXJcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSAoaW5kZXggPT09IDEgPyAhdXNlSGVpZ2h0IDogdXNlSGVpZ2h0KSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICByZXR1cm4gb3BcbiAgICAvLyBUaGlzIGFnZ3JlZ2F0ZXMgYW55IGArYCBvciBgLWAgc2lnbiB0aGF0IGFyZW4ndCBjb25zaWRlcmVkIG9wZXJhdG9yc1xuICAgIC8vIGUuZy46IDEwICsgKzUgPT4gWzEwLCArLCArNV1cbiAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYVthLmxlbmd0aCAtIDFdID09PSAnJyAmJiBbJysnLCAnLSddLmluZGV4T2YoYikgIT09IC0xKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2UgaWYgKG1lcmdlV2l0aFByZXZpb3VzKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSArPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgIH1cbiAgICB9LCBbXSlcbiAgICAvLyBIZXJlIHdlIGNvbnZlcnQgdGhlIHN0cmluZyB2YWx1ZXMgaW50byBudW1iZXIgdmFsdWVzIChpbiBweClcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBMb29wIHRyb3VnaCB0aGUgb2Zmc2V0cyBhcnJheXMgYW5kIGV4ZWN1dGUgdGhlIG9wZXJhdGlvbnNcbiAgb3BzLmZvckVhY2goZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIG9wLmZvckVhY2goZnVuY3Rpb24gKGZyYWcsIGluZGV4Mikge1xuICAgICAgaWYgKGlzTnVtZXJpYyhmcmFnKSkge1xuICAgICAgICBvZmZzZXRzW2luZGV4XSArPSBmcmFnICogKG9wW2luZGV4MiAtIDFdID09PSAnLScgPyAtMSA6IDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQGFyZ3VtZW50IHtOdW1iZXJ8U3RyaW5nfSBvcHRpb25zLm9mZnNldD0wXG4gKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gb2Zmc2V0KGRhdGEsIF9yZWYpIHtcbiAgdmFyIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQsXG4gICAgICBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIHZhciBvZmZzZXRzID0gdm9pZCAwO1xuICBpZiAoaXNOdW1lcmljKCtvZmZzZXQpKSB7XG4gICAgb2Zmc2V0cyA9IFsrb2Zmc2V0LCAwXTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRzID0gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYmFzZVBsYWNlbWVudCk7XG4gIH1cblxuICBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0IC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wIC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1sxXTtcbiAgfVxuXG4gIGRhdGEucG9wcGVyID0gcG9wcGVyO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kYXJpZXNFbGVtZW50ID0gb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCB8fCBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuXG4gIC8vIElmIG9mZnNldFBhcmVudCBpcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIHJlYWxseSB3YW50IHRvXG4gIC8vIGdvIG9uZSBzdGVwIHVwIGFuZCB1c2UgdGhlIG5leHQgb2Zmc2V0UGFyZW50IGFzIHJlZmVyZW5jZSB0b1xuICAvLyBhdm9pZCB0byBtYWtlIHRoaXMgbW9kaWZpZXIgY29tcGxldGVseSB1c2VsZXNzIGFuZCBsb29rIGxpa2UgYnJva2VuXG4gIGlmIChkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICBib3VuZGFyaWVzRWxlbWVudCA9IGdldE9mZnNldFBhcmVudChib3VuZGFyaWVzRWxlbWVudCk7XG4gIH1cblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzZXRzIHRoZSBwb3BwZXIncyBwb3NpdGlvbiBzbyB0aGF0IHRoZSBkb2N1bWVudCBzaXplIGNhbiBiZSBjYWxjdWxhdGVkIGV4Y2x1ZGluZ1xuICAvLyB0aGUgc2l6ZSBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgaXRzZWxmXG4gIHZhciB0cmFuc2Zvcm1Qcm9wID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcbiAgdmFyIHBvcHBlclN0eWxlcyA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnN0eWxlOyAvLyBhc3NpZ25tZW50IHRvIGhlbHAgbWluaWZpY2F0aW9uXG4gIHZhciB0b3AgPSBwb3BwZXJTdHlsZXMudG9wLFxuICAgICAgbGVmdCA9IHBvcHBlclN0eWxlcy5sZWZ0LFxuICAgICAgdHJhbnNmb3JtID0gcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdO1xuXG4gIHBvcHBlclN0eWxlcy50b3AgPSAnJztcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSAnJztcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gJyc7XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIG9mZnNldHMgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gIHBvcHBlclN0eWxlcy50b3AgPSB0b3A7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gbGVmdDtcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuXG4gIG9wdGlvbnMuYm91bmRhcmllcyA9IGJvdW5kYXJpZXM7XG5cbiAgdmFyIG9yZGVyID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgdmFyIGNoZWNrID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uIHByaW1hcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgocG9wcGVyW3BsYWNlbWVudF0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIHBsYWNlbWVudCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5OiBmdW5jdGlvbiBzZWNvbmRhcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPiBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKHBvcHBlclttYWluU2lkZV0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSAtIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIG1haW5TaWRlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHZhciBzaWRlID0gWydsZWZ0JywgJ3RvcCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5JztcbiAgICBwb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBjaGVja1tzaWRlXShwbGFjZW1lbnQpKTtcbiAgfSk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gc2hpZnQoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBzaGlmdHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIC8vIGlmIHNoaWZ0IHNoaWZ0dmFyaWF0aW9uIGlzIHNwZWNpZmllZCwgcnVuIHRoZSBtb2RpZmllclxuICBpZiAoc2hpZnR2YXJpYXRpb24pIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyO1xuXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgdmFyIHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgIHN0YXJ0OiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdKSxcbiAgICAgIGVuZDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVttZWFzdXJlbWVudF0gLSBwb3BwZXJbbWVhc3VyZW1lbnRdKVxuICAgIH07XG5cbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgc2hpZnRPZmZzZXRzW3NoaWZ0dmFyaWF0aW9uXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciByZWZSZWN0ID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIGJvdW5kID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdwcmV2ZW50T3ZlcmZsb3cnO1xuICB9KS5ib3VuZGFyaWVzO1xuXG4gIGlmIChyZWZSZWN0LmJvdHRvbSA8IGJvdW5kLnRvcCB8fCByZWZSZWN0LmxlZnQgPiBib3VuZC5yaWdodCB8fCByZWZSZWN0LnRvcCA+IGJvdW5kLmJvdHRvbSB8fCByZWZSZWN0LnJpZ2h0IDwgYm91bmQubGVmdCkge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IHRydWU7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gZmFsc2U7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBpbm5lcihkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc0hvcml6ID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIHN1YnRyYWN0TGVuZ3RoID0gWyd0b3AnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPT09IC0xO1xuXG4gIHBvcHBlcltpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCddID0gcmVmZXJlbmNlW2Jhc2VQbGFjZW1lbnRdIC0gKHN1YnRyYWN0TGVuZ3RoID8gcG9wcGVyW2lzSG9yaXogPyAnd2lkdGgnIDogJ2hlaWdodCddIDogMCk7XG5cbiAgZGF0YS5wbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChwb3BwZXIpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyIGZ1bmN0aW9uLCBlYWNoIG1vZGlmaWVyIGNhbiBoYXZlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIGFzc2lnbmVkXG4gKiB0byBpdHMgYGZuYCBwcm9wZXJ0eS48YnIgLz5cbiAqIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZSwgdGhpcyBtZWFucyB0aGF0IHlvdSBtdXN0XG4gKiBtYWtlIHN1cmUgdGhleSBhcmUgcGVyZm9ybWFudCBlbm91Z2ggdG8gYXZvaWQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuXG4gKlxuICogQGZ1bmN0aW9uIE1vZGlmaWVyRm5cbiAqIEBhcmd1bWVudCB7ZGF0YU9iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5cbi8qKlxuICogTW9kaWZpZXJzIGFyZSBwbHVnaW5zIHVzZWQgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHlvdXIgcG9wcGVycy48YnIgLz5cbiAqIFBvcHBlci5qcyB1c2VzIGEgc2V0IG9mIDkgbW9kaWZpZXJzIHRvIHByb3ZpZGUgYWxsIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXNcbiAqIG5lZWRlZCBieSB0aGUgbGlicmFyeS5cbiAqXG4gKiBVc3VhbGx5IHlvdSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIHRoZSBgb3JkZXJgLCBgZm5gIGFuZCBgb25Mb2FkYCBwcm9wcy5cbiAqIEFsbCB0aGUgb3RoZXIgcHJvcGVydGllcyBhcmUgY29uZmlndXJhdGlvbnMgdGhhdCBjb3VsZCBiZSB0d2Vha2VkLlxuICogQG5hbWVzcGFjZSBtb2RpZmllcnNcbiAqL1xudmFyIG1vZGlmaWVycyA9IHtcbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gc2hpZnQgdGhlIHBvcHBlciBvbiB0aGUgc3RhcnQgb3IgZW5kIG9mIGl0cyByZWZlcmVuY2VcbiAgICogZWxlbWVudC48YnIgLz5cbiAgICogSXQgd2lsbCByZWFkIHRoZSB2YXJpYXRpb24gb2YgdGhlIGBwbGFjZW1lbnRgIHByb3BlcnR5LjxiciAvPlxuICAgKiBJdCBjYW4gYmUgb25lIGVpdGhlciBgLWVuZGAgb3IgYC1zdGFydGAuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBzaGlmdDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0xMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHNoaWZ0XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBgb2Zmc2V0YCBtb2RpZmllciBjYW4gc2hpZnQgeW91ciBwb3BwZXIgb24gYm90aCBpdHMgYXhpcy5cbiAgICpcbiAgICogSXQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHVuaXRzOlxuICAgKiAtIGBweGAgb3IgdW5pdGxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGhlaWdodC5cbiAgICpcbiAgICogWW91IGNhbiBwcm92aWRlIGEgc2luZ2xlIHZhbHVlIChhcyBgTnVtYmVyYCBvciBgU3RyaW5nYCksIG9yIGEgcGFpciBvZiB2YWx1ZXNcbiAgICogYXMgYFN0cmluZ2AgZGl2aWRlZCBieSBhIGNvbW1hIG9yIG9uZSAob3IgbW9yZSkgd2hpdGUgc3BhY2VzLjxiciAvPlxuICAgKiBUaGUgbGF0dGVyIGlzIGEgZGVwcmVjYXRlZCBtZXRob2QgYmVjYXVzZSBpdCBsZWFkcyB0byBjb25mdXNpb24gYW5kIHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpbiB2Mi48YnIgLz5cbiAgICogQWRkaXRpb25hbGx5LCBpdCBhY2NlcHRzIGFkZGl0aW9ucyBhbmQgc3VidHJhY3Rpb25zIGJldHdlZW4gZGlmZmVyZW50IHVuaXRzLlxuICAgKiBOb3RlIHRoYXQgbXVsdGlwbGljYXRpb25zIGFuZCBkaXZpc2lvbnMgYXJlbid0IHN1cHBvcnRlZC5cbiAgICpcbiAgICogVmFsaWQgZXhhbXBsZXMgYXJlOlxuICAgKiBgYGBcbiAgICogMTBcbiAgICogJzEwJSdcbiAgICogJzEwLCAxMCdcbiAgICogJzEwJSwgMTAnXG4gICAqICcxMCArIDEwJSdcbiAgICogJzEwIC0gNXZoICsgMyUnXG4gICAqICctMTBweCArIDV2aCwgNXB4IC0gNiUnXG4gICAqIGBgYFxuICAgKiA+ICoqTkIqKjogSWYgeW91IGRlc2lyZSB0byBhcHBseSBvZmZzZXRzIHRvIHlvdXIgcG9wcGVycyBpbiBhIHdheSB0aGF0IG1heSBtYWtlIHRoZW0gb3ZlcmxhcFxuICAgKiA+IHdpdGggdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnQsIHVuZm9ydHVuYXRlbHksIHlvdSB3aWxsIGhhdmUgdG8gZGlzYWJsZSB0aGUgYGZsaXBgIG1vZGlmaWVyLlxuICAgKiA+IE1vcmUgb24gdGhpcyBbcmVhZGluZyB0aGlzIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9pc3N1ZXMvMzczKVxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgb2Zmc2V0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTIwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogb2Zmc2V0LFxuICAgIC8qKiBAcHJvcCB7TnVtYmVyfFN0cmluZ30gb2Zmc2V0PTBcbiAgICAgKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBvZmZzZXQ6IDBcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBwcmV2ZW50IHRoZSBwb3BwZXIgZnJvbSBiZWluZyBwb3NpdGlvbmVkIG91dHNpZGUgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBBbiBzY2VuYXJpbyBleGlzdHMgd2hlcmUgdGhlIHJlZmVyZW5jZSBpdHNlbGYgaXMgbm90IHdpdGhpbiB0aGUgYm91bmRhcmllcy48YnIgLz5cbiAgICogV2UgY2FuIHNheSBpdCBoYXMgXCJlc2NhcGVkIHRoZSBib3VuZGFyaWVzXCIg4oCUIG9yIGp1c3QgXCJlc2NhcGVkXCIuPGJyIC8+XG4gICAqIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRoZSBwb3BwZXIgc2hvdWxkIGVpdGhlcjpcbiAgICpcbiAgICogLSBkZXRhY2ggZnJvbSB0aGUgcmVmZXJlbmNlIGFuZCByZW1haW4gXCJ0cmFwcGVkXCIgaW4gdGhlIGJvdW5kYXJpZXMsIG9yXG4gICAqIC0gaWYgaXQgc2hvdWxkIGlnbm9yZSB0aGUgYm91bmRhcnkgYW5kIFwiZXNjYXBlIHdpdGggaXRzIHJlZmVyZW5jZVwiXG4gICAqXG4gICAqIFdoZW4gYGVzY2FwZVdpdGhSZWZlcmVuY2VgIGlzIHNldCB0b2B0cnVlYCBhbmQgcmVmZXJlbmNlIGlzIGNvbXBsZXRlbHlcbiAgICogb3V0c2lkZSBpdHMgYm91bmRhcmllcywgdGhlIHBvcHBlciB3aWxsIG92ZXJmbG93IChvciBjb21wbGV0ZWx5IGxlYXZlKVxuICAgKiB0aGUgYm91bmRhcmllcyBpbiBvcmRlciB0byByZW1haW4gYXR0YWNoZWQgdG8gdGhlIGVkZ2Ugb2YgdGhlIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHByZXZlbnRPdmVyZmxvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0zMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDMwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7QXJyYXl9IFtwcmlvcml0eT1bJ2xlZnQnLCdyaWdodCcsJ3RvcCcsJ2JvdHRvbSddXVxuICAgICAqIFBvcHBlciB3aWxsIHRyeSB0byBwcmV2ZW50IG92ZXJmbG93IGZvbGxvd2luZyB0aGVzZSBwcmlvcml0aWVzIGJ5IGRlZmF1bHQsXG4gICAgICogdGhlbiwgaXQgY291bGQgb3ZlcmZsb3cgb24gdGhlIGxlZnQgYW5kIG9uIHRvcCBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHByaW9yaXR5OiBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIEFtb3VudCBvZiBwaXhlbCB1c2VkIHRvIGRlZmluZSBhIG1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm91bmRhcmllc1xuICAgICAqIGFuZCB0aGUgcG9wcGVyIHRoaXMgbWFrZXMgc3VyZSB0aGUgcG9wcGVyIGhhcyBhbHdheXMgYSBsaXR0bGUgcGFkZGluZ1xuICAgICAqIGJldHdlZW4gdGhlIGVkZ2VzIG9mIGl0cyBjb250YWluZXJcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSdzY3JvbGxQYXJlbnQnXG4gICAgICogQm91bmRhcmllcyB1c2VkIGJ5IHRoZSBtb2RpZmllciwgY2FuIGJlIGBzY3JvbGxQYXJlbnRgLCBgd2luZG93YCxcbiAgICAgKiBgdmlld3BvcnRgIG9yIGFueSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3Njcm9sbFBhcmVudCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHJlZmVyZW5jZSBhbmQgaXRzIHBvcHBlciBzdGF5IG5lYXIgZWFjaG90aGVyc1xuICAgKiB3aXRob3V0IGxlYXZpbmcgYW55IGdhcCBiZXR3ZWVuIHRoZSB0d28uIEV4cGVjaWFsbHkgdXNlZnVsIHdoZW4gdGhlIGFycm93IGlzXG4gICAqIGVuYWJsZWQgYW5kIHlvdSB3YW50IHRvIGFzc3VyZSBpdCB0byBwb2ludCB0byBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEl0IGNhcmVzIG9ubHkgYWJvdXQgdGhlIGZpcnN0IGF4aXMsIHlvdSBjYW4gc3RpbGwgaGF2ZSBwb3BwZXJzIHdpdGggbWFyZ2luXG4gICAqIGJldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAga2VlcFRvZ2V0aGVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTQwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNDAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjoga2VlcFRvZ2V0aGVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kaWZpZXIgaXMgdXNlZCB0byBtb3ZlIHRoZSBgYXJyb3dFbGVtZW50YCBvZiB0aGUgcG9wcGVyIHRvIG1ha2VcbiAgICogc3VyZSBpdCBpcyBwb3NpdGlvbmVkIGJldHdlZW4gdGhlIHJlZmVyZW5jZSBlbGVtZW50IGFuZCBpdHMgcG9wcGVyIGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgb3V0ZXIgc2l6ZSBvZiB0aGUgYGFycm93RWxlbWVudGAgbm9kZSB0byBkZXRlY3QgaG93IG1hbnlcbiAgICogcGl4ZWxzIG9mIGNvbmp1Y3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBvcHBlcidzIHBsYWNlbWVudCB3aGVuIGl0IHN0YXJ0cyB0byBvdmVybGFwIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudC5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKlxuICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICogcmVzdGFydCBpdCBpZiBpdCBkZXRlY3RzIHRoZSBuZWVkIHRvIGZsaXAgdGhlIHBsYWNlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGZsaXA6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA2MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBmbGlwLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8QXJyYXl9IGJlaGF2aW9yPSdmbGlwJ1xuICAgICAqIFRoZSBiZWhhdmlvciB1c2VkIHRvIGNoYW5nZSB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LiBJdCBjYW4gYmUgb25lIG9mXG4gICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICogcGxhY2VtZW50cyAod2l0aCBvcHRpb25hbCB2YXJpYXRpb25zKS5cbiAgICAgKi9cbiAgICBiZWhhdmlvcjogJ2ZsaXAnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBmbGlwIGlmIGl0IGhpdHMgdGhlIGVkZ2VzIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0ndmlld3BvcnQnXG4gICAgICogVGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBvcHBlciBwb3NpdGlvbixcbiAgICAgKiB0aGUgcG9wcGVyIHdpbGwgbmV2ZXIgYmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllc1xuICAgICAqIChleGNlcHQgaWYga2VlcFRvZ2V0aGVyIGlzIGVuYWJsZWQpXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICd2aWV3cG9ydCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHRoZSBwb3BwZXIgZmxvdyB0b3dhcmQgdGhlIGlubmVyIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQnkgZGVmYXVsdCwgd2hlbiB0aGlzIG1vZGlmaWVyIGlzIGRpc2FibGVkLCB0aGUgcG9wcGVyIHdpbGwgYmUgcGxhY2VkIG91dHNpZGVcbiAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaW5uZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA3MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPWZhbHNlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGlubmVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gaGlkZSB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dHNpZGUgb2YgdGhlXG4gICAqIHBvcHBlciBib3VuZGFyaWVzLiBJdCB3aWxsIHNldCBhIGB4LW91dC1vZi1ib3VuZGFyaWVzYCBhdHRyaWJ1dGUgd2hpY2ggY2FuXG4gICAqIGJlIHVzZWQgdG8gaGlkZSB3aXRoIGEgQ1NTIHNlbGVjdG9yIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGlzXG4gICAqIG91dCBvZiBib3VuZGFyaWVzLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBoaWRlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTgwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaGlkZVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgc3R5bGUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBlbGVtZW50IHRvIGdldHNcbiAgICogcHJvcGVybHkgcG9zaXRpb25lZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbW9kaWZpZXIgd2lsbCBub3QgdG91Y2ggdGhlIERPTSwgaXQganVzdCBwcmVwYXJlcyB0aGUgc3R5bGVzXG4gICAqIHNvIHRoYXQgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGNhbiBhcHBseSBpdC4gVGhpcyBzZXBhcmF0aW9uIGlzIHVzZWZ1bFxuICAgKiBpbiBjYXNlIHlvdSBuZWVkIHRvIHJlcGxhY2UgYGFwcGx5U3R5bGVgIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIFRoaXMgbW9kaWZpZXIgaGFzIGA4NTBgIGFzIGBvcmRlcmAgdmFsdWUgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIFBvcHBlci5qcy4gRXhwZWN0IHRoZSBtb2RpZmllcnMgb3JkZXJpbmcgbWV0aG9kXG4gICAqIHRvIGNoYW5nZSBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMgb2YgdGhlIGxpYnJhcnkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBjb21wdXRlU3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODUwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4NTAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBjb21wdXRlU3R5bGUsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNkIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nYm90dG9tJ11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGBib3R0b21gXG4gICAgICovXG4gICAgeDogJ2JvdHRvbScsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2xlZnQnXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYHJpZ2h0YFxuICAgICAqL1xuICAgIHk6ICdyaWdodCdcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICpcbiAgICogQWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyBhcmUgbGltaXRlZCB0byB0aGlzIG1vZGlmaWVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAqIHdhbnQgdG8gZGVsZWdhdGUgYWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyB0byBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogaGFzIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGFic29sdXRlYCBiZWZvcmUgUG9wcGVyLmpzIGNhbiBkbyBpdHMgd29yayFcbiAgICpcbiAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3Ugb3duIHRvIGFjaGlldmUgdGhlIGRlc2lyZWQgZWZmZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXBwbHlTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj05MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDkwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFwcGx5U3R5bGUsXG4gICAgLyoqIEBwcm9wIHtGdW5jdGlvbn0gKi9cbiAgICBvbkxvYWQ6IGFwcGx5U3R5bGVPbkxvYWQsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEwLjAsIHRoZSBwcm9wZXJ0eSBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllclxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzZCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHVuZGVmaW5lZFxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBgZGF0YU9iamVjdGAgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvcm1hdGlvbnMgdXNlZCBieSBQb3BwZXIuanNcbiAqIHRoaXMgb2JqZWN0IGdldCBwYXNzZWQgdG8gbW9kaWZpZXJzIGFuZCB0byB0aGUgYG9uQ3JlYXRlYCBhbmQgYG9uVXBkYXRlYCBjYWxsYmFja3MuXG4gKiBAbmFtZSBkYXRhT2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5pbnN0YW5jZSBUaGUgUG9wcGVyLmpzIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5wbGFjZW1lbnQgUGxhY2VtZW50IGFwcGxpZWQgdG8gcG9wcGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5mbGlwcGVkIFRydWUgaWYgcG9wcGVyIGhhcyBiZWVuIGZsaXBwZWQgYnkgZmxpcCBtb2RpZmllclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmhpZGUgVHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0IG9mIGJvdW5kYXJpZXMsIHVzZWZ1bCB0byBrbm93IHdoZW4gdG8gaGlkZSB0aGUgcG9wcGVyLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gZGF0YS5hcnJvd0VsZW1lbnQgTm9kZSB1c2VkIGFzIGFycm93IGJ5IGFycm93IG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5zdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsIGl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5hcnJvd1N0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBhcnJvdywgaXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmJvdW5kYXJpZXMgT2Zmc2V0cyBvZiB0aGUgcG9wcGVyIGJvdW5kYXJpZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMgVGhlIG1lYXN1cmVtZW50cyBvZiBwb3BwZXIsIHJlZmVyZW5jZSBhbmQgYXJyb3cgZWxlbWVudHMuXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnBvcHBlciBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucmVmZXJlbmNlIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5hcnJvd10gYHRvcGAgYW5kIGBsZWZ0YCBvZmZzZXRzLCBvbmx5IG9uZSBvZiB0aGVtIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gMFxuICovXG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkIHRvIFBvcHBlci5qcyBjb25zdHJ1Y3Rvci48YnIgLz5cbiAqIFRoZXNlIGNhbiBiZSBvdmVycmlkZW4gdXNpbmcgdGhlIGBvcHRpb25zYCBhcmd1bWVudCBvZiBQb3BwZXIuanMuPGJyIC8+XG4gKiBUbyBvdmVycmlkZSBhbiBvcHRpb24sIHNpbXBseSBwYXNzIGFzIDNyZCBhcmd1bWVudCBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZVxuICogc3RydWN0dXJlIG9mIHRoaXMgb2JqZWN0LCBleGFtcGxlOlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZiwgcG9wLCB7XG4gKiAgIG1vZGlmaWVyczoge1xuICogICAgIHByZXZlbnRPdmVyZmxvdzogeyBlbmFibGVkOiBmYWxzZSB9XG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBEZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFBvcHBlcidzIHBsYWNlbWVudFxuICAgKiBAcHJvcCB7UG9wcGVyLnBsYWNlbWVudHN9IHBsYWNlbWVudD0nYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAvKipcbiAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCBwb3BwZXIgdG8gcG9zaXRpb24gaXQgc2VsZiBpbiAnZml4ZWQnIG1vZGVcbiAgICogQHByb3Age0Jvb2xlYW59IHBvc2l0aW9uRml4ZWQ9ZmFsc2VcbiAgICovXG4gIHBvc2l0aW9uRml4ZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGV2ZW50cyAocmVzaXplLCBzY3JvbGwpIGFyZSBpbml0aWFsbHkgZW5hYmxlZFxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gZXZlbnRzRW5hYmxlZD10cnVlXG4gICAqL1xuICBldmVudHNFbmFibGVkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgcG9wcGVyIHdoZW5cbiAgICogeW91IGNhbGwgdGhlIGBkZXN0cm95YCBtZXRob2QuXG4gICAqIEBwcm9wIHtCb29sZWFufSByZW1vdmVPbkRlc3Ryb3k9ZmFsc2VcbiAgICovXG4gIHJlbW92ZU9uRGVzdHJveTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgY3JlYXRlZC48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25DcmVhdGV9XG4gICAqL1xuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLCB0aGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoKSB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanNcbiAgICogQHByb3Age21vZGlmaWVyc31cbiAgICovXG4gIG1vZGlmaWVyczogbW9kaWZpZXJzXG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBvbkNyZWF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb25VcGRhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8vIFV0aWxzXG4vLyBNZXRob2RzXG52YXIgUG9wcGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKiBAY2xhc3MgUG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8cmVmZXJlbmNlT2JqZWN0fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gWW91ciBjdXN0b20gb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgb25lcyBkZWZpbmVkIGluIFtEZWZhdWx0c10oI2RlZmF1bHRzKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIC0gVGhlIGdlbmVyYXRlZCBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHBlcihyZWZlcmVuY2UsIHBvcHBlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wcGVyKTtcblxuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnVwZGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIG1ha2UgdXBkYXRlKCkgZGVib3VuY2VkLCBzbyB0aGF0IGl0IG9ubHkgcnVucyBhdCBtb3N0IG9uY2UtcGVyLXRpY2tcbiAgICB0aGlzLnVwZGF0ZSA9IGRlYm91bmNlKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gd2l0aCB7fSB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG9wdGlvbnMgaW5zaWRlIGl0XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAvLyBpbml0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIGlzQ3JlYXRlZDogZmFsc2UsXG4gICAgICBzY3JvbGxQYXJlbnRzOiBbXVxuICAgIH07XG5cbiAgICAvLyBnZXQgcmVmZXJlbmNlIGFuZCBwb3BwZXIgZWxlbWVudHMgKGFsbG93IGpRdWVyeSB3cmFwcGVycylcbiAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgIHRoaXMucG9wcGVyID0gcG9wcGVyICYmIHBvcHBlci5qcXVlcnkgPyBwb3BwZXJbMF0gOiBwb3BwZXI7XG5cbiAgICAvLyBEZWVwIG1lcmdlIG1vZGlmaWVycyBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzLCBvcHRpb25zLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnNbbmFtZV0gfHwge30sIG9wdGlvbnMubW9kaWZpZXJzID8gb3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gOiB7fSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3QgKE9iamVjdCA9PiBBcnJheSlcbiAgICB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0pO1xuICAgIH0pXG4gICAgLy8gc29ydCB0aGUgbW9kaWZpZXJzIGJ5IG9yZGVyXG4gICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICB9KTtcblxuICAgIC8vIG1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgd2hlbiBQb3BwZXIuanMgZ2V0IGluaXRlZFxuICAgIC8vIHN1Y2ggY29kZSBpcyBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBvZiBpdHMgbW9kaWZpZXJcbiAgICAvLyB0aGV5IGNvdWxkIGFkZCBuZXcgcHJvcGVydGllcyB0byB0aGVpciBvcHRpb25zIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBCRSBBV0FSRTogZG9uJ3QgYWRkIG9wdGlvbnMgdG8gYG9wdGlvbnMubW9kaWZpZXJzLm5hbWVgIGJ1dCB0byBgbW9kaWZpZXJPcHRpb25zYCFcbiAgICB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RpZmllck9wdGlvbnMuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQpKSB7XG4gICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoX3RoaXMucmVmZXJlbmNlLCBfdGhpcy5wb3BwZXIsIF90aGlzLm9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgX3RoaXMuc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIHZhciBldmVudHNFbmFibGVkID0gdGhpcy5vcHRpb25zLmV2ZW50c0VuYWJsZWQ7XG4gICAgaWYgKGV2ZW50c0VuYWJsZWQpIHtcbiAgICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVycywgdGhleSB3aWxsIHRha2UgY2FyZSBvZiB1cGRhdGUgdGhlIHBvc2l0aW9uIGluIHNwZWNpZmljIHNpdHVhdGlvbnNcbiAgICAgIHRoaXMuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQgPSBldmVudHNFbmFibGVkO1xuICB9XG5cbiAgLy8gV2UgY2FuJ3QgdXNlIGNsYXNzIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IGdldCBsaXN0ZWQgaW4gdGhlXG4gIC8vIGNsYXNzIHByb3RvdHlwZSBhbmQgYnJlYWsgc3R1ZmYgbGlrZSBTaW5vbiBzdHVic1xuXG5cbiAgY3JlYXRlQ2xhc3MoUG9wcGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSQkMSgpIHtcbiAgICAgIHJldHVybiB1cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSQkMSgpIHtcbiAgICAgIHJldHVybiBkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBlbmFibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZSBhbiB1cGRhdGUsIGl0IHdpbGwgcnVuIG9uIHRoZSBuZXh0IFVJIHVwZGF0ZSBhdmFpbGFibGVcbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAgICpcbiAgICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gUG9wcGVyO1xufSgpO1xuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwXG4gKiBAbmFtZSByZWZlcmVuY2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRXaWR0aFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cblxuXG5Qb3BwZXIuVXRpbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpLlBvcHBlclV0aWxzO1xuUG9wcGVyLnBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuUG9wcGVyLkRlZmF1bHRzID0gRGVmYXVsdHM7XG5cbmV4cG9ydCBkZWZhdWx0IFBvcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5qcy5tYXBcbiIsIi8qKlxuICogc2VsZWN0aXplLmpzICh2MC4xMi40KVxuICogQ29weXJpZ2h0IChjKSAyMDEz4oCTMjAxNSBCcmlhbiBSZWF2aXMgJiBjb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuICogZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GXG4gKiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQGF1dGhvciBCcmlhbiBSZWF2aXMgPGJyaWFuQHRoaXJkcm91dGUuY29tPlxuICovXG5cbi8qanNoaW50IGN1cmx5OmZhbHNlICovXG4vKmpzaGludCBicm93c2VyOnRydWUgKi9cblxuKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZShbJ2pxdWVyeScsJ3NpZnRlcicsJ21pY3JvcGx1Z2luJ10sIGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSwgcmVxdWlyZSgnc2lmdGVyJyksIHJlcXVpcmUoJ21pY3JvcGx1Z2luJykpO1xuXHR9IGVsc2Uge1xuXHRcdHJvb3QuU2VsZWN0aXplID0gZmFjdG9yeShyb290LmpRdWVyeSwgcm9vdC5TaWZ0ZXIsIHJvb3QuTWljcm9QbHVnaW4pO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uKCQsIFNpZnRlciwgTWljcm9QbHVnaW4pIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoaWdobGlnaHQgPSBmdW5jdGlvbigkZWxlbWVudCwgcGF0dGVybikge1xuXHRcdGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycgJiYgIXBhdHRlcm4ubGVuZ3RoKSByZXR1cm47XG5cdFx0dmFyIHJlZ2V4ID0gKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykgPyBuZXcgUmVnRXhwKHBhdHRlcm4sICdpJykgOiBwYXR0ZXJuO1xuXHRcblx0XHR2YXIgaGlnaGxpZ2h0ID0gZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIHNraXAgPSAwO1xuXHRcdFx0aWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcblx0XHRcdFx0dmFyIHBvcyA9IG5vZGUuZGF0YS5zZWFyY2gocmVnZXgpO1xuXHRcdFx0XHRpZiAocG9zID49IDAgJiYgbm9kZS5kYXRhLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2ggPSBub2RlLmRhdGEubWF0Y2gocmVnZXgpO1xuXHRcdFx0XHRcdHZhciBzcGFubm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblx0XHRcdFx0XHRzcGFubm9kZS5jbGFzc05hbWUgPSAnaGlnaGxpZ2h0Jztcblx0XHRcdFx0XHR2YXIgbWlkZGxlYml0ID0gbm9kZS5zcGxpdFRleHQocG9zKTtcblx0XHRcdFx0XHR2YXIgZW5kYml0ID0gbWlkZGxlYml0LnNwbGl0VGV4dChtYXRjaFswXS5sZW5ndGgpO1xuXHRcdFx0XHRcdHZhciBtaWRkbGVjbG9uZSA9IG1pZGRsZWJpdC5jbG9uZU5vZGUodHJ1ZSk7XG5cdFx0XHRcdFx0c3Bhbm5vZGUuYXBwZW5kQ2hpbGQobWlkZGxlY2xvbmUpO1xuXHRcdFx0XHRcdG1pZGRsZWJpdC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChzcGFubm9kZSwgbWlkZGxlYml0KTtcblx0XHRcdFx0XHRza2lwID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSAxICYmIG5vZGUuY2hpbGROb2RlcyAmJiAhLyhzY3JpcHR8c3R5bGUpL2kudGVzdChub2RlLnRhZ05hbWUpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0aSArPSBoaWdobGlnaHQobm9kZS5jaGlsZE5vZGVzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNraXA7XG5cdFx0fTtcblx0XG5cdFx0cmV0dXJuICRlbGVtZW50LmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRoaWdobGlnaHQodGhpcyk7XG5cdFx0fSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogcmVtb3ZlSGlnaGxpZ2h0IGZuIGNvcGllZCBmcm9tIGhpZ2hsaWdodCB2NSBhbmRcblx0ICogZWRpdGVkIHRvIHJlbW92ZSB3aXRoKCkgYW5kIHBhc3MganMgc3RyaWN0IG1vZGVcblx0ICovXG5cdCQuZm4ucmVtb3ZlSGlnaGxpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZmluZChcInNwYW4uaGlnaGxpZ2h0XCIpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnBhcmVudE5vZGUuZmlyc3RDaGlsZC5ub2RlTmFtZTtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMuZmlyc3RDaGlsZCwgdGhpcyk7XG5cdFx0XHRwYXJlbnQubm9ybWFsaXplKCk7XG5cdFx0fSkuZW5kKCk7XG5cdH07XG5cdFxuXHRcblx0dmFyIE1pY3JvRXZlbnQgPSBmdW5jdGlvbigpIHt9O1xuXHRNaWNyb0V2ZW50LnByb3RvdHlwZSA9IHtcblx0XHRvbjogZnVuY3Rpb24oZXZlbnQsIGZjdCl7XG5cdFx0XHR0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG5cdFx0XHR0aGlzLl9ldmVudHNbZXZlbnRdID0gdGhpcy5fZXZlbnRzW2V2ZW50XSB8fCBbXTtcblx0XHRcdHRoaXMuX2V2ZW50c1tldmVudF0ucHVzaChmY3QpO1xuXHRcdH0sXG5cdFx0b2ZmOiBmdW5jdGlvbihldmVudCwgZmN0KXtcblx0XHRcdHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRcdGlmIChuID09PSAwKSByZXR1cm4gZGVsZXRlIHRoaXMuX2V2ZW50cztcblx0XHRcdGlmIChuID09PSAxKSByZXR1cm4gZGVsZXRlIHRoaXMuX2V2ZW50c1tldmVudF07XG5cdFxuXHRcdFx0dGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuXHRcdFx0aWYgKGV2ZW50IGluIHRoaXMuX2V2ZW50cyA9PT0gZmFsc2UpIHJldHVybjtcblx0XHRcdHRoaXMuX2V2ZW50c1tldmVudF0uc3BsaWNlKHRoaXMuX2V2ZW50c1tldmVudF0uaW5kZXhPZihmY3QpLCAxKTtcblx0XHR9LFxuXHRcdHRyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50IC8qICwgYXJncy4uLiAqLyl7XG5cdFx0XHR0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG5cdFx0XHRpZiAoZXZlbnQgaW4gdGhpcy5fZXZlbnRzID09PSBmYWxzZSkgcmV0dXJuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ldmVudHNbZXZlbnRdLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0dGhpcy5fZXZlbnRzW2V2ZW50XVtpXS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHQvKipcblx0ICogTWl4aW4gd2lsbCBkZWxlZ2F0ZSBhbGwgTWljcm9FdmVudC5qcyBmdW5jdGlvbiBpbiB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuXHQgKlxuXHQgKiAtIE1pY3JvRXZlbnQubWl4aW4oRm9vYmFyKSB3aWxsIG1ha2UgRm9vYmFyIGFibGUgdG8gdXNlIE1pY3JvRXZlbnRcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IHRoZSBvYmplY3Qgd2hpY2ggd2lsbCBzdXBwb3J0IE1pY3JvRXZlbnRcblx0ICovXG5cdE1pY3JvRXZlbnQubWl4aW4gPSBmdW5jdGlvbihkZXN0T2JqZWN0KXtcblx0XHR2YXIgcHJvcHMgPSBbJ29uJywgJ29mZicsICd0cmlnZ2VyJ107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRkZXN0T2JqZWN0LnByb3RvdHlwZVtwcm9wc1tpXV0gPSBNaWNyb0V2ZW50LnByb3RvdHlwZVtwcm9wc1tpXV07XG5cdFx0fVxuXHR9O1xuXHRcblx0dmFyIElTX01BQyAgICAgICAgPSAvTWFjLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXHRcblx0dmFyIEtFWV9BICAgICAgICAgPSA2NTtcblx0dmFyIEtFWV9DT01NQSAgICAgPSAxODg7XG5cdHZhciBLRVlfUkVUVVJOICAgID0gMTM7XG5cdHZhciBLRVlfRVNDICAgICAgID0gMjc7XG5cdHZhciBLRVlfTEVGVCAgICAgID0gMzc7XG5cdHZhciBLRVlfVVAgICAgICAgID0gMzg7XG5cdHZhciBLRVlfUCAgICAgICAgID0gODA7XG5cdHZhciBLRVlfUklHSFQgICAgID0gMzk7XG5cdHZhciBLRVlfRE9XTiAgICAgID0gNDA7XG5cdHZhciBLRVlfTiAgICAgICAgID0gNzg7XG5cdHZhciBLRVlfQkFDS1NQQUNFID0gODtcblx0dmFyIEtFWV9ERUxFVEUgICAgPSA0Njtcblx0dmFyIEtFWV9TSElGVCAgICAgPSAxNjtcblx0dmFyIEtFWV9DTUQgICAgICAgPSBJU19NQUMgPyA5MSA6IDE3O1xuXHR2YXIgS0VZX0NUUkwgICAgICA9IElTX01BQyA/IDE4IDogMTc7XG5cdHZhciBLRVlfVEFCICAgICAgID0gOTtcblx0XG5cdHZhciBUQUdfU0VMRUNUICAgID0gMTtcblx0dmFyIFRBR19JTlBVVCAgICAgPSAyO1xuXHRcblx0Ly8gZm9yIG5vdywgYW5kcm9pZCBzdXBwb3J0IGluIGdlbmVyYWwgaXMgdG9vIHNwb3R0eSB0byBzdXBwb3J0IHZhbGlkaXR5XG5cdHZhciBTVVBQT1JUU19WQUxJRElUWV9BUEkgPSAhL2FuZHJvaWQvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JykudmFsaWRpdHk7XG5cdFxuXHRcblx0dmFyIGlzc2V0ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBvYmplY3QgIT09ICd1bmRlZmluZWQnO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc2NhbGFyIHRvIGl0cyBiZXN0IHN0cmluZyByZXByZXNlbnRhdGlvblxuXHQgKiBmb3IgaGFzaCBrZXlzIGFuZCBIVE1MIGF0dHJpYnV0ZSB2YWx1ZXMuXG5cdCAqXG5cdCAqIFRyYW5zZm9ybWF0aW9uczpcblx0ICogICAnc3RyJyAgICAgLT4gJ3N0cidcblx0ICogICBudWxsICAgICAgLT4gJydcblx0ICogICB1bmRlZmluZWQgLT4gJydcblx0ICogICB0cnVlICAgICAgLT4gJzEnXG5cdCAqICAgZmFsc2UgICAgIC0+ICcwJ1xuXHQgKiAgIDAgICAgICAgICAtPiAnMCdcblx0ICogICAxICAgICAgICAgLT4gJzEnXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XG5cdCAqL1xuXHR2YXIgaGFzaF9rZXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gbnVsbDtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHJldHVybiB2YWx1ZSA/ICcxJyA6ICcwJztcblx0XHRyZXR1cm4gdmFsdWUgKyAnJztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBFc2NhcGVzIGEgc3RyaW5nIGZvciB1c2Ugd2l0aGluIEhUTUwuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHZhciBlc2NhcGVfaHRtbCA9IGZ1bmN0aW9uKHN0cikge1xuXHRcdHJldHVybiAoc3RyICsgJycpXG5cdFx0XHQucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuXHRcdFx0LnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuXHRcdFx0LnJlcGxhY2UoLz4vZywgJyZndDsnKVxuXHRcdFx0LnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBFc2NhcGVzIFwiJFwiIGNoYXJhY3RlcnMgaW4gcmVwbGFjZW1lbnQgc3RyaW5ncy5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0clxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dmFyIGVzY2FwZV9yZXBsYWNlID0gZnVuY3Rpb24oc3RyKSB7XG5cdFx0cmV0dXJuIChzdHIgKyAnJykucmVwbGFjZSgvXFwkL2csICckJCQkJyk7XG5cdH07XG5cdFxuXHR2YXIgaG9vayA9IHt9O1xuXHRcblx0LyoqXG5cdCAqIFdyYXBzIGBtZXRob2RgIG9uIGBzZWxmYCBzbyB0aGF0IGBmbmBcblx0ICogaXMgaW52b2tlZCBiZWZvcmUgdGhlIG9yaWdpbmFsIG1ldGhvZC5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IHNlbGZcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmblxuXHQgKi9cblx0aG9vay5iZWZvcmUgPSBmdW5jdGlvbihzZWxmLCBtZXRob2QsIGZuKSB7XG5cdFx0dmFyIG9yaWdpbmFsID0gc2VsZlttZXRob2RdO1xuXHRcdHNlbGZbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm4uYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBvcmlnaW5hbC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH07XG5cdFxuXHQvKipcblx0ICogV3JhcHMgYG1ldGhvZGAgb24gYHNlbGZgIHNvIHRoYXQgYGZuYFxuXHQgKiBpcyBpbnZva2VkIGFmdGVyIHRoZSBvcmlnaW5hbCBtZXRob2QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBzZWxmXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2Rcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cblx0ICovXG5cdGhvb2suYWZ0ZXIgPSBmdW5jdGlvbihzZWxmLCBtZXRob2QsIGZuKSB7XG5cdFx0dmFyIG9yaWdpbmFsID0gc2VsZlttZXRob2RdO1xuXHRcdHNlbGZbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG5cdFx0XHRmbi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFdyYXBzIGBmbmAgc28gdGhhdCBpdCBjYW4gb25seSBiZSBpbnZva2VkIG9uY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG5cdCAqIEByZXR1cm5zIHtmdW5jdGlvbn1cblx0ICovXG5cdHZhciBvbmNlID0gZnVuY3Rpb24oZm4pIHtcblx0XHR2YXIgY2FsbGVkID0gZmFsc2U7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKGNhbGxlZCkgcmV0dXJuO1xuXHRcdFx0Y2FsbGVkID0gdHJ1ZTtcblx0XHRcdGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBXcmFwcyBgZm5gIHNvIHRoYXQgaXQgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2Vcblx0ICogZXZlcnkgYGRlbGF5YCBtaWxsaXNlY29uZHMgKGludm9rZWQgb24gdGhlIGZhbGxpbmcgZWRnZSkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG5cdCAqIEBwYXJhbSB7aW50fSBkZWxheVxuXHQgKiBAcmV0dXJucyB7ZnVuY3Rpb259XG5cdCAqL1xuXHR2YXIgZGVib3VuY2UgPSBmdW5jdGlvbihmbiwgZGVsYXkpIHtcblx0XHR2YXIgdGltZW91dDtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0XHR0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdFx0fSwgZGVsYXkpO1xuXHRcdH07XG5cdH07XG5cdFxuXHQvKipcblx0ICogRGVib3VuY2UgYWxsIGZpcmVkIGV2ZW50cyB0eXBlcyBsaXN0ZWQgaW4gYHR5cGVzYFxuXHQgKiB3aGlsZSBleGVjdXRpbmcgdGhlIHByb3ZpZGVkIGBmbmAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBzZWxmXG5cdCAqIEBwYXJhbSB7YXJyYXl9IHR5cGVzXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG5cdCAqL1xuXHR2YXIgZGVib3VuY2VfZXZlbnRzID0gZnVuY3Rpb24oc2VsZiwgdHlwZXMsIGZuKSB7XG5cdFx0dmFyIHR5cGU7XG5cdFx0dmFyIHRyaWdnZXIgPSBzZWxmLnRyaWdnZXI7XG5cdFx0dmFyIGV2ZW50X2FyZ3MgPSB7fTtcblx0XG5cdFx0Ly8gb3ZlcnJpZGUgdHJpZ2dlciBtZXRob2Rcblx0XHRzZWxmLnRyaWdnZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gYXJndW1lbnRzWzBdO1xuXHRcdFx0aWYgKHR5cGVzLmluZGV4T2YodHlwZSkgIT09IC0xKSB7XG5cdFx0XHRcdGV2ZW50X2FyZ3NbdHlwZV0gPSBhcmd1bWVudHM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdHJpZ2dlci5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdC8vIGludm9rZSBwcm92aWRlZCBmdW5jdGlvblxuXHRcdGZuLmFwcGx5KHNlbGYsIFtdKTtcblx0XHRzZWxmLnRyaWdnZXIgPSB0cmlnZ2VyO1xuXHRcblx0XHQvLyB0cmlnZ2VyIHF1ZXVlZCBldmVudHNcblx0XHRmb3IgKHR5cGUgaW4gZXZlbnRfYXJncykge1xuXHRcdFx0aWYgKGV2ZW50X2FyZ3MuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcblx0XHRcdFx0dHJpZ2dlci5hcHBseShzZWxmLCBldmVudF9hcmdzW3R5cGVdKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHQvKipcblx0ICogQSB3b3JrYXJvdW5kIGZvciBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC82Njk2XG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSAkcGFyZW50IC0gUGFyZW50IGVsZW1lbnQgdG8gbGlzdGVuIG9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBFdmVudCBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgLSBEZXNjZW5kYW50IHNlbGVjdG9yIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBFdmVudCBoYW5kbGVyLlxuXHQgKi9cblx0dmFyIHdhdGNoQ2hpbGRFdmVudCA9IGZ1bmN0aW9uKCRwYXJlbnQsIGV2ZW50LCBzZWxlY3RvciwgZm4pIHtcblx0XHQkcGFyZW50Lm9uKGV2ZW50LCBzZWxlY3RvciwgZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIGNoaWxkID0gZS50YXJnZXQ7XG5cdFx0XHR3aGlsZSAoY2hpbGQgJiYgY2hpbGQucGFyZW50Tm9kZSAhPT0gJHBhcmVudFswXSkge1xuXHRcdFx0XHRjaGlsZCA9IGNoaWxkLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRlLmN1cnJlbnRUYXJnZXQgPSBjaGlsZDtcblx0XHRcdHJldHVybiBmbi5hcHBseSh0aGlzLCBbZV0pO1xuXHRcdH0pO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIERldGVybWluZXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHdpdGhpbiBhIHRleHQgaW5wdXQgY29udHJvbC5cblx0ICogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZzpcblx0ICogICAtIHN0YXJ0XG5cdCAqICAgLSBsZW5ndGhcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IGlucHV0XG5cdCAqIEByZXR1cm5zIHtvYmplY3R9XG5cdCAqL1xuXHR2YXIgZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0XHR2YXIgcmVzdWx0ID0ge307XG5cdFx0aWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcblx0XHRcdHJlc3VsdC5zdGFydCA9IGlucHV0LnNlbGVjdGlvblN0YXJ0O1xuXHRcdFx0cmVzdWx0Lmxlbmd0aCA9IGlucHV0LnNlbGVjdGlvbkVuZCAtIHJlc3VsdC5zdGFydDtcblx0XHR9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuXHRcdFx0aW5wdXQuZm9jdXMoKTtcblx0XHRcdHZhciBzZWwgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcblx0XHRcdHZhciBzZWxMZW4gPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS50ZXh0Lmxlbmd0aDtcblx0XHRcdHNlbC5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpO1xuXHRcdFx0cmVzdWx0LnN0YXJ0ID0gc2VsLnRleHQubGVuZ3RoIC0gc2VsTGVuO1xuXHRcdFx0cmVzdWx0Lmxlbmd0aCA9IHNlbExlbjtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDb3BpZXMgQ1NTIHByb3BlcnRpZXMgZnJvbSBvbmUgZWxlbWVudCB0byBhbm90aGVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gJGZyb21cblx0ICogQHBhcmFtIHtvYmplY3R9ICR0b1xuXHQgKiBAcGFyYW0ge2FycmF5fSBwcm9wZXJ0aWVzXG5cdCAqL1xuXHR2YXIgdHJhbnNmZXJTdHlsZXMgPSBmdW5jdGlvbigkZnJvbSwgJHRvLCBwcm9wZXJ0aWVzKSB7XG5cdFx0dmFyIGksIG4sIHN0eWxlcyA9IHt9O1xuXHRcdGlmIChwcm9wZXJ0aWVzKSB7XG5cdFx0XHRmb3IgKGkgPSAwLCBuID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0c3R5bGVzW3Byb3BlcnRpZXNbaV1dID0gJGZyb20uY3NzKHByb3BlcnRpZXNbaV0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZXMgPSAkZnJvbS5jc3MoKTtcblx0XHR9XG5cdFx0JHRvLmNzcyhzdHlsZXMpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIE1lYXN1cmVzIHRoZSB3aWR0aCBvZiBhIHN0cmluZyB3aXRoaW4gYVxuXHQgKiBwYXJlbnQgZWxlbWVudCAoaW4gcGl4ZWxzKS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0clxuXHQgKiBAcGFyYW0ge29iamVjdH0gJHBhcmVudFxuXHQgKiBAcmV0dXJucyB7aW50fVxuXHQgKi9cblx0dmFyIG1lYXN1cmVTdHJpbmcgPSBmdW5jdGlvbihzdHIsICRwYXJlbnQpIHtcblx0XHRpZiAoIXN0cikge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcblx0XHR2YXIgJHRlc3QgPSAkKCc8dGVzdD4nKS5jc3Moe1xuXHRcdFx0cG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdFx0XHR0b3A6IC05OTk5OSxcblx0XHRcdGxlZnQ6IC05OTk5OSxcblx0XHRcdHdpZHRoOiAnYXV0bycsXG5cdFx0XHRwYWRkaW5nOiAwLFxuXHRcdFx0d2hpdGVTcGFjZTogJ3ByZSdcblx0XHR9KS50ZXh0KHN0cikuYXBwZW5kVG8oJ2JvZHknKTtcblx0XG5cdFx0dHJhbnNmZXJTdHlsZXMoJHBhcmVudCwgJHRlc3QsIFtcblx0XHRcdCdsZXR0ZXJTcGFjaW5nJyxcblx0XHRcdCdmb250U2l6ZScsXG5cdFx0XHQnZm9udEZhbWlseScsXG5cdFx0XHQnZm9udFdlaWdodCcsXG5cdFx0XHQndGV4dFRyYW5zZm9ybSdcblx0XHRdKTtcblx0XG5cdFx0dmFyIHdpZHRoID0gJHRlc3Qud2lkdGgoKTtcblx0XHQkdGVzdC5yZW1vdmUoKTtcblx0XG5cdFx0cmV0dXJuIHdpZHRoO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFNldHMgdXAgYW4gaW5wdXQgdG8gZ3JvdyBob3Jpem9udGFsbHkgYXMgdGhlIHVzZXJcblx0ICogdHlwZXMuIElmIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkIG1hbnVhbGx5LCB5b3UgY2FuXG5cdCAqIHRyaWdnZXIgdGhlIFwidXBkYXRlXCIgaGFuZGxlciB0byByZXNpemU6XG5cdCAqXG5cdCAqICRpbnB1dC50cmlnZ2VyKCd1cGRhdGUnKTtcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9ICRpbnB1dFxuXHQgKi9cblx0dmFyIGF1dG9Hcm93ID0gZnVuY3Rpb24oJGlucHV0KSB7XG5cdFx0dmFyIGN1cnJlbnRXaWR0aCA9IG51bGw7XG5cdFxuXHRcdHZhciB1cGRhdGUgPSBmdW5jdGlvbihlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgdmFsdWUsIGtleUNvZGUsIHByaW50YWJsZSwgcGxhY2Vob2xkZXIsIHdpZHRoO1xuXHRcdFx0dmFyIHNoaWZ0LCBjaGFyYWN0ZXIsIHNlbGVjdGlvbjtcblx0XHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudCB8fCB7fTtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcblx0XHRcdGlmIChlLm1ldGFLZXkgfHwgZS5hbHRLZXkpIHJldHVybjtcblx0XHRcdGlmICghb3B0aW9ucy5mb3JjZSAmJiAkaW5wdXQuZGF0YSgnZ3JvdycpID09PSBmYWxzZSkgcmV0dXJuO1xuXHRcblx0XHRcdHZhbHVlID0gJGlucHV0LnZhbCgpO1xuXHRcdFx0aWYgKGUudHlwZSAmJiBlLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2tleWRvd24nKSB7XG5cdFx0XHRcdGtleUNvZGUgPSBlLmtleUNvZGU7XG5cdFx0XHRcdHByaW50YWJsZSA9IChcblx0XHRcdFx0XHQoa2V5Q29kZSA+PSA5NyAmJiBrZXlDb2RlIDw9IDEyMikgfHwgLy8gYS16XG5cdFx0XHRcdFx0KGtleUNvZGUgPj0gNjUgJiYga2V5Q29kZSA8PSA5MCkgIHx8IC8vIEEtWlxuXHRcdFx0XHRcdChrZXlDb2RlID49IDQ4ICYmIGtleUNvZGUgPD0gNTcpICB8fCAvLyAwLTlcblx0XHRcdFx0XHRrZXlDb2RlID09PSAzMiAvLyBzcGFjZVxuXHRcdFx0XHQpO1xuXHRcblx0XHRcdFx0aWYgKGtleUNvZGUgPT09IEtFWV9ERUxFVEUgfHwga2V5Q29kZSA9PT0gS0VZX0JBQ0tTUEFDRSkge1xuXHRcdFx0XHRcdHNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbigkaW5wdXRbMF0pO1xuXHRcdFx0XHRcdGlmIChzZWxlY3Rpb24ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb24uc3RhcnQpICsgdmFsdWUuc3Vic3RyaW5nKHNlbGVjdGlvbi5zdGFydCArIHNlbGVjdGlvbi5sZW5ndGgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gS0VZX0JBQ0tTUEFDRSAmJiBzZWxlY3Rpb24uc3RhcnQpIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvbi5zdGFydCAtIDEpICsgdmFsdWUuc3Vic3RyaW5nKHNlbGVjdGlvbi5zdGFydCArIDEpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gS0VZX0RFTEVURSAmJiB0eXBlb2Ygc2VsZWN0aW9uLnN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uLnN0YXJ0KSArIHZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb24uc3RhcnQgKyAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAocHJpbnRhYmxlKSB7XG5cdFx0XHRcdFx0c2hpZnQgPSBlLnNoaWZ0S2V5O1xuXHRcdFx0XHRcdGNoYXJhY3RlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZS5rZXlDb2RlKTtcblx0XHRcdFx0XHRpZiAoc2hpZnQpIGNoYXJhY3RlciA9IGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHRcdGVsc2UgY2hhcmFjdGVyID0gY2hhcmFjdGVyLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0dmFsdWUgKz0gY2hhcmFjdGVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0cGxhY2Vob2xkZXIgPSAkaW5wdXQuYXR0cigncGxhY2Vob2xkZXInKTtcblx0XHRcdGlmICghdmFsdWUgJiYgcGxhY2Vob2xkZXIpIHtcblx0XHRcdFx0dmFsdWUgPSBwbGFjZWhvbGRlcjtcblx0XHRcdH1cblx0XG5cdFx0XHR3aWR0aCA9IG1lYXN1cmVTdHJpbmcodmFsdWUsICRpbnB1dCkgKyA0O1xuXHRcdFx0aWYgKHdpZHRoICE9PSBjdXJyZW50V2lkdGgpIHtcblx0XHRcdFx0Y3VycmVudFdpZHRoID0gd2lkdGg7XG5cdFx0XHRcdCRpbnB1dC53aWR0aCh3aWR0aCk7XG5cdFx0XHRcdCRpbnB1dC50cmlnZ2VySGFuZGxlcigncmVzaXplJyk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0JGlucHV0Lm9uKCdrZXlkb3duIGtleXVwIHVwZGF0ZSBibHVyJywgdXBkYXRlKTtcblx0XHR1cGRhdGUoKTtcblx0fTtcblx0XG5cdHZhciBkb21Ub1N0cmluZyA9IGZ1bmN0aW9uKGQpIHtcblx0XHR2YXIgdG1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFxuXHRcdHRtcC5hcHBlbmRDaGlsZChkLmNsb25lTm9kZSh0cnVlKSk7XG5cdFxuXHRcdHJldHVybiB0bXAuaW5uZXJIVE1MO1xuXHR9O1xuXHRcblx0dmFyIGxvZ0Vycm9yID0gZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucyl7XG5cdFx0aWYoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcblx0XHR2YXIgY29tcG9uZW50ID0gXCJTZWxlY3RpemVcIjtcblx0XG5cdFx0Y29uc29sZS5lcnJvcihjb21wb25lbnQgKyBcIjogXCIgKyBtZXNzYWdlKVxuXHRcblx0XHRpZihvcHRpb25zLmV4cGxhbmF0aW9uKXtcblx0XHRcdC8vIGNvbnNvbGUuZ3JvdXAgaXMgdW5kZWZpbmVkIGluIDxJRTExXG5cdFx0XHRpZihjb25zb2xlLmdyb3VwKSBjb25zb2xlLmdyb3VwKCk7XG5cdFx0XHRjb25zb2xlLmVycm9yKG9wdGlvbnMuZXhwbGFuYXRpb24pO1xuXHRcdFx0aWYoY29uc29sZS5ncm91cCkgY29uc29sZS5ncm91cEVuZCgpO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdHZhciBTZWxlY3RpemUgPSBmdW5jdGlvbigkaW5wdXQsIHNldHRpbmdzKSB7XG5cdFx0dmFyIGtleSwgaSwgbiwgZGlyLCBpbnB1dCwgc2VsZiA9IHRoaXM7XG5cdFx0aW5wdXQgPSAkaW5wdXRbMF07XG5cdFx0aW5wdXQuc2VsZWN0aXplID0gc2VsZjtcblx0XG5cdFx0Ly8gZGV0ZWN0IHJ0bCBlbnZpcm9ubWVudFxuXHRcdHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoaW5wdXQsIG51bGwpO1xuXHRcdGRpciA9IGNvbXB1dGVkU3R5bGUgPyBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpIDogaW5wdXQuY3VycmVudFN0eWxlICYmIGlucHV0LmN1cnJlbnRTdHlsZS5kaXJlY3Rpb247XG5cdFx0ZGlyID0gZGlyIHx8ICRpbnB1dC5wYXJlbnRzKCdbZGlyXTpmaXJzdCcpLmF0dHIoJ2RpcicpIHx8ICcnO1xuXHRcblx0XHQvLyBzZXR1cCBkZWZhdWx0IHN0YXRlXG5cdFx0JC5leHRlbmQoc2VsZiwge1xuXHRcdFx0b3JkZXIgICAgICAgICAgICA6IDAsXG5cdFx0XHRzZXR0aW5ncyAgICAgICAgIDogc2V0dGluZ3MsXG5cdFx0XHQkaW5wdXQgICAgICAgICAgIDogJGlucHV0LFxuXHRcdFx0dGFiSW5kZXggICAgICAgICA6ICRpbnB1dC5hdHRyKCd0YWJpbmRleCcpIHx8ICcnLFxuXHRcdFx0dGFnVHlwZSAgICAgICAgICA6IGlucHV0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NlbGVjdCcgPyBUQUdfU0VMRUNUIDogVEFHX0lOUFVULFxuXHRcdFx0cnRsICAgICAgICAgICAgICA6IC9ydGwvaS50ZXN0KGRpciksXG5cdFxuXHRcdFx0ZXZlbnROUyAgICAgICAgICA6ICcuc2VsZWN0aXplJyArICgrK1NlbGVjdGl6ZS5jb3VudCksXG5cdFx0XHRoaWdobGlnaHRlZFZhbHVlIDogbnVsbCxcblx0XHRcdGlzT3BlbiAgICAgICAgICAgOiBmYWxzZSxcblx0XHRcdGlzRGlzYWJsZWQgICAgICAgOiBmYWxzZSxcblx0XHRcdGlzUmVxdWlyZWQgICAgICAgOiAkaW5wdXQuaXMoJ1tyZXF1aXJlZF0nKSxcblx0XHRcdGlzSW52YWxpZCAgICAgICAgOiBmYWxzZSxcblx0XHRcdGlzTG9ja2VkICAgICAgICAgOiBmYWxzZSxcblx0XHRcdGlzRm9jdXNlZCAgICAgICAgOiBmYWxzZSxcblx0XHRcdGlzSW5wdXRIaWRkZW4gICAgOiBmYWxzZSxcblx0XHRcdGlzU2V0dXAgICAgICAgICAgOiBmYWxzZSxcblx0XHRcdGlzU2hpZnREb3duICAgICAgOiBmYWxzZSxcblx0XHRcdGlzQ21kRG93biAgICAgICAgOiBmYWxzZSxcblx0XHRcdGlzQ3RybERvd24gICAgICAgOiBmYWxzZSxcblx0XHRcdGlnbm9yZUZvY3VzICAgICAgOiBmYWxzZSxcblx0XHRcdGlnbm9yZUJsdXIgICAgICAgOiBmYWxzZSxcblx0XHRcdGlnbm9yZUhvdmVyICAgICAgOiBmYWxzZSxcblx0XHRcdGhhc09wdGlvbnMgICAgICAgOiBmYWxzZSxcblx0XHRcdGN1cnJlbnRSZXN1bHRzICAgOiBudWxsLFxuXHRcdFx0bGFzdFZhbHVlICAgICAgICA6ICcnLFxuXHRcdFx0Y2FyZXRQb3MgICAgICAgICA6IDAsXG5cdFx0XHRsb2FkaW5nICAgICAgICAgIDogMCxcblx0XHRcdGxvYWRlZFNlYXJjaGVzICAgOiB7fSxcblx0XG5cdFx0XHQkYWN0aXZlT3B0aW9uICAgIDogbnVsbCxcblx0XHRcdCRhY3RpdmVJdGVtcyAgICAgOiBbXSxcblx0XG5cdFx0XHRvcHRncm91cHMgICAgICAgIDoge30sXG5cdFx0XHRvcHRpb25zICAgICAgICAgIDoge30sXG5cdFx0XHR1c2VyT3B0aW9ucyAgICAgIDoge30sXG5cdFx0XHRpdGVtcyAgICAgICAgICAgIDogW10sXG5cdFx0XHRyZW5kZXJDYWNoZSAgICAgIDoge30sXG5cdFx0XHRvblNlYXJjaENoYW5nZSAgIDogc2V0dGluZ3MubG9hZFRocm90dGxlID09PSBudWxsID8gc2VsZi5vblNlYXJjaENoYW5nZSA6IGRlYm91bmNlKHNlbGYub25TZWFyY2hDaGFuZ2UsIHNldHRpbmdzLmxvYWRUaHJvdHRsZSlcblx0XHR9KTtcblx0XG5cdFx0Ly8gc2VhcmNoIHN5c3RlbVxuXHRcdHNlbGYuc2lmdGVyID0gbmV3IFNpZnRlcih0aGlzLm9wdGlvbnMsIHtkaWFjcml0aWNzOiBzZXR0aW5ncy5kaWFjcml0aWNzfSk7XG5cdFxuXHRcdC8vIGJ1aWxkIG9wdGlvbnMgdGFibGVcblx0XHRpZiAoc2VsZi5zZXR0aW5ncy5vcHRpb25zKSB7XG5cdFx0XHRmb3IgKGkgPSAwLCBuID0gc2VsZi5zZXR0aW5ncy5vcHRpb25zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRzZWxmLnJlZ2lzdGVyT3B0aW9uKHNlbGYuc2V0dGluZ3Mub3B0aW9uc1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgc2VsZi5zZXR0aW5ncy5vcHRpb25zO1xuXHRcdH1cblx0XG5cdFx0Ly8gYnVpbGQgb3B0Z3JvdXAgdGFibGVcblx0XHRpZiAoc2VsZi5zZXR0aW5ncy5vcHRncm91cHMpIHtcblx0XHRcdGZvciAoaSA9IDAsIG4gPSBzZWxmLnNldHRpbmdzLm9wdGdyb3Vwcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0c2VsZi5yZWdpc3Rlck9wdGlvbkdyb3VwKHNlbGYuc2V0dGluZ3Mub3B0Z3JvdXBzW2ldKTtcblx0XHRcdH1cblx0XHRcdGRlbGV0ZSBzZWxmLnNldHRpbmdzLm9wdGdyb3Vwcztcblx0XHR9XG5cdFxuXHRcdC8vIG9wdGlvbi1kZXBlbmRlbnQgZGVmYXVsdHNcblx0XHRzZWxmLnNldHRpbmdzLm1vZGUgPSBzZWxmLnNldHRpbmdzLm1vZGUgfHwgKHNlbGYuc2V0dGluZ3MubWF4SXRlbXMgPT09IDEgPyAnc2luZ2xlJyA6ICdtdWx0aScpO1xuXHRcdGlmICh0eXBlb2Ygc2VsZi5zZXR0aW5ncy5oaWRlU2VsZWN0ZWQgIT09ICdib29sZWFuJykge1xuXHRcdFx0c2VsZi5zZXR0aW5ncy5oaWRlU2VsZWN0ZWQgPSBzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdtdWx0aSc7XG5cdFx0fVxuXHRcblx0XHRzZWxmLmluaXRpYWxpemVQbHVnaW5zKHNlbGYuc2V0dGluZ3MucGx1Z2lucyk7XG5cdFx0c2VsZi5zZXR1cENhbGxiYWNrcygpO1xuXHRcdHNlbGYuc2V0dXBUZW1wbGF0ZXMoKTtcblx0XHRzZWxmLnNldHVwKCk7XG5cdH07XG5cdFxuXHQvLyBtaXhpbnNcblx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblx0XG5cdE1pY3JvRXZlbnQubWl4aW4oU2VsZWN0aXplKTtcblx0XG5cdGlmKHR5cGVvZiBNaWNyb1BsdWdpbiAhPT0gXCJ1bmRlZmluZWRcIil7XG5cdFx0TWljcm9QbHVnaW4ubWl4aW4oU2VsZWN0aXplKTtcblx0fWVsc2V7XG5cdFx0bG9nRXJyb3IoXCJEZXBlbmRlbmN5IE1pY3JvUGx1Z2luIGlzIG1pc3NpbmdcIixcblx0XHRcdHtleHBsYW5hdGlvbjpcblx0XHRcdFx0XCJNYWtlIHN1cmUgeW91IGVpdGhlcjogKDEpIGFyZSB1c2luZyB0aGUgXFxcInN0YW5kYWxvbmVcXFwiIFwiK1xuXHRcdFx0XHRcInZlcnNpb24gb2YgU2VsZWN0aXplLCBvciAoMikgcmVxdWlyZSBNaWNyb1BsdWdpbiBiZWZvcmUgeW91IFwiK1xuXHRcdFx0XHRcImxvYWQgU2VsZWN0aXplLlwifVxuXHRcdCk7XG5cdH1cblx0XG5cdFxuXHQvLyBtZXRob2RzXG5cdC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cdFxuXHQkLmV4dGVuZChTZWxlY3RpemUucHJvdG90eXBlLCB7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYWxsIGVsZW1lbnRzIGFuZCBzZXRzIHVwIGV2ZW50IGJpbmRpbmdzLlxuXHRcdCAqL1xuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmICAgICAgPSB0aGlzO1xuXHRcdFx0dmFyIHNldHRpbmdzICA9IHNlbGYuc2V0dGluZ3M7XG5cdFx0XHR2YXIgZXZlbnROUyAgID0gc2VsZi5ldmVudE5TO1xuXHRcdFx0dmFyICR3aW5kb3cgICA9ICQod2luZG93KTtcblx0XHRcdHZhciAkZG9jdW1lbnQgPSAkKGRvY3VtZW50KTtcblx0XHRcdHZhciAkaW5wdXQgICAgPSBzZWxmLiRpbnB1dDtcblx0XG5cdFx0XHR2YXIgJHdyYXBwZXI7XG5cdFx0XHR2YXIgJGNvbnRyb2w7XG5cdFx0XHR2YXIgJGNvbnRyb2xfaW5wdXQ7XG5cdFx0XHR2YXIgJGRyb3Bkb3duO1xuXHRcdFx0dmFyICRkcm9wZG93bl9jb250ZW50O1xuXHRcdFx0dmFyICRkcm9wZG93bl9wYXJlbnQ7XG5cdFx0XHR2YXIgaW5wdXRNb2RlO1xuXHRcdFx0dmFyIHRpbWVvdXRfYmx1cjtcblx0XHRcdHZhciB0aW1lb3V0X2ZvY3VzO1xuXHRcdFx0dmFyIGNsYXNzZXM7XG5cdFx0XHR2YXIgY2xhc3Nlc19wbHVnaW5zO1xuXHRcdFx0dmFyIGlucHV0SWQ7XG5cdFxuXHRcdFx0aW5wdXRNb2RlICAgICAgICAgPSBzZWxmLnNldHRpbmdzLm1vZGU7XG5cdFx0XHRjbGFzc2VzICAgICAgICAgICA9ICRpbnB1dC5hdHRyKCdjbGFzcycpIHx8ICcnO1xuXHRcblx0XHRcdCR3cmFwcGVyICAgICAgICAgID0gJCgnPGRpdj4nKS5hZGRDbGFzcyhzZXR0aW5ncy53cmFwcGVyQ2xhc3MpLmFkZENsYXNzKGNsYXNzZXMpLmFkZENsYXNzKGlucHV0TW9kZSk7XG5cdFx0XHQkY29udHJvbCAgICAgICAgICA9ICQoJzxkaXY+JykuYWRkQ2xhc3Moc2V0dGluZ3MuaW5wdXRDbGFzcykuYWRkQ2xhc3MoJ2l0ZW1zJykuYXBwZW5kVG8oJHdyYXBwZXIpO1xuXHRcdFx0JGNvbnRyb2xfaW5wdXQgICAgPSAkKCc8aW5wdXQgdHlwZT1cInRleHRcIiBhdXRvY29tcGxldGU9XCJvZmZcIiAvPicpLmFwcGVuZFRvKCRjb250cm9sKS5hdHRyKCd0YWJpbmRleCcsICRpbnB1dC5pcygnOmRpc2FibGVkJykgPyAnLTEnIDogc2VsZi50YWJJbmRleCk7XG5cdFx0XHQkZHJvcGRvd25fcGFyZW50ICA9ICQoc2V0dGluZ3MuZHJvcGRvd25QYXJlbnQgfHwgJHdyYXBwZXIpO1xuXHRcdFx0JGRyb3Bkb3duICAgICAgICAgPSAkKCc8ZGl2PicpLmFkZENsYXNzKHNldHRpbmdzLmRyb3Bkb3duQ2xhc3MpLmFkZENsYXNzKGlucHV0TW9kZSkuaGlkZSgpLmFwcGVuZFRvKCRkcm9wZG93bl9wYXJlbnQpO1xuXHRcdFx0JGRyb3Bkb3duX2NvbnRlbnQgPSAkKCc8ZGl2PicpLmFkZENsYXNzKHNldHRpbmdzLmRyb3Bkb3duQ29udGVudENsYXNzKS5hcHBlbmRUbygkZHJvcGRvd24pO1xuXHRcblx0XHRcdGlmKGlucHV0SWQgPSAkaW5wdXQuYXR0cignaWQnKSkge1xuXHRcdFx0XHQkY29udHJvbF9pbnB1dC5hdHRyKCdpZCcsIGlucHV0SWQgKyAnLXNlbGVjdGl6ZWQnKTtcblx0XHRcdFx0JChcImxhYmVsW2Zvcj0nXCIraW5wdXRJZCtcIiddXCIpLmF0dHIoJ2ZvcicsIGlucHV0SWQgKyAnLXNlbGVjdGl6ZWQnKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZihzZWxmLnNldHRpbmdzLmNvcHlDbGFzc2VzVG9Ecm9wZG93bikge1xuXHRcdFx0XHQkZHJvcGRvd24uYWRkQ2xhc3MoY2xhc3Nlcyk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0JHdyYXBwZXIuY3NzKHtcblx0XHRcdFx0d2lkdGg6ICRpbnB1dFswXS5zdHlsZS53aWR0aFxuXHRcdFx0fSk7XG5cdFxuXHRcdFx0aWYgKHNlbGYucGx1Z2lucy5uYW1lcy5sZW5ndGgpIHtcblx0XHRcdFx0Y2xhc3Nlc19wbHVnaW5zID0gJ3BsdWdpbi0nICsgc2VsZi5wbHVnaW5zLm5hbWVzLmpvaW4oJyBwbHVnaW4tJyk7XG5cdFx0XHRcdCR3cmFwcGVyLmFkZENsYXNzKGNsYXNzZXNfcGx1Z2lucyk7XG5cdFx0XHRcdCRkcm9wZG93bi5hZGRDbGFzcyhjbGFzc2VzX3BsdWdpbnMpO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICgoc2V0dGluZ3MubWF4SXRlbXMgPT09IG51bGwgfHwgc2V0dGluZ3MubWF4SXRlbXMgPiAxKSAmJiBzZWxmLnRhZ1R5cGUgPT09IFRBR19TRUxFQ1QpIHtcblx0XHRcdFx0JGlucHV0LmF0dHIoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKHNlbGYuc2V0dGluZ3MucGxhY2Vob2xkZXIpIHtcblx0XHRcdFx0JGNvbnRyb2xfaW5wdXQuYXR0cigncGxhY2Vob2xkZXInLCBzZXR0aW5ncy5wbGFjZWhvbGRlcik7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gaWYgc3BsaXRPbiB3YXMgbm90IHBhc3NlZCBpbiwgY29uc3RydWN0IGl0IGZyb20gdGhlIGRlbGltaXRlciB0byBhbGxvdyBwYXN0aW5nIHVuaXZlcnNhbGx5XG5cdFx0XHRpZiAoIXNlbGYuc2V0dGluZ3Muc3BsaXRPbiAmJiBzZWxmLnNldHRpbmdzLmRlbGltaXRlcikge1xuXHRcdFx0XHR2YXIgZGVsaW1pdGVyRXNjYXBlZCA9IHNlbGYuc2V0dGluZ3MuZGVsaW1pdGVyLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuXHRcdFx0XHRzZWxmLnNldHRpbmdzLnNwbGl0T24gPSBuZXcgUmVnRXhwKCdcXFxccyonICsgZGVsaW1pdGVyRXNjYXBlZCArICcrXFxcXHMqJyk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCRpbnB1dC5hdHRyKCdhdXRvY29ycmVjdCcpKSB7XG5cdFx0XHRcdCRjb250cm9sX2lucHV0LmF0dHIoJ2F1dG9jb3JyZWN0JywgJGlucHV0LmF0dHIoJ2F1dG9jb3JyZWN0JykpO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmICgkaW5wdXQuYXR0cignYXV0b2NhcGl0YWxpemUnKSkge1xuXHRcdFx0XHQkY29udHJvbF9pbnB1dC5hdHRyKCdhdXRvY2FwaXRhbGl6ZScsICRpbnB1dC5hdHRyKCdhdXRvY2FwaXRhbGl6ZScpKTtcblx0XHRcdH1cblx0XG5cdFx0XHRzZWxmLiR3cmFwcGVyICAgICAgICAgID0gJHdyYXBwZXI7XG5cdFx0XHRzZWxmLiRjb250cm9sICAgICAgICAgID0gJGNvbnRyb2w7XG5cdFx0XHRzZWxmLiRjb250cm9sX2lucHV0ICAgID0gJGNvbnRyb2xfaW5wdXQ7XG5cdFx0XHRzZWxmLiRkcm9wZG93biAgICAgICAgID0gJGRyb3Bkb3duO1xuXHRcdFx0c2VsZi4kZHJvcGRvd25fY29udGVudCA9ICRkcm9wZG93bl9jb250ZW50O1xuXHRcblx0XHRcdCRkcm9wZG93bi5vbignbW91c2VlbnRlcicsICdbZGF0YS1zZWxlY3RhYmxlXScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5vbk9wdGlvbkhvdmVyLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7IH0pO1xuXHRcdFx0JGRyb3Bkb3duLm9uKCdtb3VzZWRvd24gY2xpY2snLCAnW2RhdGEtc2VsZWN0YWJsZV0nLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYub25PcHRpb25TZWxlY3QuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTsgfSk7XG5cdFx0XHR3YXRjaENoaWxkRXZlbnQoJGNvbnRyb2wsICdtb3VzZWRvd24nLCAnKjpub3QoaW5wdXQpJywgZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLm9uSXRlbVNlbGVjdC5hcHBseShzZWxmLCBhcmd1bWVudHMpOyB9KTtcblx0XHRcdGF1dG9Hcm93KCRjb250cm9sX2lucHV0KTtcblx0XG5cdFx0XHQkY29udHJvbC5vbih7XG5cdFx0XHRcdG1vdXNlZG93biA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5vbk1vdXNlRG93bi5hcHBseShzZWxmLCBhcmd1bWVudHMpOyB9LFxuXHRcdFx0XHRjbGljayAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYub25DbGljay5hcHBseShzZWxmLCBhcmd1bWVudHMpOyB9XG5cdFx0XHR9KTtcblx0XG5cdFx0XHQkY29udHJvbF9pbnB1dC5vbih7XG5cdFx0XHRcdG1vdXNlZG93biA6IGZ1bmN0aW9uKGUpIHsgZS5zdG9wUHJvcGFnYXRpb24oKTsgfSxcblx0XHRcdFx0a2V5ZG93biAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLm9uS2V5RG93bi5hcHBseShzZWxmLCBhcmd1bWVudHMpOyB9LFxuXHRcdFx0XHRrZXl1cCAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYub25LZXlVcC5hcHBseShzZWxmLCBhcmd1bWVudHMpOyB9LFxuXHRcdFx0XHRrZXlwcmVzcyAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYub25LZXlQcmVzcy5hcHBseShzZWxmLCBhcmd1bWVudHMpOyB9LFxuXHRcdFx0XHRyZXNpemUgICAgOiBmdW5jdGlvbigpIHsgc2VsZi5wb3NpdGlvbkRyb3Bkb3duLmFwcGx5KHNlbGYsIFtdKTsgfSxcblx0XHRcdFx0Ymx1ciAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLm9uQmx1ci5hcHBseShzZWxmLCBhcmd1bWVudHMpOyB9LFxuXHRcdFx0XHRmb2N1cyAgICAgOiBmdW5jdGlvbigpIHsgc2VsZi5pZ25vcmVCbHVyID0gZmFsc2U7IHJldHVybiBzZWxmLm9uRm9jdXMuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTsgfSxcblx0XHRcdFx0cGFzdGUgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLm9uUGFzdGUuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTsgfVxuXHRcdFx0fSk7XG5cdFxuXHRcdFx0JGRvY3VtZW50Lm9uKCdrZXlkb3duJyArIGV2ZW50TlMsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0c2VsZi5pc0NtZERvd24gPSBlW0lTX01BQyA/ICdtZXRhS2V5JyA6ICdjdHJsS2V5J107XG5cdFx0XHRcdHNlbGYuaXNDdHJsRG93biA9IGVbSVNfTUFDID8gJ2FsdEtleScgOiAnY3RybEtleSddO1xuXHRcdFx0XHRzZWxmLmlzU2hpZnREb3duID0gZS5zaGlmdEtleTtcblx0XHRcdH0pO1xuXHRcblx0XHRcdCRkb2N1bWVudC5vbigna2V5dXAnICsgZXZlbnROUywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRpZiAoZS5rZXlDb2RlID09PSBLRVlfQ1RSTCkgc2VsZi5pc0N0cmxEb3duID0gZmFsc2U7XG5cdFx0XHRcdGlmIChlLmtleUNvZGUgPT09IEtFWV9TSElGVCkgc2VsZi5pc1NoaWZ0RG93biA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoZS5rZXlDb2RlID09PSBLRVlfQ01EKSBzZWxmLmlzQ21kRG93biA9IGZhbHNlO1xuXHRcdFx0fSk7XG5cdFxuXHRcdFx0JGRvY3VtZW50Lm9uKCdtb3VzZWRvd24nICsgZXZlbnROUywgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRpZiAoc2VsZi5pc0ZvY3VzZWQpIHtcblx0XHRcdFx0XHQvLyBwcmV2ZW50IGV2ZW50cyBvbiB0aGUgZHJvcGRvd24gc2Nyb2xsYmFyIGZyb20gY2F1c2luZyB0aGUgY29udHJvbCB0byBibHVyXG5cdFx0XHRcdFx0aWYgKGUudGFyZ2V0ID09PSBzZWxmLiRkcm9wZG93blswXSB8fCBlLnRhcmdldC5wYXJlbnROb2RlID09PSBzZWxmLiRkcm9wZG93blswXSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBibHVyIG9uIGNsaWNrIG91dHNpZGVcblx0XHRcdFx0XHRpZiAoIXNlbGYuJGNvbnRyb2wuaGFzKGUudGFyZ2V0KS5sZW5ndGggJiYgZS50YXJnZXQgIT09IHNlbGYuJGNvbnRyb2xbMF0pIHtcblx0XHRcdFx0XHRcdHNlbGYuYmx1cihlLnRhcmdldCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XG5cdFx0XHQkd2luZG93Lm9uKFsnc2Nyb2xsJyArIGV2ZW50TlMsICdyZXNpemUnICsgZXZlbnROU10uam9pbignICcpLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKHNlbGYuaXNPcGVuKSB7XG5cdFx0XHRcdFx0c2VsZi5wb3NpdGlvbkRyb3Bkb3duLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0JHdpbmRvdy5vbignbW91c2Vtb3ZlJyArIGV2ZW50TlMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmlnbm9yZUhvdmVyID0gZmFsc2U7XG5cdFx0XHR9KTtcblx0XG5cdFx0XHQvLyBzdG9yZSBvcmlnaW5hbCBjaGlsZHJlbiBhbmQgdGFiIGluZGV4IHNvIHRoYXQgdGhleSBjYW4gYmVcblx0XHRcdC8vIHJlc3RvcmVkIHdoZW4gdGhlIGRlc3Ryb3koKSBtZXRob2QgaXMgY2FsbGVkLlxuXHRcdFx0dGhpcy5yZXZlcnRTZXR0aW5ncyA9IHtcblx0XHRcdFx0JGNoaWxkcmVuIDogJGlucHV0LmNoaWxkcmVuKCkuZGV0YWNoKCksXG5cdFx0XHRcdHRhYmluZGV4ICA6ICRpbnB1dC5hdHRyKCd0YWJpbmRleCcpXG5cdFx0XHR9O1xuXHRcblx0XHRcdCRpbnB1dC5hdHRyKCd0YWJpbmRleCcsIC0xKS5oaWRlKCkuYWZ0ZXIoc2VsZi4kd3JhcHBlcik7XG5cdFxuXHRcdFx0aWYgKCQuaXNBcnJheShzZXR0aW5ncy5pdGVtcykpIHtcblx0XHRcdFx0c2VsZi5zZXRWYWx1ZShzZXR0aW5ncy5pdGVtcyk7XG5cdFx0XHRcdGRlbGV0ZSBzZXR0aW5ncy5pdGVtcztcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBmZWF0dXJlIGRldGVjdCBmb3IgdGhlIHZhbGlkYXRpb24gQVBJXG5cdFx0XHRpZiAoU1VQUE9SVFNfVkFMSURJVFlfQVBJKSB7XG5cdFx0XHRcdCRpbnB1dC5vbignaW52YWxpZCcgKyBldmVudE5TLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHNlbGYuaXNJbnZhbGlkID0gdHJ1ZTtcblx0XHRcdFx0XHRzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XG5cdFx0XHRzZWxmLnVwZGF0ZU9yaWdpbmFsSW5wdXQoKTtcblx0XHRcdHNlbGYucmVmcmVzaEl0ZW1zKCk7XG5cdFx0XHRzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHRcdFx0c2VsZi51cGRhdGVQbGFjZWhvbGRlcigpO1xuXHRcdFx0c2VsZi5pc1NldHVwID0gdHJ1ZTtcblx0XG5cdFx0XHRpZiAoJGlucHV0LmlzKCc6ZGlzYWJsZWQnKSkge1xuXHRcdFx0XHRzZWxmLmRpc2FibGUoKTtcblx0XHRcdH1cblx0XG5cdFx0XHRzZWxmLm9uKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlKTtcblx0XG5cdFx0XHQkaW5wdXQuZGF0YSgnc2VsZWN0aXplJywgc2VsZik7XG5cdFx0XHQkaW5wdXQuYWRkQ2xhc3MoJ3NlbGVjdGl6ZWQnKTtcblx0XHRcdHNlbGYudHJpZ2dlcignaW5pdGlhbGl6ZScpO1xuXHRcblx0XHRcdC8vIHByZWxvYWQgb3B0aW9uc1xuXHRcdFx0aWYgKHNldHRpbmdzLnByZWxvYWQgPT09IHRydWUpIHtcblx0XHRcdFx0c2VsZi5vblNlYXJjaENoYW5nZSgnJyk7XG5cdFx0XHR9XG5cdFxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNldHMgdXAgZGVmYXVsdCByZW5kZXJpbmcgZnVuY3Rpb25zLlxuXHRcdCAqL1xuXHRcdHNldHVwVGVtcGxhdGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBmaWVsZF9sYWJlbCA9IHNlbGYuc2V0dGluZ3MubGFiZWxGaWVsZDtcblx0XHRcdHZhciBmaWVsZF9vcHRncm91cCA9IHNlbGYuc2V0dGluZ3Mub3B0Z3JvdXBMYWJlbEZpZWxkO1xuXHRcblx0XHRcdHZhciB0ZW1wbGF0ZXMgPSB7XG5cdFx0XHRcdCdvcHRncm91cCc6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0XHRyZXR1cm4gJzxkaXYgY2xhc3M9XCJvcHRncm91cFwiPicgKyBkYXRhLmh0bWwgKyAnPC9kaXY+Jztcblx0XHRcdFx0fSxcblx0XHRcdFx0J29wdGdyb3VwX2hlYWRlcic6IGZ1bmN0aW9uKGRhdGEsIGVzY2FwZSkge1xuXHRcdFx0XHRcdHJldHVybiAnPGRpdiBjbGFzcz1cIm9wdGdyb3VwLWhlYWRlclwiPicgKyBlc2NhcGUoZGF0YVtmaWVsZF9vcHRncm91cF0pICsgJzwvZGl2Pic7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdvcHRpb24nOiBmdW5jdGlvbihkYXRhLCBlc2NhcGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gJzxkaXYgY2xhc3M9XCJvcHRpb25cIj4nICsgZXNjYXBlKGRhdGFbZmllbGRfbGFiZWxdKSArICc8L2Rpdj4nO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQnaXRlbSc6IGZ1bmN0aW9uKGRhdGEsIGVzY2FwZSkge1xuXHRcdFx0XHRcdHJldHVybiAnPGRpdiBjbGFzcz1cIml0ZW1cIj4nICsgZXNjYXBlKGRhdGFbZmllbGRfbGFiZWxdKSArICc8L2Rpdj4nO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQnb3B0aW9uX2NyZWF0ZSc6IGZ1bmN0aW9uKGRhdGEsIGVzY2FwZSkge1xuXHRcdFx0XHRcdHJldHVybiAnPGRpdiBjbGFzcz1cImNyZWF0ZVwiPkFkZCA8c3Ryb25nPicgKyBlc2NhcGUoZGF0YS5pbnB1dCkgKyAnPC9zdHJvbmc+JmhlbGxpcDs8L2Rpdj4nO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcblx0XHRcdHNlbGYuc2V0dGluZ3MucmVuZGVyID0gJC5leHRlbmQoe30sIHRlbXBsYXRlcywgc2VsZi5zZXR0aW5ncy5yZW5kZXIpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIE1hcHMgZmlyZWQgZXZlbnRzIHRvIGNhbGxiYWNrcyBwcm92aWRlZFxuXHRcdCAqIGluIHRoZSBzZXR0aW5ncyB1c2VkIHdoZW4gY3JlYXRpbmcgdGhlIGNvbnRyb2wuXG5cdFx0ICovXG5cdFx0c2V0dXBDYWxsYmFja3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGtleSwgZm4sIGNhbGxiYWNrcyA9IHtcblx0XHRcdFx0J2luaXRpYWxpemUnICAgICAgOiAnb25Jbml0aWFsaXplJyxcblx0XHRcdFx0J2NoYW5nZScgICAgICAgICAgOiAnb25DaGFuZ2UnLFxuXHRcdFx0XHQnaXRlbV9hZGQnICAgICAgICA6ICdvbkl0ZW1BZGQnLFxuXHRcdFx0XHQnaXRlbV9yZW1vdmUnICAgICA6ICdvbkl0ZW1SZW1vdmUnLFxuXHRcdFx0XHQnY2xlYXInICAgICAgICAgICA6ICdvbkNsZWFyJyxcblx0XHRcdFx0J29wdGlvbl9hZGQnICAgICAgOiAnb25PcHRpb25BZGQnLFxuXHRcdFx0XHQnb3B0aW9uX3JlbW92ZScgICA6ICdvbk9wdGlvblJlbW92ZScsXG5cdFx0XHRcdCdvcHRpb25fY2xlYXInICAgIDogJ29uT3B0aW9uQ2xlYXInLFxuXHRcdFx0XHQnb3B0Z3JvdXBfYWRkJyAgICA6ICdvbk9wdGlvbkdyb3VwQWRkJyxcblx0XHRcdFx0J29wdGdyb3VwX3JlbW92ZScgOiAnb25PcHRpb25Hcm91cFJlbW92ZScsXG5cdFx0XHRcdCdvcHRncm91cF9jbGVhcicgIDogJ29uT3B0aW9uR3JvdXBDbGVhcicsXG5cdFx0XHRcdCdkcm9wZG93bl9vcGVuJyAgIDogJ29uRHJvcGRvd25PcGVuJyxcblx0XHRcdFx0J2Ryb3Bkb3duX2Nsb3NlJyAgOiAnb25Ecm9wZG93bkNsb3NlJyxcblx0XHRcdFx0J3R5cGUnICAgICAgICAgICAgOiAnb25UeXBlJyxcblx0XHRcdFx0J2xvYWQnICAgICAgICAgICAgOiAnb25Mb2FkJyxcblx0XHRcdFx0J2ZvY3VzJyAgICAgICAgICAgOiAnb25Gb2N1cycsXG5cdFx0XHRcdCdibHVyJyAgICAgICAgICAgIDogJ29uQmx1cidcblx0XHRcdH07XG5cdFxuXHRcdFx0Zm9yIChrZXkgaW4gY2FsbGJhY2tzKSB7XG5cdFx0XHRcdGlmIChjYWxsYmFja3MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdGZuID0gdGhpcy5zZXR0aW5nc1tjYWxsYmFja3Nba2V5XV07XG5cdFx0XHRcdFx0aWYgKGZuKSB0aGlzLm9uKGtleSwgZm4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlcmVkIHdoZW4gdGhlIG1haW4gY29udHJvbCBlbGVtZW50XG5cdFx0ICogaGFzIGEgY2xpY2sgZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZVxuXHRcdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0XHRcdC8vIG5lY2Vzc2FyeSBmb3IgbW9iaWxlIHdlYmtpdCBkZXZpY2VzIChtYW51YWwgZm9jdXMgdHJpZ2dlcmluZ1xuXHRcdFx0Ly8gaXMgaWdub3JlZCB1bmxlc3MgaW52b2tlZCB3aXRoaW4gYSBjbGljayBldmVudClcblx0XHRcdGlmICghc2VsZi5pc0ZvY3VzZWQpIHtcblx0XHRcdFx0c2VsZi5mb2N1cygpO1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlcmVkIHdoZW4gdGhlIG1haW4gY29udHJvbCBlbGVtZW50XG5cdFx0ICogaGFzIGEgbW91c2UgZG93biBldmVudC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBlXG5cdFx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHRvbk1vdXNlRG93bjogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBlLmlzRGVmYXVsdFByZXZlbnRlZCgpO1xuXHRcdFx0dmFyICR0YXJnZXQgPSAkKGUudGFyZ2V0KTtcblx0XG5cdFx0XHRpZiAoc2VsZi5pc0ZvY3VzZWQpIHtcblx0XHRcdFx0Ly8gcmV0YWluIGZvY3VzIGJ5IHByZXZlbnRpbmcgbmF0aXZlIGhhbmRsaW5nLiBpZiB0aGVcblx0XHRcdFx0Ly8gZXZlbnQgdGFyZ2V0IGlzIHRoZSBpbnB1dCBpdCBzaG91bGQgbm90IGJlIG1vZGlmaWVkLlxuXHRcdFx0XHQvLyBvdGhlcndpc2UsIHRleHQgc2VsZWN0aW9uIHdpdGhpbiB0aGUgaW5wdXQgd29uJ3Qgd29yay5cblx0XHRcdFx0aWYgKGUudGFyZ2V0ICE9PSBzZWxmLiRjb250cm9sX2lucHV0WzBdKSB7XG5cdFx0XHRcdFx0aWYgKHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScpIHtcblx0XHRcdFx0XHRcdC8vIHRvZ2dsZSBkcm9wZG93blxuXHRcdFx0XHRcdFx0c2VsZi5pc09wZW4gPyBzZWxmLmNsb3NlKCkgOiBzZWxmLm9wZW4oKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFkZWZhdWx0UHJldmVudGVkKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW0obnVsbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gZ2l2ZSBjb250cm9sIGZvY3VzXG5cdFx0XHRcdGlmICghZGVmYXVsdFByZXZlbnRlZCkge1xuXHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c2VsZi5mb2N1cygpO1xuXHRcdFx0XHRcdH0sIDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlcmVkIHdoZW4gdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sIGhhcyBiZWVuIGNoYW5nZWQuXG5cdFx0ICogVGhpcyBzaG91bGQgcHJvcGFnYXRlIHRoZSBldmVudCB0byB0aGUgb3JpZ2luYWwgRE9NXG5cdFx0ICogaW5wdXQgLyBzZWxlY3QgZWxlbWVudC5cblx0XHQgKi9cblx0XHRvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLiRpbnB1dC50cmlnZ2VyKCdjaGFuZ2UnKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBUcmlnZ2VyZWQgb24gPGlucHV0PiBwYXN0ZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBlXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0b25QYXN0ZTogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0XHRcdGlmIChzZWxmLmlzRnVsbCgpIHx8IHNlbGYuaXNJbnB1dEhpZGRlbiB8fCBzZWxmLmlzTG9ja2VkKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIElmIGEgcmVnZXggb3Igc3RyaW5nIGlzIGluY2x1ZGVkLCB0aGlzIHdpbGwgc3BsaXQgdGhlIHBhc3RlZFxuXHRcdFx0Ly8gaW5wdXQgYW5kIGNyZWF0ZSBJdGVtcyBmb3IgZWFjaCBzZXBhcmF0ZSB2YWx1ZVxuXHRcdFx0aWYgKHNlbGYuc2V0dGluZ3Muc3BsaXRPbikge1xuXHRcblx0XHRcdFx0Ly8gV2FpdCBmb3IgcGFzdGVkIHRleHQgdG8gYmUgcmVjb2duaXplZCBpbiB2YWx1ZVxuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBwYXN0ZWRUZXh0ID0gc2VsZi4kY29udHJvbF9pbnB1dC52YWwoKTtcblx0XHRcdFx0XHRpZighcGFzdGVkVGV4dC5tYXRjaChzZWxmLnNldHRpbmdzLnNwbGl0T24pKXsgcmV0dXJuIH1cblx0XG5cdFx0XHRcdFx0dmFyIHNwbGl0SW5wdXQgPSAkLnRyaW0ocGFzdGVkVGV4dCkuc3BsaXQoc2VsZi5zZXR0aW5ncy5zcGxpdE9uKTtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHNwbGl0SW5wdXQubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRzZWxmLmNyZWF0ZUl0ZW0oc3BsaXRJbnB1dFtpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCAwKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBUcmlnZ2VyZWQgb24gPGlucHV0PiBrZXlwcmVzcy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBlXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0b25LZXlQcmVzczogZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKHRoaXMuaXNMb2NrZWQpIHJldHVybiBlICYmIGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHZhciBjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUua2V5Q29kZSB8fCBlLndoaWNoKTtcblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmNyZWF0ZSAmJiB0aGlzLnNldHRpbmdzLm1vZGUgPT09ICdtdWx0aScgJiYgY2hhcmFjdGVyID09PSB0aGlzLnNldHRpbmdzLmRlbGltaXRlcikge1xuXHRcdFx0XHR0aGlzLmNyZWF0ZUl0ZW0oKTtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4ga2V5ZG93bi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBlXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0b25LZXlEb3duOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgaXNJbnB1dCA9IGUudGFyZ2V0ID09PSB0aGlzLiRjb250cm9sX2lucHV0WzBdO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0XHRcdGlmIChzZWxmLmlzTG9ja2VkKSB7XG5cdFx0XHRcdGlmIChlLmtleUNvZGUgIT09IEtFWV9UQUIpIHtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcblx0XHRcdHN3aXRjaCAoZS5rZXlDb2RlKSB7XG5cdFx0XHRcdGNhc2UgS0VZX0E6XG5cdFx0XHRcdFx0aWYgKHNlbGYuaXNDbWREb3duKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnNlbGVjdEFsbCgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBLRVlfRVNDOlxuXHRcdFx0XHRcdGlmIChzZWxmLmlzT3Blbikge1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRjYXNlIEtFWV9OOlxuXHRcdFx0XHRcdGlmICghZS5jdHJsS2V5IHx8IGUuYWx0S2V5KSBicmVhaztcblx0XHRcdFx0Y2FzZSBLRVlfRE9XTjpcblx0XHRcdFx0XHRpZiAoIXNlbGYuaXNPcGVuICYmIHNlbGYuaGFzT3B0aW9ucykge1xuXHRcdFx0XHRcdFx0c2VsZi5vcGVuKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChzZWxmLiRhY3RpdmVPcHRpb24pIHtcblx0XHRcdFx0XHRcdHNlbGYuaWdub3JlSG92ZXIgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dmFyICRuZXh0ID0gc2VsZi5nZXRBZGphY2VudE9wdGlvbihzZWxmLiRhY3RpdmVPcHRpb24sIDEpO1xuXHRcdFx0XHRcdFx0aWYgKCRuZXh0Lmxlbmd0aCkgc2VsZi5zZXRBY3RpdmVPcHRpb24oJG5leHQsIHRydWUsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRjYXNlIEtFWV9QOlxuXHRcdFx0XHRcdGlmICghZS5jdHJsS2V5IHx8IGUuYWx0S2V5KSBicmVhaztcblx0XHRcdFx0Y2FzZSBLRVlfVVA6XG5cdFx0XHRcdFx0aWYgKHNlbGYuJGFjdGl2ZU9wdGlvbikge1xuXHRcdFx0XHRcdFx0c2VsZi5pZ25vcmVIb3ZlciA9IHRydWU7XG5cdFx0XHRcdFx0XHR2YXIgJHByZXYgPSBzZWxmLmdldEFkamFjZW50T3B0aW9uKHNlbGYuJGFjdGl2ZU9wdGlvbiwgLTEpO1xuXHRcdFx0XHRcdFx0aWYgKCRwcmV2Lmxlbmd0aCkgc2VsZi5zZXRBY3RpdmVPcHRpb24oJHByZXYsIHRydWUsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRjYXNlIEtFWV9SRVRVUk46XG5cdFx0XHRcdFx0aWYgKHNlbGYuaXNPcGVuICYmIHNlbGYuJGFjdGl2ZU9wdGlvbikge1xuXHRcdFx0XHRcdFx0c2VsZi5vbk9wdGlvblNlbGVjdCh7Y3VycmVudFRhcmdldDogc2VsZi4kYWN0aXZlT3B0aW9ufSk7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0Y2FzZSBLRVlfTEVGVDpcblx0XHRcdFx0XHRzZWxmLmFkdmFuY2VTZWxlY3Rpb24oLTEsIGUpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0Y2FzZSBLRVlfUklHSFQ6XG5cdFx0XHRcdFx0c2VsZi5hZHZhbmNlU2VsZWN0aW9uKDEsIGUpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0Y2FzZSBLRVlfVEFCOlxuXHRcdFx0XHRcdGlmIChzZWxmLnNldHRpbmdzLnNlbGVjdE9uVGFiICYmIHNlbGYuaXNPcGVuICYmIHNlbGYuJGFjdGl2ZU9wdGlvbikge1xuXHRcdFx0XHRcdFx0c2VsZi5vbk9wdGlvblNlbGVjdCh7Y3VycmVudFRhcmdldDogc2VsZi4kYWN0aXZlT3B0aW9ufSk7XG5cdFxuXHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBiZWhhdmlvdXIgaXMgdG8ganVtcCB0byB0aGUgbmV4dCBmaWVsZCwgd2Ugb25seSB3YW50IHRoaXNcblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBjdXJyZW50IGZpZWxkIGRvZXNuJ3QgYWNjZXB0IGFueSBtb3JlIGVudHJpZXNcblx0XHRcdFx0XHRcdGlmICghc2VsZi5pc0Z1bGwoKSkge1xuXHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzZWxmLnNldHRpbmdzLmNyZWF0ZSAmJiBzZWxmLmNyZWF0ZUl0ZW0oKSkge1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdGNhc2UgS0VZX0JBQ0tTUEFDRTpcblx0XHRcdFx0Y2FzZSBLRVlfREVMRVRFOlxuXHRcdFx0XHRcdHNlbGYuZGVsZXRlU2VsZWN0aW9uKGUpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoKHNlbGYuaXNGdWxsKCkgfHwgc2VsZi5pc0lucHV0SGlkZGVuKSAmJiAhKElTX01BQyA/IGUubWV0YUtleSA6IGUuY3RybEtleSkpIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4ga2V5dXAuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZVxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdG9uS2V5VXA6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XG5cdFx0XHRpZiAoc2VsZi5pc0xvY2tlZCkgcmV0dXJuIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dmFyIHZhbHVlID0gc2VsZi4kY29udHJvbF9pbnB1dC52YWwoKSB8fCAnJztcblx0XHRcdGlmIChzZWxmLmxhc3RWYWx1ZSAhPT0gdmFsdWUpIHtcblx0XHRcdFx0c2VsZi5sYXN0VmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0c2VsZi5vblNlYXJjaENoYW5nZSh2YWx1ZSk7XG5cdFx0XHRcdHNlbGYucmVmcmVzaE9wdGlvbnMoKTtcblx0XHRcdFx0c2VsZi50cmlnZ2VyKCd0eXBlJywgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEludm9rZXMgdGhlIHVzZXItcHJvdmlkZSBvcHRpb24gcHJvdmlkZXIgLyBsb2FkZXIuXG5cdFx0ICpcblx0XHQgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIGlzIGRlYm91bmNlZCBpbiB0aGUgU2VsZWN0aXplXG5cdFx0ICogY29uc3RydWN0b3IgKGJ5IGBzZXR0aW5ncy5sb2FkVGhyb3R0bGVgIG1pbGxpc2Vjb25kcylcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHRcdCAqL1xuXHRcdG9uU2VhcmNoQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIGZuID0gc2VsZi5zZXR0aW5ncy5sb2FkO1xuXHRcdFx0aWYgKCFmbikgcmV0dXJuO1xuXHRcdFx0aWYgKHNlbGYubG9hZGVkU2VhcmNoZXMuaGFzT3duUHJvcGVydHkodmFsdWUpKSByZXR1cm47XG5cdFx0XHRzZWxmLmxvYWRlZFNlYXJjaGVzW3ZhbHVlXSA9IHRydWU7XG5cdFx0XHRzZWxmLmxvYWQoZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0Zm4uYXBwbHkoc2VsZiwgW3ZhbHVlLCBjYWxsYmFja10pO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlcmVkIG9uIDxpbnB1dD4gZm9jdXMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZSAob3B0aW9uYWwpXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0b25Gb2N1czogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIHdhc0ZvY3VzZWQgPSBzZWxmLmlzRm9jdXNlZDtcblx0XG5cdFx0XHRpZiAoc2VsZi5pc0Rpc2FibGVkKSB7XG5cdFx0XHRcdHNlbGYuYmx1cigpO1xuXHRcdFx0XHRlICYmIGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmIChzZWxmLmlnbm9yZUZvY3VzKSByZXR1cm47XG5cdFx0XHRzZWxmLmlzRm9jdXNlZCA9IHRydWU7XG5cdFx0XHRpZiAoc2VsZi5zZXR0aW5ncy5wcmVsb2FkID09PSAnZm9jdXMnKSBzZWxmLm9uU2VhcmNoQ2hhbmdlKCcnKTtcblx0XG5cdFx0XHRpZiAoIXdhc0ZvY3VzZWQpIHNlbGYudHJpZ2dlcignZm9jdXMnKTtcblx0XG5cdFx0XHRpZiAoIXNlbGYuJGFjdGl2ZUl0ZW1zLmxlbmd0aCkge1xuXHRcdFx0XHRzZWxmLnNob3dJbnB1dCgpO1xuXHRcdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW0obnVsbCk7XG5cdFx0XHRcdHNlbGYucmVmcmVzaE9wdGlvbnMoISFzZWxmLnNldHRpbmdzLm9wZW5PbkZvY3VzKTtcblx0XHRcdH1cblx0XG5cdFx0XHRzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRyaWdnZXJlZCBvbiA8aW5wdXQ+IGJsdXIuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZVxuXHRcdCAqIEBwYXJhbSB7RWxlbWVudH0gZGVzdFxuXHRcdCAqL1xuXHRcdG9uQmx1cjogZnVuY3Rpb24oZSwgZGVzdCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0aWYgKCFzZWxmLmlzRm9jdXNlZCkgcmV0dXJuO1xuXHRcdFx0c2VsZi5pc0ZvY3VzZWQgPSBmYWxzZTtcblx0XG5cdFx0XHRpZiAoc2VsZi5pZ25vcmVGb2N1cykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2UgaWYgKCFzZWxmLmlnbm9yZUJsdXIgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gc2VsZi4kZHJvcGRvd25fY29udGVudFswXSkge1xuXHRcdFx0XHQvLyBuZWNlc3NhcnkgdG8gcHJldmVudCBJRSBjbG9zaW5nIHRoZSBkcm9wZG93biB3aGVuIHRoZSBzY3JvbGxiYXIgaXMgY2xpY2tlZFxuXHRcdFx0XHRzZWxmLmlnbm9yZUJsdXIgPSB0cnVlO1xuXHRcdFx0XHRzZWxmLm9uRm9jdXMoZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHR2YXIgZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmNsb3NlKCk7XG5cdFx0XHRcdHNlbGYuc2V0VGV4dGJveFZhbHVlKCcnKTtcblx0XHRcdFx0c2VsZi5zZXRBY3RpdmVJdGVtKG51bGwpO1xuXHRcdFx0XHRzZWxmLnNldEFjdGl2ZU9wdGlvbihudWxsKTtcblx0XHRcdFx0c2VsZi5zZXRDYXJldChzZWxmLml0ZW1zLmxlbmd0aCk7XG5cdFx0XHRcdHNlbGYucmVmcmVzaFN0YXRlKCk7XG5cdFxuXHRcdFx0XHQvLyBJRTExIGJ1ZzogZWxlbWVudCBzdGlsbCBtYXJrZWQgYXMgYWN0aXZlXG5cdFx0XHRcdGRlc3QgJiYgZGVzdC5mb2N1cyAmJiBkZXN0LmZvY3VzKCk7XG5cdFxuXHRcdFx0XHRzZWxmLmlnbm9yZUZvY3VzID0gZmFsc2U7XG5cdFx0XHRcdHNlbGYudHJpZ2dlcignYmx1cicpO1xuXHRcdFx0fTtcblx0XG5cdFx0XHRzZWxmLmlnbm9yZUZvY3VzID0gdHJ1ZTtcblx0XHRcdGlmIChzZWxmLnNldHRpbmdzLmNyZWF0ZSAmJiBzZWxmLnNldHRpbmdzLmNyZWF0ZU9uQmx1cikge1xuXHRcdFx0XHRzZWxmLmNyZWF0ZUl0ZW0obnVsbCwgZmFsc2UsIGRlYWN0aXZhdGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVhY3RpdmF0ZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIHJvbGxzIG92ZXJcblx0XHQgKiBhbiBvcHRpb24gaW4gdGhlIGF1dG9jb21wbGV0ZSBkcm9wZG93biBtZW51LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGVcblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHRvbk9wdGlvbkhvdmVyOiBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAodGhpcy5pZ25vcmVIb3ZlcikgcmV0dXJuO1xuXHRcdFx0dGhpcy5zZXRBY3RpdmVPcHRpb24oZS5jdXJyZW50VGFyZ2V0LCBmYWxzZSk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGFuIG9wdGlvblxuXHRcdCAqIGluIHRoZSBhdXRvY29tcGxldGUgZHJvcGRvd24gbWVudS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBlXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0b25PcHRpb25TZWxlY3Q6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciB2YWx1ZSwgJHRhcmdldCwgJG9wdGlvbiwgc2VsZiA9IHRoaXM7XG5cdFxuXHRcdFx0aWYgKGUucHJldmVudERlZmF1bHQpIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0fVxuXHRcblx0XHRcdCR0YXJnZXQgPSAkKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRpZiAoJHRhcmdldC5oYXNDbGFzcygnY3JlYXRlJykpIHtcblx0XHRcdFx0c2VsZi5jcmVhdGVJdGVtKG51bGwsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmIChzZWxmLnNldHRpbmdzLmNsb3NlQWZ0ZXJTZWxlY3QpIHtcblx0XHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsdWUgPSAkdGFyZ2V0LmF0dHIoJ2RhdGEtdmFsdWUnKTtcblx0XHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG5cdFx0XHRcdFx0c2VsZi5zZXRUZXh0Ym94VmFsdWUoJycpO1xuXHRcdFx0XHRcdHNlbGYuYWRkSXRlbSh2YWx1ZSk7XG5cdFx0XHRcdFx0aWYgKHNlbGYuc2V0dGluZ3MuY2xvc2VBZnRlclNlbGVjdCkge1xuXHRcdFx0XHRcdFx0c2VsZi5jbG9zZSgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIXNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkICYmIGUudHlwZSAmJiAvbW91c2UvLnRlc3QoZS50eXBlKSkge1xuXHRcdFx0XHRcdFx0c2VsZi5zZXRBY3RpdmVPcHRpb24oc2VsZi5nZXRPcHRpb24odmFsdWUpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gaXRlbVxuXHRcdCAqIHRoYXQgaGFzIGJlZW4gc2VsZWN0ZWQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZVxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdG9uSXRlbVNlbGVjdDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0XHRcdGlmIChzZWxmLmlzTG9ja2VkKSByZXR1cm47XG5cdFx0XHRpZiAoc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnbXVsdGknKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0c2VsZi5zZXRBY3RpdmVJdGVtKGUuY3VycmVudFRhcmdldCwgZSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogSW52b2tlcyB0aGUgcHJvdmlkZWQgbWV0aG9kIHRoYXQgcHJvdmlkZXNcblx0XHQgKiByZXN1bHRzIHRvIGEgY2FsbGJhY2stLS13aGljaCBhcmUgdGhlbiBhZGRlZFxuXHRcdCAqIGFzIG9wdGlvbnMgdG8gdGhlIGNvbnRyb2wuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmblxuXHRcdCAqL1xuXHRcdGxvYWQ6IGZ1bmN0aW9uKGZuKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgJHdyYXBwZXIgPSBzZWxmLiR3cmFwcGVyLmFkZENsYXNzKHNlbGYuc2V0dGluZ3MubG9hZGluZ0NsYXNzKTtcblx0XG5cdFx0XHRzZWxmLmxvYWRpbmcrKztcblx0XHRcdGZuLmFwcGx5KHNlbGYsIFtmdW5jdGlvbihyZXN1bHRzKSB7XG5cdFx0XHRcdHNlbGYubG9hZGluZyA9IE1hdGgubWF4KHNlbGYubG9hZGluZyAtIDEsIDApO1xuXHRcdFx0XHRpZiAocmVzdWx0cyAmJiByZXN1bHRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHNlbGYuYWRkT3B0aW9uKHJlc3VsdHMpO1xuXHRcdFx0XHRcdHNlbGYucmVmcmVzaE9wdGlvbnMoc2VsZi5pc0ZvY3VzZWQgJiYgIXNlbGYuaXNJbnB1dEhpZGRlbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzZWxmLmxvYWRpbmcpIHtcblx0XHRcdFx0XHQkd3JhcHBlci5yZW1vdmVDbGFzcyhzZWxmLnNldHRpbmdzLmxvYWRpbmdDbGFzcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi50cmlnZ2VyKCdsb2FkJywgcmVzdWx0cyk7XG5cdFx0XHR9XSk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU2V0cyB0aGUgaW5wdXQgZmllbGQgb2YgdGhlIGNvbnRyb2wgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHRcdCAqL1xuXHRcdHNldFRleHRib3hWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciAkaW5wdXQgPSB0aGlzLiRjb250cm9sX2lucHV0O1xuXHRcdFx0dmFyIGNoYW5nZWQgPSAkaW5wdXQudmFsKCkgIT09IHZhbHVlO1xuXHRcdFx0aWYgKGNoYW5nZWQpIHtcblx0XHRcdFx0JGlucHV0LnZhbCh2YWx1ZSkudHJpZ2dlckhhbmRsZXIoJ3VwZGF0ZScpO1xuXHRcdFx0XHR0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sLiBJZiBtdWx0aXBsZSBpdGVtc1xuXHRcdCAqIGNhbiBiZSBzZWxlY3RlZCAoZS5nLiA8c2VsZWN0IG11bHRpcGxlPiksIHRoaXMgcmV0dXJuc1xuXHRcdCAqIGFuIGFycmF5LiBJZiBvbmx5IG9uZSBpdGVtIGNhbiBiZSBzZWxlY3RlZCwgdGhpc1xuXHRcdCAqIHJldHVybnMgYSBzdHJpbmcuXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyB7bWl4ZWR9XG5cdFx0ICovXG5cdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMudGFnVHlwZSA9PT0gVEFHX1NFTEVDVCAmJiB0aGlzLiRpbnB1dC5hdHRyKCdtdWx0aXBsZScpKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLml0ZW1zO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuaXRlbXMuam9pbih0aGlzLnNldHRpbmdzLmRlbGltaXRlcik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUmVzZXRzIHRoZSBzZWxlY3RlZCBpdGVtcyB0byB0aGUgZ2l2ZW4gdmFsdWUuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge21peGVkfSB2YWx1ZVxuXHRcdCAqL1xuXHRcdHNldFZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgc2lsZW50KSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gc2lsZW50ID8gW10gOiBbJ2NoYW5nZSddO1xuXHRcblx0XHRcdGRlYm91bmNlX2V2ZW50cyh0aGlzLCBldmVudHMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmNsZWFyKHNpbGVudCk7XG5cdFx0XHRcdHRoaXMuYWRkSXRlbXModmFsdWUsIHNpbGVudCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBTZXRzIHRoZSBzZWxlY3RlZCBpdGVtLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9ICRpdGVtXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGUgKG9wdGlvbmFsKVxuXHRcdCAqL1xuXHRcdHNldEFjdGl2ZUl0ZW06IGZ1bmN0aW9uKCRpdGVtLCBlKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgZXZlbnROYW1lO1xuXHRcdFx0dmFyIGksIGlkeCwgYmVnaW4sIGVuZCwgaXRlbSwgc3dhcDtcblx0XHRcdHZhciAkbGFzdDtcblx0XG5cdFx0XHRpZiAoc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJykgcmV0dXJuO1xuXHRcdFx0JGl0ZW0gPSAkKCRpdGVtKTtcblx0XG5cdFx0XHQvLyBjbGVhciB0aGUgYWN0aXZlIHNlbGVjdGlvblxuXHRcdFx0aWYgKCEkaXRlbS5sZW5ndGgpIHtcblx0XHRcdFx0JChzZWxmLiRhY3RpdmVJdGVtcykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdFx0XHRzZWxmLiRhY3RpdmVJdGVtcyA9IFtdO1xuXHRcdFx0XHRpZiAoc2VsZi5pc0ZvY3VzZWQpIHtcblx0XHRcdFx0XHRzZWxmLnNob3dJbnB1dCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBtb2RpZnkgc2VsZWN0aW9uXG5cdFx0XHRldmVudE5hbWUgPSBlICYmIGUudHlwZS50b0xvd2VyQ2FzZSgpO1xuXHRcblx0XHRcdGlmIChldmVudE5hbWUgPT09ICdtb3VzZWRvd24nICYmIHNlbGYuaXNTaGlmdERvd24gJiYgc2VsZi4kYWN0aXZlSXRlbXMubGVuZ3RoKSB7XG5cdFx0XHRcdCRsYXN0ID0gc2VsZi4kY29udHJvbC5jaGlsZHJlbignLmFjdGl2ZTpsYXN0Jyk7XG5cdFx0XHRcdGJlZ2luID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuYXBwbHkoc2VsZi4kY29udHJvbFswXS5jaGlsZE5vZGVzLCBbJGxhc3RbMF1dKTtcblx0XHRcdFx0ZW5kICAgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5hcHBseShzZWxmLiRjb250cm9sWzBdLmNoaWxkTm9kZXMsIFskaXRlbVswXV0pO1xuXHRcdFx0XHRpZiAoYmVnaW4gPiBlbmQpIHtcblx0XHRcdFx0XHRzd2FwICA9IGJlZ2luO1xuXHRcdFx0XHRcdGJlZ2luID0gZW5kO1xuXHRcdFx0XHRcdGVuZCAgID0gc3dhcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGkgPSBiZWdpbjsgaSA8PSBlbmQ7IGkrKykge1xuXHRcdFx0XHRcdGl0ZW0gPSBzZWxmLiRjb250cm9sWzBdLmNoaWxkTm9kZXNbaV07XG5cdFx0XHRcdFx0aWYgKHNlbGYuJGFjdGl2ZUl0ZW1zLmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHQkKGl0ZW0pLmFkZENsYXNzKCdhY3RpdmUnKTtcblx0XHRcdFx0XHRcdHNlbGYuJGFjdGl2ZUl0ZW1zLnB1c2goaXRlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH0gZWxzZSBpZiAoKGV2ZW50TmFtZSA9PT0gJ21vdXNlZG93bicgJiYgc2VsZi5pc0N0cmxEb3duKSB8fCAoZXZlbnROYW1lID09PSAna2V5ZG93bicgJiYgdGhpcy5pc1NoaWZ0RG93bikpIHtcblx0XHRcdFx0aWYgKCRpdGVtLmhhc0NsYXNzKCdhY3RpdmUnKSkge1xuXHRcdFx0XHRcdGlkeCA9IHNlbGYuJGFjdGl2ZUl0ZW1zLmluZGV4T2YoJGl0ZW1bMF0pO1xuXHRcdFx0XHRcdHNlbGYuJGFjdGl2ZUl0ZW1zLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHRcdCRpdGVtLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLiRhY3RpdmVJdGVtcy5wdXNoKCRpdGVtLmFkZENsYXNzKCdhY3RpdmUnKVswXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQoc2VsZi4kYWN0aXZlSXRlbXMpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcblx0XHRcdFx0c2VsZi4kYWN0aXZlSXRlbXMgPSBbJGl0ZW0uYWRkQ2xhc3MoJ2FjdGl2ZScpWzBdXTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBlbnN1cmUgY29udHJvbCBoYXMgZm9jdXNcblx0XHRcdHNlbGYuaGlkZUlucHV0KCk7XG5cdFx0XHRpZiAoIXRoaXMuaXNGb2N1c2VkKSB7XG5cdFx0XHRcdHNlbGYuZm9jdXMoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBTZXRzIHRoZSBzZWxlY3RlZCBpdGVtIGluIHRoZSBkcm9wZG93biBtZW51XG5cdFx0ICogb2YgYXZhaWxhYmxlIG9wdGlvbnMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gJG9iamVjdFxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2Nyb2xsXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBhbmltYXRlXG5cdFx0ICovXG5cdFx0c2V0QWN0aXZlT3B0aW9uOiBmdW5jdGlvbigkb3B0aW9uLCBzY3JvbGwsIGFuaW1hdGUpIHtcblx0XHRcdHZhciBoZWlnaHRfbWVudSwgaGVpZ2h0X2l0ZW0sIHk7XG5cdFx0XHR2YXIgc2Nyb2xsX3RvcCwgc2Nyb2xsX2JvdHRvbTtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XG5cdFx0XHRpZiAoc2VsZi4kYWN0aXZlT3B0aW9uKSBzZWxmLiRhY3RpdmVPcHRpb24ucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdFx0c2VsZi4kYWN0aXZlT3B0aW9uID0gbnVsbDtcblx0XG5cdFx0XHQkb3B0aW9uID0gJCgkb3B0aW9uKTtcblx0XHRcdGlmICghJG9wdGlvbi5sZW5ndGgpIHJldHVybjtcblx0XG5cdFx0XHRzZWxmLiRhY3RpdmVPcHRpb24gPSAkb3B0aW9uLmFkZENsYXNzKCdhY3RpdmUnKTtcblx0XG5cdFx0XHRpZiAoc2Nyb2xsIHx8ICFpc3NldChzY3JvbGwpKSB7XG5cdFxuXHRcdFx0XHRoZWlnaHRfbWVudSAgID0gc2VsZi4kZHJvcGRvd25fY29udGVudC5oZWlnaHQoKTtcblx0XHRcdFx0aGVpZ2h0X2l0ZW0gICA9IHNlbGYuJGFjdGl2ZU9wdGlvbi5vdXRlckhlaWdodCh0cnVlKTtcblx0XHRcdFx0c2Nyb2xsICAgICAgICA9IHNlbGYuJGRyb3Bkb3duX2NvbnRlbnQuc2Nyb2xsVG9wKCkgfHwgMDtcblx0XHRcdFx0eSAgICAgICAgICAgICA9IHNlbGYuJGFjdGl2ZU9wdGlvbi5vZmZzZXQoKS50b3AgLSBzZWxmLiRkcm9wZG93bl9jb250ZW50Lm9mZnNldCgpLnRvcCArIHNjcm9sbDtcblx0XHRcdFx0c2Nyb2xsX3RvcCAgICA9IHk7XG5cdFx0XHRcdHNjcm9sbF9ib3R0b20gPSB5IC0gaGVpZ2h0X21lbnUgKyBoZWlnaHRfaXRlbTtcblx0XG5cdFx0XHRcdGlmICh5ICsgaGVpZ2h0X2l0ZW0gPiBoZWlnaHRfbWVudSArIHNjcm9sbCkge1xuXHRcdFx0XHRcdHNlbGYuJGRyb3Bkb3duX2NvbnRlbnQuc3RvcCgpLmFuaW1hdGUoe3Njcm9sbFRvcDogc2Nyb2xsX2JvdHRvbX0sIGFuaW1hdGUgPyBzZWxmLnNldHRpbmdzLnNjcm9sbER1cmF0aW9uIDogMCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoeSA8IHNjcm9sbCkge1xuXHRcdFx0XHRcdHNlbGYuJGRyb3Bkb3duX2NvbnRlbnQuc3RvcCgpLmFuaW1hdGUoe3Njcm9sbFRvcDogc2Nyb2xsX3RvcH0sIGFuaW1hdGUgPyBzZWxmLnNldHRpbmdzLnNjcm9sbER1cmF0aW9uIDogMCk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU2VsZWN0cyBhbGwgaXRlbXMgKENUUkwgKyBBKS5cblx0XHQgKi9cblx0XHRzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0aWYgKHNlbGYuc2V0dGluZ3MubW9kZSA9PT0gJ3NpbmdsZScpIHJldHVybjtcblx0XG5cdFx0XHRzZWxmLiRhY3RpdmVJdGVtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShzZWxmLiRjb250cm9sLmNoaWxkcmVuKCc6bm90KGlucHV0KScpLmFkZENsYXNzKCdhY3RpdmUnKSk7XG5cdFx0XHRpZiAoc2VsZi4kYWN0aXZlSXRlbXMubGVuZ3RoKSB7XG5cdFx0XHRcdHNlbGYuaGlkZUlucHV0KCk7XG5cdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdH1cblx0XHRcdHNlbGYuZm9jdXMoKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBIaWRlcyB0aGUgaW5wdXQgZWxlbWVudCBvdXQgb2Ygdmlldywgd2hpbGVcblx0XHQgKiByZXRhaW5pbmcgaXRzIGZvY3VzLlxuXHRcdCAqL1xuXHRcdGhpZGVJbnB1dDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHRcdFx0c2VsZi5zZXRUZXh0Ym94VmFsdWUoJycpO1xuXHRcdFx0c2VsZi4kY29udHJvbF9pbnB1dC5jc3Moe29wYWNpdHk6IDAsIHBvc2l0aW9uOiAnYWJzb2x1dGUnLCBsZWZ0OiBzZWxmLnJ0bCA/IDEwMDAwIDogLTEwMDAwfSk7XG5cdFx0XHRzZWxmLmlzSW5wdXRIaWRkZW4gPSB0cnVlO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJlc3RvcmVzIGlucHV0IHZpc2liaWxpdHkuXG5cdFx0ICovXG5cdFx0c2hvd0lucHV0OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuJGNvbnRyb2xfaW5wdXQuY3NzKHtvcGFjaXR5OiAxLCBwb3NpdGlvbjogJ3JlbGF0aXZlJywgbGVmdDogMH0pO1xuXHRcdFx0dGhpcy5pc0lucHV0SGlkZGVuID0gZmFsc2U7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogR2l2ZXMgdGhlIGNvbnRyb2wgZm9jdXMuXG5cdFx0ICovXG5cdFx0Zm9jdXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0aWYgKHNlbGYuaXNEaXNhYmxlZCkgcmV0dXJuO1xuXHRcblx0XHRcdHNlbGYuaWdub3JlRm9jdXMgPSB0cnVlO1xuXHRcdFx0c2VsZi4kY29udHJvbF9pbnB1dFswXS5mb2N1cygpO1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuaWdub3JlRm9jdXMgPSBmYWxzZTtcblx0XHRcdFx0c2VsZi5vbkZvY3VzKCk7XG5cdFx0XHR9LCAwKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBGb3JjZXMgdGhlIGNvbnRyb2wgb3V0IG9mIGZvY3VzLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtFbGVtZW50fSBkZXN0XG5cdFx0ICovXG5cdFx0Ymx1cjogZnVuY3Rpb24oZGVzdCkge1xuXHRcdFx0dGhpcy4kY29udHJvbF9pbnB1dFswXS5ibHVyKCk7XG5cdFx0XHR0aGlzLm9uQmx1cihudWxsLCBkZXN0KTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBzY29yZXMgYW4gb2JqZWN0XG5cdFx0ICogdG8gc2hvdyBob3cgZ29vZCBvZiBhIG1hdGNoIGl0IGlzIHRvIHRoZVxuXHRcdCAqIHByb3ZpZGVkIHF1ZXJ5LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5XG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcblx0XHQgKiBAcmV0dXJuIHtmdW5jdGlvbn1cblx0XHQgKi9cblx0XHRnZXRTY29yZUZ1bmN0aW9uOiBmdW5jdGlvbihxdWVyeSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc2lmdGVyLmdldFNjb3JlRnVuY3Rpb24ocXVlcnksIHRoaXMuZ2V0U2VhcmNoT3B0aW9ucygpKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHNlYXJjaCBvcHRpb25zIGZvciBzaWZ0ZXIgKHRoZSBzeXN0ZW1cblx0XHQgKiBmb3Igc2NvcmluZyBhbmQgc29ydGluZyByZXN1bHRzKS5cblx0XHQgKlxuXHRcdCAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2JyaWFucmVhdmlzL3NpZnRlci5qc1xuXHRcdCAqIEByZXR1cm4ge29iamVjdH1cblx0XHQgKi9cblx0XHRnZXRTZWFyY2hPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG5cdFx0XHR2YXIgc29ydCA9IHNldHRpbmdzLnNvcnRGaWVsZDtcblx0XHRcdGlmICh0eXBlb2Ygc29ydCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0c29ydCA9IFt7ZmllbGQ6IHNvcnR9XTtcblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRmaWVsZHMgICAgICA6IHNldHRpbmdzLnNlYXJjaEZpZWxkLFxuXHRcdFx0XHRjb25qdW5jdGlvbiA6IHNldHRpbmdzLnNlYXJjaENvbmp1bmN0aW9uLFxuXHRcdFx0XHRzb3J0ICAgICAgICA6IHNvcnRcblx0XHRcdH07XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogU2VhcmNoZXMgdGhyb3VnaCBhdmFpbGFibGUgb3B0aW9ucyBhbmQgcmV0dXJuc1xuXHRcdCAqIGEgc29ydGVkIGFycmF5IG9mIG1hdGNoZXMuXG5cdFx0ICpcblx0XHQgKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nOlxuXHRcdCAqXG5cdFx0ICogICAtIHF1ZXJ5IHtzdHJpbmd9XG5cdFx0ICogICAtIHRva2VucyB7YXJyYXl9XG5cdFx0ICogICAtIHRvdGFsIHtpbnR9XG5cdFx0ICogICAtIGl0ZW1zIHthcnJheX1cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeVxuXHRcdCAqIEByZXR1cm5zIHtvYmplY3R9XG5cdFx0ICovXG5cdFx0c2VhcmNoOiBmdW5jdGlvbihxdWVyeSkge1xuXHRcdFx0dmFyIGksIHZhbHVlLCBzY29yZSwgcmVzdWx0LCBjYWxjdWxhdGVTY29yZTtcblx0XHRcdHZhciBzZWxmICAgICA9IHRoaXM7XG5cdFx0XHR2YXIgc2V0dGluZ3MgPSBzZWxmLnNldHRpbmdzO1xuXHRcdFx0dmFyIG9wdGlvbnMgID0gdGhpcy5nZXRTZWFyY2hPcHRpb25zKCk7XG5cdFxuXHRcdFx0Ly8gdmFsaWRhdGUgdXNlci1wcm92aWRlZCByZXN1bHQgc2NvcmluZyBmdW5jdGlvblxuXHRcdFx0aWYgKHNldHRpbmdzLnNjb3JlKSB7XG5cdFx0XHRcdGNhbGN1bGF0ZVNjb3JlID0gc2VsZi5zZXR0aW5ncy5zY29yZS5hcHBseSh0aGlzLCBbcXVlcnldKTtcblx0XHRcdFx0aWYgKHR5cGVvZiBjYWxjdWxhdGVTY29yZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignU2VsZWN0aXplIFwic2NvcmVcIiBzZXR0aW5nIG11c3QgYmUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gcGVyZm9ybSBzZWFyY2hcblx0XHRcdGlmIChxdWVyeSAhPT0gc2VsZi5sYXN0UXVlcnkpIHtcblx0XHRcdFx0c2VsZi5sYXN0UXVlcnkgPSBxdWVyeTtcblx0XHRcdFx0cmVzdWx0ID0gc2VsZi5zaWZ0ZXIuc2VhcmNoKHF1ZXJ5LCAkLmV4dGVuZChvcHRpb25zLCB7c2NvcmU6IGNhbGN1bGF0ZVNjb3JlfSkpO1xuXHRcdFx0XHRzZWxmLmN1cnJlbnRSZXN1bHRzID0gcmVzdWx0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0ID0gJC5leHRlbmQodHJ1ZSwge30sIHNlbGYuY3VycmVudFJlc3VsdHMpO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIGZpbHRlciBvdXQgc2VsZWN0ZWQgaXRlbXNcblx0XHRcdGlmIChzZXR0aW5ncy5oaWRlU2VsZWN0ZWQpIHtcblx0XHRcdFx0Zm9yIChpID0gcmVzdWx0Lml0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0aWYgKHNlbGYuaXRlbXMuaW5kZXhPZihoYXNoX2tleShyZXN1bHQuaXRlbXNbaV0uaWQpKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHJlc3VsdC5pdGVtcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBSZWZyZXNoZXMgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIG9wdGlvbnMgc2hvd25cblx0XHQgKiBpbiB0aGUgYXV0b2NvbXBsZXRlIGRyb3Bkb3duIG1lbnUuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IHRyaWdnZXJEcm9wZG93blxuXHRcdCAqL1xuXHRcdHJlZnJlc2hPcHRpb25zOiBmdW5jdGlvbih0cmlnZ2VyRHJvcGRvd24pIHtcblx0XHRcdHZhciBpLCBqLCBrLCBuLCBncm91cHMsIGdyb3Vwc19vcmRlciwgb3B0aW9uLCBvcHRpb25faHRtbCwgb3B0Z3JvdXAsIG9wdGdyb3VwcywgaHRtbCwgaHRtbF9jaGlsZHJlbiwgaGFzX2NyZWF0ZV9vcHRpb247XG5cdFx0XHR2YXIgJGFjdGl2ZSwgJGFjdGl2ZV9iZWZvcmUsICRjcmVhdGU7XG5cdFxuXHRcdFx0aWYgKHR5cGVvZiB0cmlnZ2VyRHJvcGRvd24gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHRyaWdnZXJEcm9wZG93biA9IHRydWU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0dmFyIHNlbGYgICAgICAgICAgICAgID0gdGhpcztcblx0XHRcdHZhciBxdWVyeSAgICAgICAgICAgICA9ICQudHJpbShzZWxmLiRjb250cm9sX2lucHV0LnZhbCgpKTtcblx0XHRcdHZhciByZXN1bHRzICAgICAgICAgICA9IHNlbGYuc2VhcmNoKHF1ZXJ5KTtcblx0XHRcdHZhciAkZHJvcGRvd25fY29udGVudCA9IHNlbGYuJGRyb3Bkb3duX2NvbnRlbnQ7XG5cdFx0XHR2YXIgYWN0aXZlX2JlZm9yZSAgICAgPSBzZWxmLiRhY3RpdmVPcHRpb24gJiYgaGFzaF9rZXkoc2VsZi4kYWN0aXZlT3B0aW9uLmF0dHIoJ2RhdGEtdmFsdWUnKSk7XG5cdFxuXHRcdFx0Ly8gYnVpbGQgbWFya3VwXG5cdFx0XHRuID0gcmVzdWx0cy5pdGVtcy5sZW5ndGg7XG5cdFx0XHRpZiAodHlwZW9mIHNlbGYuc2V0dGluZ3MubWF4T3B0aW9ucyA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0biA9IE1hdGgubWluKG4sIHNlbGYuc2V0dGluZ3MubWF4T3B0aW9ucyk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gcmVuZGVyIGFuZCBncm91cCBhdmFpbGFibGUgb3B0aW9ucyBpbmRpdmlkdWFsbHlcblx0XHRcdGdyb3VwcyA9IHt9O1xuXHRcdFx0Z3JvdXBzX29yZGVyID0gW107XG5cdFxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRvcHRpb24gICAgICA9IHNlbGYub3B0aW9uc1tyZXN1bHRzLml0ZW1zW2ldLmlkXTtcblx0XHRcdFx0b3B0aW9uX2h0bWwgPSBzZWxmLnJlbmRlcignb3B0aW9uJywgb3B0aW9uKTtcblx0XHRcdFx0b3B0Z3JvdXAgICAgPSBvcHRpb25bc2VsZi5zZXR0aW5ncy5vcHRncm91cEZpZWxkXSB8fCAnJztcblx0XHRcdFx0b3B0Z3JvdXBzICAgPSAkLmlzQXJyYXkob3B0Z3JvdXApID8gb3B0Z3JvdXAgOiBbb3B0Z3JvdXBdO1xuXHRcblx0XHRcdFx0Zm9yIChqID0gMCwgayA9IG9wdGdyb3VwcyAmJiBvcHRncm91cHMubGVuZ3RoOyBqIDwgazsgaisrKSB7XG5cdFx0XHRcdFx0b3B0Z3JvdXAgPSBvcHRncm91cHNbal07XG5cdFx0XHRcdFx0aWYgKCFzZWxmLm9wdGdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShvcHRncm91cCkpIHtcblx0XHRcdFx0XHRcdG9wdGdyb3VwID0gJyc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghZ3JvdXBzLmhhc093blByb3BlcnR5KG9wdGdyb3VwKSkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzW29wdGdyb3VwXSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0XHRcdGdyb3Vwc19vcmRlci5wdXNoKG9wdGdyb3VwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Z3JvdXBzW29wdGdyb3VwXS5hcHBlbmRDaGlsZChvcHRpb25faHRtbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBzb3J0IG9wdGdyb3Vwc1xuXHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MubG9ja09wdGdyb3VwT3JkZXIpIHtcblx0XHRcdFx0Z3JvdXBzX29yZGVyLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRcdHZhciBhX29yZGVyID0gc2VsZi5vcHRncm91cHNbYV0uJG9yZGVyIHx8IDA7XG5cdFx0XHRcdFx0dmFyIGJfb3JkZXIgPSBzZWxmLm9wdGdyb3Vwc1tiXS4kb3JkZXIgfHwgMDtcblx0XHRcdFx0XHRyZXR1cm4gYV9vcmRlciAtIGJfb3JkZXI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIHJlbmRlciBvcHRncm91cCBoZWFkZXJzICYgam9pbiBncm91cHNcblx0XHRcdGh0bWwgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRmb3IgKGkgPSAwLCBuID0gZ3JvdXBzX29yZGVyLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRvcHRncm91cCA9IGdyb3Vwc19vcmRlcltpXTtcblx0XHRcdFx0aWYgKHNlbGYub3B0Z3JvdXBzLmhhc093blByb3BlcnR5KG9wdGdyb3VwKSAmJiBncm91cHNbb3B0Z3JvdXBdLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Ly8gcmVuZGVyIHRoZSBvcHRncm91cCBoZWFkZXIgYW5kIG9wdGlvbnMgd2l0aGluIGl0LFxuXHRcdFx0XHRcdC8vIHRoZW4gcGFzcyBpdCB0byB0aGUgd3JhcHBlciB0ZW1wbGF0ZVxuXHRcdFx0XHRcdGh0bWxfY2hpbGRyZW4gPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRcdFx0aHRtbF9jaGlsZHJlbi5hcHBlbmRDaGlsZChzZWxmLnJlbmRlcignb3B0Z3JvdXBfaGVhZGVyJywgc2VsZi5vcHRncm91cHNbb3B0Z3JvdXBdKSk7XG5cdFx0XHRcdFx0aHRtbF9jaGlsZHJlbi5hcHBlbmRDaGlsZChncm91cHNbb3B0Z3JvdXBdKTtcblx0XG5cdFx0XHRcdFx0aHRtbC5hcHBlbmRDaGlsZChzZWxmLnJlbmRlcignb3B0Z3JvdXAnLCAkLmV4dGVuZCh7fSwgc2VsZi5vcHRncm91cHNbb3B0Z3JvdXBdLCB7XG5cdFx0XHRcdFx0XHRodG1sOiBkb21Ub1N0cmluZyhodG1sX2NoaWxkcmVuKSxcblx0XHRcdFx0XHRcdGRvbTogIGh0bWxfY2hpbGRyZW5cblx0XHRcdFx0XHR9KSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGh0bWwuYXBwZW5kQ2hpbGQoZ3JvdXBzW29wdGdyb3VwXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQkZHJvcGRvd25fY29udGVudC5odG1sKGh0bWwpO1xuXHRcblx0XHRcdC8vIGhpZ2hsaWdodCBtYXRjaGluZyB0ZXJtcyBpbmxpbmVcblx0XHRcdGlmIChzZWxmLnNldHRpbmdzLmhpZ2hsaWdodCAmJiByZXN1bHRzLnF1ZXJ5Lmxlbmd0aCAmJiByZXN1bHRzLnRva2Vucy5sZW5ndGgpIHtcblx0XHRcdFx0JGRyb3Bkb3duX2NvbnRlbnQucmVtb3ZlSGlnaGxpZ2h0KCk7XG5cdFx0XHRcdGZvciAoaSA9IDAsIG4gPSByZXN1bHRzLnRva2Vucy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0XHRoaWdobGlnaHQoJGRyb3Bkb3duX2NvbnRlbnQsIHJlc3VsdHMudG9rZW5zW2ldLnJlZ2V4KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdC8vIGFkZCBcInNlbGVjdGVkXCIgY2xhc3MgdG8gc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0aWYgKCFzZWxmLnNldHRpbmdzLmhpZGVTZWxlY3RlZCkge1xuXHRcdFx0XHRmb3IgKGkgPSAwLCBuID0gc2VsZi5pdGVtcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0XHRzZWxmLmdldE9wdGlvbihzZWxmLml0ZW1zW2ldKS5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdC8vIGFkZCBjcmVhdGUgb3B0aW9uXG5cdFx0XHRoYXNfY3JlYXRlX29wdGlvbiA9IHNlbGYuY2FuQ3JlYXRlKHF1ZXJ5KTtcblx0XHRcdGlmIChoYXNfY3JlYXRlX29wdGlvbikge1xuXHRcdFx0XHQkZHJvcGRvd25fY29udGVudC5wcmVwZW5kKHNlbGYucmVuZGVyKCdvcHRpb25fY3JlYXRlJywge2lucHV0OiBxdWVyeX0pKTtcblx0XHRcdFx0JGNyZWF0ZSA9ICQoJGRyb3Bkb3duX2NvbnRlbnRbMF0uY2hpbGROb2Rlc1swXSk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gYWN0aXZhdGVcblx0XHRcdHNlbGYuaGFzT3B0aW9ucyA9IHJlc3VsdHMuaXRlbXMubGVuZ3RoID4gMCB8fCBoYXNfY3JlYXRlX29wdGlvbjtcblx0XHRcdGlmIChzZWxmLmhhc09wdGlvbnMpIHtcblx0XHRcdFx0aWYgKHJlc3VsdHMuaXRlbXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdCRhY3RpdmVfYmVmb3JlID0gYWN0aXZlX2JlZm9yZSAmJiBzZWxmLmdldE9wdGlvbihhY3RpdmVfYmVmb3JlKTtcblx0XHRcdFx0XHRpZiAoJGFjdGl2ZV9iZWZvcmUgJiYgJGFjdGl2ZV9iZWZvcmUubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQkYWN0aXZlID0gJGFjdGl2ZV9iZWZvcmU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnICYmIHNlbGYuaXRlbXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQkYWN0aXZlID0gc2VsZi5nZXRPcHRpb24oc2VsZi5pdGVtc1swXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghJGFjdGl2ZSB8fCAhJGFjdGl2ZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmICgkY3JlYXRlICYmICFzZWxmLnNldHRpbmdzLmFkZFByZWNlZGVuY2UpIHtcblx0XHRcdFx0XHRcdFx0JGFjdGl2ZSA9IHNlbGYuZ2V0QWRqYWNlbnRPcHRpb24oJGNyZWF0ZSwgMSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQkYWN0aXZlID0gJGRyb3Bkb3duX2NvbnRlbnQuZmluZCgnW2RhdGEtc2VsZWN0YWJsZV06Zmlyc3QnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JGFjdGl2ZSA9ICRjcmVhdGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5zZXRBY3RpdmVPcHRpb24oJGFjdGl2ZSk7XG5cdFx0XHRcdGlmICh0cmlnZ2VyRHJvcGRvd24gJiYgIXNlbGYuaXNPcGVuKSB7IHNlbGYub3BlbigpOyB9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLnNldEFjdGl2ZU9wdGlvbihudWxsKTtcblx0XHRcdFx0aWYgKHRyaWdnZXJEcm9wZG93biAmJiBzZWxmLmlzT3BlbikgeyBzZWxmLmNsb3NlKCk7IH1cblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBBZGRzIGFuIGF2YWlsYWJsZSBvcHRpb24uIElmIGl0IGFscmVhZHkgZXhpc3RzLFxuXHRcdCAqIG5vdGhpbmcgd2lsbCBoYXBwZW4uIE5vdGU6IHRoaXMgZG9lcyBub3QgcmVmcmVzaFxuXHRcdCAqIHRoZSBvcHRpb25zIGxpc3QgZHJvcGRvd24gKHVzZSBgcmVmcmVzaE9wdGlvbnNgXG5cdFx0ICogZm9yIHRoYXQpLlxuXHRcdCAqXG5cdFx0ICogVXNhZ2U6XG5cdFx0ICpcblx0XHQgKiAgIHRoaXMuYWRkT3B0aW9uKGRhdGEpXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdHxhcnJheX0gZGF0YVxuXHRcdCAqL1xuXHRcdGFkZE9wdGlvbjogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0dmFyIGksIG4sIHZhbHVlLCBzZWxmID0gdGhpcztcblx0XG5cdFx0XHRpZiAoJC5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAoaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRcdHNlbGYuYWRkT3B0aW9uKGRhdGFbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAodmFsdWUgPSBzZWxmLnJlZ2lzdGVyT3B0aW9uKGRhdGEpKSB7XG5cdFx0XHRcdHNlbGYudXNlck9wdGlvbnNbdmFsdWVdID0gdHJ1ZTtcblx0XHRcdFx0c2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuXHRcdFx0XHRzZWxmLnRyaWdnZXIoJ29wdGlvbl9hZGQnLCB2YWx1ZSwgZGF0YSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXJzIGFuIG9wdGlvbiB0byB0aGUgcG9vbCBvZiBvcHRpb25zLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGFcblx0XHQgKiBAcmV0dXJuIHtib29sZWFufHN0cmluZ31cblx0XHQgKi9cblx0XHRyZWdpc3Rlck9wdGlvbjogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0dmFyIGtleSA9IGhhc2hfa2V5KGRhdGFbdGhpcy5zZXR0aW5ncy52YWx1ZUZpZWxkXSk7XG5cdFx0XHRpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcgfHwga2V5ID09PSBudWxsIHx8IHRoaXMub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRkYXRhLiRvcmRlciA9IGRhdGEuJG9yZGVyIHx8ICsrdGhpcy5vcmRlcjtcblx0XHRcdHRoaXMub3B0aW9uc1trZXldID0gZGF0YTtcblx0XHRcdHJldHVybiBrZXk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXJzIGFuIG9wdGlvbiBncm91cCB0byB0aGUgcG9vbCBvZiBvcHRpb24gZ3JvdXBzLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGFcblx0XHQgKiBAcmV0dXJuIHtib29sZWFufHN0cmluZ31cblx0XHQgKi9cblx0XHRyZWdpc3Rlck9wdGlvbkdyb3VwOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHR2YXIga2V5ID0gaGFzaF9rZXkoZGF0YVt0aGlzLnNldHRpbmdzLm9wdGdyb3VwVmFsdWVGaWVsZF0pO1xuXHRcdFx0aWYgKCFrZXkpIHJldHVybiBmYWxzZTtcblx0XG5cdFx0XHRkYXRhLiRvcmRlciA9IGRhdGEuJG9yZGVyIHx8ICsrdGhpcy5vcmRlcjtcblx0XHRcdHRoaXMub3B0Z3JvdXBzW2tleV0gPSBkYXRhO1xuXHRcdFx0cmV0dXJuIGtleTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBSZWdpc3RlcnMgYSBuZXcgb3B0Z3JvdXAgZm9yIG9wdGlvbnNcblx0XHQgKiB0byBiZSBidWNrZXRlZCBpbnRvLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGFcblx0XHQgKi9cblx0XHRhZGRPcHRpb25Hcm91cDogZnVuY3Rpb24oaWQsIGRhdGEpIHtcblx0XHRcdGRhdGFbdGhpcy5zZXR0aW5ncy5vcHRncm91cFZhbHVlRmllbGRdID0gaWQ7XG5cdFx0XHRpZiAoaWQgPSB0aGlzLnJlZ2lzdGVyT3B0aW9uR3JvdXAoZGF0YSkpIHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdvcHRncm91cF9hZGQnLCBpZCwgZGF0YSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyBhbiBleGlzdGluZyBvcHRpb24gZ3JvdXAuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0XHQgKi9cblx0XHRyZW1vdmVPcHRpb25Hcm91cDogZnVuY3Rpb24oaWQpIHtcblx0XHRcdGlmICh0aGlzLm9wdGdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXMub3B0Z3JvdXBzW2lkXTtcblx0XHRcdFx0dGhpcy5yZW5kZXJDYWNoZSA9IHt9O1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ29wdGdyb3VwX3JlbW92ZScsIGlkKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBDbGVhcnMgYWxsIGV4aXN0aW5nIG9wdGlvbiBncm91cHMuXG5cdFx0ICovXG5cdFx0Y2xlYXJPcHRpb25Hcm91cHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5vcHRncm91cHMgPSB7fTtcblx0XHRcdHRoaXMucmVuZGVyQ2FjaGUgPSB7fTtcblx0XHRcdHRoaXMudHJpZ2dlcignb3B0Z3JvdXBfY2xlYXInKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIGFuIG9wdGlvbiBhdmFpbGFibGUgZm9yIHNlbGVjdGlvbi4gSWZcblx0XHQgKiBpdCBpcyB2aXNpYmxlIGluIHRoZSBzZWxlY3RlZCBpdGVtcyBvciBvcHRpb25zXG5cdFx0ICogZHJvcGRvd24sIGl0IHdpbGwgYmUgcmUtcmVuZGVyZWQgYXV0b21hdGljYWxseS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG5cdFx0ICovXG5cdFx0dXBkYXRlT3B0aW9uOiBmdW5jdGlvbih2YWx1ZSwgZGF0YSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyICRpdGVtLCAkaXRlbV9uZXc7XG5cdFx0XHR2YXIgdmFsdWVfbmV3LCBpbmRleF9pdGVtLCBjYWNoZV9pdGVtcywgY2FjaGVfb3B0aW9ucywgb3JkZXJfb2xkO1xuXHRcblx0XHRcdHZhbHVlICAgICA9IGhhc2hfa2V5KHZhbHVlKTtcblx0XHRcdHZhbHVlX25ldyA9IGhhc2hfa2V5KGRhdGFbc2VsZi5zZXR0aW5ncy52YWx1ZUZpZWxkXSk7XG5cdFxuXHRcdFx0Ly8gc2FuaXR5IGNoZWNrc1xuXHRcdFx0aWYgKHZhbHVlID09PSBudWxsKSByZXR1cm47XG5cdFx0XHRpZiAoIXNlbGYub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIHJldHVybjtcblx0XHRcdGlmICh0eXBlb2YgdmFsdWVfbmV3ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBtdXN0IGJlIHNldCBpbiBvcHRpb24gZGF0YScpO1xuXHRcblx0XHRcdG9yZGVyX29sZCA9IHNlbGYub3B0aW9uc1t2YWx1ZV0uJG9yZGVyO1xuXHRcblx0XHRcdC8vIHVwZGF0ZSByZWZlcmVuY2VzXG5cdFx0XHRpZiAodmFsdWVfbmV3ICE9PSB2YWx1ZSkge1xuXHRcdFx0XHRkZWxldGUgc2VsZi5vcHRpb25zW3ZhbHVlXTtcblx0XHRcdFx0aW5kZXhfaXRlbSA9IHNlbGYuaXRlbXMuaW5kZXhPZih2YWx1ZSk7XG5cdFx0XHRcdGlmIChpbmRleF9pdGVtICE9PSAtMSkge1xuXHRcdFx0XHRcdHNlbGYuaXRlbXMuc3BsaWNlKGluZGV4X2l0ZW0sIDEsIHZhbHVlX25ldyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGRhdGEuJG9yZGVyID0gZGF0YS4kb3JkZXIgfHwgb3JkZXJfb2xkO1xuXHRcdFx0c2VsZi5vcHRpb25zW3ZhbHVlX25ld10gPSBkYXRhO1xuXHRcblx0XHRcdC8vIGludmFsaWRhdGUgcmVuZGVyIGNhY2hlXG5cdFx0XHRjYWNoZV9pdGVtcyA9IHNlbGYucmVuZGVyQ2FjaGVbJ2l0ZW0nXTtcblx0XHRcdGNhY2hlX29wdGlvbnMgPSBzZWxmLnJlbmRlckNhY2hlWydvcHRpb24nXTtcblx0XG5cdFx0XHRpZiAoY2FjaGVfaXRlbXMpIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlX2l0ZW1zW3ZhbHVlXTtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlX2l0ZW1zW3ZhbHVlX25ld107XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2FjaGVfb3B0aW9ucykge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVfb3B0aW9uc1t2YWx1ZV07XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZV9vcHRpb25zW3ZhbHVlX25ld107XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gdXBkYXRlIHRoZSBpdGVtIGlmIGl0J3Mgc2VsZWN0ZWRcblx0XHRcdGlmIChzZWxmLml0ZW1zLmluZGV4T2YodmFsdWVfbmV3KSAhPT0gLTEpIHtcblx0XHRcdFx0JGl0ZW0gPSBzZWxmLmdldEl0ZW0odmFsdWUpO1xuXHRcdFx0XHQkaXRlbV9uZXcgPSAkKHNlbGYucmVuZGVyKCdpdGVtJywgZGF0YSkpO1xuXHRcdFx0XHRpZiAoJGl0ZW0uaGFzQ2xhc3MoJ2FjdGl2ZScpKSAkaXRlbV9uZXcuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdFx0XHQkaXRlbS5yZXBsYWNlV2l0aCgkaXRlbV9uZXcpO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIGludmFsaWRhdGUgbGFzdCBxdWVyeSBiZWNhdXNlIHdlIG1pZ2h0IGhhdmUgdXBkYXRlZCB0aGUgc29ydEZpZWxkXG5cdFx0XHRzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG5cdFxuXHRcdFx0Ly8gdXBkYXRlIGRyb3Bkb3duIGNvbnRlbnRzXG5cdFx0XHRpZiAoc2VsZi5pc09wZW4pIHtcblx0XHRcdFx0c2VsZi5yZWZyZXNoT3B0aW9ucyhmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyBhIHNpbmdsZSBvcHRpb24uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudFxuXHRcdCAqL1xuXHRcdHJlbW92ZU9wdGlvbjogZnVuY3Rpb24odmFsdWUsIHNpbGVudCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFsdWUgPSBoYXNoX2tleSh2YWx1ZSk7XG5cdFxuXHRcdFx0dmFyIGNhY2hlX2l0ZW1zID0gc2VsZi5yZW5kZXJDYWNoZVsnaXRlbSddO1xuXHRcdFx0dmFyIGNhY2hlX29wdGlvbnMgPSBzZWxmLnJlbmRlckNhY2hlWydvcHRpb24nXTtcblx0XHRcdGlmIChjYWNoZV9pdGVtcykgZGVsZXRlIGNhY2hlX2l0ZW1zW3ZhbHVlXTtcblx0XHRcdGlmIChjYWNoZV9vcHRpb25zKSBkZWxldGUgY2FjaGVfb3B0aW9uc1t2YWx1ZV07XG5cdFxuXHRcdFx0ZGVsZXRlIHNlbGYudXNlck9wdGlvbnNbdmFsdWVdO1xuXHRcdFx0ZGVsZXRlIHNlbGYub3B0aW9uc1t2YWx1ZV07XG5cdFx0XHRzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG5cdFx0XHRzZWxmLnRyaWdnZXIoJ29wdGlvbl9yZW1vdmUnLCB2YWx1ZSk7XG5cdFx0XHRzZWxmLnJlbW92ZUl0ZW0odmFsdWUsIHNpbGVudCk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQ2xlYXJzIGFsbCBvcHRpb25zLlxuXHRcdCAqL1xuXHRcdGNsZWFyT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHRcdFx0c2VsZi5sb2FkZWRTZWFyY2hlcyA9IHt9O1xuXHRcdFx0c2VsZi51c2VyT3B0aW9ucyA9IHt9O1xuXHRcdFx0c2VsZi5yZW5kZXJDYWNoZSA9IHt9O1xuXHRcdFx0c2VsZi5vcHRpb25zID0gc2VsZi5zaWZ0ZXIuaXRlbXMgPSB7fTtcblx0XHRcdHNlbGYubGFzdFF1ZXJ5ID0gbnVsbDtcblx0XHRcdHNlbGYudHJpZ2dlcignb3B0aW9uX2NsZWFyJyk7XG5cdFx0XHRzZWxmLmNsZWFyKCk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgalF1ZXJ5IGVsZW1lbnQgb2YgdGhlIG9wdGlvblxuXHRcdCAqIG1hdGNoaW5nIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHRcdCAqIEByZXR1cm5zIHtvYmplY3R9XG5cdFx0ICovXG5cdFx0Z2V0T3B0aW9uOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0RWxlbWVudFdpdGhWYWx1ZSh2YWx1ZSwgdGhpcy4kZHJvcGRvd25fY29udGVudC5maW5kKCdbZGF0YS1zZWxlY3RhYmxlXScpKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBqUXVlcnkgZWxlbWVudCBvZiB0aGUgbmV4dCBvclxuXHRcdCAqIHByZXZpb3VzIHNlbGVjdGFibGUgb3B0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9ICRvcHRpb25cblx0XHQgKiBAcGFyYW0ge2ludH0gZGlyZWN0aW9uICBjYW4gYmUgMSBmb3IgbmV4dCBvciAtMSBmb3IgcHJldmlvdXNcblx0XHQgKiBAcmV0dXJuIHtvYmplY3R9XG5cdFx0ICovXG5cdFx0Z2V0QWRqYWNlbnRPcHRpb246IGZ1bmN0aW9uKCRvcHRpb24sIGRpcmVjdGlvbikge1xuXHRcdFx0dmFyICRvcHRpb25zID0gdGhpcy4kZHJvcGRvd24uZmluZCgnW2RhdGEtc2VsZWN0YWJsZV0nKTtcblx0XHRcdHZhciBpbmRleCAgICA9ICRvcHRpb25zLmluZGV4KCRvcHRpb24pICsgZGlyZWN0aW9uO1xuXHRcblx0XHRcdHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgJG9wdGlvbnMubGVuZ3RoID8gJG9wdGlvbnMuZXEoaW5kZXgpIDogJCgpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZpbmRzIHRoZSBmaXJzdCBlbGVtZW50IHdpdGggYSBcImRhdGEtdmFsdWVcIiBhdHRyaWJ1dGVcblx0XHQgKiB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gdmFsdWVcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gJGVsc1xuXHRcdCAqIEByZXR1cm4ge29iamVjdH1cblx0XHQgKi9cblx0XHRnZXRFbGVtZW50V2l0aFZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgJGVscykge1xuXHRcdFx0dmFsdWUgPSBoYXNoX2tleSh2YWx1ZSk7XG5cdFxuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgIT09IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSAkZWxzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRcdGlmICgkZWxzW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpID09PSB2YWx1ZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuICQoJGVsc1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuICQoKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBqUXVlcnkgZWxlbWVudCBvZiB0aGUgaXRlbVxuXHRcdCAqIG1hdGNoaW5nIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHRcdCAqIEByZXR1cm5zIHtvYmplY3R9XG5cdFx0ICovXG5cdFx0Z2V0SXRlbTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldEVsZW1lbnRXaXRoVmFsdWUodmFsdWUsIHRoaXMuJGNvbnRyb2wuY2hpbGRyZW4oKSk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogXCJTZWxlY3RzXCIgbXVsdGlwbGUgaXRlbXMgYXQgb25jZS4gQWRkcyB0aGVtIHRvIHRoZSBsaXN0XG5cdFx0ICogYXQgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudFxuXHRcdCAqL1xuXHRcdGFkZEl0ZW1zOiBmdW5jdGlvbih2YWx1ZXMsIHNpbGVudCkge1xuXHRcdFx0dmFyIGl0ZW1zID0gJC5pc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMgOiBbdmFsdWVzXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuaXNQZW5kaW5nID0gKGkgPCBuIC0gMSk7XG5cdFx0XHRcdHRoaXMuYWRkSXRlbShpdGVtc1tpXSwgc2lsZW50KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBcIlNlbGVjdHNcIiBhbiBpdGVtLiBBZGRzIGl0IHRvIHRoZSBsaXN0XG5cdFx0ICogYXQgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudFxuXHRcdCAqL1xuXHRcdGFkZEl0ZW06IGZ1bmN0aW9uKHZhbHVlLCBzaWxlbnQpIHtcblx0XHRcdHZhciBldmVudHMgPSBzaWxlbnQgPyBbXSA6IFsnY2hhbmdlJ107XG5cdFxuXHRcdFx0ZGVib3VuY2VfZXZlbnRzKHRoaXMsIGV2ZW50cywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciAkaXRlbSwgJG9wdGlvbiwgJG9wdGlvbnM7XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdFx0dmFyIGlucHV0TW9kZSA9IHNlbGYuc2V0dGluZ3MubW9kZTtcblx0XHRcdFx0dmFyIGksIGFjdGl2ZSwgdmFsdWVfbmV4dCwgd2FzRnVsbDtcblx0XHRcdFx0dmFsdWUgPSBoYXNoX2tleSh2YWx1ZSk7XG5cdFxuXHRcdFx0XHRpZiAoc2VsZi5pdGVtcy5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRpZiAoaW5wdXRNb2RlID09PSAnc2luZ2xlJykgc2VsZi5jbG9zZSgpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0aWYgKCFzZWxmLm9wdGlvbnMuaGFzT3duUHJvcGVydHkodmFsdWUpKSByZXR1cm47XG5cdFx0XHRcdGlmIChpbnB1dE1vZGUgPT09ICdzaW5nbGUnKSBzZWxmLmNsZWFyKHNpbGVudCk7XG5cdFx0XHRcdGlmIChpbnB1dE1vZGUgPT09ICdtdWx0aScgJiYgc2VsZi5pc0Z1bGwoKSkgcmV0dXJuO1xuXHRcblx0XHRcdFx0JGl0ZW0gPSAkKHNlbGYucmVuZGVyKCdpdGVtJywgc2VsZi5vcHRpb25zW3ZhbHVlXSkpO1xuXHRcdFx0XHR3YXNGdWxsID0gc2VsZi5pc0Z1bGwoKTtcblx0XHRcdFx0c2VsZi5pdGVtcy5zcGxpY2Uoc2VsZi5jYXJldFBvcywgMCwgdmFsdWUpO1xuXHRcdFx0XHRzZWxmLmluc2VydEF0Q2FyZXQoJGl0ZW0pO1xuXHRcdFx0XHRpZiAoIXNlbGYuaXNQZW5kaW5nIHx8ICghd2FzRnVsbCAmJiBzZWxmLmlzRnVsbCgpKSkge1xuXHRcdFx0XHRcdHNlbGYucmVmcmVzaFN0YXRlKCk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGlmIChzZWxmLmlzU2V0dXApIHtcblx0XHRcdFx0XHQkb3B0aW9ucyA9IHNlbGYuJGRyb3Bkb3duX2NvbnRlbnQuZmluZCgnW2RhdGEtc2VsZWN0YWJsZV0nKTtcblx0XG5cdFx0XHRcdFx0Ly8gdXBkYXRlIG1lbnUgLyByZW1vdmUgdGhlIG9wdGlvbiAoaWYgdGhpcyBpcyBub3Qgb25lIGl0ZW0gYmVpbmcgYWRkZWQgYXMgcGFydCBvZiBzZXJpZXMpXG5cdFx0XHRcdFx0aWYgKCFzZWxmLmlzUGVuZGluZykge1xuXHRcdFx0XHRcdFx0JG9wdGlvbiA9IHNlbGYuZ2V0T3B0aW9uKHZhbHVlKTtcblx0XHRcdFx0XHRcdHZhbHVlX25leHQgPSBzZWxmLmdldEFkamFjZW50T3B0aW9uKCRvcHRpb24sIDEpLmF0dHIoJ2RhdGEtdmFsdWUnKTtcblx0XHRcdFx0XHRcdHNlbGYucmVmcmVzaE9wdGlvbnMoc2VsZi5pc0ZvY3VzZWQgJiYgaW5wdXRNb2RlICE9PSAnc2luZ2xlJyk7XG5cdFx0XHRcdFx0XHRpZiAodmFsdWVfbmV4dCkge1xuXHRcdFx0XHRcdFx0XHRzZWxmLnNldEFjdGl2ZU9wdGlvbihzZWxmLmdldE9wdGlvbih2YWx1ZV9uZXh0KSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBoaWRlIHRoZSBtZW51IGlmIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyBoYXZlIGJlZW4gc2VsZWN0ZWQgb3Igbm8gb3B0aW9ucyBhcmUgbGVmdFxuXHRcdFx0XHRcdGlmICghJG9wdGlvbnMubGVuZ3RoIHx8IHNlbGYuaXNGdWxsKCkpIHtcblx0XHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRzZWxmLnVwZGF0ZVBsYWNlaG9sZGVyKCk7XG5cdFx0XHRcdFx0c2VsZi50cmlnZ2VyKCdpdGVtX2FkZCcsIHZhbHVlLCAkaXRlbSk7XG5cdFx0XHRcdFx0c2VsZi51cGRhdGVPcmlnaW5hbElucHV0KHtzaWxlbnQ6IHNpbGVudH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIHRoZSBzZWxlY3RlZCBpdGVtIG1hdGNoaW5nXG5cdFx0ICogdGhlIHByb3ZpZGVkIHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG5cdFx0ICovXG5cdFx0cmVtb3ZlSXRlbTogZnVuY3Rpb24odmFsdWUsIHNpbGVudCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyICRpdGVtLCBpLCBpZHg7XG5cdFxuXHRcdFx0JGl0ZW0gPSAodmFsdWUgaW5zdGFuY2VvZiAkKSA/IHZhbHVlIDogc2VsZi5nZXRJdGVtKHZhbHVlKTtcblx0XHRcdHZhbHVlID0gaGFzaF9rZXkoJGl0ZW0uYXR0cignZGF0YS12YWx1ZScpKTtcblx0XHRcdGkgPSBzZWxmLml0ZW1zLmluZGV4T2YodmFsdWUpO1xuXHRcblx0XHRcdGlmIChpICE9PSAtMSkge1xuXHRcdFx0XHQkaXRlbS5yZW1vdmUoKTtcblx0XHRcdFx0aWYgKCRpdGVtLmhhc0NsYXNzKCdhY3RpdmUnKSkge1xuXHRcdFx0XHRcdGlkeCA9IHNlbGYuJGFjdGl2ZUl0ZW1zLmluZGV4T2YoJGl0ZW1bMF0pO1xuXHRcdFx0XHRcdHNlbGYuJGFjdGl2ZUl0ZW1zLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRzZWxmLml0ZW1zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0c2VsZi5sYXN0UXVlcnkgPSBudWxsO1xuXHRcdFx0XHRpZiAoIXNlbGYuc2V0dGluZ3MucGVyc2lzdCAmJiBzZWxmLnVzZXJPcHRpb25zLmhhc093blByb3BlcnR5KHZhbHVlKSkge1xuXHRcdFx0XHRcdHNlbGYucmVtb3ZlT3B0aW9uKHZhbHVlLCBzaWxlbnQpO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRpZiAoaSA8IHNlbGYuY2FyZXRQb3MpIHtcblx0XHRcdFx0XHRzZWxmLnNldENhcmV0KHNlbGYuY2FyZXRQb3MgLSAxKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0c2VsZi5yZWZyZXNoU3RhdGUoKTtcblx0XHRcdFx0c2VsZi51cGRhdGVQbGFjZWhvbGRlcigpO1xuXHRcdFx0XHRzZWxmLnVwZGF0ZU9yaWdpbmFsSW5wdXQoe3NpbGVudDogc2lsZW50fSk7XG5cdFx0XHRcdHNlbGYucG9zaXRpb25Ecm9wZG93bigpO1xuXHRcdFx0XHRzZWxmLnRyaWdnZXIoJ2l0ZW1fcmVtb3ZlJywgdmFsdWUsICRpdGVtKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBJbnZva2VzIHRoZSBgY3JlYXRlYCBtZXRob2QgcHJvdmlkZWQgaW4gdGhlXG5cdFx0ICogc2VsZWN0aXplIG9wdGlvbnMgdGhhdCBzaG91bGQgcHJvdmlkZSB0aGUgZGF0YVxuXHRcdCAqIGZvciB0aGUgbmV3IGl0ZW0sIGdpdmVuIHRoZSB1c2VyIGlucHV0LlxuXHRcdCAqXG5cdFx0ICogT25jZSB0aGlzIGNvbXBsZXRlcywgaXQgd2lsbCBiZSBhZGRlZFxuXHRcdCAqIHRvIHRoZSBpdGVtIGxpc3QuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt0cmlnZ2VyRHJvcGRvd25dXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXVxuXHRcdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0Y3JlYXRlSXRlbTogZnVuY3Rpb24oaW5wdXQsIHRyaWdnZXJEcm9wZG93bikge1xuXHRcdFx0dmFyIHNlbGYgID0gdGhpcztcblx0XHRcdHZhciBjYXJldCA9IHNlbGYuY2FyZXRQb3M7XG5cdFx0XHRpbnB1dCA9IGlucHV0IHx8ICQudHJpbShzZWxmLiRjb250cm9sX2lucHV0LnZhbCgpIHx8ICcnKTtcblx0XG5cdFx0XHR2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuXHRcdFx0aWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHt9O1xuXHRcblx0XHRcdGlmICh0eXBlb2YgdHJpZ2dlckRyb3Bkb3duICE9PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0dHJpZ2dlckRyb3Bkb3duID0gdHJ1ZTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIXNlbGYuY2FuQ3JlYXRlKGlucHV0KSkge1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFxuXHRcdFx0c2VsZi5sb2NrKCk7XG5cdFxuXHRcdFx0dmFyIHNldHVwID0gKHR5cGVvZiBzZWxmLnNldHRpbmdzLmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLnNldHRpbmdzLmNyZWF0ZSA6IGZ1bmN0aW9uKGlucHV0KSB7XG5cdFx0XHRcdHZhciBkYXRhID0ge307XG5cdFx0XHRcdGRhdGFbc2VsZi5zZXR0aW5ncy5sYWJlbEZpZWxkXSA9IGlucHV0O1xuXHRcdFx0XHRkYXRhW3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF0gPSBpbnB1dDtcblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9O1xuXHRcblx0XHRcdHZhciBjcmVhdGUgPSBvbmNlKGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2VsZi51bmxvY2soKTtcblx0XG5cdFx0XHRcdGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHJldHVybiBjYWxsYmFjaygpO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBoYXNoX2tleShkYXRhW3NlbGYuc2V0dGluZ3MudmFsdWVGaWVsZF0pO1xuXHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgcmV0dXJuIGNhbGxiYWNrKCk7XG5cdFxuXHRcdFx0XHRzZWxmLnNldFRleHRib3hWYWx1ZSgnJyk7XG5cdFx0XHRcdHNlbGYuYWRkT3B0aW9uKGRhdGEpO1xuXHRcdFx0XHRzZWxmLnNldENhcmV0KGNhcmV0KTtcblx0XHRcdFx0c2VsZi5hZGRJdGVtKHZhbHVlKTtcblx0XHRcdFx0c2VsZi5yZWZyZXNoT3B0aW9ucyh0cmlnZ2VyRHJvcGRvd24gJiYgc2VsZi5zZXR0aW5ncy5tb2RlICE9PSAnc2luZ2xlJyk7XG5cdFx0XHRcdGNhbGxiYWNrKGRhdGEpO1xuXHRcdFx0fSk7XG5cdFxuXHRcdFx0dmFyIG91dHB1dCA9IHNldHVwLmFwcGx5KHRoaXMsIFtpbnB1dCwgY3JlYXRlXSk7XG5cdFx0XHRpZiAodHlwZW9mIG91dHB1dCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0Y3JlYXRlKG91dHB1dCk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUmUtcmVuZGVycyB0aGUgc2VsZWN0ZWQgaXRlbSBsaXN0cy5cblx0XHQgKi9cblx0XHRyZWZyZXNoSXRlbXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5sYXN0UXVlcnkgPSBudWxsO1xuXHRcblx0XHRcdGlmICh0aGlzLmlzU2V0dXApIHtcblx0XHRcdFx0dGhpcy5hZGRJdGVtKHRoaXMuaXRlbXMpO1xuXHRcdFx0fVxuXHRcblx0XHRcdHRoaXMucmVmcmVzaFN0YXRlKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZU9yaWdpbmFsSW5wdXQoKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIGFsbCBzdGF0ZS1kZXBlbmRlbnQgYXR0cmlidXRlc1xuXHRcdCAqIGFuZCBDU1MgY2xhc3Nlcy5cblx0XHQgKi9cblx0XHRyZWZyZXNoU3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZWZyZXNoVmFsaWRpdHlTdGF0ZSgpO1xuXHRcdFx0dGhpcy5yZWZyZXNoQ2xhc3NlcygpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZSB0aGUgYHJlcXVpcmVkYCBhdHRyaWJ1dGUgb2YgYm90aCBpbnB1dCBhbmQgY29udHJvbCBpbnB1dC5cblx0XHQgKlxuXHRcdCAqIFRoZSBgcmVxdWlyZWRgIHByb3BlcnR5IG5lZWRzIHRvIGJlIGFjdGl2YXRlZCBvbiB0aGUgY29udHJvbCBpbnB1dFxuXHRcdCAqIGZvciB0aGUgZXJyb3IgdG8gYmUgZGlzcGxheWVkIGF0IHRoZSByaWdodCBwbGFjZS4gYHJlcXVpcmVkYCBhbHNvXG5cdFx0ICogbmVlZHMgdG8gYmUgdGVtcG9yYXJpbHkgZGVhY3RpdmF0ZWQgb24gdGhlIGlucHV0IHNpbmNlIHRoZSBpbnB1dCBpc1xuXHRcdCAqIGhpZGRlbiBhbmQgY2FuJ3Qgc2hvdyBlcnJvcnMuXG5cdFx0ICovXG5cdFx0cmVmcmVzaFZhbGlkaXR5U3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLmlzUmVxdWlyZWQpIHJldHVybiBmYWxzZTtcblx0XG5cdFx0XHR2YXIgaW52YWxpZCA9ICF0aGlzLml0ZW1zLmxlbmd0aDtcblx0XG5cdFx0XHR0aGlzLmlzSW52YWxpZCA9IGludmFsaWQ7XG5cdFx0XHR0aGlzLiRjb250cm9sX2lucHV0LnByb3AoJ3JlcXVpcmVkJywgaW52YWxpZCk7XG5cdFx0XHR0aGlzLiRpbnB1dC5wcm9wKCdyZXF1aXJlZCcsICFpbnZhbGlkKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIGFsbCBzdGF0ZS1kZXBlbmRlbnQgQ1NTIGNsYXNzZXMuXG5cdFx0ICovXG5cdFx0cmVmcmVzaENsYXNzZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgICAgID0gdGhpcztcblx0XHRcdHZhciBpc0Z1bGwgICA9IHNlbGYuaXNGdWxsKCk7XG5cdFx0XHR2YXIgaXNMb2NrZWQgPSBzZWxmLmlzTG9ja2VkO1xuXHRcblx0XHRcdHNlbGYuJHdyYXBwZXJcblx0XHRcdFx0LnRvZ2dsZUNsYXNzKCdydGwnLCBzZWxmLnJ0bCk7XG5cdFxuXHRcdFx0c2VsZi4kY29udHJvbFxuXHRcdFx0XHQudG9nZ2xlQ2xhc3MoJ2ZvY3VzJywgc2VsZi5pc0ZvY3VzZWQpXG5cdFx0XHRcdC50b2dnbGVDbGFzcygnZGlzYWJsZWQnLCBzZWxmLmlzRGlzYWJsZWQpXG5cdFx0XHRcdC50b2dnbGVDbGFzcygncmVxdWlyZWQnLCBzZWxmLmlzUmVxdWlyZWQpXG5cdFx0XHRcdC50b2dnbGVDbGFzcygnaW52YWxpZCcsIHNlbGYuaXNJbnZhbGlkKVxuXHRcdFx0XHQudG9nZ2xlQ2xhc3MoJ2xvY2tlZCcsIGlzTG9ja2VkKVxuXHRcdFx0XHQudG9nZ2xlQ2xhc3MoJ2Z1bGwnLCBpc0Z1bGwpLnRvZ2dsZUNsYXNzKCdub3QtZnVsbCcsICFpc0Z1bGwpXG5cdFx0XHRcdC50b2dnbGVDbGFzcygnaW5wdXQtYWN0aXZlJywgc2VsZi5pc0ZvY3VzZWQgJiYgIXNlbGYuaXNJbnB1dEhpZGRlbilcblx0XHRcdFx0LnRvZ2dsZUNsYXNzKCdkcm9wZG93bi1hY3RpdmUnLCBzZWxmLmlzT3Blbilcblx0XHRcdFx0LnRvZ2dsZUNsYXNzKCdoYXMtb3B0aW9ucycsICEkLmlzRW1wdHlPYmplY3Qoc2VsZi5vcHRpb25zKSlcblx0XHRcdFx0LnRvZ2dsZUNsYXNzKCdoYXMtaXRlbXMnLCBzZWxmLml0ZW1zLmxlbmd0aCA+IDApO1xuXHRcblx0XHRcdHNlbGYuJGNvbnRyb2xfaW5wdXQuZGF0YSgnZ3JvdycsICFpc0Z1bGwgJiYgIWlzTG9ja2VkKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IG1vcmUgaXRlbXMgY2FuIGJlIGFkZGVkXG5cdFx0ICogdG8gdGhlIGNvbnRyb2wgd2l0aG91dCBleGNlZWRpbmcgdGhlIHVzZXItZGVmaW5lZCBtYXhpbXVtLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNGdWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnNldHRpbmdzLm1heEl0ZW1zICE9PSBudWxsICYmIHRoaXMuaXRlbXMubGVuZ3RoID49IHRoaXMuc2V0dGluZ3MubWF4SXRlbXM7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogUmVmcmVzaGVzIHRoZSBvcmlnaW5hbCA8c2VsZWN0PiBvciA8aW5wdXQ+XG5cdFx0ICogZWxlbWVudCB0byByZWZsZWN0IHRoZSBjdXJyZW50IHN0YXRlLlxuXHRcdCAqL1xuXHRcdHVwZGF0ZU9yaWdpbmFsSW5wdXQ6IGZ1bmN0aW9uKG9wdHMpIHtcblx0XHRcdHZhciBpLCBuLCBvcHRpb25zLCBsYWJlbCwgc2VsZiA9IHRoaXM7XG5cdFx0XHRvcHRzID0gb3B0cyB8fCB7fTtcblx0XG5cdFx0XHRpZiAoc2VsZi50YWdUeXBlID09PSBUQUdfU0VMRUNUKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSBbXTtcblx0XHRcdFx0Zm9yIChpID0gMCwgbiA9IHNlbGYuaXRlbXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdFx0bGFiZWwgPSBzZWxmLm9wdGlvbnNbc2VsZi5pdGVtc1tpXV1bc2VsZi5zZXR0aW5ncy5sYWJlbEZpZWxkXSB8fCAnJztcblx0XHRcdFx0XHRvcHRpb25zLnB1c2goJzxvcHRpb24gdmFsdWU9XCInICsgZXNjYXBlX2h0bWwoc2VsZi5pdGVtc1tpXSkgKyAnXCIgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiPicgKyBlc2NhcGVfaHRtbChsYWJlbCkgKyAnPC9vcHRpb24+Jyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFvcHRpb25zLmxlbmd0aCAmJiAhdGhpcy4kaW5wdXQuYXR0cignbXVsdGlwbGUnKSkge1xuXHRcdFx0XHRcdG9wdGlvbnMucHVzaCgnPG9wdGlvbiB2YWx1ZT1cIlwiIHNlbGVjdGVkPVwic2VsZWN0ZWRcIj48L29wdGlvbj4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLiRpbnB1dC5odG1sKG9wdGlvbnMuam9pbignJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi4kaW5wdXQudmFsKHNlbGYuZ2V0VmFsdWUoKSk7XG5cdFx0XHRcdHNlbGYuJGlucHV0LmF0dHIoJ3ZhbHVlJyxzZWxmLiRpbnB1dC52YWwoKSk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKHNlbGYuaXNTZXR1cCkge1xuXHRcdFx0XHRpZiAoIW9wdHMuc2lsZW50KSB7XG5cdFx0XHRcdFx0c2VsZi50cmlnZ2VyKCdjaGFuZ2UnLCBzZWxmLiRpbnB1dC52YWwoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBTaG93cy9oaWRlIHRoZSBpbnB1dCBwbGFjZWhvbGRlciBkZXBlbmRpbmdcblx0XHQgKiBvbiBpZiB0aGVyZSBpdGVtcyBpbiB0aGUgbGlzdCBhbHJlYWR5LlxuXHRcdCAqL1xuXHRcdHVwZGF0ZVBsYWNlaG9sZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy5zZXR0aW5ncy5wbGFjZWhvbGRlcikgcmV0dXJuO1xuXHRcdFx0dmFyICRpbnB1dCA9IHRoaXMuJGNvbnRyb2xfaW5wdXQ7XG5cdFxuXHRcdFx0aWYgKHRoaXMuaXRlbXMubGVuZ3RoKSB7XG5cdFx0XHRcdCRpbnB1dC5yZW1vdmVBdHRyKCdwbGFjZWhvbGRlcicpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JGlucHV0LmF0dHIoJ3BsYWNlaG9sZGVyJywgdGhpcy5zZXR0aW5ncy5wbGFjZWhvbGRlcik7XG5cdFx0XHR9XG5cdFx0XHQkaW5wdXQudHJpZ2dlckhhbmRsZXIoJ3VwZGF0ZScsIHtmb3JjZTogdHJ1ZX0pO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNob3dzIHRoZSBhdXRvY29tcGxldGUgZHJvcGRvd24gY29udGFpbmluZ1xuXHRcdCAqIHRoZSBhdmFpbGFibGUgb3B0aW9ucy5cblx0XHQgKi9cblx0XHRvcGVuOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XG5cdFx0XHRpZiAoc2VsZi5pc0xvY2tlZCB8fCBzZWxmLmlzT3BlbiB8fCAoc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnbXVsdGknICYmIHNlbGYuaXNGdWxsKCkpKSByZXR1cm47XG5cdFx0XHRzZWxmLmZvY3VzKCk7XG5cdFx0XHRzZWxmLmlzT3BlbiA9IHRydWU7XG5cdFx0XHRzZWxmLnJlZnJlc2hTdGF0ZSgpO1xuXHRcdFx0c2VsZi4kZHJvcGRvd24uY3NzKHt2aXNpYmlsaXR5OiAnaGlkZGVuJywgZGlzcGxheTogJ2Jsb2NrJ30pO1xuXHRcdFx0c2VsZi5wb3NpdGlvbkRyb3Bkb3duKCk7XG5cdFx0XHRzZWxmLiRkcm9wZG93bi5jc3Moe3Zpc2liaWxpdHk6ICd2aXNpYmxlJ30pO1xuXHRcdFx0c2VsZi50cmlnZ2VyKCdkcm9wZG93bl9vcGVuJywgc2VsZi4kZHJvcGRvd24pO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENsb3NlcyB0aGUgYXV0b2NvbXBsZXRlIGRyb3Bkb3duIG1lbnUuXG5cdFx0ICovXG5cdFx0Y2xvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIHRyaWdnZXIgPSBzZWxmLmlzT3Blbjtcblx0XG5cdFx0XHRpZiAoc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJyAmJiBzZWxmLml0ZW1zLmxlbmd0aCkge1xuXHRcdFx0XHRzZWxmLmhpZGVJbnB1dCgpO1xuXHRcdFx0XHRzZWxmLiRjb250cm9sX2lucHV0LmJsdXIoKTsgLy8gY2xvc2Uga2V5Ym9hcmQgb24gaU9TXG5cdFx0XHR9XG5cdFxuXHRcdFx0c2VsZi5pc09wZW4gPSBmYWxzZTtcblx0XHRcdHNlbGYuJGRyb3Bkb3duLmhpZGUoKTtcblx0XHRcdHNlbGYuc2V0QWN0aXZlT3B0aW9uKG51bGwpO1xuXHRcdFx0c2VsZi5yZWZyZXNoU3RhdGUoKTtcblx0XG5cdFx0XHRpZiAodHJpZ2dlcikgc2VsZi50cmlnZ2VyKCdkcm9wZG93bl9jbG9zZScsIHNlbGYuJGRyb3Bkb3duKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBDYWxjdWxhdGVzIGFuZCBhcHBsaWVzIHRoZSBhcHByb3ByaWF0ZVxuXHRcdCAqIHBvc2l0aW9uIG9mIHRoZSBkcm9wZG93bi5cblx0XHQgKi9cblx0XHRwb3NpdGlvbkRyb3Bkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciAkY29udHJvbCA9IHRoaXMuJGNvbnRyb2w7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5zZXR0aW5ncy5kcm9wZG93blBhcmVudCA9PT0gJ2JvZHknID8gJGNvbnRyb2wub2Zmc2V0KCkgOiAkY29udHJvbC5wb3NpdGlvbigpO1xuXHRcdFx0b2Zmc2V0LnRvcCArPSAkY29udHJvbC5vdXRlckhlaWdodCh0cnVlKTtcblx0XG5cdFx0XHR0aGlzLiRkcm9wZG93bi5jc3Moe1xuXHRcdFx0XHR3aWR0aCA6ICRjb250cm9sLm91dGVyV2lkdGgoKSxcblx0XHRcdFx0dG9wICAgOiBvZmZzZXQudG9wLFxuXHRcdFx0XHRsZWZ0ICA6IG9mZnNldC5sZWZ0XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBSZXNldHMgLyBjbGVhcnMgYWxsIHNlbGVjdGVkIGl0ZW1zXG5cdFx0ICogZnJvbSB0aGUgY29udHJvbC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50XG5cdFx0ICovXG5cdFx0Y2xlYXI6IGZ1bmN0aW9uKHNpbGVudCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0XHRcdGlmICghc2VsZi5pdGVtcy5sZW5ndGgpIHJldHVybjtcblx0XHRcdHNlbGYuJGNvbnRyb2wuY2hpbGRyZW4oJzpub3QoaW5wdXQpJykucmVtb3ZlKCk7XG5cdFx0XHRzZWxmLml0ZW1zID0gW107XG5cdFx0XHRzZWxmLmxhc3RRdWVyeSA9IG51bGw7XG5cdFx0XHRzZWxmLnNldENhcmV0KDApO1xuXHRcdFx0c2VsZi5zZXRBY3RpdmVJdGVtKG51bGwpO1xuXHRcdFx0c2VsZi51cGRhdGVQbGFjZWhvbGRlcigpO1xuXHRcdFx0c2VsZi51cGRhdGVPcmlnaW5hbElucHV0KHtzaWxlbnQ6IHNpbGVudH0pO1xuXHRcdFx0c2VsZi5yZWZyZXNoU3RhdGUoKTtcblx0XHRcdHNlbGYuc2hvd0lucHV0KCk7XG5cdFx0XHRzZWxmLnRyaWdnZXIoJ2NsZWFyJyk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQSBoZWxwZXIgbWV0aG9kIGZvciBpbnNlcnRpbmcgYW4gZWxlbWVudFxuXHRcdCAqIGF0IHRoZSBjdXJyZW50IGNhcmV0IHBvc2l0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9ICRlbFxuXHRcdCAqL1xuXHRcdGluc2VydEF0Q2FyZXQ6IGZ1bmN0aW9uKCRlbCkge1xuXHRcdFx0dmFyIGNhcmV0ID0gTWF0aC5taW4odGhpcy5jYXJldFBvcywgdGhpcy5pdGVtcy5sZW5ndGgpO1xuXHRcdFx0aWYgKGNhcmV0ID09PSAwKSB7XG5cdFx0XHRcdHRoaXMuJGNvbnRyb2wucHJlcGVuZCgkZWwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JCh0aGlzLiRjb250cm9sWzBdLmNoaWxkTm9kZXNbY2FyZXRdKS5iZWZvcmUoJGVsKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc2V0Q2FyZXQoY2FyZXQgKyAxKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIHRoZSBjdXJyZW50IHNlbGVjdGVkIGl0ZW0ocykuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZSAob3B0aW9uYWwpXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0ZGVsZXRlU2VsZWN0aW9uOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgaSwgbiwgZGlyZWN0aW9uLCBzZWxlY3Rpb24sIHZhbHVlcywgY2FyZXQsIG9wdGlvbl9zZWxlY3QsICRvcHRpb25fc2VsZWN0LCAkdGFpbDtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XG5cdFx0XHRkaXJlY3Rpb24gPSAoZSAmJiBlLmtleUNvZGUgPT09IEtFWV9CQUNLU1BBQ0UpID8gLTEgOiAxO1xuXHRcdFx0c2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKHNlbGYuJGNvbnRyb2xfaW5wdXRbMF0pO1xuXHRcblx0XHRcdGlmIChzZWxmLiRhY3RpdmVPcHRpb24gJiYgIXNlbGYuc2V0dGluZ3MuaGlkZVNlbGVjdGVkKSB7XG5cdFx0XHRcdG9wdGlvbl9zZWxlY3QgPSBzZWxmLmdldEFkamFjZW50T3B0aW9uKHNlbGYuJGFjdGl2ZU9wdGlvbiwgLTEpLmF0dHIoJ2RhdGEtdmFsdWUnKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBkZXRlcm1pbmUgaXRlbXMgdGhhdCB3aWxsIGJlIHJlbW92ZWRcblx0XHRcdHZhbHVlcyA9IFtdO1xuXHRcblx0XHRcdGlmIChzZWxmLiRhY3RpdmVJdGVtcy5sZW5ndGgpIHtcblx0XHRcdFx0JHRhaWwgPSBzZWxmLiRjb250cm9sLmNoaWxkcmVuKCcuYWN0aXZlOicgKyAoZGlyZWN0aW9uID4gMCA/ICdsYXN0JyA6ICdmaXJzdCcpKTtcblx0XHRcdFx0Y2FyZXQgPSBzZWxmLiRjb250cm9sLmNoaWxkcmVuKCc6bm90KGlucHV0KScpLmluZGV4KCR0YWlsKTtcblx0XHRcdFx0aWYgKGRpcmVjdGlvbiA+IDApIHsgY2FyZXQrKzsgfVxuXHRcblx0XHRcdFx0Zm9yIChpID0gMCwgbiA9IHNlbGYuJGFjdGl2ZUl0ZW1zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKCQoc2VsZi4kYWN0aXZlSXRlbXNbaV0pLmF0dHIoJ2RhdGEtdmFsdWUnKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGUpIHtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICgoc2VsZi5pc0ZvY3VzZWQgfHwgc2VsZi5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJykgJiYgc2VsZi5pdGVtcy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKGRpcmVjdGlvbiA8IDAgJiYgc2VsZWN0aW9uLnN0YXJ0ID09PSAwICYmIHNlbGVjdGlvbi5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChzZWxmLml0ZW1zW3NlbGYuY2FyZXRQb3MgLSAxXSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID4gMCAmJiBzZWxlY3Rpb24uc3RhcnQgPT09IHNlbGYuJGNvbnRyb2xfaW5wdXQudmFsKCkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goc2VsZi5pdGVtc1tzZWxmLmNhcmV0UG9zXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBhbGxvdyB0aGUgY2FsbGJhY2sgdG8gYWJvcnRcblx0XHRcdGlmICghdmFsdWVzLmxlbmd0aCB8fCAodHlwZW9mIHNlbGYuc2V0dGluZ3Mub25EZWxldGUgPT09ICdmdW5jdGlvbicgJiYgc2VsZi5zZXR0aW5ncy5vbkRlbGV0ZS5hcHBseShzZWxmLCBbdmFsdWVzXSkgPT09IGZhbHNlKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gcGVyZm9ybSByZW1vdmFsXG5cdFx0XHRpZiAodHlwZW9mIGNhcmV0ICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRzZWxmLnNldENhcmV0KGNhcmV0KTtcblx0XHRcdH1cblx0XHRcdHdoaWxlICh2YWx1ZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHNlbGYucmVtb3ZlSXRlbSh2YWx1ZXMucG9wKCkpO1xuXHRcdFx0fVxuXHRcblx0XHRcdHNlbGYuc2hvd0lucHV0KCk7XG5cdFx0XHRzZWxmLnBvc2l0aW9uRHJvcGRvd24oKTtcblx0XHRcdHNlbGYucmVmcmVzaE9wdGlvbnModHJ1ZSk7XG5cdFxuXHRcdFx0Ly8gc2VsZWN0IHByZXZpb3VzIG9wdGlvblxuXHRcdFx0aWYgKG9wdGlvbl9zZWxlY3QpIHtcblx0XHRcdFx0JG9wdGlvbl9zZWxlY3QgPSBzZWxmLmdldE9wdGlvbihvcHRpb25fc2VsZWN0KTtcblx0XHRcdFx0aWYgKCRvcHRpb25fc2VsZWN0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdHNlbGYuc2V0QWN0aXZlT3B0aW9uKCRvcHRpb25fc2VsZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNlbGVjdHMgdGhlIHByZXZpb3VzIC8gbmV4dCBpdGVtIChkZXBlbmRpbmdcblx0XHQgKiBvbiB0aGUgYGRpcmVjdGlvbmAgYXJndW1lbnQpLlxuXHRcdCAqXG5cdFx0ICogPiAwIC0gcmlnaHRcblx0XHQgKiA8IDAgLSBsZWZ0XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2ludH0gZGlyZWN0aW9uXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGUgKG9wdGlvbmFsKVxuXHRcdCAqL1xuXHRcdGFkdmFuY2VTZWxlY3Rpb246IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuXHRcdFx0dmFyIHRhaWwsIHNlbGVjdGlvbiwgaWR4LCB2YWx1ZUxlbmd0aCwgY3Vyc29yQXRFZGdlLCAkdGFpbDtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XG5cdFx0XHRpZiAoZGlyZWN0aW9uID09PSAwKSByZXR1cm47XG5cdFx0XHRpZiAoc2VsZi5ydGwpIGRpcmVjdGlvbiAqPSAtMTtcblx0XG5cdFx0XHR0YWlsID0gZGlyZWN0aW9uID4gMCA/ICdsYXN0JyA6ICdmaXJzdCc7XG5cdFx0XHRzZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oc2VsZi4kY29udHJvbF9pbnB1dFswXSk7XG5cdFxuXHRcdFx0aWYgKHNlbGYuaXNGb2N1c2VkICYmICFzZWxmLmlzSW5wdXRIaWRkZW4pIHtcblx0XHRcdFx0dmFsdWVMZW5ndGggPSBzZWxmLiRjb250cm9sX2lucHV0LnZhbCgpLmxlbmd0aDtcblx0XHRcdFx0Y3Vyc29yQXRFZGdlID0gZGlyZWN0aW9uIDwgMFxuXHRcdFx0XHRcdD8gc2VsZWN0aW9uLnN0YXJ0ID09PSAwICYmIHNlbGVjdGlvbi5sZW5ndGggPT09IDBcblx0XHRcdFx0XHQ6IHNlbGVjdGlvbi5zdGFydCA9PT0gdmFsdWVMZW5ndGg7XG5cdFxuXHRcdFx0XHRpZiAoY3Vyc29yQXRFZGdlICYmICF2YWx1ZUxlbmd0aCkge1xuXHRcdFx0XHRcdHNlbGYuYWR2YW5jZUNhcmV0KGRpcmVjdGlvbiwgZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCR0YWlsID0gc2VsZi4kY29udHJvbC5jaGlsZHJlbignLmFjdGl2ZTonICsgdGFpbCk7XG5cdFx0XHRcdGlmICgkdGFpbC5sZW5ndGgpIHtcblx0XHRcdFx0XHRpZHggPSBzZWxmLiRjb250cm9sLmNoaWxkcmVuKCc6bm90KGlucHV0KScpLmluZGV4KCR0YWlsKTtcblx0XHRcdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW0obnVsbCk7XG5cdFx0XHRcdFx0c2VsZi5zZXRDYXJldChkaXJlY3Rpb24gPiAwID8gaWR4ICsgMSA6IGlkeCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBNb3ZlcyB0aGUgY2FyZXQgbGVmdCAvIHJpZ2h0LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtpbnR9IGRpcmVjdGlvblxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBlIChvcHRpb25hbClcblx0XHQgKi9cblx0XHRhZHZhbmNlQ2FyZXQ6IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCBmbiwgJGFkajtcblx0XG5cdFx0XHRpZiAoZGlyZWN0aW9uID09PSAwKSByZXR1cm47XG5cdFxuXHRcdFx0Zm4gPSBkaXJlY3Rpb24gPiAwID8gJ25leHQnIDogJ3ByZXYnO1xuXHRcdFx0aWYgKHNlbGYuaXNTaGlmdERvd24pIHtcblx0XHRcdFx0JGFkaiA9IHNlbGYuJGNvbnRyb2xfaW5wdXRbZm5dKCk7XG5cdFx0XHRcdGlmICgkYWRqLmxlbmd0aCkge1xuXHRcdFx0XHRcdHNlbGYuaGlkZUlucHV0KCk7XG5cdFx0XHRcdFx0c2VsZi5zZXRBY3RpdmVJdGVtKCRhZGopO1xuXHRcdFx0XHRcdGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLnNldENhcmV0KHNlbGYuY2FyZXRQb3MgKyBkaXJlY3Rpb24pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIE1vdmVzIHRoZSBjYXJldCB0byB0aGUgc3BlY2lmaWVkIGluZGV4LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtpbnR9IGlcblx0XHQgKi9cblx0XHRzZXRDYXJldDogZnVuY3Rpb24oaSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0XHRcdGlmIChzZWxmLnNldHRpbmdzLm1vZGUgPT09ICdzaW5nbGUnKSB7XG5cdFx0XHRcdGkgPSBzZWxmLml0ZW1zLmxlbmd0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZWxmLml0ZW1zLmxlbmd0aCwgaSkpO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmKCFzZWxmLmlzUGVuZGluZykge1xuXHRcdFx0XHQvLyB0aGUgaW5wdXQgbXVzdCBiZSBtb3ZlZCBieSBsZWF2aW5nIGl0IGluIHBsYWNlIGFuZCBtb3ZpbmcgdGhlXG5cdFx0XHRcdC8vIHNpYmxpbmdzLCBkdWUgdG8gdGhlIGZhY3QgdGhhdCBmb2N1cyBjYW5ub3QgYmUgcmVzdG9yZWQgb25jZSBsb3N0XG5cdFx0XHRcdC8vIG9uIG1vYmlsZSB3ZWJraXQgZGV2aWNlc1xuXHRcdFx0XHR2YXIgaiwgbiwgZm4sICRjaGlsZHJlbiwgJGNoaWxkO1xuXHRcdFx0XHQkY2hpbGRyZW4gPSBzZWxmLiRjb250cm9sLmNoaWxkcmVuKCc6bm90KGlucHV0KScpO1xuXHRcdFx0XHRmb3IgKGogPSAwLCBuID0gJGNoaWxkcmVuLmxlbmd0aDsgaiA8IG47IGorKykge1xuXHRcdFx0XHRcdCRjaGlsZCA9ICQoJGNoaWxkcmVuW2pdKS5kZXRhY2goKTtcblx0XHRcdFx0XHRpZiAoaiA8ICBpKSB7XG5cdFx0XHRcdFx0XHRzZWxmLiRjb250cm9sX2lucHV0LmJlZm9yZSgkY2hpbGQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLiRjb250cm9sLmFwcGVuZCgkY2hpbGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdHNlbGYuY2FyZXRQb3MgPSBpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERpc2FibGVzIHVzZXIgaW5wdXQgb24gdGhlIGNvbnRyb2wuIFVzZWQgd2hpbGVcblx0XHQgKiBpdGVtcyBhcmUgYmVpbmcgYXN5bmNocm9ub3VzbHkgY3JlYXRlZC5cblx0XHQgKi9cblx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuY2xvc2UoKTtcblx0XHRcdHRoaXMuaXNMb2NrZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5yZWZyZXNoU3RhdGUoKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBSZS1lbmFibGVzIHVzZXIgaW5wdXQgb24gdGhlIGNvbnRyb2wuXG5cdFx0ICovXG5cdFx0dW5sb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuaXNMb2NrZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMucmVmcmVzaFN0YXRlKCk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRGlzYWJsZXMgdXNlciBpbnB1dCBvbiB0aGUgY29udHJvbCBjb21wbGV0ZWx5LlxuXHRcdCAqIFdoaWxlIGRpc2FibGVkLCBpdCBjYW5ub3QgcmVjZWl2ZSBmb2N1cy5cblx0XHQgKi9cblx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHNlbGYuJGlucHV0LnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XG5cdFx0XHRzZWxmLiRjb250cm9sX2lucHV0LnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSkucHJvcCgndGFiaW5kZXgnLCAtMSk7XG5cdFx0XHRzZWxmLmlzRGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0c2VsZi5sb2NrKCk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlcyB0aGUgY29udHJvbCBzbyB0aGF0IGl0IGNhbiByZXNwb25kXG5cdFx0ICogdG8gZm9jdXMgYW5kIHVzZXIgaW5wdXQuXG5cdFx0ICovXG5cdFx0ZW5hYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHNlbGYuJGlucHV0LnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuXHRcdFx0c2VsZi4kY29udHJvbF9pbnB1dC5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKS5wcm9wKCd0YWJpbmRleCcsIHNlbGYudGFiSW5kZXgpO1xuXHRcdFx0c2VsZi5pc0Rpc2FibGVkID0gZmFsc2U7XG5cdFx0XHRzZWxmLnVubG9jaygpO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENvbXBsZXRlbHkgZGVzdHJveXMgdGhlIGNvbnRyb2wgYW5kXG5cdFx0ICogdW5iaW5kcyBhbGwgZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXQgaXQgY2FuXG5cdFx0ICogYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG5cdFx0ICovXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgZXZlbnROUyA9IHNlbGYuZXZlbnROUztcblx0XHRcdHZhciByZXZlcnRTZXR0aW5ncyA9IHNlbGYucmV2ZXJ0U2V0dGluZ3M7XG5cdFxuXHRcdFx0c2VsZi50cmlnZ2VyKCdkZXN0cm95Jyk7XG5cdFx0XHRzZWxmLm9mZigpO1xuXHRcdFx0c2VsZi4kd3JhcHBlci5yZW1vdmUoKTtcblx0XHRcdHNlbGYuJGRyb3Bkb3duLnJlbW92ZSgpO1xuXHRcblx0XHRcdHNlbGYuJGlucHV0XG5cdFx0XHRcdC5odG1sKCcnKVxuXHRcdFx0XHQuYXBwZW5kKHJldmVydFNldHRpbmdzLiRjaGlsZHJlbilcblx0XHRcdFx0LnJlbW92ZUF0dHIoJ3RhYmluZGV4Jylcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCdzZWxlY3RpemVkJylcblx0XHRcdFx0LmF0dHIoe3RhYmluZGV4OiByZXZlcnRTZXR0aW5ncy50YWJpbmRleH0pXG5cdFx0XHRcdC5zaG93KCk7XG5cdFxuXHRcdFx0c2VsZi4kY29udHJvbF9pbnB1dC5yZW1vdmVEYXRhKCdncm93Jyk7XG5cdFx0XHRzZWxmLiRpbnB1dC5yZW1vdmVEYXRhKCdzZWxlY3RpemUnKTtcblx0XG5cdFx0XHQkKHdpbmRvdykub2ZmKGV2ZW50TlMpO1xuXHRcdFx0JChkb2N1bWVudCkub2ZmKGV2ZW50TlMpO1xuXHRcdFx0JChkb2N1bWVudC5ib2R5KS5vZmYoZXZlbnROUyk7XG5cdFxuXHRcdFx0ZGVsZXRlIHNlbGYuJGlucHV0WzBdLnNlbGVjdGl6ZTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBBIGhlbHBlciBtZXRob2QgZm9yIHJlbmRlcmluZyBcIml0ZW1cIiBhbmRcblx0XHQgKiBcIm9wdGlvblwiIHRlbXBsYXRlcywgZ2l2ZW4gdGhlIGRhdGEuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVOYW1lXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGFcblx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdHJlbmRlcjogZnVuY3Rpb24odGVtcGxhdGVOYW1lLCBkYXRhKSB7XG5cdFx0XHR2YXIgdmFsdWUsIGlkLCBsYWJlbDtcblx0XHRcdHZhciBodG1sID0gJyc7XG5cdFx0XHR2YXIgY2FjaGUgPSBmYWxzZTtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciByZWdleF90YWcgPSAvXltcXHQgXFxyXFxuXSo8KFthLXpdW2EtejAtOVxcLV9dKig/OlxcOlthLXpdW2EtejAtOVxcLV9dKik/KS9pO1xuXHRcblx0XHRcdGlmICh0ZW1wbGF0ZU5hbWUgPT09ICdvcHRpb24nIHx8IHRlbXBsYXRlTmFtZSA9PT0gJ2l0ZW0nKSB7XG5cdFx0XHRcdHZhbHVlID0gaGFzaF9rZXkoZGF0YVtzZWxmLnNldHRpbmdzLnZhbHVlRmllbGRdKTtcblx0XHRcdFx0Y2FjaGUgPSAhIXZhbHVlO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIHB1bGwgbWFya3VwIGZyb20gY2FjaGUgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoY2FjaGUpIHtcblx0XHRcdFx0aWYgKCFpc3NldChzZWxmLnJlbmRlckNhY2hlW3RlbXBsYXRlTmFtZV0pKSB7XG5cdFx0XHRcdFx0c2VsZi5yZW5kZXJDYWNoZVt0ZW1wbGF0ZU5hbWVdID0ge307XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHNlbGYucmVuZGVyQ2FjaGVbdGVtcGxhdGVOYW1lXS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi5yZW5kZXJDYWNoZVt0ZW1wbGF0ZU5hbWVdW3ZhbHVlXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdC8vIHJlbmRlciBtYXJrdXBcblx0XHRcdGh0bWwgPSAkKHNlbGYuc2V0dGluZ3MucmVuZGVyW3RlbXBsYXRlTmFtZV0uYXBwbHkodGhpcywgW2RhdGEsIGVzY2FwZV9odG1sXSkpO1xuXHRcblx0XHRcdC8vIGFkZCBtYW5kYXRvcnkgYXR0cmlidXRlc1xuXHRcdFx0aWYgKHRlbXBsYXRlTmFtZSA9PT0gJ29wdGlvbicgfHwgdGVtcGxhdGVOYW1lID09PSAnb3B0aW9uX2NyZWF0ZScpIHtcblx0XHRcdFx0aHRtbC5hdHRyKCdkYXRhLXNlbGVjdGFibGUnLCAnJyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0ZW1wbGF0ZU5hbWUgPT09ICdvcHRncm91cCcpIHtcblx0XHRcdFx0aWQgPSBkYXRhW3NlbGYuc2V0dGluZ3Mub3B0Z3JvdXBWYWx1ZUZpZWxkXSB8fCAnJztcblx0XHRcdFx0aHRtbC5hdHRyKCdkYXRhLWdyb3VwJywgaWQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRlbXBsYXRlTmFtZSA9PT0gJ29wdGlvbicgfHwgdGVtcGxhdGVOYW1lID09PSAnaXRlbScpIHtcblx0XHRcdFx0aHRtbC5hdHRyKCdkYXRhLXZhbHVlJywgdmFsdWUgfHwgJycpO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIHVwZGF0ZSBjYWNoZVxuXHRcdFx0aWYgKGNhY2hlKSB7XG5cdFx0XHRcdHNlbGYucmVuZGVyQ2FjaGVbdGVtcGxhdGVOYW1lXVt2YWx1ZV0gPSBodG1sWzBdO1xuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiBodG1sWzBdO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIENsZWFycyB0aGUgcmVuZGVyIGNhY2hlIGZvciBhIHRlbXBsYXRlLiBJZlxuXHRcdCAqIG5vIHRlbXBsYXRlIGlzIGdpdmVuLCBjbGVhcnMgYWxsIHJlbmRlclxuXHRcdCAqIGNhY2hlcy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZU5hbWVcblx0XHQgKi9cblx0XHRjbGVhckNhY2hlOiBmdW5jdGlvbih0ZW1wbGF0ZU5hbWUpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGlmICh0eXBlb2YgdGVtcGxhdGVOYW1lID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRzZWxmLnJlbmRlckNhY2hlID0ge307XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgc2VsZi5yZW5kZXJDYWNoZVt0ZW1wbGF0ZU5hbWVdO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gZGlzcGxheSB0aGVcblx0XHQgKiBjcmVhdGUgaXRlbSBwcm9tcHQsIGdpdmVuIGEgdXNlciBpbnB1dC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuXHRcdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0Y2FuQ3JlYXRlOiBmdW5jdGlvbihpbnB1dCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0aWYgKCFzZWxmLnNldHRpbmdzLmNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0dmFyIGZpbHRlciA9IHNlbGYuc2V0dGluZ3MuY3JlYXRlRmlsdGVyO1xuXHRcdFx0cmV0dXJuIGlucHV0Lmxlbmd0aFxuXHRcdFx0XHQmJiAodHlwZW9mIGZpbHRlciAhPT0gJ2Z1bmN0aW9uJyB8fCBmaWx0ZXIuYXBwbHkoc2VsZiwgW2lucHV0XSkpXG5cdFx0XHRcdCYmICh0eXBlb2YgZmlsdGVyICE9PSAnc3RyaW5nJyB8fCBuZXcgUmVnRXhwKGZpbHRlcikudGVzdChpbnB1dCkpXG5cdFx0XHRcdCYmICghKGZpbHRlciBpbnN0YW5jZW9mIFJlZ0V4cCkgfHwgZmlsdGVyLnRlc3QoaW5wdXQpKTtcblx0XHR9XG5cdFxuXHR9KTtcblx0XG5cdFxuXHRTZWxlY3RpemUuY291bnQgPSAwO1xuXHRTZWxlY3RpemUuZGVmYXVsdHMgPSB7XG5cdFx0b3B0aW9uczogW10sXG5cdFx0b3B0Z3JvdXBzOiBbXSxcblx0XG5cdFx0cGx1Z2luczogW10sXG5cdFx0ZGVsaW1pdGVyOiAnLCcsXG5cdFx0c3BsaXRPbjogbnVsbCwgLy8gcmVnZXhwIG9yIHN0cmluZyBmb3Igc3BsaXR0aW5nIHVwIHZhbHVlcyBmcm9tIGEgcGFzdGUgY29tbWFuZFxuXHRcdHBlcnNpc3Q6IHRydWUsXG5cdFx0ZGlhY3JpdGljczogdHJ1ZSxcblx0XHRjcmVhdGU6IGZhbHNlLFxuXHRcdGNyZWF0ZU9uQmx1cjogZmFsc2UsXG5cdFx0Y3JlYXRlRmlsdGVyOiBudWxsLFxuXHRcdGhpZ2hsaWdodDogdHJ1ZSxcblx0XHRvcGVuT25Gb2N1czogdHJ1ZSxcblx0XHRtYXhPcHRpb25zOiAxMDAwLFxuXHRcdG1heEl0ZW1zOiBudWxsLFxuXHRcdGhpZGVTZWxlY3RlZDogbnVsbCxcblx0XHRhZGRQcmVjZWRlbmNlOiBmYWxzZSxcblx0XHRzZWxlY3RPblRhYjogZmFsc2UsXG5cdFx0cHJlbG9hZDogZmFsc2UsXG5cdFx0YWxsb3dFbXB0eU9wdGlvbjogZmFsc2UsXG5cdFx0Y2xvc2VBZnRlclNlbGVjdDogZmFsc2UsXG5cdFxuXHRcdHNjcm9sbER1cmF0aW9uOiA2MCxcblx0XHRsb2FkVGhyb3R0bGU6IDMwMCxcblx0XHRsb2FkaW5nQ2xhc3M6ICdsb2FkaW5nJyxcblx0XG5cdFx0ZGF0YUF0dHI6ICdkYXRhLWRhdGEnLFxuXHRcdG9wdGdyb3VwRmllbGQ6ICdvcHRncm91cCcsXG5cdFx0dmFsdWVGaWVsZDogJ3ZhbHVlJyxcblx0XHRsYWJlbEZpZWxkOiAndGV4dCcsXG5cdFx0b3B0Z3JvdXBMYWJlbEZpZWxkOiAnbGFiZWwnLFxuXHRcdG9wdGdyb3VwVmFsdWVGaWVsZDogJ3ZhbHVlJyxcblx0XHRsb2NrT3B0Z3JvdXBPcmRlcjogZmFsc2UsXG5cdFxuXHRcdHNvcnRGaWVsZDogJyRvcmRlcicsXG5cdFx0c2VhcmNoRmllbGQ6IFsndGV4dCddLFxuXHRcdHNlYXJjaENvbmp1bmN0aW9uOiAnYW5kJyxcblx0XG5cdFx0bW9kZTogbnVsbCxcblx0XHR3cmFwcGVyQ2xhc3M6ICdzZWxlY3RpemUtY29udHJvbCcsXG5cdFx0aW5wdXRDbGFzczogJ3NlbGVjdGl6ZS1pbnB1dCcsXG5cdFx0ZHJvcGRvd25DbGFzczogJ3NlbGVjdGl6ZS1kcm9wZG93bicsXG5cdFx0ZHJvcGRvd25Db250ZW50Q2xhc3M6ICdzZWxlY3RpemUtZHJvcGRvd24tY29udGVudCcsXG5cdFxuXHRcdGRyb3Bkb3duUGFyZW50OiBudWxsLFxuXHRcblx0XHRjb3B5Q2xhc3Nlc1RvRHJvcGRvd246IHRydWUsXG5cdFxuXHRcdC8qXG5cdFx0bG9hZCAgICAgICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbihxdWVyeSwgY2FsbGJhY2spIHsgLi4uIH1cblx0XHRzY29yZSAgICAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHNlYXJjaCkgeyAuLi4gfVxuXHRcdG9uSW5pdGlhbGl6ZSAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oKSB7IC4uLiB9XG5cdFx0b25DaGFuZ2UgICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbih2YWx1ZSkgeyAuLi4gfVxuXHRcdG9uSXRlbUFkZCAgICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWUsICRpdGVtKSB7IC4uLiB9XG5cdFx0b25JdGVtUmVtb3ZlICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbih2YWx1ZSkgeyAuLi4gfVxuXHRcdG9uQ2xlYXIgICAgICAgICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oKSB7IC4uLiB9XG5cdFx0b25PcHRpb25BZGQgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbih2YWx1ZSwgZGF0YSkgeyAuLi4gfVxuXHRcdG9uT3B0aW9uUmVtb3ZlICAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24odmFsdWUpIHsgLi4uIH1cblx0XHRvbk9wdGlvbkNsZWFyICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKCkgeyAuLi4gfVxuXHRcdG9uT3B0aW9uR3JvdXBBZGQgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oaWQsIGRhdGEpIHsgLi4uIH1cblx0XHRvbk9wdGlvbkdyb3VwUmVtb3ZlICA6IG51bGwsIC8vIGZ1bmN0aW9uKGlkKSB7IC4uLiB9XG5cdFx0b25PcHRpb25Hcm91cENsZWFyICAgOiBudWxsLCAvLyBmdW5jdGlvbigpIHsgLi4uIH1cblx0XHRvbkRyb3Bkb3duT3BlbiAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKCRkcm9wZG93bikgeyAuLi4gfVxuXHRcdG9uRHJvcGRvd25DbG9zZSAgICAgIDogbnVsbCwgLy8gZnVuY3Rpb24oJGRyb3Bkb3duKSB7IC4uLiB9XG5cdFx0b25UeXBlICAgICAgICAgICAgICAgOiBudWxsLCAvLyBmdW5jdGlvbihzdHIpIHsgLi4uIH1cblx0XHRvbkRlbGV0ZSAgICAgICAgICAgICA6IG51bGwsIC8vIGZ1bmN0aW9uKHZhbHVlcykgeyAuLi4gfVxuXHRcdCovXG5cdFxuXHRcdHJlbmRlcjoge1xuXHRcdFx0Lypcblx0XHRcdGl0ZW06IG51bGwsXG5cdFx0XHRvcHRncm91cDogbnVsbCxcblx0XHRcdG9wdGdyb3VwX2hlYWRlcjogbnVsbCxcblx0XHRcdG9wdGlvbjogbnVsbCxcblx0XHRcdG9wdGlvbl9jcmVhdGU6IG51bGxcblx0XHRcdCovXG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdCQuZm4uc2VsZWN0aXplID0gZnVuY3Rpb24oc2V0dGluZ3NfdXNlcikge1xuXHRcdHZhciBkZWZhdWx0cyAgICAgICAgICAgICA9ICQuZm4uc2VsZWN0aXplLmRlZmF1bHRzO1xuXHRcdHZhciBzZXR0aW5ncyAgICAgICAgICAgICA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgc2V0dGluZ3NfdXNlcik7XG5cdFx0dmFyIGF0dHJfZGF0YSAgICAgICAgICAgID0gc2V0dGluZ3MuZGF0YUF0dHI7XG5cdFx0dmFyIGZpZWxkX2xhYmVsICAgICAgICAgID0gc2V0dGluZ3MubGFiZWxGaWVsZDtcblx0XHR2YXIgZmllbGRfdmFsdWUgICAgICAgICAgPSBzZXR0aW5ncy52YWx1ZUZpZWxkO1xuXHRcdHZhciBmaWVsZF9vcHRncm91cCAgICAgICA9IHNldHRpbmdzLm9wdGdyb3VwRmllbGQ7XG5cdFx0dmFyIGZpZWxkX29wdGdyb3VwX2xhYmVsID0gc2V0dGluZ3Mub3B0Z3JvdXBMYWJlbEZpZWxkO1xuXHRcdHZhciBmaWVsZF9vcHRncm91cF92YWx1ZSA9IHNldHRpbmdzLm9wdGdyb3VwVmFsdWVGaWVsZDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZXMgc2VsZWN0aXplIGZyb20gYSA8aW5wdXQgdHlwZT1cInRleHRcIj4gZWxlbWVudC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSAkaW5wdXRcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NfZWxlbWVudFxuXHRcdCAqL1xuXHRcdHZhciBpbml0X3RleHRib3ggPSBmdW5jdGlvbigkaW5wdXQsIHNldHRpbmdzX2VsZW1lbnQpIHtcblx0XHRcdHZhciBpLCBuLCB2YWx1ZXMsIG9wdGlvbjtcblx0XG5cdFx0XHR2YXIgZGF0YV9yYXcgPSAkaW5wdXQuYXR0cihhdHRyX2RhdGEpO1xuXHRcblx0XHRcdGlmICghZGF0YV9yYXcpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gJC50cmltKCRpbnB1dC52YWwoKSB8fCAnJyk7XG5cdFx0XHRcdGlmICghc2V0dGluZ3MuYWxsb3dFbXB0eU9wdGlvbiAmJiAhdmFsdWUubGVuZ3RoKSByZXR1cm47XG5cdFx0XHRcdHZhbHVlcyA9IHZhbHVlLnNwbGl0KHNldHRpbmdzLmRlbGltaXRlcik7XG5cdFx0XHRcdGZvciAoaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0ge307XG5cdFx0XHRcdFx0b3B0aW9uW2ZpZWxkX2xhYmVsXSA9IHZhbHVlc1tpXTtcblx0XHRcdFx0XHRvcHRpb25bZmllbGRfdmFsdWVdID0gdmFsdWVzW2ldO1xuXHRcdFx0XHRcdHNldHRpbmdzX2VsZW1lbnQub3B0aW9ucy5wdXNoKG9wdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0dGluZ3NfZWxlbWVudC5pdGVtcyA9IHZhbHVlcztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNldHRpbmdzX2VsZW1lbnQub3B0aW9ucyA9IEpTT04ucGFyc2UoZGF0YV9yYXcpO1xuXHRcdFx0XHRmb3IgKGkgPSAwLCBuID0gc2V0dGluZ3NfZWxlbWVudC5vcHRpb25zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRcdHNldHRpbmdzX2VsZW1lbnQuaXRlbXMucHVzaChzZXR0aW5nc19lbGVtZW50Lm9wdGlvbnNbaV1bZmllbGRfdmFsdWVdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemVzIHNlbGVjdGl6ZSBmcm9tIGEgPHNlbGVjdD4gZWxlbWVudC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSAkaW5wdXRcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NfZWxlbWVudFxuXHRcdCAqL1xuXHRcdHZhciBpbml0X3NlbGVjdCA9IGZ1bmN0aW9uKCRpbnB1dCwgc2V0dGluZ3NfZWxlbWVudCkge1xuXHRcdFx0dmFyIGksIG4sIHRhZ05hbWUsICRjaGlsZHJlbiwgb3JkZXIgPSAwO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBzZXR0aW5nc19lbGVtZW50Lm9wdGlvbnM7XG5cdFx0XHR2YXIgb3B0aW9uc01hcCA9IHt9O1xuXHRcblx0XHRcdHZhciByZWFkRGF0YSA9IGZ1bmN0aW9uKCRlbCkge1xuXHRcdFx0XHR2YXIgZGF0YSA9IGF0dHJfZGF0YSAmJiAkZWwuYXR0cihhdHRyX2RhdGEpO1xuXHRcdFx0XHRpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmIGRhdGEubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9O1xuXHRcblx0XHRcdHZhciBhZGRPcHRpb24gPSBmdW5jdGlvbigkb3B0aW9uLCBncm91cCkge1xuXHRcdFx0XHQkb3B0aW9uID0gJCgkb3B0aW9uKTtcblx0XG5cdFx0XHRcdHZhciB2YWx1ZSA9IGhhc2hfa2V5KCRvcHRpb24udmFsKCkpO1xuXHRcdFx0XHRpZiAoIXZhbHVlICYmICFzZXR0aW5ncy5hbGxvd0VtcHR5T3B0aW9uKSByZXR1cm47XG5cdFxuXHRcdFx0XHQvLyBpZiB0aGUgb3B0aW9uIGFscmVhZHkgZXhpc3RzLCBpdCdzIHByb2JhYmx5IGJlZW5cblx0XHRcdFx0Ly8gZHVwbGljYXRlZCBpbiBhbm90aGVyIG9wdGdyb3VwLiBpbiB0aGlzIGNhc2UsIHB1c2hcblx0XHRcdFx0Ly8gdGhlIGN1cnJlbnQgZ3JvdXAgdG8gdGhlIFwib3B0Z3JvdXBcIiBwcm9wZXJ0eSBvbiB0aGVcblx0XHRcdFx0Ly8gZXhpc3Rpbmcgb3B0aW9uIHNvIHRoYXQgaXQncyByZW5kZXJlZCBpbiBib3RoIHBsYWNlcy5cblx0XHRcdFx0aWYgKG9wdGlvbnNNYXAuaGFzT3duUHJvcGVydHkodmFsdWUpKSB7XG5cdFx0XHRcdFx0aWYgKGdyb3VwKSB7XG5cdFx0XHRcdFx0XHR2YXIgYXJyID0gb3B0aW9uc01hcFt2YWx1ZV1bZmllbGRfb3B0Z3JvdXBdO1xuXHRcdFx0XHRcdFx0aWYgKCFhcnIpIHtcblx0XHRcdFx0XHRcdFx0b3B0aW9uc01hcFt2YWx1ZV1bZmllbGRfb3B0Z3JvdXBdID0gZ3JvdXA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCEkLmlzQXJyYXkoYXJyKSkge1xuXHRcdFx0XHRcdFx0XHRvcHRpb25zTWFwW3ZhbHVlXVtmaWVsZF9vcHRncm91cF0gPSBbYXJyLCBncm91cF07XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRhcnIucHVzaChncm91cCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0dmFyIG9wdGlvbiAgICAgICAgICAgICA9IHJlYWREYXRhKCRvcHRpb24pIHx8IHt9O1xuXHRcdFx0XHRvcHRpb25bZmllbGRfbGFiZWxdICAgID0gb3B0aW9uW2ZpZWxkX2xhYmVsXSB8fCAkb3B0aW9uLnRleHQoKTtcblx0XHRcdFx0b3B0aW9uW2ZpZWxkX3ZhbHVlXSAgICA9IG9wdGlvbltmaWVsZF92YWx1ZV0gfHwgdmFsdWU7XG5cdFx0XHRcdG9wdGlvbltmaWVsZF9vcHRncm91cF0gPSBvcHRpb25bZmllbGRfb3B0Z3JvdXBdIHx8IGdyb3VwO1xuXHRcblx0XHRcdFx0b3B0aW9uc01hcFt2YWx1ZV0gPSBvcHRpb247XG5cdFx0XHRcdG9wdGlvbnMucHVzaChvcHRpb24pO1xuXHRcblx0XHRcdFx0aWYgKCRvcHRpb24uaXMoJzpzZWxlY3RlZCcpKSB7XG5cdFx0XHRcdFx0c2V0dGluZ3NfZWxlbWVudC5pdGVtcy5wdXNoKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XG5cdFx0XHR2YXIgYWRkR3JvdXAgPSBmdW5jdGlvbigkb3B0Z3JvdXApIHtcblx0XHRcdFx0dmFyIGksIG4sIGlkLCBvcHRncm91cCwgJG9wdGlvbnM7XG5cdFxuXHRcdFx0XHQkb3B0Z3JvdXAgPSAkKCRvcHRncm91cCk7XG5cdFx0XHRcdGlkID0gJG9wdGdyb3VwLmF0dHIoJ2xhYmVsJyk7XG5cdFxuXHRcdFx0XHRpZiAoaWQpIHtcblx0XHRcdFx0XHRvcHRncm91cCA9IHJlYWREYXRhKCRvcHRncm91cCkgfHwge307XG5cdFx0XHRcdFx0b3B0Z3JvdXBbZmllbGRfb3B0Z3JvdXBfbGFiZWxdID0gaWQ7XG5cdFx0XHRcdFx0b3B0Z3JvdXBbZmllbGRfb3B0Z3JvdXBfdmFsdWVdID0gaWQ7XG5cdFx0XHRcdFx0c2V0dGluZ3NfZWxlbWVudC5vcHRncm91cHMucHVzaChvcHRncm91cCk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdCRvcHRpb25zID0gJCgnb3B0aW9uJywgJG9wdGdyb3VwKTtcblx0XHRcdFx0Zm9yIChpID0gMCwgbiA9ICRvcHRpb25zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRcdGFkZE9wdGlvbigkb3B0aW9uc1tpXSwgaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcblx0XHRcdHNldHRpbmdzX2VsZW1lbnQubWF4SXRlbXMgPSAkaW5wdXQuYXR0cignbXVsdGlwbGUnKSA/IG51bGwgOiAxO1xuXHRcblx0XHRcdCRjaGlsZHJlbiA9ICRpbnB1dC5jaGlsZHJlbigpO1xuXHRcdFx0Zm9yIChpID0gMCwgbiA9ICRjaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0dGFnTmFtZSA9ICRjaGlsZHJlbltpXS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdGlmICh0YWdOYW1lID09PSAnb3B0Z3JvdXAnKSB7XG5cdFx0XHRcdFx0YWRkR3JvdXAoJGNoaWxkcmVuW2ldKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0YWdOYW1lID09PSAnb3B0aW9uJykge1xuXHRcdFx0XHRcdGFkZE9wdGlvbigkY2hpbGRyZW5baV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLnNlbGVjdGl6ZSkgcmV0dXJuO1xuXHRcblx0XHRcdHZhciBpbnN0YW5jZTtcblx0XHRcdHZhciAkaW5wdXQgPSAkKHRoaXMpO1xuXHRcdFx0dmFyIHRhZ19uYW1lID0gdGhpcy50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR2YXIgcGxhY2Vob2xkZXIgPSAkaW5wdXQuYXR0cigncGxhY2Vob2xkZXInKSB8fCAkaW5wdXQuYXR0cignZGF0YS1wbGFjZWhvbGRlcicpO1xuXHRcdFx0aWYgKCFwbGFjZWhvbGRlciAmJiAhc2V0dGluZ3MuYWxsb3dFbXB0eU9wdGlvbikge1xuXHRcdFx0XHRwbGFjZWhvbGRlciA9ICRpbnB1dC5jaGlsZHJlbignb3B0aW9uW3ZhbHVlPVwiXCJdJykudGV4dCgpO1xuXHRcdFx0fVxuXHRcblx0XHRcdHZhciBzZXR0aW5nc19lbGVtZW50ID0ge1xuXHRcdFx0XHQncGxhY2Vob2xkZXInIDogcGxhY2Vob2xkZXIsXG5cdFx0XHRcdCdvcHRpb25zJyAgICAgOiBbXSxcblx0XHRcdFx0J29wdGdyb3VwcycgICA6IFtdLFxuXHRcdFx0XHQnaXRlbXMnICAgICAgIDogW11cblx0XHRcdH07XG5cdFxuXHRcdFx0aWYgKHRhZ19uYW1lID09PSAnc2VsZWN0Jykge1xuXHRcdFx0XHRpbml0X3NlbGVjdCgkaW5wdXQsIHNldHRpbmdzX2VsZW1lbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5pdF90ZXh0Ym94KCRpbnB1dCwgc2V0dGluZ3NfZWxlbWVudCk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aW5zdGFuY2UgPSBuZXcgU2VsZWN0aXplKCRpbnB1dCwgJC5leHRlbmQodHJ1ZSwge30sIGRlZmF1bHRzLCBzZXR0aW5nc19lbGVtZW50LCBzZXR0aW5nc191c2VyKSk7XG5cdFx0fSk7XG5cdH07XG5cdFxuXHQkLmZuLnNlbGVjdGl6ZS5kZWZhdWx0cyA9IFNlbGVjdGl6ZS5kZWZhdWx0cztcblx0JC5mbi5zZWxlY3RpemUuc3VwcG9ydCA9IHtcblx0XHR2YWxpZGl0eTogU1VQUE9SVFNfVkFMSURJVFlfQVBJXG5cdH07XG5cdFxuXHRcblx0U2VsZWN0aXplLmRlZmluZSgnZHJhZ19kcm9wJywgZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdGlmICghJC5mbi5zb3J0YWJsZSkgdGhyb3cgbmV3IEVycm9yKCdUaGUgXCJkcmFnX2Ryb3BcIiBwbHVnaW4gcmVxdWlyZXMgalF1ZXJ5IFVJIFwic29ydGFibGVcIi4nKTtcblx0XHRpZiAodGhpcy5zZXR0aW5ncy5tb2RlICE9PSAnbXVsdGknKSByZXR1cm47XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0XHRzZWxmLmxvY2sgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWwgPSBzZWxmLmxvY2s7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzb3J0YWJsZSA9IHNlbGYuJGNvbnRyb2wuZGF0YSgnc29ydGFibGUnKTtcblx0XHRcdFx0aWYgKHNvcnRhYmxlKSBzb3J0YWJsZS5kaXNhYmxlKCk7XG5cdFx0XHRcdHJldHVybiBvcmlnaW5hbC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXHRcdFx0fTtcblx0XHR9KSgpO1xuXHRcblx0XHRzZWxmLnVubG9jayA9IChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvcmlnaW5hbCA9IHNlbGYudW5sb2NrO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc29ydGFibGUgPSBzZWxmLiRjb250cm9sLmRhdGEoJ3NvcnRhYmxlJyk7XG5cdFx0XHRcdGlmIChzb3J0YWJsZSkgc29ydGFibGUuZW5hYmxlKCk7XG5cdFx0XHRcdHJldHVybiBvcmlnaW5hbC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXHRcdFx0fTtcblx0XHR9KSgpO1xuXHRcblx0XHRzZWxmLnNldHVwID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9yaWdpbmFsID0gc2VsZi5zZXR1cDtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0b3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XG5cdFx0XHRcdHZhciAkY29udHJvbCA9IHNlbGYuJGNvbnRyb2wuc29ydGFibGUoe1xuXHRcdFx0XHRcdGl0ZW1zOiAnW2RhdGEtdmFsdWVdJyxcblx0XHRcdFx0XHRmb3JjZVBsYWNlaG9sZGVyU2l6ZTogdHJ1ZSxcblx0XHRcdFx0XHRkaXNhYmxlZDogc2VsZi5pc0xvY2tlZCxcblx0XHRcdFx0XHRzdGFydDogZnVuY3Rpb24oZSwgdWkpIHtcblx0XHRcdFx0XHRcdHVpLnBsYWNlaG9sZGVyLmNzcygnd2lkdGgnLCB1aS5oZWxwZXIuY3NzKCd3aWR0aCcpKTtcblx0XHRcdFx0XHRcdCRjb250cm9sLmNzcyh7b3ZlcmZsb3c6ICd2aXNpYmxlJ30pO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHQkY29udHJvbC5jc3Moe292ZXJmbG93OiAnaGlkZGVuJ30pO1xuXHRcdFx0XHRcdFx0dmFyIGFjdGl2ZSA9IHNlbGYuJGFjdGl2ZUl0ZW1zID8gc2VsZi4kYWN0aXZlSXRlbXMuc2xpY2UoKSA6IG51bGw7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gW107XG5cdFx0XHRcdFx0XHQkY29udHJvbC5jaGlsZHJlbignW2RhdGEtdmFsdWVdJykuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goJCh0aGlzKS5hdHRyKCdkYXRhLXZhbHVlJykpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRzZWxmLnNldFZhbHVlKHZhbHVlcyk7XG5cdFx0XHRcdFx0XHRzZWxmLnNldEFjdGl2ZUl0ZW0oYWN0aXZlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblx0XHR9KSgpO1xuXHRcblx0fSk7XG5cdFxuXHRTZWxlY3RpemUuZGVmaW5lKCdkcm9wZG93bl9oZWFkZXInLCBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0XHRvcHRpb25zID0gJC5leHRlbmQoe1xuXHRcdFx0dGl0bGUgICAgICAgICA6ICdVbnRpdGxlZCcsXG5cdFx0XHRoZWFkZXJDbGFzcyAgIDogJ3NlbGVjdGl6ZS1kcm9wZG93bi1oZWFkZXInLFxuXHRcdFx0dGl0bGVSb3dDbGFzcyA6ICdzZWxlY3RpemUtZHJvcGRvd24taGVhZGVyLXRpdGxlJyxcblx0XHRcdGxhYmVsQ2xhc3MgICAgOiAnc2VsZWN0aXplLWRyb3Bkb3duLWhlYWRlci1sYWJlbCcsXG5cdFx0XHRjbG9zZUNsYXNzICAgIDogJ3NlbGVjdGl6ZS1kcm9wZG93bi1oZWFkZXItY2xvc2UnLFxuXHRcblx0XHRcdGh0bWw6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cIicgKyBkYXRhLmhlYWRlckNsYXNzICsgJ1wiPicgK1xuXHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCInICsgZGF0YS50aXRsZVJvd0NsYXNzICsgJ1wiPicgK1xuXHRcdFx0XHRcdFx0XHQnPHNwYW4gY2xhc3M9XCInICsgZGF0YS5sYWJlbENsYXNzICsgJ1wiPicgKyBkYXRhLnRpdGxlICsgJzwvc3Bhbj4nICtcblx0XHRcdFx0XHRcdFx0JzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBjbGFzcz1cIicgKyBkYXRhLmNsb3NlQ2xhc3MgKyAnXCI+JnRpbWVzOzwvYT4nICtcblx0XHRcdFx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdFx0XHQnPC9kaXY+J1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0sIG9wdGlvbnMpO1xuXHRcblx0XHRzZWxmLnNldHVwID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9yaWdpbmFsID0gc2VsZi5zZXR1cDtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0b3JpZ2luYWwuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcblx0XHRcdFx0c2VsZi4kZHJvcGRvd25faGVhZGVyID0gJChvcHRpb25zLmh0bWwob3B0aW9ucykpO1xuXHRcdFx0XHRzZWxmLiRkcm9wZG93bi5wcmVwZW5kKHNlbGYuJGRyb3Bkb3duX2hlYWRlcik7XG5cdFx0XHR9O1xuXHRcdH0pKCk7XG5cdFxuXHR9KTtcblx0XG5cdFNlbGVjdGl6ZS5kZWZpbmUoJ29wdGdyb3VwX2NvbHVtbnMnLCBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0XHRvcHRpb25zID0gJC5leHRlbmQoe1xuXHRcdFx0ZXF1YWxpemVXaWR0aCAgOiB0cnVlLFxuXHRcdFx0ZXF1YWxpemVIZWlnaHQgOiB0cnVlXG5cdFx0fSwgb3B0aW9ucyk7XG5cdFxuXHRcdHRoaXMuZ2V0QWRqYWNlbnRPcHRpb24gPSBmdW5jdGlvbigkb3B0aW9uLCBkaXJlY3Rpb24pIHtcblx0XHRcdHZhciAkb3B0aW9ucyA9ICRvcHRpb24uY2xvc2VzdCgnW2RhdGEtZ3JvdXBdJykuZmluZCgnW2RhdGEtc2VsZWN0YWJsZV0nKTtcblx0XHRcdHZhciBpbmRleCAgICA9ICRvcHRpb25zLmluZGV4KCRvcHRpb24pICsgZGlyZWN0aW9uO1xuXHRcblx0XHRcdHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgJG9wdGlvbnMubGVuZ3RoID8gJG9wdGlvbnMuZXEoaW5kZXgpIDogJCgpO1xuXHRcdH07XG5cdFxuXHRcdHRoaXMub25LZXlEb3duID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9yaWdpbmFsID0gc2VsZi5vbktleURvd247XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHR2YXIgaW5kZXgsICRvcHRpb24sICRvcHRpb25zLCAkb3B0Z3JvdXA7XG5cdFxuXHRcdFx0XHRpZiAodGhpcy5pc09wZW4gJiYgKGUua2V5Q29kZSA9PT0gS0VZX0xFRlQgfHwgZS5rZXlDb2RlID09PSBLRVlfUklHSFQpKSB7XG5cdFx0XHRcdFx0c2VsZi5pZ25vcmVIb3ZlciA9IHRydWU7XG5cdFx0XHRcdFx0JG9wdGdyb3VwID0gdGhpcy4kYWN0aXZlT3B0aW9uLmNsb3Nlc3QoJ1tkYXRhLWdyb3VwXScpO1xuXHRcdFx0XHRcdGluZGV4ID0gJG9wdGdyb3VwLmZpbmQoJ1tkYXRhLXNlbGVjdGFibGVdJykuaW5kZXgodGhpcy4kYWN0aXZlT3B0aW9uKTtcblx0XG5cdFx0XHRcdFx0aWYoZS5rZXlDb2RlID09PSBLRVlfTEVGVCkge1xuXHRcdFx0XHRcdFx0JG9wdGdyb3VwID0gJG9wdGdyb3VwLnByZXYoJ1tkYXRhLWdyb3VwXScpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQkb3B0Z3JvdXAgPSAkb3B0Z3JvdXAubmV4dCgnW2RhdGEtZ3JvdXBdJyk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQkb3B0aW9ucyA9ICRvcHRncm91cC5maW5kKCdbZGF0YS1zZWxlY3RhYmxlXScpO1xuXHRcdFx0XHRcdCRvcHRpb24gID0gJG9wdGlvbnMuZXEoTWF0aC5taW4oJG9wdGlvbnMubGVuZ3RoIC0gMSwgaW5kZXgpKTtcblx0XHRcdFx0XHRpZiAoJG9wdGlvbi5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0QWN0aXZlT3B0aW9uKCRvcHRpb24pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fTtcblx0XHR9KSgpO1xuXHRcblx0XHR2YXIgZ2V0U2Nyb2xsYmFyV2lkdGggPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkaXY7XG5cdFx0XHR2YXIgd2lkdGggPSBnZXRTY3JvbGxiYXJXaWR0aC53aWR0aDtcblx0XHRcdHZhciBkb2MgPSBkb2N1bWVudDtcblx0XG5cdFx0XHRpZiAodHlwZW9mIHdpZHRoID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRcdGRpdi5pbm5lckhUTUwgPSAnPGRpdiBzdHlsZT1cIndpZHRoOjUwcHg7aGVpZ2h0OjUwcHg7cG9zaXRpb246YWJzb2x1dGU7bGVmdDotNTBweDt0b3A6LTUwcHg7b3ZlcmZsb3c6YXV0bztcIj48ZGl2IHN0eWxlPVwid2lkdGg6MXB4O2hlaWdodDoxMDBweDtcIj48L2Rpdj48L2Rpdj4nO1xuXHRcdFx0XHRkaXYgPSBkaXYuZmlyc3RDaGlsZDtcblx0XHRcdFx0ZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcblx0XHRcdFx0d2lkdGggPSBnZXRTY3JvbGxiYXJXaWR0aC53aWR0aCA9IGRpdi5vZmZzZXRXaWR0aCAtIGRpdi5jbGllbnRXaWR0aDtcblx0XHRcdFx0ZG9jLmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB3aWR0aDtcblx0XHR9O1xuXHRcblx0XHR2YXIgZXF1YWxpemVTaXplcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGksIG4sIGhlaWdodF9tYXgsIHdpZHRoLCB3aWR0aF9sYXN0LCB3aWR0aF9wYXJlbnQsICRvcHRncm91cHM7XG5cdFxuXHRcdFx0JG9wdGdyb3VwcyA9ICQoJ1tkYXRhLWdyb3VwXScsIHNlbGYuJGRyb3Bkb3duX2NvbnRlbnQpO1xuXHRcdFx0biA9ICRvcHRncm91cHMubGVuZ3RoO1xuXHRcdFx0aWYgKCFuIHx8ICFzZWxmLiRkcm9wZG93bl9jb250ZW50LndpZHRoKCkpIHJldHVybjtcblx0XG5cdFx0XHRpZiAob3B0aW9ucy5lcXVhbGl6ZUhlaWdodCkge1xuXHRcdFx0XHRoZWlnaHRfbWF4ID0gMDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRcdGhlaWdodF9tYXggPSBNYXRoLm1heChoZWlnaHRfbWF4LCAkb3B0Z3JvdXBzLmVxKGkpLmhlaWdodCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkb3B0Z3JvdXBzLmNzcyh7aGVpZ2h0OiBoZWlnaHRfbWF4fSk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKG9wdGlvbnMuZXF1YWxpemVXaWR0aCkge1xuXHRcdFx0XHR3aWR0aF9wYXJlbnQgPSBzZWxmLiRkcm9wZG93bl9jb250ZW50LmlubmVyV2lkdGgoKSAtIGdldFNjcm9sbGJhcldpZHRoKCk7XG5cdFx0XHRcdHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aF9wYXJlbnQgLyBuKTtcblx0XHRcdFx0JG9wdGdyb3Vwcy5jc3Moe3dpZHRoOiB3aWR0aH0pO1xuXHRcdFx0XHRpZiAobiA+IDEpIHtcblx0XHRcdFx0XHR3aWR0aF9sYXN0ID0gd2lkdGhfcGFyZW50IC0gd2lkdGggKiAobiAtIDEpO1xuXHRcdFx0XHRcdCRvcHRncm91cHMuZXEobiAtIDEpLmNzcyh7d2lkdGg6IHdpZHRoX2xhc3R9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdGlmIChvcHRpb25zLmVxdWFsaXplSGVpZ2h0IHx8IG9wdGlvbnMuZXF1YWxpemVXaWR0aCkge1xuXHRcdFx0aG9vay5hZnRlcih0aGlzLCAncG9zaXRpb25Ecm9wZG93bicsIGVxdWFsaXplU2l6ZXMpO1xuXHRcdFx0aG9vay5hZnRlcih0aGlzLCAncmVmcmVzaE9wdGlvbnMnLCBlcXVhbGl6ZVNpemVzKTtcblx0XHR9XG5cdFxuXHRcblx0fSk7XG5cdFxuXHRTZWxlY3RpemUuZGVmaW5lKCdyZW1vdmVfYnV0dG9uJywgZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSAkLmV4dGVuZCh7XG5cdFx0XHRcdGxhYmVsICAgICA6ICcmdGltZXM7Jyxcblx0XHRcdFx0dGl0bGUgICAgIDogJ1JlbW92ZScsXG5cdFx0XHRcdGNsYXNzTmFtZSA6ICdyZW1vdmUnLFxuXHRcdFx0XHRhcHBlbmQgICAgOiB0cnVlXG5cdFx0XHR9LCBvcHRpb25zKTtcblx0XG5cdFx0XHR2YXIgc2luZ2xlQ2xvc2UgPSBmdW5jdGlvbih0aGlzUmVmLCBvcHRpb25zKSB7XG5cdFxuXHRcdFx0XHRvcHRpb25zLmNsYXNzTmFtZSA9ICdyZW1vdmUtc2luZ2xlJztcblx0XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpc1JlZjtcblx0XHRcdFx0dmFyIGh0bWwgPSAnPGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiIGNsYXNzPVwiJyArIG9wdGlvbnMuY2xhc3NOYW1lICsgJ1wiIHRhYmluZGV4PVwiLTFcIiB0aXRsZT1cIicgKyBlc2NhcGVfaHRtbChvcHRpb25zLnRpdGxlKSArICdcIj4nICsgb3B0aW9ucy5sYWJlbCArICc8L2E+Jztcblx0XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBBcHBlbmRzIGFuIGVsZW1lbnQgYXMgYSBjaGlsZCAod2l0aCByYXcgSFRNTCkuXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sX2NvbnRhaW5lclxuXHRcdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbF9lbGVtZW50XG5cdFx0XHRcdCAqIEByZXR1cm4ge3N0cmluZ31cblx0XHRcdFx0ICovXG5cdFx0XHRcdHZhciBhcHBlbmQgPSBmdW5jdGlvbihodG1sX2NvbnRhaW5lciwgaHRtbF9lbGVtZW50KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGh0bWxfY29udGFpbmVyICsgaHRtbF9lbGVtZW50O1xuXHRcdFx0XHR9O1xuXHRcblx0XHRcdFx0dGhpc1JlZi5zZXR1cCA9IChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgb3JpZ2luYWwgPSBzZWxmLnNldHVwO1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdC8vIG92ZXJyaWRlIHRoZSBpdGVtIHJlbmRlcmluZyBtZXRob2QgdG8gYWRkIHRoZSBidXR0b24gdG8gZWFjaFxuXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMuYXBwZW5kKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBpZCA9ICQoc2VsZi4kaW5wdXQuY29udGV4dCkuYXR0cignaWQnKTtcblx0XHRcdFx0XHRcdFx0dmFyIHNlbGVjdGl6ZXIgPSAkKCcjJytpZCk7XG5cdFxuXHRcdFx0XHRcdFx0XHR2YXIgcmVuZGVyX2l0ZW0gPSBzZWxmLnNldHRpbmdzLnJlbmRlci5pdGVtO1xuXHRcdFx0XHRcdFx0XHRzZWxmLnNldHRpbmdzLnJlbmRlci5pdGVtID0gZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBhcHBlbmQocmVuZGVyX2l0ZW0uYXBwbHkodGhpc1JlZiwgYXJndW1lbnRzKSwgaHRtbCk7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0b3JpZ2luYWwuYXBwbHkodGhpc1JlZiwgYXJndW1lbnRzKTtcblx0XG5cdFx0XHRcdFx0XHQvLyBhZGQgZXZlbnQgbGlzdGVuZXJcblx0XHRcdFx0XHRcdHRoaXNSZWYuJGNvbnRyb2wub24oJ2NsaWNrJywgJy4nICsgb3B0aW9ucy5jbGFzc05hbWUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoc2VsZi5pc0xvY2tlZCkgcmV0dXJuO1xuXHRcblx0XHRcdFx0XHRcdFx0c2VsZi5jbGVhcigpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0pKCk7XG5cdFx0XHR9O1xuXHRcblx0XHRcdHZhciBtdWx0aUNsb3NlID0gZnVuY3Rpb24odGhpc1JlZiwgb3B0aW9ucykge1xuXHRcblx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzUmVmO1xuXHRcdFx0XHR2YXIgaHRtbCA9ICc8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCIgY2xhc3M9XCInICsgb3B0aW9ucy5jbGFzc05hbWUgKyAnXCIgdGFiaW5kZXg9XCItMVwiIHRpdGxlPVwiJyArIGVzY2FwZV9odG1sKG9wdGlvbnMudGl0bGUpICsgJ1wiPicgKyBvcHRpb25zLmxhYmVsICsgJzwvYT4nO1xuXHRcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEFwcGVuZHMgYW4gZWxlbWVudCBhcyBhIGNoaWxkICh3aXRoIHJhdyBIVE1MKS5cblx0XHRcdFx0ICpcblx0XHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxfY29udGFpbmVyXG5cdFx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sX2VsZW1lbnRcblx0XHRcdFx0ICogQHJldHVybiB7c3RyaW5nfVxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dmFyIGFwcGVuZCA9IGZ1bmN0aW9uKGh0bWxfY29udGFpbmVyLCBodG1sX2VsZW1lbnQpIHtcblx0XHRcdFx0XHR2YXIgcG9zID0gaHRtbF9jb250YWluZXIuc2VhcmNoKC8oPFxcL1tePl0rPlxccyopJC8pO1xuXHRcdFx0XHRcdHJldHVybiBodG1sX2NvbnRhaW5lci5zdWJzdHJpbmcoMCwgcG9zKSArIGh0bWxfZWxlbWVudCArIGh0bWxfY29udGFpbmVyLnN1YnN0cmluZyhwb3MpO1xuXHRcdFx0XHR9O1xuXHRcblx0XHRcdFx0dGhpc1JlZi5zZXR1cCA9IChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgb3JpZ2luYWwgPSBzZWxmLnNldHVwO1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdC8vIG92ZXJyaWRlIHRoZSBpdGVtIHJlbmRlcmluZyBtZXRob2QgdG8gYWRkIHRoZSBidXR0b24gdG8gZWFjaFxuXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMuYXBwZW5kKSB7XG5cdFx0XHRcdFx0XHRcdHZhciByZW5kZXJfaXRlbSA9IHNlbGYuc2V0dGluZ3MucmVuZGVyLml0ZW07XG5cdFx0XHRcdFx0XHRcdHNlbGYuc2V0dGluZ3MucmVuZGVyLml0ZW0gPSBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGFwcGVuZChyZW5kZXJfaXRlbS5hcHBseSh0aGlzUmVmLCBhcmd1bWVudHMpLCBodG1sKTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRvcmlnaW5hbC5hcHBseSh0aGlzUmVmLCBhcmd1bWVudHMpO1xuXHRcblx0XHRcdFx0XHRcdC8vIGFkZCBldmVudCBsaXN0ZW5lclxuXHRcdFx0XHRcdFx0dGhpc1JlZi4kY29udHJvbC5vbignY2xpY2snLCAnLicgKyBvcHRpb25zLmNsYXNzTmFtZSwgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGlmIChzZWxmLmlzTG9ja2VkKSByZXR1cm47XG5cdFxuXHRcdFx0XHRcdFx0XHR2YXIgJGl0ZW0gPSAkKGUuY3VycmVudFRhcmdldCkucGFyZW50KCk7XG5cdFx0XHRcdFx0XHRcdHNlbGYuc2V0QWN0aXZlSXRlbSgkaXRlbSk7XG5cdFx0XHRcdFx0XHRcdGlmIChzZWxmLmRlbGV0ZVNlbGVjdGlvbigpKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2VsZi5zZXRDYXJldChzZWxmLml0ZW1zLmxlbmd0aCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9KSgpO1xuXHRcdFx0fTtcblx0XG5cdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5tb2RlID09PSAnc2luZ2xlJykge1xuXHRcdFx0XHRzaW5nbGVDbG9zZSh0aGlzLCBvcHRpb25zKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bXVsdGlDbG9zZSh0aGlzLCBvcHRpb25zKTtcblx0XHRcdH1cblx0fSk7XG5cdFxuXHRcblx0U2VsZWN0aXplLmRlZmluZSgncmVzdG9yZV9vbl9iYWNrc3BhY2UnLCBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0XHRvcHRpb25zLnRleHQgPSBvcHRpb25zLnRleHQgfHwgZnVuY3Rpb24ob3B0aW9uKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9uW3RoaXMuc2V0dGluZ3MubGFiZWxGaWVsZF07XG5cdFx0fTtcblx0XG5cdFx0dGhpcy5vbktleURvd24gPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWwgPSBzZWxmLm9uS2V5RG93bjtcblx0XHRcdHJldHVybiBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHZhciBpbmRleCwgb3B0aW9uO1xuXHRcdFx0XHRpZiAoZS5rZXlDb2RlID09PSBLRVlfQkFDS1NQQUNFICYmIHRoaXMuJGNvbnRyb2xfaW5wdXQudmFsKCkgPT09ICcnICYmICF0aGlzLiRhY3RpdmVJdGVtcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRpbmRleCA9IHRoaXMuY2FyZXRQb3MgLSAxO1xuXHRcdFx0XHRcdGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5pdGVtcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdG9wdGlvbiA9IHRoaXMub3B0aW9uc1t0aGlzLml0ZW1zW2luZGV4XV07XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5kZWxldGVTZWxlY3Rpb24oZSkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRUZXh0Ym94VmFsdWUob3B0aW9ucy50ZXh0LmFwcGx5KHRoaXMsIFtvcHRpb25dKSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMucmVmcmVzaE9wdGlvbnModHJ1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fTtcblx0XHR9KSgpO1xuXHR9KTtcblx0XG5cblx0cmV0dXJuIFNlbGVjdGl6ZTtcbn0pKTsiLCIvKipcbiAqIHNpZnRlci5qc1xuICogQ29weXJpZ2h0IChjKSAyMDEzIEJyaWFuIFJlYXZpcyAmIGNvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4gKiBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAYXV0aG9yIEJyaWFuIFJlYXZpcyA8YnJpYW5AdGhpcmRyb3V0ZS5jb20+XG4gKi9cblxuKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZShmYWN0b3J5KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fSBlbHNlIHtcblx0XHRyb290LlNpZnRlciA9IGZhY3RvcnkoKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbigpIHtcblxuXHQvKipcblx0ICogVGV4dHVhbGx5IHNlYXJjaGVzIGFycmF5cyBhbmQgaGFzaGVzIG9mIG9iamVjdHNcblx0ICogYnkgcHJvcGVydHkgKG9yIG11bHRpcGxlIHByb3BlcnRpZXMpLiBEZXNpZ25lZFxuXHQgKiBzcGVjaWZpY2FsbHkgZm9yIGF1dG9jb21wbGV0ZS5cblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBpdGVtc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gaXRlbXNcblx0ICovXG5cdHZhciBTaWZ0ZXIgPSBmdW5jdGlvbihpdGVtcywgc2V0dGluZ3MpIHtcblx0XHR0aGlzLml0ZW1zID0gaXRlbXM7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzIHx8IHtkaWFjcml0aWNzOiB0cnVlfTtcblx0fTtcblxuXHQvKipcblx0ICogU3BsaXRzIGEgc2VhcmNoIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIGluZGl2aWR1YWxcblx0ICogcmVnZXhwcyB0byBiZSB1c2VkIHRvIG1hdGNoIHJlc3VsdHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeVxuXHQgKiBAcmV0dXJucyB7YXJyYXl9XG5cdCAqL1xuXHRTaWZ0ZXIucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24ocXVlcnkpIHtcblx0XHRxdWVyeSA9IHRyaW0oU3RyaW5nKHF1ZXJ5IHx8ICcnKS50b0xvd2VyQ2FzZSgpKTtcblx0XHRpZiAoIXF1ZXJ5IHx8ICFxdWVyeS5sZW5ndGgpIHJldHVybiBbXTtcblxuXHRcdHZhciBpLCBuLCByZWdleCwgbGV0dGVyO1xuXHRcdHZhciB0b2tlbnMgPSBbXTtcblx0XHR2YXIgd29yZHMgPSBxdWVyeS5zcGxpdCgvICsvKTtcblxuXHRcdGZvciAoaSA9IDAsIG4gPSB3b3Jkcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdHJlZ2V4ID0gZXNjYXBlX3JlZ2V4KHdvcmRzW2ldKTtcblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmRpYWNyaXRpY3MpIHtcblx0XHRcdFx0Zm9yIChsZXR0ZXIgaW4gRElBQ1JJVElDUykge1xuXHRcdFx0XHRcdGlmIChESUFDUklUSUNTLmhhc093blByb3BlcnR5KGxldHRlcikpIHtcblx0XHRcdFx0XHRcdHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuZXcgUmVnRXhwKGxldHRlciwgJ2cnKSwgRElBQ1JJVElDU1tsZXR0ZXJdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0c3RyaW5nIDogd29yZHNbaV0sXG5cdFx0XHRcdHJlZ2V4ICA6IG5ldyBSZWdFeHAocmVnZXgsICdpJylcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0b2tlbnM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEl0ZXJhdGVzIG92ZXIgYXJyYXlzIGFuZCBoYXNoZXMuXG5cdCAqXG5cdCAqIGBgYFxuXHQgKiB0aGlzLml0ZXJhdG9yKHRoaXMuaXRlbXMsIGZ1bmN0aW9uKGl0ZW0sIGlkKSB7XG5cdCAqICAgIC8vIGludm9rZWQgZm9yIGVhY2ggaXRlbVxuXHQgKiB9KTtcblx0ICogYGBgXG5cdCAqXG5cdCAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBvYmplY3Rcblx0ICovXG5cdFNpZnRlci5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIGl0ZXJhdG9yO1xuXHRcdGlmIChpc19hcnJheShvYmplY3QpKSB7XG5cdFx0XHRpdGVyYXRvciA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoIHx8IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0XHRjYWxsYmFjayh0aGlzW2ldLCBpLCB0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aXRlcmF0b3IgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcykge1xuXHRcdFx0XHRcdGlmICh0aGlzLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKHRoaXNba2V5XSwga2V5LCB0aGlzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aXRlcmF0b3IuYXBwbHkob2JqZWN0LCBbY2FsbGJhY2tdKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgdG8gc2NvcmUgaW5kaXZpZHVhbCByZXN1bHRzLlxuXHQgKlxuXHQgKiBHb29kIG1hdGNoZXMgd2lsbCBoYXZlIGEgaGlnaGVyIHNjb3JlIHRoYW4gcG9vciBtYXRjaGVzLlxuXHQgKiBJZiBhbiBpdGVtIGlzIG5vdCBhIG1hdGNoLCAwIHdpbGwgYmUgcmV0dXJuZWQgYnkgdGhlIGZ1bmN0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IHNlYXJjaFxuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAob3B0aW9uYWwpXG5cdCAqIEByZXR1cm5zIHtmdW5jdGlvbn1cblx0ICovXG5cdFNpZnRlci5wcm90b3R5cGUuZ2V0U2NvcmVGdW5jdGlvbiA9IGZ1bmN0aW9uKHNlYXJjaCwgb3B0aW9ucykge1xuXHRcdHZhciBzZWxmLCBmaWVsZHMsIHRva2VucywgdG9rZW5fY291bnQsIG5lc3Rpbmc7XG5cblx0XHRzZWxmICAgICAgICA9IHRoaXM7XG5cdFx0c2VhcmNoICAgICAgPSBzZWxmLnByZXBhcmVTZWFyY2goc2VhcmNoLCBvcHRpb25zKTtcblx0XHR0b2tlbnMgICAgICA9IHNlYXJjaC50b2tlbnM7XG5cdFx0ZmllbGRzICAgICAgPSBzZWFyY2gub3B0aW9ucy5maWVsZHM7XG5cdFx0dG9rZW5fY291bnQgPSB0b2tlbnMubGVuZ3RoO1xuXHRcdG5lc3RpbmcgICAgID0gc2VhcmNoLm9wdGlvbnMubmVzdGluZztcblxuXHRcdC8qKlxuXHRcdCAqIENhbGN1bGF0ZXMgaG93IGNsb3NlIG9mIGEgbWF0Y2ggdGhlXG5cdFx0ICogZ2l2ZW4gdmFsdWUgaXMgYWdhaW5zdCBhIHNlYXJjaCB0b2tlbi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IHZhbHVlXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IHRva2VuXG5cdFx0ICogQHJldHVybiB7bnVtYmVyfVxuXHRcdCAqL1xuXHRcdHZhciBzY29yZVZhbHVlID0gZnVuY3Rpb24odmFsdWUsIHRva2VuKSB7XG5cdFx0XHR2YXIgc2NvcmUsIHBvcztcblxuXHRcdFx0aWYgKCF2YWx1ZSkgcmV0dXJuIDA7XG5cdFx0XHR2YWx1ZSA9IFN0cmluZyh2YWx1ZSB8fCAnJyk7XG5cdFx0XHRwb3MgPSB2YWx1ZS5zZWFyY2godG9rZW4ucmVnZXgpO1xuXHRcdFx0aWYgKHBvcyA9PT0gLTEpIHJldHVybiAwO1xuXHRcdFx0c2NvcmUgPSB0b2tlbi5zdHJpbmcubGVuZ3RoIC8gdmFsdWUubGVuZ3RoO1xuXHRcdFx0aWYgKHBvcyA9PT0gMCkgc2NvcmUgKz0gMC41O1xuXHRcdFx0cmV0dXJuIHNjb3JlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBDYWxjdWxhdGVzIHRoZSBzY29yZSBvZiBhbiBvYmplY3Rcblx0XHQgKiBhZ2FpbnN0IHRoZSBzZWFyY2ggcXVlcnkuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gdG9rZW5cblx0XHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuXHRcdCAqIEByZXR1cm4ge251bWJlcn1cblx0XHQgKi9cblx0XHR2YXIgc2NvcmVPYmplY3QgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZmllbGRfY291bnQgPSBmaWVsZHMubGVuZ3RoO1xuXHRcdFx0aWYgKCFmaWVsZF9jb3VudCkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGZpZWxkX2NvdW50ID09PSAxKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbih0b2tlbiwgZGF0YSkge1xuXHRcdFx0XHRcdHJldHVybiBzY29yZVZhbHVlKGdldGF0dHIoZGF0YSwgZmllbGRzWzBdLCBuZXN0aW5nKSwgdG9rZW4pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHRva2VuLCBkYXRhKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBzdW0gPSAwOyBpIDwgZmllbGRfY291bnQ7IGkrKykge1xuXHRcdFx0XHRcdHN1bSArPSBzY29yZVZhbHVlKGdldGF0dHIoZGF0YSwgZmllbGRzW2ldLCBuZXN0aW5nKSwgdG9rZW4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzdW0gLyBmaWVsZF9jb3VudDtcblx0XHRcdH07XG5cdFx0fSkoKTtcblxuXHRcdGlmICghdG9rZW5fY291bnQpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cdFx0fVxuXHRcdGlmICh0b2tlbl9jb3VudCA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0cmV0dXJuIHNjb3JlT2JqZWN0KHRva2Vuc1swXSwgZGF0YSk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGlmIChzZWFyY2gub3B0aW9ucy5jb25qdW5jdGlvbiA9PT0gJ2FuZCcpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdHZhciBzY29yZTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIHN1bSA9IDA7IGkgPCB0b2tlbl9jb3VudDsgaSsrKSB7XG5cdFx0XHRcdFx0c2NvcmUgPSBzY29yZU9iamVjdCh0b2tlbnNbaV0sIGRhdGEpO1xuXHRcdFx0XHRcdGlmIChzY29yZSA8PSAwKSByZXR1cm4gMDtcblx0XHRcdFx0XHRzdW0gKz0gc2NvcmU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHN1bSAvIHRva2VuX2NvdW50O1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIHN1bSA9IDA7IGkgPCB0b2tlbl9jb3VudDsgaSsrKSB7XG5cdFx0XHRcdFx0c3VtICs9IHNjb3JlT2JqZWN0KHRva2Vuc1tpXSwgZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHN1bSAvIHRva2VuX2NvdW50O1xuXHRcdFx0fTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbXBhcmUgdHdvXG5cdCAqIHJlc3VsdHMsIGZvciBzb3J0aW5nIHB1cnBvc2VzLiBJZiBubyBzb3J0aW5nIHNob3VsZFxuXHQgKiBiZSBwZXJmb3JtZWQsIGBudWxsYCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHNlYXJjaFxuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuXHQgKiBAcmV0dXJuIGZ1bmN0aW9uKGEsYilcblx0ICovXG5cdFNpZnRlci5wcm90b3R5cGUuZ2V0U29ydEZ1bmN0aW9uID0gZnVuY3Rpb24oc2VhcmNoLCBvcHRpb25zKSB7XG5cdFx0dmFyIGksIG4sIHNlbGYsIGZpZWxkLCBmaWVsZHMsIGZpZWxkc19jb3VudCwgbXVsdGlwbGllciwgbXVsdGlwbGllcnMsIGdldF9maWVsZCwgaW1wbGljaXRfc2NvcmUsIHNvcnQ7XG5cblx0XHRzZWxmICAgPSB0aGlzO1xuXHRcdHNlYXJjaCA9IHNlbGYucHJlcGFyZVNlYXJjaChzZWFyY2gsIG9wdGlvbnMpO1xuXHRcdHNvcnQgICA9ICghc2VhcmNoLnF1ZXJ5ICYmIG9wdGlvbnMuc29ydF9lbXB0eSkgfHwgb3B0aW9ucy5zb3J0O1xuXG5cdFx0LyoqXG5cdFx0ICogRmV0Y2hlcyB0aGUgc3BlY2lmaWVkIHNvcnQgZmllbGQgdmFsdWVcblx0XHQgKiBmcm9tIGEgc2VhcmNoIHJlc3VsdCBpdGVtLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG5cdFx0ICogQHBhcmFtICB7b2JqZWN0fSByZXN1bHRcblx0XHQgKiBAcmV0dXJuIHttaXhlZH1cblx0XHQgKi9cblx0XHRnZXRfZmllbGQgPSBmdW5jdGlvbihuYW1lLCByZXN1bHQpIHtcblx0XHRcdGlmIChuYW1lID09PSAnJHNjb3JlJykgcmV0dXJuIHJlc3VsdC5zY29yZTtcblx0XHRcdHJldHVybiBnZXRhdHRyKHNlbGYuaXRlbXNbcmVzdWx0LmlkXSwgbmFtZSwgb3B0aW9ucy5uZXN0aW5nKTtcblx0XHR9O1xuXG5cdFx0Ly8gcGFyc2Ugb3B0aW9uc1xuXHRcdGZpZWxkcyA9IFtdO1xuXHRcdGlmIChzb3J0KSB7XG5cdFx0XHRmb3IgKGkgPSAwLCBuID0gc29ydC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0aWYgKHNlYXJjaC5xdWVyeSB8fCBzb3J0W2ldLmZpZWxkICE9PSAnJHNjb3JlJykge1xuXHRcdFx0XHRcdGZpZWxkcy5wdXNoKHNvcnRbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIFwiJHNjb3JlXCIgZmllbGQgaXMgaW1wbGllZCB0byBiZSB0aGUgcHJpbWFyeVxuXHRcdC8vIHNvcnQgZmllbGQsIHVubGVzcyBpdCdzIG1hbnVhbGx5IHNwZWNpZmllZFxuXHRcdGlmIChzZWFyY2gucXVlcnkpIHtcblx0XHRcdGltcGxpY2l0X3Njb3JlID0gdHJ1ZTtcblx0XHRcdGZvciAoaSA9IDAsIG4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdGlmIChmaWVsZHNbaV0uZmllbGQgPT09ICckc2NvcmUnKSB7XG5cdFx0XHRcdFx0aW1wbGljaXRfc2NvcmUgPSBmYWxzZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGltcGxpY2l0X3Njb3JlKSB7XG5cdFx0XHRcdGZpZWxkcy51bnNoaWZ0KHtmaWVsZDogJyRzY29yZScsIGRpcmVjdGlvbjogJ2Rlc2MnfSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoaSA9IDAsIG4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdGlmIChmaWVsZHNbaV0uZmllbGQgPT09ICckc2NvcmUnKSB7XG5cdFx0XHRcdFx0ZmllbGRzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG11bHRpcGxpZXJzID0gW107XG5cdFx0Zm9yIChpID0gMCwgbiA9IGZpZWxkcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHRcdG11bHRpcGxpZXJzLnB1c2goZmllbGRzW2ldLmRpcmVjdGlvbiA9PT0gJ2Rlc2MnID8gLTEgOiAxKTtcblx0XHR9XG5cblx0XHQvLyBidWlsZCBmdW5jdGlvblxuXHRcdGZpZWxkc19jb3VudCA9IGZpZWxkcy5sZW5ndGg7XG5cdFx0aWYgKCFmaWVsZHNfY291bnQpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0gZWxzZSBpZiAoZmllbGRzX2NvdW50ID09PSAxKSB7XG5cdFx0XHRmaWVsZCA9IGZpZWxkc1swXS5maWVsZDtcblx0XHRcdG11bHRpcGxpZXIgPSBtdWx0aXBsaWVyc1swXTtcblx0XHRcdHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBtdWx0aXBsaWVyICogY21wKFxuXHRcdFx0XHRcdGdldF9maWVsZChmaWVsZCwgYSksXG5cdFx0XHRcdFx0Z2V0X2ZpZWxkKGZpZWxkLCBiKVxuXHRcdFx0XHQpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0dmFyIGksIHJlc3VsdCwgYV92YWx1ZSwgYl92YWx1ZSwgZmllbGQ7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBmaWVsZHNfY291bnQ7IGkrKykge1xuXHRcdFx0XHRcdGZpZWxkID0gZmllbGRzW2ldLmZpZWxkO1xuXHRcdFx0XHRcdHJlc3VsdCA9IG11bHRpcGxpZXJzW2ldICogY21wKFxuXHRcdFx0XHRcdFx0Z2V0X2ZpZWxkKGZpZWxkLCBhKSxcblx0XHRcdFx0XHRcdGdldF9maWVsZChmaWVsZCwgYilcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUGFyc2VzIGEgc2VhcmNoIHF1ZXJ5IGFuZCByZXR1cm5zIGFuIG9iamVjdFxuXHQgKiB3aXRoIHRva2VucyBhbmQgZmllbGRzIHJlYWR5IHRvIGJlIHBvcHVsYXRlZFxuXHQgKiB3aXRoIHJlc3VsdHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeVxuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuXHQgKiBAcmV0dXJucyB7b2JqZWN0fVxuXHQgKi9cblx0U2lmdGVyLnByb3RvdHlwZS5wcmVwYXJlU2VhcmNoID0gZnVuY3Rpb24ocXVlcnksIG9wdGlvbnMpIHtcblx0XHRpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0JykgcmV0dXJuIHF1ZXJ5O1xuXG5cdFx0b3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG5cblx0XHR2YXIgb3B0aW9uX2ZpZWxkcyAgICAgPSBvcHRpb25zLmZpZWxkcztcblx0XHR2YXIgb3B0aW9uX3NvcnQgICAgICAgPSBvcHRpb25zLnNvcnQ7XG5cdFx0dmFyIG9wdGlvbl9zb3J0X2VtcHR5ID0gb3B0aW9ucy5zb3J0X2VtcHR5O1xuXG5cdFx0aWYgKG9wdGlvbl9maWVsZHMgJiYgIWlzX2FycmF5KG9wdGlvbl9maWVsZHMpKSBvcHRpb25zLmZpZWxkcyA9IFtvcHRpb25fZmllbGRzXTtcblx0XHRpZiAob3B0aW9uX3NvcnQgJiYgIWlzX2FycmF5KG9wdGlvbl9zb3J0KSkgb3B0aW9ucy5zb3J0ID0gW29wdGlvbl9zb3J0XTtcblx0XHRpZiAob3B0aW9uX3NvcnRfZW1wdHkgJiYgIWlzX2FycmF5KG9wdGlvbl9zb3J0X2VtcHR5KSkgb3B0aW9ucy5zb3J0X2VtcHR5ID0gW29wdGlvbl9zb3J0X2VtcHR5XTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRvcHRpb25zIDogb3B0aW9ucyxcblx0XHRcdHF1ZXJ5ICAgOiBTdHJpbmcocXVlcnkgfHwgJycpLnRvTG93ZXJDYXNlKCksXG5cdFx0XHR0b2tlbnMgIDogdGhpcy50b2tlbml6ZShxdWVyeSksXG5cdFx0XHR0b3RhbCAgIDogMCxcblx0XHRcdGl0ZW1zICAgOiBbXVxuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIFNlYXJjaGVzIHRocm91Z2ggYWxsIGl0ZW1zIGFuZCByZXR1cm5zIGEgc29ydGVkIGFycmF5IG9mIG1hdGNoZXMuXG5cdCAqXG5cdCAqIFRoZSBgb3B0aW9uc2AgcGFyYW1ldGVyIGNhbiBjb250YWluOlxuXHQgKlxuXHQgKiAgIC0gZmllbGRzIHtzdHJpbmd8YXJyYXl9XG5cdCAqICAgLSBzb3J0IHthcnJheX1cblx0ICogICAtIHNjb3JlIHtmdW5jdGlvbn1cblx0ICogICAtIGZpbHRlciB7Ym9vbH1cblx0ICogICAtIGxpbWl0IHtpbnRlZ2VyfVxuXHQgKlxuXHQgKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nOlxuXHQgKlxuXHQgKiAgIC0gb3B0aW9ucyB7b2JqZWN0fVxuXHQgKiAgIC0gcXVlcnkge3N0cmluZ31cblx0ICogICAtIHRva2VucyB7YXJyYXl9XG5cdCAqICAgLSB0b3RhbCB7aW50fVxuXHQgKiAgIC0gaXRlbXMge2FycmF5fVxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcblx0ICogQHJldHVybnMge29iamVjdH1cblx0ICovXG5cdFNpZnRlci5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24ocXVlcnksIG9wdGlvbnMpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsIHZhbHVlLCBzY29yZSwgc2VhcmNoLCBjYWxjdWxhdGVTY29yZTtcblx0XHR2YXIgZm5fc29ydDtcblx0XHR2YXIgZm5fc2NvcmU7XG5cblx0XHRzZWFyY2ggID0gdGhpcy5wcmVwYXJlU2VhcmNoKHF1ZXJ5LCBvcHRpb25zKTtcblx0XHRvcHRpb25zID0gc2VhcmNoLm9wdGlvbnM7XG5cdFx0cXVlcnkgICA9IHNlYXJjaC5xdWVyeTtcblxuXHRcdC8vIGdlbmVyYXRlIHJlc3VsdCBzY29yaW5nIGZ1bmN0aW9uXG5cdFx0Zm5fc2NvcmUgPSBvcHRpb25zLnNjb3JlIHx8IHNlbGYuZ2V0U2NvcmVGdW5jdGlvbihzZWFyY2gpO1xuXG5cdFx0Ly8gcGVyZm9ybSBzZWFyY2ggYW5kIHNvcnRcblx0XHRpZiAocXVlcnkubGVuZ3RoKSB7XG5cdFx0XHRzZWxmLml0ZXJhdG9yKHNlbGYuaXRlbXMsIGZ1bmN0aW9uKGl0ZW0sIGlkKSB7XG5cdFx0XHRcdHNjb3JlID0gZm5fc2NvcmUoaXRlbSk7XG5cdFx0XHRcdGlmIChvcHRpb25zLmZpbHRlciA9PT0gZmFsc2UgfHwgc2NvcmUgPiAwKSB7XG5cdFx0XHRcdFx0c2VhcmNoLml0ZW1zLnB1c2goeydzY29yZSc6IHNjb3JlLCAnaWQnOiBpZH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2VsZi5pdGVyYXRvcihzZWxmLml0ZW1zLCBmdW5jdGlvbihpdGVtLCBpZCkge1xuXHRcdFx0XHRzZWFyY2guaXRlbXMucHVzaCh7J3Njb3JlJzogMSwgJ2lkJzogaWR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGZuX3NvcnQgPSBzZWxmLmdldFNvcnRGdW5jdGlvbihzZWFyY2gsIG9wdGlvbnMpO1xuXHRcdGlmIChmbl9zb3J0KSBzZWFyY2guaXRlbXMuc29ydChmbl9zb3J0KTtcblxuXHRcdC8vIGFwcGx5IGxpbWl0c1xuXHRcdHNlYXJjaC50b3RhbCA9IHNlYXJjaC5pdGVtcy5sZW5ndGg7XG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLmxpbWl0ID09PSAnbnVtYmVyJykge1xuXHRcdFx0c2VhcmNoLml0ZW1zID0gc2VhcmNoLml0ZW1zLnNsaWNlKDAsIG9wdGlvbnMubGltaXQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzZWFyY2g7XG5cdH07XG5cblx0Ly8gdXRpbGl0aWVzXG5cdC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblxuXHR2YXIgY21wID0gZnVuY3Rpb24oYSwgYikge1xuXHRcdGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGIgPT09ICdudW1iZXInKSB7XG5cdFx0XHRyZXR1cm4gYSA+IGIgPyAxIDogKGEgPCBiID8gLTEgOiAwKTtcblx0XHR9XG5cdFx0YSA9IGFzY2lpZm9sZChTdHJpbmcoYSB8fCAnJykpO1xuXHRcdGIgPSBhc2NpaWZvbGQoU3RyaW5nKGIgfHwgJycpKTtcblx0XHRpZiAoYSA+IGIpIHJldHVybiAxO1xuXHRcdGlmIChiID4gYSkgcmV0dXJuIC0xO1xuXHRcdHJldHVybiAwO1xuXHR9O1xuXG5cdHZhciBleHRlbmQgPSBmdW5jdGlvbihhLCBiKSB7XG5cdFx0dmFyIGksIG4sIGssIG9iamVjdDtcblx0XHRmb3IgKGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0b2JqZWN0ID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFvYmplY3QpIGNvbnRpbnVlO1xuXHRcdFx0Zm9yIChrIGluIG9iamVjdCkge1xuXHRcdFx0XHRpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGspKSB7XG5cdFx0XHRcdFx0YVtrXSA9IG9iamVjdFtrXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYTtcblx0fTtcblxuXHQvKipcblx0ICogQSBwcm9wZXJ0eSBnZXR0ZXIgcmVzb2x2aW5nIGRvdC1ub3RhdGlvblxuXHQgKiBAcGFyYW0gIHtPYmplY3R9ICBvYmogICAgIFRoZSByb290IG9iamVjdCB0byBmZXRjaCBwcm9wZXJ0eSBvblxuXHQgKiBAcGFyYW0gIHtTdHJpbmd9ICBuYW1lICAgIFRoZSBvcHRpb25hbGx5IGRvdHRlZCBwcm9wZXJ0eSBuYW1lIHRvIGZldGNoXG5cdCAqIEBwYXJhbSAge0Jvb2xlYW59IG5lc3RpbmcgSGFuZGxlIG5lc3Rpbmcgb3Igbm90XG5cdCAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgVGhlIHJlc29sdmVkIHByb3BlcnR5IHZhbHVlXG5cdCAqL1xuXHR2YXIgZ2V0YXR0ciA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgbmVzdGluZykge1xuXHQgICAgaWYgKCFvYmogfHwgIW5hbWUpIHJldHVybjtcblx0ICAgIGlmICghbmVzdGluZykgcmV0dXJuIG9ialtuYW1lXTtcblx0ICAgIHZhciBuYW1lcyA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuXHQgICAgd2hpbGUobmFtZXMubGVuZ3RoICYmIChvYmogPSBvYmpbbmFtZXMuc2hpZnQoKV0pKTtcblx0ICAgIHJldHVybiBvYmo7XG5cdH07XG5cblx0dmFyIHRyaW0gPSBmdW5jdGlvbihzdHIpIHtcblx0XHRyZXR1cm4gKHN0ciArICcnKS5yZXBsYWNlKC9eXFxzK3xcXHMrJHwvZywgJycpO1xuXHR9O1xuXG5cdHZhciBlc2NhcGVfcmVnZXggPSBmdW5jdGlvbihzdHIpIHtcblx0XHRyZXR1cm4gKHN0ciArICcnKS5yZXBsYWNlKC8oWy4/KiteJFtcXF1cXFxcKCl7fXwtXSkvZywgJ1xcXFwkMScpO1xuXHR9O1xuXG5cdHZhciBpc19hcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgKHR5cGVvZiAkICE9PSAndW5kZWZpbmVkJyAmJiAkLmlzQXJyYXkpIHx8IGZ1bmN0aW9uKG9iamVjdCkge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblx0fTtcblxuXHR2YXIgRElBQ1JJVElDUyA9IHtcblx0XHQnYSc6ICdbYeG4gOG4gcSCxIPDgsOix43Hjsi64rGlyKbIp+G6oOG6ocOEw6TDgMOgw4HDocSAxIHDg8Ojw4XDpcSFxITDg8SFxIRdJyxcblx0XHQnYic6ICdbYuKQos6yzpJC4Li/8JCMgeGbkl0nLFxuXHRcdCdjJzogJ1tjxIbEh8SIxInEjMSNxIrEi0PMhGPMhMOHw6fhuIjhuInIu8i8xofGiMmV4bSE77yj772DXScsXG5cdFx0J2QnOiAnW2TEjsSP4biK4biL4biQ4biR4biM4biN4biS4biT4biO4biPxJDEkUTMpmTMpsaJyZbGismXxovGjOG1reG2geG2kcih4bSF77yk772Ew7BdJyxcblx0XHQnZSc6ICdbZcOJw6nDiMOow4rDquG4mOG4mcSaxJvElMSV4bq84bq94bia4bib4bq64bq7xJbEl8OLw6vEksSTyKjIqcSYxJnhtpLJhsmHyITIheG6vuG6v+G7gOG7geG7hOG7heG7guG7g+G4nOG4neG4luG4l+G4lOG4lciGyIfhurjhurnhu4bhu4fisbjhtIfvvKXvvYXJmMedxo/GkM61XScsXG5cdFx0J2YnOiAnW2bGkcaS4bie4bifXScsXG5cdFx0J2cnOiAnW2fJouKCssekx6XEnMSdxJ7En8SixKPGk8mgxKDEoV0nLFxuXHRcdCdoJzogJ1toxKTEpcSmxKfhuKjhuKnhupbhupbhuKThuKXhuKLhuKPJpsqwx7bGlV0nLFxuXHRcdCdpJzogJ1tpw43DrcOMw6zErMStw47DrsePx5DDj8Ov4biu4bivxKjEqcSuxK/EqsSr4buI4buJyIjIiciKyIvhu4rhu4vhuKzhuK3Gl8moyajMhuG1u+G2lsSwaUnEscmq77yp772JXScsXG5cdFx0J2onOiAnW2rIt8S0xLXJiMmJyp3Jn8qyXScsXG5cdFx0J2snOiAnW2vGmMaZ6p2A6p2B4biw4bixx6jHqeG4suG4s+G4tOG4tc66z7Digq1dJyxcblx0XHQnbCc6ICdbbMWBxYLEvcS+xLvEvMS5xLrhuLbhuLfhuLjhuLnhuLzhuL3huLrhuLvEv8WAyL3GmuKxoOKxoeKxosmryazhtoXJrci0yp/vvKzvvYxdJyxcblx0XHQnbic6ICdbbsWDxYTHuMe5xYfFiMORw7HhuYThuYXFhcWG4bmG4bmH4bmK4bmL4bmI4bmJTsyIbsyIxp3Jssigxp7htbDhtofJs8i1ybTvvK7vvY7FisWLXScsXG5cdFx0J28nOiAnW2/DmMO4w5bDtsOTw7PDksOyw5TDtMeRx5LFkMWRxY7Fj8iuyK/hu4zhu43Gn8m1xqDGoeG7juG7j8WMxY3DlcO1x6rHq8iMyI3VldaFXScsXG5cdFx0J3AnOiAnW3DhuZThuZXhuZbhuZfisaPhtb3GpMal4bWxXScsXG5cdFx0J3EnOiAnW3HqnZbqnZfKoMmKyYvqnZjqnZlxzINdJyxcblx0XHQncic6ICdbcsWUxZXJjMmNxZjFmcWWxZfhuZjhuZnIkMiRyJLIk+G5muG5m+KxpMm9XScsXG5cdFx0J3MnOiAnW3PFmsWb4bmg4bmh4bmi4bmj6p6o6p6pxZzFncWgxaHFnsWfyJjImVPMiHPMiF0nLFxuXHRcdCd0JzogJ1t0xaTFpeG5quG5q8WixaPhuazhua3GrsqIyJrIm+G5sOG5seG5ruG5r8asxq1dJyxcblx0XHQndSc6ICdbdcWsxa3JhMqJ4buk4bulw5zDvMOaw7rDmcO5w5vDu8eTx5TFsMWxxazFrcavxrDhu6bhu6fFqsWrxajFqcWyxbPIlMiV4oiqXScsXG5cdFx0J3YnOiAnW3bhubzhub3hub7hub/GssqL6p2e6p2f4rGxyotdJyxcblx0XHQndyc6ICdbd+G6guG6g+G6gOG6gcW0xbXhuoThuoXhuobhuofhuojhuoldJyxcblx0XHQneCc6ICdbeOG6jOG6jeG6iuG6i8+HXScsXG5cdFx0J3knOiAnW3nDncO94buy4buzxbbFt8W4w7/hu7jhu7nhuo7huo/hu7Thu7XJjsmPxrPGtF0nLFxuXHRcdCd6JzogJ1t6xbnFuuG6kOG6kcW9xb7Fu8W84bqS4bqT4bqU4bqVxrXGtl0nXG5cdH07XG5cblx0dmFyIGFzY2lpZm9sZCA9IChmdW5jdGlvbigpIHtcblx0XHR2YXIgaSwgbiwgaywgY2h1bms7XG5cdFx0dmFyIGZvcmVpZ25sZXR0ZXJzID0gJyc7XG5cdFx0dmFyIGxvb2t1cCA9IHt9O1xuXHRcdGZvciAoayBpbiBESUFDUklUSUNTKSB7XG5cdFx0XHRpZiAoRElBQ1JJVElDUy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuXHRcdFx0XHRjaHVuayA9IERJQUNSSVRJQ1Nba10uc3Vic3RyaW5nKDIsIERJQUNSSVRJQ1Nba10ubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdGZvcmVpZ25sZXR0ZXJzICs9IGNodW5rO1xuXHRcdFx0XHRmb3IgKGkgPSAwLCBuID0gY2h1bmsubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdFx0bG9va3VwW2NodW5rLmNoYXJBdChpKV0gPSBrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCdbJyArICBmb3JlaWdubGV0dGVycyArICddJywgJ2cnKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UocmVnZXhwLCBmdW5jdGlvbihmb3JlaWdubGV0dGVyKSB7XG5cdFx0XHRcdHJldHVybiBsb29rdXBbZm9yZWlnbmxldHRlcl07XG5cdFx0XHR9KS50b0xvd2VyQ2FzZSgpO1xuXHRcdH07XG5cdH0pKCk7XG5cblxuXHQvLyBleHBvcnRcblx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuXG5cdHJldHVybiBTaWZ0ZXI7XG59KSk7XG5cbiIsIi8qXG4gKiBzcGFya2xpbmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zaGl3YW5vL3NwYXJrbGluZVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMyBTaG9nbyBJd2Fub1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbihmdW5jdGlvbih3aW5kb3cpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBzcGFya2xpbmUsXG4gICAgICB0aWNrcyA9IFsn4paBJywgJ+KWgicsICfiloMnLCAn4paEJywgJ+KWhScsICfiloYnLCAn4paHJywgJ+KWiCddO1xuXG4gIGZ1bmN0aW9uIGxzaGlmdChuLCBiaXRzKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobikgKiBNYXRoLnBvdygyLCBiaXRzKTtcbiAgfVxuXG4gIHNwYXJrbGluZSA9IGZ1bmN0aW9uKG51bWJlcnMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgbWF4ID0gdHlwZW9mIG9wdGlvbnMubWF4ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMubWF4IDogTWF0aC5tYXguYXBwbHkobnVsbCwgbnVtYmVycyksXG4gICAgICAgIG1pbiA9IHR5cGVvZiBvcHRpb25zLm1pbiA9PT0gJ251bWJlcicgPyBvcHRpb25zLm1pbiA6IE1hdGgubWluLmFwcGx5KG51bGwsIG51bWJlcnMpLFxuICAgICAgICBodG1sID0gdHlwZW9mIG9wdGlvbnMuaHRtbCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5odG1sIDogZmFsc2UsXG4gICAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgZiwgaTtcblxuICAgIGYgPSBNYXRoLmZsb29yKGxzaGlmdChtYXggLSBtaW4sIDgpIC8gKHRpY2tzLmxlbmd0aCAtIDEpKTtcbiAgICBpZiAoZiA8IDEpIHsgZiA9IDE7IH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBudW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aWNrc1tNYXRoLmZsb29yKGxzaGlmdChudW1iZXJzW2ldIC0gbWluLCA4KSAvIGYpXTtcblxuICAgICAgaWYgKGh0bWwpIHtcbiAgICAgICAgdmFsdWUgPSAnPHNwYW4gdGl0bGU9XCInICsgbnVtYmVyc1tpXSArICdcIj4nICsgdmFsdWUgKyAnPC9zcGFuPic7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHMuam9pbignJyk7XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNwYXJrbGluZTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuc3BhcmtsaW5lID0gc3BhcmtsaW5lO1xuXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgZGVmaW5lKCdzcGFya2xpbmUnLCBbXSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gc3BhcmtsaW5lOyB9KTtcbiAgICB9XG4gIH1cbn0pKHRoaXMpO1xuIiwiLyohIHRhYmxlc29ydGVyIChGT1JLKSAtIHVwZGF0ZWQgMjAxOC0wNS0xNiAodjIuMzAuNCkqL1xuLyogSW5jbHVkZXMgd2lkZ2V0cyAoIHN0b3JhZ2UsdWl0aGVtZSxjb2x1bW5zLGZpbHRlcixzdGlja3lIZWFkZXJzLHJlc2l6YWJsZSxzYXZlU29ydCApICovXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0ZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoalF1ZXJ5KTtcblx0fVxufShmdW5jdGlvbihqUXVlcnkpIHtcblxuLyohIFRhYmxlU29ydGVyIChGT1JLKSB2Mi4zMC40ICovLypcbiogQ2xpZW50LXNpZGUgdGFibGUgc29ydGluZyB3aXRoIGVhc2UhXG4qIEByZXF1aXJlcyBqUXVlcnkgdjEuMi42K1xuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMDcgQ2hyaXN0aWFuIEJhY2hcbiogZm9yayBtYWludGFpbmVkIGJ5IFJvYiBHYXJyaXNvblxuKlxuKiBFeGFtcGxlcyBhbmQgb3JpZ2luYWwgZG9jcyBhdDogaHR0cDovL3RhYmxlc29ydGVyLmNvbVxuKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTCBsaWNlbnNlczpcbiogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiogaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC5odG1sXG4qXG4qIEB0eXBlIGpRdWVyeVxuKiBAbmFtZSB0YWJsZXNvcnRlciAoRk9SSylcbiogQGNhdCBQbHVnaW5zL1RhYmxlc29ydGVyXG4qIEBhdXRob3IgQ2hyaXN0aWFuIEJhY2ggLSBjaHJpc3RpYW4uYmFjaEBwb2x5ZXN0ZXIuc2VcbiogQGNvbnRyaWJ1dG9yIFJvYiBHYXJyaXNvbiAtIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb3R0aWUvdGFibGVzb3J0ZXJcbiogQGRvY3MgKGZvcmspIC0gaHR0cHM6Ly9tb3R0aWUuZ2l0aHViLmlvL3RhYmxlc29ydGVyL2RvY3MvXG4qL1xuLypqc2hpbnQgYnJvd3Nlcjp0cnVlLCBqcXVlcnk6dHJ1ZSwgdW51c2VkOmZhbHNlLCBleHByOiB0cnVlICovXG47KCBmdW5jdGlvbiggJCApIHtcblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgdHMgPSAkLnRhYmxlc29ydGVyID0ge1xuXG5cdFx0dmVyc2lvbiA6ICcyLjMwLjQnLFxuXG5cdFx0cGFyc2VycyA6IFtdLFxuXHRcdHdpZGdldHMgOiBbXSxcblx0XHRkZWZhdWx0cyA6IHtcblxuXHRcdFx0Ly8gKioqIGFwcGVhcmFuY2Vcblx0XHRcdHRoZW1lICAgICAgICAgICAgOiAnZGVmYXVsdCcsICAvLyBhZGRzIHRhYmxlc29ydGVyLXt0aGVtZX0gdG8gdGhlIHRhYmxlIGZvciBzdHlsaW5nXG5cdFx0XHR3aWR0aEZpeGVkICAgICAgIDogZmFsc2UsICAgICAgLy8gYWRkcyBjb2xncm91cCB0byBmaXggd2lkdGhzIG9mIGNvbHVtbnNcblx0XHRcdHNob3dQcm9jZXNzaW5nICAgOiBmYWxzZSwgICAgICAvLyBzaG93IGFuIGluZGV0ZXJtaW5hdGUgdGltZXIgaWNvbiBpbiB0aGUgaGVhZGVyIHdoZW4gdGhlIHRhYmxlIGlzIHNvcnRlZCBvciBmaWx0ZXJlZC5cblxuXHRcdFx0aGVhZGVyVGVtcGxhdGUgICA6ICd7Y29udGVudH0nLC8vIGhlYWRlciBsYXlvdXQgdGVtcGxhdGUgKEhUTUwgb2spOyB7Y29udGVudH0gPSBpbm5lckhUTUwsIHtpY29ufSA9IDxpLz4gLy8gY2xhc3MgZnJvbSBjc3NJY29uXG5cdFx0XHRvblJlbmRlclRlbXBsYXRlIDogbnVsbCwgICAgICAgLy8gZnVuY3Rpb24oIGluZGV4LCB0ZW1wbGF0ZSApIHsgcmV0dXJuIHRlbXBsYXRlOyB9LCAvLyB0ZW1wbGF0ZSBpcyBhIHN0cmluZ1xuXHRcdFx0b25SZW5kZXJIZWFkZXIgICA6IG51bGwsICAgICAgIC8vIGZ1bmN0aW9uKCBpbmRleCApIHt9LCAvLyBub3RoaW5nIHRvIHJldHVyblxuXG5cdFx0XHQvLyAqKiogZnVuY3Rpb25hbGl0eVxuXHRcdFx0Y2FuY2VsU2VsZWN0aW9uICA6IHRydWUsICAgICAgIC8vIHByZXZlbnQgdGV4dCBzZWxlY3Rpb24gaW4gdGhlIGhlYWRlclxuXHRcdFx0dGFiSW5kZXggICAgICAgICA6IHRydWUsICAgICAgIC8vIGFkZCB0YWJpbmRleCB0byBoZWFkZXIgZm9yIGtleWJvYXJkIGFjY2Vzc2liaWxpdHlcblx0XHRcdGRhdGVGb3JtYXQgICAgICAgOiAnbW1kZHl5eXknLCAvLyBvdGhlciBvcHRpb25zOiAnZGRtbXl5eScgb3IgJ3l5eXltbWRkJ1xuXHRcdFx0c29ydE11bHRpU29ydEtleSA6ICdzaGlmdEtleScsIC8vIGtleSB1c2VkIHRvIHNlbGVjdCBhZGRpdGlvbmFsIGNvbHVtbnNcblx0XHRcdHNvcnRSZXNldEtleSAgICAgOiAnY3RybEtleScsICAvLyBrZXkgdXNlZCB0byByZW1vdmUgc29ydGluZyBvbiBhIGNvbHVtblxuXHRcdFx0dXNOdW1iZXJGb3JtYXQgICA6IHRydWUsICAgICAgIC8vIGZhbHNlIGZvciBHZXJtYW4gJzEuMjM0LjU2Nyw4OScgb3IgRnJlbmNoICcxIDIzNCA1NjcsODknXG5cdFx0XHRkZWxheUluaXQgICAgICAgIDogZmFsc2UsICAgICAgLy8gaWYgZmFsc2UsIHRoZSBwYXJzZWQgdGFibGUgY29udGVudHMgd2lsbCBub3QgdXBkYXRlIHVudGlsIHRoZSBmaXJzdCBzb3J0XG5cdFx0XHRzZXJ2ZXJTaWRlU29ydGluZzogZmFsc2UsICAgICAgLy8gaWYgdHJ1ZSwgc2VydmVyLXNpZGUgc29ydGluZyBzaG91bGQgYmUgcGVyZm9ybWVkIGJlY2F1c2UgY2xpZW50LXNpZGUgc29ydGluZyB3aWxsIGJlIGRpc2FibGVkLCBidXQgdGhlIHVpIGFuZCBldmVudHMgd2lsbCBzdGlsbCBiZSB1c2VkLlxuXHRcdFx0cmVzb3J0ICAgICAgICAgICA6IHRydWUsICAgICAgIC8vIGRlZmF1bHQgc2V0dGluZyB0byB0cmlnZ2VyIGEgcmVzb3J0IGFmdGVyIGFuICd1cGRhdGUnLCAnYWRkUm93cycsICd1cGRhdGVDZWxsJywgZXRjIGhhcyBjb21wbGV0ZWRcblxuXHRcdFx0Ly8gKioqIHNvcnQgb3B0aW9uc1xuXHRcdFx0aGVhZGVycyAgICAgICAgICA6IHt9LCAgICAgICAgIC8vIHNldCBzb3J0ZXIsIHN0cmluZywgZW1wdHksIGxvY2tlZCBvcmRlciwgc29ydEluaXRpYWxPcmRlciwgZmlsdGVyLCBldGMuXG5cdFx0XHRpZ25vcmVDYXNlICAgICAgIDogdHJ1ZSwgICAgICAgLy8gaWdub3JlIGNhc2Ugd2hpbGUgc29ydGluZ1xuXHRcdFx0c29ydEZvcmNlICAgICAgICA6IG51bGwsICAgICAgIC8vIGNvbHVtbihzKSBmaXJzdCBzb3J0ZWQ7IGFsd2F5cyBhcHBsaWVkXG5cdFx0XHRzb3J0TGlzdCAgICAgICAgIDogW10sICAgICAgICAgLy8gSW5pdGlhbCBzb3J0IG9yZGVyOyBhcHBsaWVkIGluaXRpYWxseTsgdXBkYXRlZCB3aGVuIG1hbnVhbGx5IHNvcnRlZFxuXHRcdFx0c29ydEFwcGVuZCAgICAgICA6IG51bGwsICAgICAgIC8vIGNvbHVtbihzKSBzb3J0ZWQgbGFzdDsgYWx3YXlzIGFwcGxpZWRcblx0XHRcdHNvcnRTdGFibGUgICAgICAgOiBmYWxzZSwgICAgICAvLyB3aGVuIHNvcnRpbmcgdHdvIHJvd3Mgd2l0aCBleGFjdGx5IHRoZSBzYW1lIGNvbnRlbnQsIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIGlzIG1haW50YWluZWRcblxuXHRcdFx0c29ydEluaXRpYWxPcmRlciA6ICdhc2MnLCAgICAgIC8vIHNvcnQgZGlyZWN0aW9uIG9uIGZpcnN0IGNsaWNrXG5cdFx0XHRzb3J0TG9jYWxlQ29tcGFyZTogZmFsc2UsICAgICAgLy8gcmVwbGFjZSBlcXVpdmFsZW50IGNoYXJhY3RlciAoYWNjZW50ZWQgY2hhcmFjdGVycylcblx0XHRcdHNvcnRSZXNldCAgICAgICAgOiBmYWxzZSwgICAgICAvLyB0aGlyZCBjbGljayBvbiB0aGUgaGVhZGVyIHdpbGwgcmVzZXQgY29sdW1uIHRvIGRlZmF1bHQgLSB1bnNvcnRlZFxuXHRcdFx0c29ydFJlc3RhcnQgICAgICA6IGZhbHNlLCAgICAgIC8vIHJlc3RhcnQgc29ydCB0byAnc29ydEluaXRpYWxPcmRlcicgd2hlbiBjbGlja2luZyBvbiBwcmV2aW91c2x5IHVuc29ydGVkIGNvbHVtbnNcblxuXHRcdFx0ZW1wdHlUbyAgICAgICAgICA6ICdib3R0b20nLCAgIC8vIHNvcnQgZW1wdHkgY2VsbCB0byBib3R0b20sIHRvcCwgbm9uZSwgemVybywgZW1wdHlNYXgsIGVtcHR5TWluXG5cdFx0XHRzdHJpbmdUbyAgICAgICAgIDogJ21heCcsICAgICAgLy8gc29ydCBzdHJpbmdzIGluIG51bWVyaWNhbCBjb2x1bW4gYXMgbWF4LCBtaW4sIHRvcCwgYm90dG9tLCB6ZXJvXG5cdFx0XHRkdXBsaWNhdGVTcGFuICAgIDogdHJ1ZSwgICAgICAgLy8gY29sc3BhbiBjZWxscyBpbiB0aGUgdGJvZHkgd2lsbCBoYXZlIGR1cGxpY2F0ZWQgY29udGVudCBpbiB0aGUgY2FjaGUgZm9yIGVhY2ggc3Bhbm5lZCBjb2x1bW5cblx0XHRcdHRleHRFeHRyYWN0aW9uICAgOiAnYmFzaWMnLCAgICAvLyB0ZXh0IGV4dHJhY3Rpb24gbWV0aG9kL2Z1bmN0aW9uIC0gZnVuY3Rpb24oIG5vZGUsIHRhYmxlLCBjZWxsSW5kZXggKSB7fVxuXHRcdFx0dGV4dEF0dHJpYnV0ZSAgICA6ICdkYXRhLXRleHQnLC8vIGRhdGEtYXR0cmlidXRlIHRoYXQgY29udGFpbnMgYWx0ZXJuYXRlIGNlbGwgdGV4dCAodXNlZCBpbiBkZWZhdWx0IHRleHRFeHRyYWN0aW9uIGZ1bmN0aW9uKVxuXHRcdFx0dGV4dFNvcnRlciAgICAgICA6IG51bGwsICAgICAgIC8vIGNob29zZSBvdmVyYWxsIG9yIHNwZWNpZmljIGNvbHVtbiBzb3J0ZXIgZnVuY3Rpb24oIGEsIGIsIGRpcmVjdGlvbiwgdGFibGUsIGNvbHVtbkluZGV4ICkgW2FsdDogdHMuc29ydFRleHRdXG5cdFx0XHRudW1iZXJTb3J0ZXIgICAgIDogbnVsbCwgICAgICAgLy8gY2hvb3NlIG92ZXJhbGwgbnVtZXJpYyBzb3J0ZXIgZnVuY3Rpb24oIGEsIGIsIGRpcmVjdGlvbiwgbWF4Q29sdW1uVmFsdWUgKVxuXG5cdFx0XHQvLyAqKiogd2lkZ2V0IG9wdGlvbnNcblx0XHRcdGluaXRXaWRnZXRzICAgICAgOiB0cnVlLCAgICAgICAvLyBhcHBseSB3aWRnZXRzIG9uIHRhYmxlc29ydGVyIGluaXRpYWxpemF0aW9uXG5cdFx0XHR3aWRnZXRDbGFzcyAgICAgIDogJ3dpZGdldC17bmFtZX0nLCAvLyB0YWJsZSBjbGFzcyBuYW1lIHRlbXBsYXRlIHRvIG1hdGNoIHRvIGluY2x1ZGUgYSB3aWRnZXRcblx0XHRcdHdpZGdldHMgICAgICAgICAgOiBbXSwgICAgICAgICAvLyBtZXRob2QgdG8gYWRkIHdpZGdldHMsIGUuZy4gd2lkZ2V0czogWyd6ZWJyYSddXG5cdFx0XHR3aWRnZXRPcHRpb25zICAgIDoge1xuXHRcdFx0XHR6ZWJyYSA6IFsgJ2V2ZW4nLCAnb2RkJyBdICAvLyB6ZWJyYSB3aWRnZXQgYWx0ZXJuYXRpbmcgcm93IGNsYXNzIG5hbWVzXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyAqKiogY2FsbGJhY2tzXG5cdFx0XHRpbml0aWFsaXplZCAgICAgIDogbnVsbCwgICAgICAgLy8gZnVuY3Rpb24oIHRhYmxlICkge30sXG5cblx0XHRcdC8vICoqKiBleHRyYSBjc3MgY2xhc3MgbmFtZXNcblx0XHRcdHRhYmxlQ2xhc3MgICAgICAgOiAnJyxcblx0XHRcdGNzc0FzYyAgICAgICAgICAgOiAnJyxcblx0XHRcdGNzc0Rlc2MgICAgICAgICAgOiAnJyxcblx0XHRcdGNzc05vbmUgICAgICAgICAgOiAnJyxcblx0XHRcdGNzc0hlYWRlciAgICAgICAgOiAnJyxcblx0XHRcdGNzc0hlYWRlclJvdyAgICAgOiAnJyxcblx0XHRcdGNzc1Byb2Nlc3NpbmcgICAgOiAnJywgLy8gcHJvY2Vzc2luZyBpY29uIGFwcGxpZWQgdG8gaGVhZGVyIGR1cmluZyBzb3J0L2ZpbHRlclxuXG5cdFx0XHRjc3NDaGlsZFJvdyAgICAgIDogJ3RhYmxlc29ydGVyLWNoaWxkUm93JywgLy8gY2xhc3MgbmFtZSBpbmRpY2lhdGluZyB0aGF0IGEgcm93IGlzIHRvIGJlIGF0dGFjaGVkIHRvIGl0cyBwYXJlbnRcblx0XHRcdGNzc0luZm9CbG9jayAgICAgOiAndGFibGVzb3J0ZXItaW5mb09ubHknLCAvLyBkb24ndCBzb3J0IHRib2R5IHdpdGggdGhpcyBjbGFzcyBuYW1lIChvbmx5IG9uZSBjbGFzcyBuYW1lIGFsbG93ZWQgaGVyZSEpXG5cdFx0XHRjc3NOb1NvcnQgICAgICAgIDogJ3RhYmxlc29ydGVyLW5vU29ydCcsICAgLy8gY2xhc3MgbmFtZSBhZGRlZCB0byBlbGVtZW50IGluc2lkZSBoZWFkZXI7IGNsaWNraW5nIG9uIGl0IHdvbid0IGNhdXNlIGEgc29ydFxuXHRcdFx0Y3NzSWdub3JlUm93ICAgICA6ICd0YWJsZXNvcnRlci1pZ25vcmVSb3cnLC8vIGhlYWRlciByb3cgdG8gaWdub3JlOyBjZWxscyB3aXRoaW4gdGhpcyByb3cgd2lsbCBub3QgYmUgYWRkZWQgdG8gYy4kaGVhZGVyc1xuXG5cdFx0XHRjc3NJY29uICAgICAgICAgIDogJ3RhYmxlc29ydGVyLWljb24nLCAvLyBpZiB0aGlzIGNsYXNzIGRvZXMgbm90IGV4aXN0LCB0aGUge2ljb259IHdpbGwgbm90IGJlIGFkZGVkIGZyb20gdGhlIGhlYWRlclRlbXBsYXRlXG5cdFx0XHRjc3NJY29uTm9uZSAgICAgIDogJycsIC8vIGNsYXNzIG5hbWUgYWRkZWQgdG8gdGhlIGljb24gd2hlbiB0aGVyZSBpcyBubyBjb2x1bW4gc29ydFxuXHRcdFx0Y3NzSWNvbkFzYyAgICAgICA6ICcnLCAvLyBjbGFzcyBuYW1lIGFkZGVkIHRvIHRoZSBpY29uIHdoZW4gdGhlIGNvbHVtbiBoYXMgYW4gYXNjZW5kaW5nIHNvcnRcblx0XHRcdGNzc0ljb25EZXNjICAgICAgOiAnJywgLy8gY2xhc3MgbmFtZSBhZGRlZCB0byB0aGUgaWNvbiB3aGVuIHRoZSBjb2x1bW4gaGFzIGEgZGVzY2VuZGluZyBzb3J0XG5cdFx0XHRjc3NJY29uRGlzYWJsZWQgIDogJycsIC8vIGNsYXNzIG5hbWUgYWRkZWQgdG8gdGhlIGljb24gd2hlbiB0aGUgY29sdW1uIGhhcyBhIGRpc2FibGVkIHNvcnRcblxuXHRcdFx0Ly8gKioqIGV2ZW50c1xuXHRcdFx0cG9pbnRlckNsaWNrICAgICA6ICdjbGljaycsXG5cdFx0XHRwb2ludGVyRG93biAgICAgIDogJ21vdXNlZG93bicsXG5cdFx0XHRwb2ludGVyVXAgICAgICAgIDogJ21vdXNldXAnLFxuXG5cdFx0XHQvLyAqKiogc2VsZWN0b3JzXG5cdFx0XHRzZWxlY3RvckhlYWRlcnMgIDogJz4gdGhlYWQgdGgsID4gdGhlYWQgdGQnLFxuXHRcdFx0c2VsZWN0b3JTb3J0ICAgICA6ICd0aCwgdGQnLCAvLyBqUXVlcnkgc2VsZWN0b3Igb2YgY29udGVudCB3aXRoaW4gc2VsZWN0b3JIZWFkZXJzIHRoYXQgaXMgY2xpY2thYmxlIHRvIHRyaWdnZXIgYSBzb3J0XG5cdFx0XHRzZWxlY3RvclJlbW92ZSAgIDogJy5yZW1vdmUtbWUnLFxuXG5cdFx0XHQvLyAqKiogYWR2YW5jZWRcblx0XHRcdGRlYnVnICAgICAgICAgICAgOiBmYWxzZSxcblxuXHRcdFx0Ly8gKioqIEludGVybmFsIHZhcmlhYmxlc1xuXHRcdFx0aGVhZGVyTGlzdDogW10sXG5cdFx0XHRlbXB0aWVzOiB7fSxcblx0XHRcdHN0cmluZ3M6IHt9LFxuXHRcdFx0cGFyc2VyczogW10sXG5cblx0XHRcdC8vICoqKiBwYXJzZXIgb3B0aW9ucyBmb3IgdmFsaWRhdG9yOyB2YWx1ZXMgbXVzdCBiZSBmYWxzeSFcblx0XHRcdGdsb2JhbGl6ZTogMCxcblx0XHRcdGltZ0F0dHI6IDBcblxuXHRcdFx0Ly8gcmVtb3ZlZDogd2lkZ2V0WmVicmE6IHsgY3NzOiBbJ2V2ZW4nLCAnb2RkJ10gfVxuXG5cdFx0fSxcblxuXHRcdC8vIGludGVybmFsIGNzcyBjbGFzc2VzIC0gdGhlc2Ugd2lsbCBBTFdBWVMgYmUgYWRkZWQgdG9cblx0XHQvLyB0aGUgdGFibGUgYW5kIE1VU1Qgb25seSBjb250YWluIG9uZSBjbGFzcyBuYW1lIC0gZml4ZXMgIzM4MVxuXHRcdGNzcyA6IHtcblx0XHRcdHRhYmxlICAgICAgOiAndGFibGVzb3J0ZXInLFxuXHRcdFx0Y3NzSGFzQ2hpbGQ6ICd0YWJsZXNvcnRlci1oYXNDaGlsZFJvdycsXG5cdFx0XHRjaGlsZFJvdyAgIDogJ3RhYmxlc29ydGVyLWNoaWxkUm93Jyxcblx0XHRcdGNvbGdyb3VwICAgOiAndGFibGVzb3J0ZXItY29sZ3JvdXAnLFxuXHRcdFx0aGVhZGVyICAgICA6ICd0YWJsZXNvcnRlci1oZWFkZXInLFxuXHRcdFx0aGVhZGVyUm93ICA6ICd0YWJsZXNvcnRlci1oZWFkZXJSb3cnLFxuXHRcdFx0aGVhZGVySW4gICA6ICd0YWJsZXNvcnRlci1oZWFkZXItaW5uZXInLFxuXHRcdFx0aWNvbiAgICAgICA6ICd0YWJsZXNvcnRlci1pY29uJyxcblx0XHRcdHByb2Nlc3NpbmcgOiAndGFibGVzb3J0ZXItcHJvY2Vzc2luZycsXG5cdFx0XHRzb3J0QXNjICAgIDogJ3RhYmxlc29ydGVyLWhlYWRlckFzYycsXG5cdFx0XHRzb3J0RGVzYyAgIDogJ3RhYmxlc29ydGVyLWhlYWRlckRlc2MnLFxuXHRcdFx0c29ydE5vbmUgICA6ICd0YWJsZXNvcnRlci1oZWFkZXJVblNvcnRlZCdcblx0XHR9LFxuXG5cdFx0Ly8gbGFiZWxzIGFwcGxpZWQgdG8gc29ydGFibGUgaGVhZGVycyBmb3IgYWNjZXNzaWJpbGl0eSAoYXJpYSkgc3VwcG9ydFxuXHRcdGxhbmd1YWdlIDoge1xuXHRcdFx0c29ydEFzYyAgICAgIDogJ0FzY2VuZGluZyBzb3J0IGFwcGxpZWQsICcsXG5cdFx0XHRzb3J0RGVzYyAgICAgOiAnRGVzY2VuZGluZyBzb3J0IGFwcGxpZWQsICcsXG5cdFx0XHRzb3J0Tm9uZSAgICAgOiAnTm8gc29ydCBhcHBsaWVkLCAnLFxuXHRcdFx0c29ydERpc2FibGVkIDogJ3NvcnRpbmcgaXMgZGlzYWJsZWQnLFxuXHRcdFx0bmV4dEFzYyAgICAgIDogJ2FjdGl2YXRlIHRvIGFwcGx5IGFuIGFzY2VuZGluZyBzb3J0Jyxcblx0XHRcdG5leHREZXNjICAgICA6ICdhY3RpdmF0ZSB0byBhcHBseSBhIGRlc2NlbmRpbmcgc29ydCcsXG5cdFx0XHRuZXh0Tm9uZSAgICAgOiAnYWN0aXZhdGUgdG8gcmVtb3ZlIHRoZSBzb3J0J1xuXHRcdH0sXG5cblx0XHRyZWdleCA6IHtcblx0XHRcdHRlbXBsYXRlQ29udGVudCA6IC9cXHtjb250ZW50XFx9L2csXG5cdFx0XHR0ZW1wbGF0ZUljb24gICAgOiAvXFx7aWNvblxcfS9nLFxuXHRcdFx0dGVtcGxhdGVOYW1lICAgIDogL1xce25hbWVcXH0vaSxcblx0XHRcdHNwYWNlcyAgICAgICAgICA6IC9cXHMrL2csXG5cdFx0XHRub25Xb3JkICAgICAgICAgOiAvXFxXL2csXG5cdFx0XHRmb3JtRWxlbWVudHMgICAgOiAvKGlucHV0fHNlbGVjdHxidXR0b258dGV4dGFyZWEpL2ksXG5cblx0XHRcdC8vICoqKiBzb3J0IGZ1bmN0aW9ucyAqKipcblx0XHRcdC8vIHJlZ2V4IHVzZWQgaW4gbmF0dXJhbCBzb3J0XG5cdFx0XHQvLyBjaHVuay90b2tlbml6ZSBudW1iZXJzICYgbGV0dGVyc1xuXHRcdFx0Y2h1bmsgIDogLyheKFsrXFwtXT8oPzpcXGQqKSg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/KT8kfF4weFswLTlhLWZdKyR8XFxkKykvZ2ksXG5cdFx0XHQvLyByZXBsYWNlIGNodW5rcyBAIGVuZHNcblx0XHRcdGNodW5rcyA6IC8oXlxcXFwwfFxcXFwwJCkvLFxuXHRcdFx0aGV4ICAgIDogL14weFswLTlhLWZdKyQvaSxcblxuXHRcdFx0Ly8gKioqIGZvcm1hdEZsb2F0ICoqKlxuXHRcdFx0Y29tbWEgICAgICAgICAgICAgICAgOiAvLC9nLFxuXHRcdFx0ZGlnaXROb25VUyAgICAgICAgICAgOiAvW1xcc3xcXC5dL2csXG5cdFx0XHRkaWdpdE5lZ2F0aXZlVGVzdCAgICA6IC9eXFxzKlxcKFsuXFxkXStcXCkvLFxuXHRcdFx0ZGlnaXROZWdhdGl2ZVJlcGxhY2UgOiAvXlxccypcXCgoWy5cXGRdKylcXCkvLFxuXG5cdFx0XHQvLyAqKiogaXNEaWdpdCAqKipcblx0XHRcdGRpZ2l0VGVzdCAgICA6IC9eW1xcLSsoXT9cXGQrWyldPyQvLFxuXHRcdFx0ZGlnaXRSZXBsYWNlIDogL1ssLidcIlxcc10vZ1xuXG5cdFx0fSxcblxuXHRcdC8vIGRpZ2l0IHNvcnQsIHRleHQgbG9jYXRpb25cblx0XHRzdHJpbmcgOiB7XG5cdFx0XHRtYXggICAgICA6IDEsXG5cdFx0XHRtaW4gICAgICA6IC0xLFxuXHRcdFx0ZW1wdHltaW4gOiAxLFxuXHRcdFx0ZW1wdHltYXggOiAtMSxcblx0XHRcdHplcm8gICAgIDogMCxcblx0XHRcdG5vbmUgICAgIDogMCxcblx0XHRcdCdudWxsJyAgIDogMCxcblx0XHRcdHRvcCAgICAgIDogdHJ1ZSxcblx0XHRcdGJvdHRvbSAgIDogZmFsc2Vcblx0XHR9LFxuXG5cdFx0a2V5Q29kZXMgOiB7XG5cdFx0XHRlbnRlciA6IDEzXG5cdFx0fSxcblxuXHRcdC8vIHBsYWNlaG9sZGVyIGRhdGUgcGFyc2VyIGRhdGEgKGdsb2JhbGl6ZSlcblx0XHRkYXRlcyA6IHt9LFxuXG5cdFx0Ly8gVGhlc2UgbWV0aG9kcyBjYW4gYmUgYXBwbGllZCBvbiB0YWJsZS5jb25maWcgaW5zdGFuY2Vcblx0XHRpbnN0YW5jZU1ldGhvZHMgOiB7fSxcblxuXHRcdC8qXG5cdFx04paE4paI4paI4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiCDilojilojilojilojilojilogg4paI4paIICDilojilogg4paI4paI4paI4paI4paI4paEXG5cdFx04paA4paI4paEICAgIOKWiOKWiOKWhOKWhCAgICAg4paI4paIICAg4paI4paIICDilojilogg4paI4paI4paE4paE4paI4paIXG5cdFx0ICAg4paA4paI4paEIOKWiOKWiOKWgOKWgCAgICAg4paI4paIICAg4paI4paIICDilojilogg4paI4paI4paA4paA4paAXG5cdFx04paI4paI4paI4paI4paI4paAIOKWiOKWiOKWiOKWiOKWiOKWiCAgIOKWiOKWiCAgIOKWgOKWiOKWiOKWiOKWiOKWgCDilojilohcblx0XHQqL1xuXG5cdFx0c2V0dXAgOiBmdW5jdGlvbiggdGFibGUsIGMgKSB7XG5cdFx0XHQvLyBpZiBubyB0aGVhZCBvciB0Ym9keSwgb3IgdGFibGVzb3J0ZXIgaXMgYWxyZWFkeSBwcmVzZW50LCBxdWl0XG5cdFx0XHRpZiAoICF0YWJsZSB8fCAhdGFibGUudEhlYWQgfHwgdGFibGUudEJvZGllcy5sZW5ndGggPT09IDAgfHwgdGFibGUuaGFzSW5pdGlhbGl6ZWQgPT09IHRydWUgKSB7XG5cdFx0XHRcdGlmICggdHMuZGVidWcoYywgJ2NvcmUnKSApIHtcblx0XHRcdFx0XHRpZiAoIHRhYmxlLmhhc0luaXRpYWxpemVkICkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnU3RvcHBpbmcgaW5pdGlhbGl6YXRpb24uIFRhYmxlc29ydGVyIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWQnICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdTdG9wcGluZyBpbml0aWFsaXphdGlvbiEgTm8gdGFibGUsIHRoZWFkIG9yIHRib2R5JywgdGFibGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdG1wID0gJycsXG5cdFx0XHRcdCR0YWJsZSA9ICQoIHRhYmxlICksXG5cdFx0XHRcdG1ldGEgPSAkLm1ldGFkYXRhO1xuXHRcdFx0Ly8gaW5pdGlhbGl6YXRpb24gZmxhZ1xuXHRcdFx0dGFibGUuaGFzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblx0XHRcdC8vIHRhYmxlIGlzIGJlaW5nIHByb2Nlc3NlZCBmbGFnXG5cdFx0XHR0YWJsZS5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuXHRcdFx0Ly8gbWFrZSBzdXJlIHRvIHN0b3JlIHRoZSBjb25maWcgb2JqZWN0XG5cdFx0XHR0YWJsZS5jb25maWcgPSBjO1xuXHRcdFx0Ly8gc2F2ZSB0aGUgc2V0dGluZ3Mgd2hlcmUgdGhleSByZWFkXG5cdFx0XHQkLmRhdGEoIHRhYmxlLCAndGFibGVzb3J0ZXInLCBjICk7XG5cdFx0XHRpZiAoIHRzLmRlYnVnKGMsICdjb3JlJykgKSB7XG5cdFx0XHRcdGNvbnNvbGVbIGNvbnNvbGUuZ3JvdXAgPyAnZ3JvdXAnIDogJ2xvZycgXSggJ0luaXRpYWxpemluZyB0YWJsZXNvcnRlciB2JyArIHRzLnZlcnNpb24gKTtcblx0XHRcdFx0JC5kYXRhKCB0YWJsZSwgJ3N0YXJ0b3ZlcmFsbHRpbWVyJywgbmV3IERhdGUoKSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmluZyB0aGlzIGluIHZlcnNpb24gMyAob25seSBzdXBwb3J0cyBqUXVlcnkgMS43Kylcblx0XHRcdGMuc3VwcG9ydHNEYXRhT2JqZWN0ID0gKCBmdW5jdGlvbiggdmVyc2lvbiApIHtcblx0XHRcdFx0dmVyc2lvblsgMCBdID0gcGFyc2VJbnQoIHZlcnNpb25bIDAgXSwgMTAgKTtcblx0XHRcdFx0cmV0dXJuICggdmVyc2lvblsgMCBdID4gMSApIHx8ICggdmVyc2lvblsgMCBdID09PSAxICYmIHBhcnNlSW50KCB2ZXJzaW9uWyAxIF0sIDEwICkgPj0gNCApO1xuXHRcdFx0fSkoICQuZm4uanF1ZXJ5LnNwbGl0KCAnLicgKSApO1xuXHRcdFx0Ly8gZW5zdXJlIGNhc2UgaW5zZW5zaXRpdml0eVxuXHRcdFx0Yy5lbXB0eVRvID0gYy5lbXB0eVRvLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRjLnN0cmluZ1RvID0gYy5zdHJpbmdUby50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0Yy5sYXN0ID0geyBzb3J0TGlzdCA6IFtdLCBjbGlja2VkSW5kZXggOiAtMSB9O1xuXHRcdFx0Ly8gYWRkIHRhYmxlIHRoZW1lIGNsYXNzIG9ubHkgaWYgdGhlcmUgaXNuJ3QgYWxyZWFkeSBvbmUgdGhlcmVcblx0XHRcdGlmICggIS90YWJsZXNvcnRlclxcLS8udGVzdCggJHRhYmxlLmF0dHIoICdjbGFzcycgKSApICkge1xuXHRcdFx0XHR0bXAgPSAoIGMudGhlbWUgIT09ICcnID8gJyB0YWJsZXNvcnRlci0nICsgYy50aGVtZSA6ICcnICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGdpdmUgdGhlIHRhYmxlIGEgdW5pcXVlIGlkLCB3aGljaCB3aWxsIGJlIHVzZWQgaW4gbmFtZXNwYWNlIGJpbmRpbmdcblx0XHRcdGlmICggIWMubmFtZXNwYWNlICkge1xuXHRcdFx0XHRjLm5hbWVzcGFjZSA9ICcudGFibGVzb3J0ZXInICsgTWF0aC5yYW5kb20oKS50b1N0cmluZyggMTYgKS5zbGljZSggMiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gbWFrZSBzdXJlIG5hbWVzcGFjZSBzdGFydHMgd2l0aCBhIHBlcmlvZCAmIGRvZXNuJ3QgaGF2ZSB3ZWlyZCBjaGFyYWN0ZXJzXG5cdFx0XHRcdGMubmFtZXNwYWNlID0gJy4nICsgYy5uYW1lc3BhY2UucmVwbGFjZSggdHMucmVnZXgubm9uV29yZCwgJycgKTtcblx0XHRcdH1cblxuXHRcdFx0Yy50YWJsZSA9IHRhYmxlO1xuXHRcdFx0Yy4kdGFibGUgPSAkdGFibGVcblx0XHRcdFx0Ly8gYWRkIG5hbWVzcGFjZSB0byB0YWJsZSB0byBhbGxvdyBiaW5kaW5ncyBvbiBleHRyYSBlbGVtZW50cyB0byB0YXJnZXRcblx0XHRcdFx0Ly8gdGhlIHBhcmVudCB0YWJsZSAoZS5nLiBwYXJzZXItaW5wdXQtc2VsZWN0KVxuXHRcdFx0XHQuYWRkQ2xhc3MoIHRzLmNzcy50YWJsZSArICcgJyArIGMudGFibGVDbGFzcyArIHRtcCArICcgJyArIGMubmFtZXNwYWNlLnNsaWNlKDEpIClcblx0XHRcdFx0LmF0dHIoICdyb2xlJywgJ2dyaWQnICk7XG5cdFx0XHRjLiRoZWFkZXJzID0gJHRhYmxlLmZpbmQoIGMuc2VsZWN0b3JIZWFkZXJzICk7XG5cblx0XHRcdGMuJHRhYmxlLmNoaWxkcmVuKCkuY2hpbGRyZW4oICd0cicgKS5hdHRyKCAncm9sZScsICdyb3cnICk7XG5cdFx0XHRjLiR0Ym9kaWVzID0gJHRhYmxlLmNoaWxkcmVuKCAndGJvZHk6bm90KC4nICsgYy5jc3NJbmZvQmxvY2sgKyAnKScgKS5hdHRyKHtcblx0XHRcdFx0J2FyaWEtbGl2ZScgOiAncG9saXRlJyxcblx0XHRcdFx0J2FyaWEtcmVsZXZhbnQnIDogJ2FsbCdcblx0XHRcdH0pO1xuXHRcdFx0aWYgKCBjLiR0YWJsZS5jaGlsZHJlbiggJ2NhcHRpb24nICkubGVuZ3RoICkge1xuXHRcdFx0XHR0bXAgPSBjLiR0YWJsZS5jaGlsZHJlbiggJ2NhcHRpb24nIClbIDAgXTtcblx0XHRcdFx0aWYgKCAhdG1wLmlkICkgeyB0bXAuaWQgPSBjLm5hbWVzcGFjZS5zbGljZSggMSApICsgJ2NhcHRpb24nOyB9XG5cdFx0XHRcdGMuJHRhYmxlLmF0dHIoICdhcmlhLWxhYmVsbGVkYnknLCB0bXAuaWQgKTtcblx0XHRcdH1cblx0XHRcdGMud2lkZ2V0SW5pdCA9IHt9OyAvLyBrZWVwIGEgbGlzdCBvZiBpbml0aWFsaXplZCB3aWRnZXRzXG5cdFx0XHQvLyBjaGFuZ2UgdGV4dEV4dHJhY3Rpb24gdmlhIGRhdGEtYXR0cmlidXRlXG5cdFx0XHRjLnRleHRFeHRyYWN0aW9uID0gYy4kdGFibGUuYXR0ciggJ2RhdGEtdGV4dC1leHRyYWN0aW9uJyApIHx8IGMudGV4dEV4dHJhY3Rpb24gfHwgJ2Jhc2ljJztcblx0XHRcdC8vIGJ1aWxkIGhlYWRlcnNcblx0XHRcdHRzLmJ1aWxkSGVhZGVycyggYyApO1xuXHRcdFx0Ly8gZml4YXRlIGNvbHVtbnMgaWYgdGhlIHVzZXJzIHN1cHBsaWVzIHRoZSBmaXhlZFdpZHRoIG9wdGlvblxuXHRcdFx0Ly8gZG8gdGhpcyBhZnRlciB0aGVtZSBoYXMgYmVlbiBhcHBsaWVkXG5cdFx0XHR0cy5maXhDb2x1bW5XaWR0aCggdGFibGUgKTtcblx0XHRcdC8vIGFkZCB3aWRnZXRzIGZyb20gY2xhc3MgbmFtZVxuXHRcdFx0dHMuYWRkV2lkZ2V0RnJvbUNsYXNzKCB0YWJsZSApO1xuXHRcdFx0Ly8gYWRkIHdpZGdldCBvcHRpb25zIGJlZm9yZSBwYXJzaW5nIChlLmcuIGdyb3VwaW5nIHdpZGdldCBoYXMgcGFyc2VyIHNldHRpbmdzKVxuXHRcdFx0dHMuYXBwbHlXaWRnZXRPcHRpb25zKCB0YWJsZSApO1xuXHRcdFx0Ly8gdHJ5IHRvIGF1dG8gZGV0ZWN0IGNvbHVtbiB0eXBlLCBhbmQgc3RvcmUgaW4gdGFibGVzIGNvbmZpZ1xuXHRcdFx0dHMuc2V0dXBQYXJzZXJzKCBjICk7XG5cdFx0XHQvLyBzdGFydCB0b3RhbCByb3cgY291bnQgYXQgemVyb1xuXHRcdFx0Yy50b3RhbFJvd3MgPSAwO1xuXHRcdFx0Ly8gb25seSB2YWxpZGF0ZSBvcHRpb25zIHdoaWxlIGRlYnVnZ2luZy4gU2VlICMxNTI4XG5cdFx0XHRpZiAoYy5kZWJ1Zykge1xuXHRcdFx0XHR0cy52YWxpZGF0ZU9wdGlvbnMoIGMgKTtcblx0XHRcdH1cblx0XHRcdC8vIGJ1aWxkIHRoZSBjYWNoZSBmb3IgdGhlIHRib2R5IGNlbGxzXG5cdFx0XHQvLyBkZWxheUluaXQgd2lsbCBkZWxheSBidWlsZGluZyB0aGUgY2FjaGUgdW50aWwgdGhlIHVzZXIgc3RhcnRzIGEgc29ydFxuXHRcdFx0aWYgKCAhYy5kZWxheUluaXQgKSB7IHRzLmJ1aWxkQ2FjaGUoIGMgKTsgfVxuXHRcdFx0Ly8gYmluZCBhbGwgaGVhZGVyIGV2ZW50cyBhbmQgbWV0aG9kc1xuXHRcdFx0dHMuYmluZEV2ZW50cyggdGFibGUsIGMuJGhlYWRlcnMsIHRydWUgKTtcblx0XHRcdHRzLmJpbmRNZXRob2RzKCBjICk7XG5cdFx0XHQvLyBnZXQgc29ydCBsaXN0IGZyb20galF1ZXJ5IGRhdGEgb3IgbWV0YWRhdGFcblx0XHRcdC8vIGluIGpRdWVyeSA8IDEuNCwgYW4gZXJyb3Igb2NjdXJzIHdoZW4gY2FsbGluZyAkdGFibGUuZGF0YSgpXG5cdFx0XHRpZiAoIGMuc3VwcG9ydHNEYXRhT2JqZWN0ICYmIHR5cGVvZiAkdGFibGUuZGF0YSgpLnNvcnRsaXN0ICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0Yy5zb3J0TGlzdCA9ICR0YWJsZS5kYXRhKCkuc29ydGxpc3Q7XG5cdFx0XHR9IGVsc2UgaWYgKCBtZXRhICYmICggJHRhYmxlLm1ldGFkYXRhKCkgJiYgJHRhYmxlLm1ldGFkYXRhKCkuc29ydGxpc3QgKSApIHtcblx0XHRcdFx0Yy5zb3J0TGlzdCA9ICR0YWJsZS5tZXRhZGF0YSgpLnNvcnRsaXN0O1xuXHRcdFx0fVxuXHRcdFx0Ly8gYXBwbHkgd2lkZ2V0IGluaXQgY29kZVxuXHRcdFx0dHMuYXBwbHlXaWRnZXQoIHRhYmxlLCB0cnVlICk7XG5cdFx0XHQvLyBpZiB1c2VyIGhhcyBzdXBwbGllZCBhIHNvcnQgbGlzdCB0byBjb25zdHJ1Y3RvclxuXHRcdFx0aWYgKCBjLnNvcnRMaXN0Lmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdHRzLnNvcnRPbiggYywgYy5zb3J0TGlzdCwge30sICFjLmluaXRXaWRnZXRzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0cy5zZXRIZWFkZXJzQ3NzKCBjICk7XG5cdFx0XHRcdGlmICggYy5pbml0V2lkZ2V0cyApIHtcblx0XHRcdFx0XHQvLyBhcHBseSB3aWRnZXQgZm9ybWF0XG5cdFx0XHRcdFx0dHMuYXBwbHlXaWRnZXQoIHRhYmxlLCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNob3cgcHJvY2Vzc2VzaW5nIGljb25cblx0XHRcdGlmICggYy5zaG93UHJvY2Vzc2luZyApIHtcblx0XHRcdFx0JHRhYmxlXG5cdFx0XHRcdC51bmJpbmQoICdzb3J0QmVnaW4nICsgYy5uYW1lc3BhY2UgKyAnIHNvcnRFbmQnICsgYy5uYW1lc3BhY2UgKVxuXHRcdFx0XHQuYmluZCggJ3NvcnRCZWdpbicgKyBjLm5hbWVzcGFjZSArICcgc29ydEVuZCcgKyBjLm5hbWVzcGFjZSwgZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KCBjLnRpbWVyUHJvY2Vzc2luZyApO1xuXHRcdFx0XHRcdHRzLmlzUHJvY2Vzc2luZyggdGFibGUgKTtcblx0XHRcdFx0XHRpZiAoIGUudHlwZSA9PT0gJ3NvcnRCZWdpbicgKSB7XG5cdFx0XHRcdFx0XHRjLnRpbWVyUHJvY2Vzc2luZyA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR0cy5pc1Byb2Nlc3NpbmcoIHRhYmxlLCB0cnVlICk7XG5cdFx0XHRcdFx0XHR9LCA1MDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbml0aWFsaXplZFxuXHRcdFx0dGFibGUuaGFzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHRcdFx0dGFibGUuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG5cdFx0XHRpZiAoIHRzLmRlYnVnKGMsICdjb3JlJykgKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCAnT3ZlcmFsbCBpbml0aWFsaXphdGlvbiB0aW1lOicgKyB0cy5iZW5jaG1hcmsoICQuZGF0YSggdGFibGUsICdzdGFydG92ZXJhbGx0aW1lcicgKSApICk7XG5cdFx0XHRcdGlmICggdHMuZGVidWcoYywgJ2NvcmUnKSAmJiBjb25zb2xlLmdyb3VwRW5kICkgeyBjb25zb2xlLmdyb3VwRW5kKCk7IH1cblx0XHRcdH1cblx0XHRcdCR0YWJsZS50cmlnZ2VySGFuZGxlciggJ3RhYmxlc29ydGVyLWluaXRpYWxpemVkJywgdGFibGUgKTtcblx0XHRcdGlmICggdHlwZW9mIGMuaW5pdGlhbGl6ZWQgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdGMuaW5pdGlhbGl6ZWQoIHRhYmxlICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJpbmRNZXRob2RzIDogZnVuY3Rpb24oIGMgKSB7XG5cdFx0XHR2YXIgJHRhYmxlID0gYy4kdGFibGUsXG5cdFx0XHRcdG5hbWVzcGFjZSA9IGMubmFtZXNwYWNlLFxuXHRcdFx0XHRldmVudHMgPSAoICdzb3J0UmVzZXQgdXBkYXRlIHVwZGF0ZVJvd3MgdXBkYXRlQWxsIHVwZGF0ZUhlYWRlcnMgYWRkUm93cyB1cGRhdGVDZWxsIHVwZGF0ZUNvbXBsZXRlICcgK1xuXHRcdFx0XHRcdCdzb3J0b24gYXBwZW5kQ2FjaGUgdXBkYXRlQ2FjaGUgYXBwbHlXaWRnZXRJZCBhcHBseVdpZGdldHMgcmVmcmVzaFdpZGdldHMgZGVzdHJveSBtb3VzZXVwICcgK1xuXHRcdFx0XHRcdCdtb3VzZWxlYXZlICcgKS5zcGxpdCggJyAnIClcblx0XHRcdFx0XHQuam9pbiggbmFtZXNwYWNlICsgJyAnICk7XG5cdFx0XHQvLyBhcHBseSBlYXN5IG1ldGhvZHMgdGhhdCB0cmlnZ2VyIGJvdW5kIGV2ZW50c1xuXHRcdFx0JHRhYmxlXG5cdFx0XHQudW5iaW5kKCBldmVudHMucmVwbGFjZSggdHMucmVnZXguc3BhY2VzLCAnICcgKSApXG5cdFx0XHQuYmluZCggJ3NvcnRSZXNldCcgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCBlLCBjYWxsYmFjayApIHtcblx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0Ly8gdXNpbmcgdGhpcy5jb25maWcgdG8gZW5zdXJlIGZ1bmN0aW9ucyBhcmUgZ2V0dGluZyBhIG5vbi1jYWNoZWQgdmVyc2lvbiBvZiB0aGUgY29uZmlnXG5cdFx0XHRcdHRzLnNvcnRSZXNldCggdGhpcy5jb25maWcsIGZ1bmN0aW9uKCB0YWJsZSApIHtcblx0XHRcdFx0XHRpZiAodGFibGUuaXNBcHBseWluZ1dpZGdldHMpIHtcblx0XHRcdFx0XHRcdC8vIG11bHRpcGxlIHRyaWdnZXJzIGluIGEgcm93Li4uIGZpbHRlclJlc2V0LCB0aGVuIHNvcnRSZXNldCAtIHNlZSAjMTM2MVxuXHRcdFx0XHRcdFx0Ly8gd2FpdCB0byB1cGRhdGUgd2lkZ2V0c1xuXHRcdFx0XHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHRzLmFwcGx5V2lkZ2V0KCB0YWJsZSwgJycsIGNhbGxiYWNrICk7XG5cdFx0XHRcdFx0XHR9LCAxMDAgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHMuYXBwbHlXaWRnZXQoIHRhYmxlLCAnJywgY2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCAndXBkYXRlQWxsJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oIGUsIHJlc29ydCwgY2FsbGJhY2sgKSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdHRzLnVwZGF0ZUFsbCggdGhpcy5jb25maWcsIHJlc29ydCwgY2FsbGJhY2sgKTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCggJ3VwZGF0ZScgKyBuYW1lc3BhY2UgKyAnIHVwZGF0ZVJvd3MnICsgbmFtZXNwYWNlLCBmdW5jdGlvbiggZSwgcmVzb3J0LCBjYWxsYmFjayApIHtcblx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0dHMudXBkYXRlKCB0aGlzLmNvbmZpZywgcmVzb3J0LCBjYWxsYmFjayApO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCAndXBkYXRlSGVhZGVycycgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCBlLCBjYWxsYmFjayApIHtcblx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0dHMudXBkYXRlSGVhZGVycyggdGhpcy5jb25maWcsIGNhbGxiYWNrICk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoICd1cGRhdGVDZWxsJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oIGUsIGNlbGwsIHJlc29ydCwgY2FsbGJhY2sgKSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdHRzLnVwZGF0ZUNlbGwoIHRoaXMuY29uZmlnLCBjZWxsLCByZXNvcnQsIGNhbGxiYWNrICk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoICdhZGRSb3dzJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oIGUsICRyb3csIHJlc29ydCwgY2FsbGJhY2sgKSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdHRzLmFkZFJvd3MoIHRoaXMuY29uZmlnLCAkcm93LCByZXNvcnQsIGNhbGxiYWNrICk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoICd1cGRhdGVDb21wbGV0ZScgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCggJ3NvcnRvbicgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCBlLCBsaXN0LCBjYWxsYmFjaywgaW5pdCApIHtcblx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0dHMuc29ydE9uKCB0aGlzLmNvbmZpZywgbGlzdCwgY2FsbGJhY2ssIGluaXQgKTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCggJ2FwcGVuZENhY2hlJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oIGUsIGNhbGxiYWNrLCBpbml0ICkge1xuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR0cy5hcHBlbmRDYWNoZSggdGhpcy5jb25maWcsIGluaXQgKTtcblx0XHRcdFx0aWYgKCAkLmlzRnVuY3Rpb24oIGNhbGxiYWNrICkgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC8vICR0Ym9kaWVzIHZhcmlhYmxlIGlzIHVzZWQgYnkgdGhlIHRib2R5IHNvcnRpbmcgd2lkZ2V0XG5cdFx0XHQuYmluZCggJ3VwZGF0ZUNhY2hlJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oIGUsIGNhbGxiYWNrLCAkdGJvZGllcyApIHtcblx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0dHMudXBkYXRlQ2FjaGUoIHRoaXMuY29uZmlnLCBjYWxsYmFjaywgJHRib2RpZXMgKTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCggJ2FwcGx5V2lkZ2V0SWQnICsgbmFtZXNwYWNlLCBmdW5jdGlvbiggZSwgaWQgKSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdHRzLmFwcGx5V2lkZ2V0SWQoIHRoaXMsIGlkICk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoICdhcHBseVdpZGdldHMnICsgbmFtZXNwYWNlLCBmdW5jdGlvbiggZSwgY2FsbGJhY2sgKSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdC8vIGFwcGx5IHdpZGdldHMgKGZhbHNlID0gbm90IGluaXRpYWxpemluZylcblx0XHRcdFx0dHMuYXBwbHlXaWRnZXQoIHRoaXMsIGZhbHNlLCBjYWxsYmFjayApO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCAncmVmcmVzaFdpZGdldHMnICsgbmFtZXNwYWNlLCBmdW5jdGlvbiggZSwgYWxsLCBkb250YXBwbHkgKSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdHRzLnJlZnJlc2hXaWRnZXRzKCB0aGlzLCBhbGwsIGRvbnRhcHBseSApO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCAncmVtb3ZlV2lkZ2V0JyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oIGUsIG5hbWUsIHJlZnJlc2hpbmcgKSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdHRzLnJlbW92ZVdpZGdldCggdGhpcywgbmFtZSwgcmVmcmVzaGluZyApO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCAnZGVzdHJveScgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCBlLCByZW1vdmVDbGFzc2VzLCBjYWxsYmFjayApIHtcblx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0dHMuZGVzdHJveSggdGhpcywgcmVtb3ZlQ2xhc3NlcywgY2FsbGJhY2sgKTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCggJ3Jlc2V0VG9Mb2FkU3RhdGUnICsgbmFtZXNwYWNlLCBmdW5jdGlvbiggZSApIHtcblx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0Ly8gcmVtb3ZlIGFsbCB3aWRnZXRzXG5cdFx0XHRcdHRzLnJlbW92ZVdpZGdldCggdGhpcywgdHJ1ZSwgZmFsc2UgKTtcblx0XHRcdFx0dmFyIHRtcCA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgYy5vcmlnaW5hbFNldHRpbmdzICk7XG5cdFx0XHRcdC8vIHJlc3RvcmUgb3JpZ2luYWwgc2V0dGluZ3M7IHRoaXMgY2xlYXJzIG91dCBjdXJyZW50IHNldHRpbmdzLCBidXQgZG9lcyBub3QgY2xlYXJcblx0XHRcdFx0Ly8gdmFsdWVzIHNhdmVkIHRvIHN0b3JhZ2UuXG5cdFx0XHRcdGMgPSAkLmV4dGVuZCggdHJ1ZSwge30sIHRzLmRlZmF1bHRzLCB0bXAgKTtcblx0XHRcdFx0Yy5vcmlnaW5hbFNldHRpbmdzID0gdG1wO1xuXHRcdFx0XHR0aGlzLmhhc0luaXRpYWxpemVkID0gZmFsc2U7XG5cdFx0XHRcdC8vIHNldHVwIHRoZSBlbnRpcmUgdGFibGUgYWdhaW5cblx0XHRcdFx0dHMuc2V0dXAoIHRoaXMsIGMgKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRiaW5kRXZlbnRzIDogZnVuY3Rpb24oIHRhYmxlLCAkaGVhZGVycywgY29yZSApIHtcblx0XHRcdHRhYmxlID0gJCggdGFibGUgKVsgMCBdO1xuXHRcdFx0dmFyIHRtcCxcblx0XHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdFx0bmFtZXNwYWNlID0gYy5uYW1lc3BhY2UsXG5cdFx0XHRcdGRvd25UYXJnZXQgPSBudWxsO1xuXHRcdFx0aWYgKCBjb3JlICE9PSB0cnVlICkge1xuXHRcdFx0XHQkaGVhZGVycy5hZGRDbGFzcyggbmFtZXNwYWNlLnNsaWNlKCAxICkgKyAnX2V4dHJhX2hlYWRlcnMnICk7XG5cdFx0XHRcdHRtcCA9IHRzLmdldENsb3Nlc3QoICRoZWFkZXJzLCAndGFibGUnICk7XG5cdFx0XHRcdGlmICggdG1wLmxlbmd0aCAmJiB0bXBbIDAgXS5ub2RlTmFtZSA9PT0gJ1RBQkxFJyAmJiB0bXBbIDAgXSAhPT0gdGFibGUgKSB7XG5cdFx0XHRcdFx0JCggdG1wWyAwIF0gKS5hZGRDbGFzcyggbmFtZXNwYWNlLnNsaWNlKCAxICkgKyAnX2V4dHJhX3RhYmxlJyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0bXAgPSAoIGMucG9pbnRlckRvd24gKyAnICcgKyBjLnBvaW50ZXJVcCArICcgJyArIGMucG9pbnRlckNsaWNrICsgJyBzb3J0IGtleXVwICcgKVxuXHRcdFx0XHQucmVwbGFjZSggdHMucmVnZXguc3BhY2VzLCAnICcgKVxuXHRcdFx0XHQuc3BsaXQoICcgJyApXG5cdFx0XHRcdC5qb2luKCBuYW1lc3BhY2UgKyAnICcgKTtcblx0XHRcdC8vIGFwcGx5IGV2ZW50IGhhbmRsaW5nIHRvIGhlYWRlcnMgYW5kL29yIGFkZGl0aW9uYWwgaGVhZGVycyAoc3RpY2t5aGVhZGVycywgc2Nyb2xsZXIsIGV0Yylcblx0XHRcdCRoZWFkZXJzXG5cdFx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzUzMTI4NDkvanF1ZXJ5LWZpbmQtc2VsZjtcblx0XHRcdC5maW5kKCBjLnNlbGVjdG9yU29ydCApXG5cdFx0XHQuYWRkKCAkaGVhZGVycy5maWx0ZXIoIGMuc2VsZWN0b3JTb3J0ICkgKVxuXHRcdFx0LnVuYmluZCggdG1wIClcblx0XHRcdC5iaW5kKCB0bXAsIGZ1bmN0aW9uKCBlLCBleHRlcm5hbCApIHtcblx0XHRcdFx0dmFyICRjZWxsLCBjZWxsLCB0ZW1wLFxuXHRcdFx0XHRcdCR0YXJnZXQgPSAkKCBlLnRhcmdldCApLFxuXHRcdFx0XHRcdC8vIHdyYXAgZXZlbnQgdHlwZSBpbiBzcGFjZXMsIHNvIHRoZSBtYXRjaCBkb2Vzbid0IHRyaWdnZXIgb24gaW5uZXIgd29yZHNcblx0XHRcdFx0XHR0eXBlID0gJyAnICsgZS50eXBlICsgJyAnO1xuXHRcdFx0XHQvLyBvbmx5IHJlY29nbml6ZSBsZWZ0IGNsaWNrc1xuXHRcdFx0XHRpZiAoICggKCBlLndoaWNoIHx8IGUuYnV0dG9uICkgIT09IDEgJiYgIXR5cGUubWF0Y2goICcgJyArIGMucG9pbnRlckNsaWNrICsgJyB8IHNvcnQgfCBrZXl1cCAnICkgKSB8fFxuXHRcdFx0XHRcdC8vIGFsbG93IHByZXNzaW5nIGVudGVyXG5cdFx0XHRcdFx0KCB0eXBlID09PSAnIGtleXVwICcgJiYgZS53aGljaCAhPT0gdHMua2V5Q29kZXMuZW50ZXIgKSB8fFxuXHRcdFx0XHRcdC8vIGFsbG93IHRyaWdnZXJpbmcgYSBjbGljayBldmVudCAoZS53aGljaCBpcyB1bmRlZmluZWQpICYgaWdub3JlIHBoeXNpY2FsIGNsaWNrc1xuXHRcdFx0XHRcdCggdHlwZS5tYXRjaCggJyAnICsgYy5wb2ludGVyQ2xpY2sgKyAnICcgKSAmJiB0eXBlb2YgZS53aGljaCAhPT0gJ3VuZGVmaW5lZCcgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWdub3JlIG1vdXNldXAgaWYgbW91c2Vkb3duIHdhc24ndCBvbiB0aGUgc2FtZSB0YXJnZXRcblx0XHRcdFx0aWYgKCB0eXBlLm1hdGNoKCAnICcgKyBjLnBvaW50ZXJVcCArICcgJyApICYmIGRvd25UYXJnZXQgIT09IGUudGFyZ2V0ICYmIGV4dGVybmFsICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBzZXQgdGFyZ2V0IG9uIG1vdXNlZG93blxuXHRcdFx0XHRpZiAoIHR5cGUubWF0Y2goICcgJyArIGMucG9pbnRlckRvd24gKyAnICcgKSApIHtcblx0XHRcdFx0XHRkb3duVGFyZ2V0ID0gZS50YXJnZXQ7XG5cdFx0XHRcdFx0Ly8gcHJldmVudERlZmF1bHQgbmVlZGVkIG9yIGpRdWVyeSB2MS4zLjIgYW5kIG9sZGVyIHRocm93cyBhblxuXHRcdFx0XHRcdC8vIFwiVW5jYXVnaHQgVHlwZUVycm9yOiBoYW5kbGVyLmFwcGx5IGlzIG5vdCBhIGZ1bmN0aW9uXCIgZXJyb3Jcblx0XHRcdFx0XHR0ZW1wID0gJHRhcmdldC5qcXVlcnkuc3BsaXQoICcuJyApO1xuXHRcdFx0XHRcdGlmICggdGVtcFsgMCBdID09PSAnMScgJiYgdGVtcFsgMSBdIDwgNCApIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRvd25UYXJnZXQgPSBudWxsO1xuXHRcdFx0XHQvLyBwcmV2ZW50IHNvcnQgYmVpbmcgdHJpZ2dlcmVkIG9uIGZvcm0gZWxlbWVudHNcblx0XHRcdFx0aWYgKCB0cy5yZWdleC5mb3JtRWxlbWVudHMudGVzdCggZS50YXJnZXQubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdC8vIG5vc29ydCBjbGFzcyBuYW1lLCBvciBlbGVtZW50cyB3aXRoaW4gYSBub3NvcnQgY29udGFpbmVyXG5cdFx0XHRcdFx0JHRhcmdldC5oYXNDbGFzcyggYy5jc3NOb1NvcnQgKSB8fCAkdGFyZ2V0LnBhcmVudHMoICcuJyArIGMuY3NzTm9Tb3J0ICkubGVuZ3RoID4gMCB8fFxuXHRcdFx0XHRcdC8vIGVsZW1lbnRzIHdpdGhpbiBhIGJ1dHRvblxuXHRcdFx0XHRcdCR0YXJnZXQucGFyZW50cyggJ2J1dHRvbicgKS5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRcdHJldHVybiAhYy5jYW5jZWxTZWxlY3Rpb247XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBjLmRlbGF5SW5pdCAmJiB0cy5pc0VtcHR5T2JqZWN0KCBjLmNhY2hlICkgKSB7XG5cdFx0XHRcdFx0dHMuYnVpbGRDYWNoZSggYyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCRjZWxsID0gdHMuZ2V0Q2xvc2VzdCggJCggdGhpcyApLCAnLicgKyB0cy5jc3MuaGVhZGVyICk7XG5cdFx0XHRcdC8vIHVzZSBjb2x1bW4gaW5kZXggZnJvbSBkYXRhLWF0dHJpYnV0ZSBvciBpbmRleCBvZiBjdXJyZW50IHJvdzsgZml4ZXMgIzExMTZcblx0XHRcdFx0Yy5sYXN0LmNsaWNrZWRJbmRleCA9ICRjZWxsLmF0dHIoICdkYXRhLWNvbHVtbicgKSB8fCAkY2VsbC5pbmRleCgpO1xuXHRcdFx0XHRjZWxsID0gYy4kaGVhZGVySW5kZXhlZFsgYy5sYXN0LmNsaWNrZWRJbmRleCBdWzBdO1xuXHRcdFx0XHRpZiAoIGNlbGwgJiYgIWNlbGwuc29ydERpc2FibGVkICkge1xuXHRcdFx0XHRcdHRzLmluaXRTb3J0KCBjLCBjZWxsLCBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0aWYgKCBjLmNhbmNlbFNlbGVjdGlvbiApIHtcblx0XHRcdFx0Ly8gY2FuY2VsIHNlbGVjdGlvblxuXHRcdFx0XHQkaGVhZGVyc1xuXHRcdFx0XHRcdC5hdHRyKCAndW5zZWxlY3RhYmxlJywgJ29uJyApXG5cdFx0XHRcdFx0LmJpbmQoICdzZWxlY3RzdGFydCcsIGZhbHNlIClcblx0XHRcdFx0XHQuY3NzKHtcblx0XHRcdFx0XHRcdCd1c2VyLXNlbGVjdCcgOiAnbm9uZScsXG5cdFx0XHRcdFx0XHQnTW96VXNlclNlbGVjdCcgOiAnbm9uZScgLy8gbm90IG5lZWRlZCBmb3IgalF1ZXJ5IDEuOCtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YnVpbGRIZWFkZXJzIDogZnVuY3Rpb24oIGMgKSB7XG5cdFx0XHR2YXIgJHRlbXAsIGljb24sIHRpbWVyLCBpbmR4O1xuXHRcdFx0Yy5oZWFkZXJMaXN0ID0gW107XG5cdFx0XHRjLmhlYWRlckNvbnRlbnQgPSBbXTtcblx0XHRcdGMuc29ydFZhcnMgPSBbXTtcblx0XHRcdGlmICggdHMuZGVidWcoYywgJ2NvcmUnKSApIHtcblx0XHRcdFx0dGltZXIgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY2hpbGRyZW4gdHIgaW4gdGZvb3QgLSBzZWUgaXNzdWUgIzE5NiAmICM1NDdcblx0XHRcdC8vIGRvbid0IHBhc3MgdGFibGUuY29uZmlnIHRvIGNvbXB1dGVDb2x1bW5JbmRleCBoZXJlIC0gd2lkZ2V0cyAobWF0aCkgcGFzcyBpdCB0byBcInF1aWNrbHlcIiBpbmRleCB0Ym9keSBjZWxsc1xuXHRcdFx0Yy5jb2x1bW5zID0gdHMuY29tcHV0ZUNvbHVtbkluZGV4KCBjLiR0YWJsZS5jaGlsZHJlbiggJ3RoZWFkLCB0Zm9vdCcgKS5jaGlsZHJlbiggJ3RyJyApICk7XG5cdFx0XHQvLyBhZGQgaWNvbiBpZiBjc3NJY29uIG9wdGlvbiBleGlzdHNcblx0XHRcdGljb24gPSBjLmNzc0ljb24gP1xuXHRcdFx0XHQnPGkgY2xhc3M9XCInICsgKCBjLmNzc0ljb24gPT09IHRzLmNzcy5pY29uID8gdHMuY3NzLmljb24gOiBjLmNzc0ljb24gKyAnICcgKyB0cy5jc3MuaWNvbiApICsgJ1wiPjwvaT4nIDpcblx0XHRcdFx0Jyc7XG5cdFx0XHQvLyByZWRlZmluZSBjLiRoZWFkZXJzIGhlcmUgaW4gY2FzZSBvZiBhbiB1cGRhdGVBbGwgdGhhdCByZXBsYWNlcyBvciBhZGRzIGFuIGVudGlyZSBoZWFkZXIgY2VsbCAtIHNlZSAjNjgzXG5cdFx0XHRjLiRoZWFkZXJzID0gJCggJC5tYXAoIGMuJHRhYmxlLmZpbmQoIGMuc2VsZWN0b3JIZWFkZXJzICksIGZ1bmN0aW9uKCBlbGVtLCBpbmRleCApIHtcblx0XHRcdFx0dmFyIGNvbmZpZ0hlYWRlcnMsIGhlYWRlciwgY29sdW1uLCB0ZW1wbGF0ZSwgdG1wLFxuXHRcdFx0XHRcdCRlbGVtID0gJCggZWxlbSApO1xuXHRcdFx0XHQvLyBpZ25vcmUgY2VsbCAoZG9uJ3QgYWRkIGl0IHRvIGMuJGhlYWRlcnMpIGlmIHJvdyBoYXMgaWdub3JlUm93IGNsYXNzXG5cdFx0XHRcdGlmICggdHMuZ2V0Q2xvc2VzdCggJGVsZW0sICd0cicgKS5oYXNDbGFzcyggYy5jc3NJZ25vcmVSb3cgKSApIHsgcmV0dXJuOyB9XG5cdFx0XHRcdC8vIHRyYW5zZmVyIGRhdGEtY29sdW1uIHRvIGVsZW1lbnQgaWYgbm90IHRoL3RkIC0gIzE0NTlcblx0XHRcdFx0aWYgKCAhLyh0aHx0ZCkvaS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgKSB7XG5cdFx0XHRcdFx0dG1wID0gdHMuZ2V0Q2xvc2VzdCggJGVsZW0sICd0aCwgdGQnICk7XG5cdFx0XHRcdFx0JGVsZW0uYXR0ciggJ2RhdGEtY29sdW1uJywgdG1wLmF0dHIoICdkYXRhLWNvbHVtbicgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG1ha2Ugc3VyZSB0byBnZXQgaGVhZGVyIGNlbGwgJiBub3QgY29sdW1uIGluZGV4ZWQgY2VsbFxuXHRcdFx0XHRjb25maWdIZWFkZXJzID0gdHMuZ2V0Q29sdW1uRGF0YSggYy50YWJsZSwgYy5oZWFkZXJzLCBpbmRleCwgdHJ1ZSApO1xuXHRcdFx0XHQvLyBzYXZlIG9yaWdpbmFsIGhlYWRlciBjb250ZW50XG5cdFx0XHRcdGMuaGVhZGVyQ29udGVudFsgaW5kZXggXSA9ICRlbGVtLmh0bWwoKTtcblx0XHRcdFx0Ly8gaWYgaGVhZGVyVGVtcGxhdGUgaXMgZW1wdHksIGRvbid0IHJlZm9ybWF0IHRoZSBoZWFkZXIgY2VsbFxuXHRcdFx0XHRpZiAoIGMuaGVhZGVyVGVtcGxhdGUgIT09ICcnICYmICEkZWxlbS5maW5kKCAnLicgKyB0cy5jc3MuaGVhZGVySW4gKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0Ly8gc2V0IHVwIGhlYWRlciB0ZW1wbGF0ZVxuXHRcdFx0XHRcdHRlbXBsYXRlID0gYy5oZWFkZXJUZW1wbGF0ZVxuXHRcdFx0XHRcdFx0LnJlcGxhY2UoIHRzLnJlZ2V4LnRlbXBsYXRlQ29udGVudCwgJGVsZW0uaHRtbCgpIClcblx0XHRcdFx0XHRcdC5yZXBsYWNlKCB0cy5yZWdleC50ZW1wbGF0ZUljb24sICRlbGVtLmZpbmQoICcuJyArIHRzLmNzcy5pY29uICkubGVuZ3RoID8gJycgOiBpY29uICk7XG5cdFx0XHRcdFx0aWYgKCBjLm9uUmVuZGVyVGVtcGxhdGUgKSB7XG5cdFx0XHRcdFx0XHRoZWFkZXIgPSBjLm9uUmVuZGVyVGVtcGxhdGUuYXBwbHkoICRlbGVtLCBbIGluZGV4LCB0ZW1wbGF0ZSBdICk7XG5cdFx0XHRcdFx0XHQvLyBvbmx5IGNoYW5nZSB0IGlmIHNvbWV0aGluZyBpcyByZXR1cm5lZFxuXHRcdFx0XHRcdFx0aWYgKCBoZWFkZXIgJiYgdHlwZW9mIGhlYWRlciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRcdHRlbXBsYXRlID0gaGVhZGVyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQkZWxlbS5odG1sKCAnPGRpdiBjbGFzcz1cIicgKyB0cy5jc3MuaGVhZGVySW4gKyAnXCI+JyArIHRlbXBsYXRlICsgJzwvZGl2PicgKTsgLy8gZmFzdGVyIHRoYW4gd3JhcElubmVyXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBjLm9uUmVuZGVySGVhZGVyICkge1xuXHRcdFx0XHRcdGMub25SZW5kZXJIZWFkZXIuYXBwbHkoICRlbGVtLCBbIGluZGV4LCBjLCBjLiR0YWJsZSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29sdW1uID0gcGFyc2VJbnQoICRlbGVtLmF0dHIoICdkYXRhLWNvbHVtbicgKSwgMTAgKTtcblx0XHRcdFx0ZWxlbS5jb2x1bW4gPSBjb2x1bW47XG5cdFx0XHRcdHRtcCA9IHRzLmdldE9yZGVyKCB0cy5nZXREYXRhKCAkZWxlbSwgY29uZmlnSGVhZGVycywgJ3NvcnRJbml0aWFsT3JkZXInICkgfHwgYy5zb3J0SW5pdGlhbE9yZGVyICk7XG5cdFx0XHRcdC8vIHRoaXMgbWF5IGdldCB1cGRhdGVkIG51bWVyb3VzIHRpbWVzIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSByb3dzXG5cdFx0XHRcdGMuc29ydFZhcnNbIGNvbHVtbiBdID0ge1xuXHRcdFx0XHRcdGNvdW50IDogLTEsIC8vIHNldCB0byAtMSBiZWNhdXNlIGNsaWNraW5nIG9uIHRoZSBoZWFkZXIgYXV0b21hdGljYWxseSBhZGRzIG9uZVxuXHRcdFx0XHRcdG9yZGVyOiAgdG1wID9cblx0XHRcdFx0XHRcdCggYy5zb3J0UmVzZXQgPyBbIDEsIDAsIDIgXSA6IFsgMSwgMCBdICkgOiAvLyBkZXNjLCBhc2MsIHVuc29ydGVkXG5cdFx0XHRcdFx0XHQoIGMuc29ydFJlc2V0ID8gWyAwLCAxLCAyIF0gOiBbIDAsIDEgXSApLCAgLy8gYXNjLCBkZXNjLCB1bnNvcnRlZFxuXHRcdFx0XHRcdGxvY2tlZE9yZGVyIDogZmFsc2Vcblx0XHRcdFx0fTtcblx0XHRcdFx0dG1wID0gdHMuZ2V0RGF0YSggJGVsZW0sIGNvbmZpZ0hlYWRlcnMsICdsb2NrZWRPcmRlcicgKSB8fCBmYWxzZTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgdG1wICE9PSAndW5kZWZpbmVkJyAmJiB0bXAgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGMuc29ydFZhcnNbIGNvbHVtbiBdLmxvY2tlZE9yZGVyID0gdHJ1ZTtcblx0XHRcdFx0XHRjLnNvcnRWYXJzWyBjb2x1bW4gXS5vcmRlciA9IHRzLmdldE9yZGVyKCB0bXAgKSA/IFsgMSwgMSBdIDogWyAwLCAwIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gYWRkIGNlbGwgdG8gaGVhZGVyTGlzdFxuXHRcdFx0XHRjLmhlYWRlckxpc3RbIGluZGV4IF0gPSBlbGVtO1xuXHRcdFx0XHQkZWxlbS5hZGRDbGFzcyggdHMuY3NzLmhlYWRlciArICcgJyArIGMuY3NzSGVhZGVyICk7XG5cdFx0XHRcdC8vIGFkZCB0byBwYXJlbnQgaW4gY2FzZSB0aGVyZSBhcmUgbXVsdGlwbGUgcm93c1xuXHRcdFx0XHR0cy5nZXRDbG9zZXN0KCAkZWxlbSwgJ3RyJyApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCB0cy5jc3MuaGVhZGVyUm93ICsgJyAnICsgYy5jc3NIZWFkZXJSb3cgKVxuXHRcdFx0XHRcdC5hdHRyKCAncm9sZScsICdyb3cnICk7XG5cdFx0XHRcdC8vIGFsbG93IGtleWJvYXJkIGN1cnNvciB0byBmb2N1cyBvbiBlbGVtZW50XG5cdFx0XHRcdGlmICggYy50YWJJbmRleCApIHtcblx0XHRcdFx0XHQkZWxlbS5hdHRyKCAndGFiaW5kZXgnLCAwICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9KSApO1xuXHRcdFx0Ly8gY2FjaGUgaGVhZGVycyBwZXIgY29sdW1uXG5cdFx0XHRjLiRoZWFkZXJJbmRleGVkID0gW107XG5cdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGMuY29sdW1uczsgaW5keCsrICkge1xuXHRcdFx0XHQvLyBjb2xzcGFuIGluIGhlYWRlciBtYWtpbmcgYSBjb2x1bW4gdW5kZWZpbmVkXG5cdFx0XHRcdGlmICggdHMuaXNFbXB0eU9iamVjdCggYy5zb3J0VmFyc1sgaW5keCBdICkgKSB7XG5cdFx0XHRcdFx0Yy5zb3J0VmFyc1sgaW5keCBdID0ge307XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVXNlIGMuJGhlYWRlcnMucGFyZW50KCkgaW4gY2FzZSBzZWxlY3RvckhlYWRlcnMgZG9lc24ndCBwb2ludCB0byB0aGUgdGgvdGRcblx0XHRcdFx0JHRlbXAgPSBjLiRoZWFkZXJzLmZpbHRlciggJ1tkYXRhLWNvbHVtbj1cIicgKyBpbmR4ICsgJ1wiXScgKTtcblx0XHRcdFx0Ly8gdGFyZ2V0IHNvcnRhYmxlIGNvbHVtbiBjZWxscywgdW5sZXNzIHRoZXJlIGFyZSBub25lLCB0aGVuIHVzZSBub24tc29ydGFibGUgY2VsbHNcblx0XHRcdFx0Ly8gLmxhc3QoKSBhZGRlZCBpbiBqUXVlcnkgMS40OyB1c2UgLmZpbHRlcignOmxhc3QnKSB0byBtYWludGFpbiBjb21wYXRpYmlsaXR5IHdpdGggalF1ZXJ5IHYxLjIuNlxuXHRcdFx0XHRjLiRoZWFkZXJJbmRleGVkWyBpbmR4IF0gPSAkdGVtcC5sZW5ndGggP1xuXHRcdFx0XHRcdCR0ZW1wLm5vdCggJy5zb3J0ZXItZmFsc2UnICkubGVuZ3RoID9cblx0XHRcdFx0XHRcdCR0ZW1wLm5vdCggJy5zb3J0ZXItZmFsc2UnICkuZmlsdGVyKCAnOmxhc3QnICkgOlxuXHRcdFx0XHRcdFx0JHRlbXAuZmlsdGVyKCAnOmxhc3QnICkgOlxuXHRcdFx0XHRcdCQoKTtcblx0XHRcdH1cblx0XHRcdGMuJHRhYmxlLmZpbmQoIGMuc2VsZWN0b3JIZWFkZXJzICkuYXR0cih7XG5cdFx0XHRcdHNjb3BlOiAnY29sJyxcblx0XHRcdFx0cm9sZSA6ICdjb2x1bW5oZWFkZXInXG5cdFx0XHR9KTtcblx0XHRcdC8vIGVuYWJsZS9kaXNhYmxlIHNvcnRpbmdcblx0XHRcdHRzLnVwZGF0ZUhlYWRlciggYyApO1xuXHRcdFx0aWYgKCB0cy5kZWJ1ZyhjLCAnY29yZScpICkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyggJ0J1aWx0IGhlYWRlcnM6JyArIHRzLmJlbmNobWFyayggdGltZXIgKSApO1xuXHRcdFx0XHRjb25zb2xlLmxvZyggYy4kaGVhZGVycyApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBVc2UgaXQgdG8gYWRkIGEgc2V0IG9mIG1ldGhvZHMgdG8gdGFibGUuY29uZmlnIHdoaWNoIHdpbGwgYmUgYXZhaWxhYmxlIGZvciBhbGwgdGFibGVzLlxuXHRcdC8vIFRoaXMgc2hvdWxkIGJlIGRvbmUgYmVmb3JlIHRhYmxlIGluaXRpYWxpemF0aW9uXG5cdFx0YWRkSW5zdGFuY2VNZXRob2RzIDogZnVuY3Rpb24oIG1ldGhvZHMgKSB7XG5cdFx0XHQkLmV4dGVuZCggdHMuaW5zdGFuY2VNZXRob2RzLCBtZXRob2RzICk7XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx04paI4paI4paI4paI4paI4paEIOKWhOKWiOKWiOKWiOKWiOKWhCDilojilojilojilojilojiloQg4paE4paI4paI4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiCDilojilojilojilojilojiloQg4paE4paI4paI4paI4paI4paIXG5cdFx04paI4paI4paE4paE4paI4paIIOKWiOKWiOKWhOKWhOKWiOKWiCDilojilojiloTiloTilojilogg4paA4paI4paEICAgIOKWiOKWiOKWhOKWhCAgIOKWiOKWiOKWhOKWhOKWiOKWiCDiloDilojiloRcblx0XHTilojilojiloDiloDiloAgIOKWiOKWiOKWgOKWgOKWiOKWiCDilojilojiloDilojiloggICAgIOKWgOKWiOKWhCDilojilojiloDiloAgICDilojilojiloDilojiloggICAgIOKWgOKWiOKWhFxuXHRcdOKWiOKWiCAgICAg4paI4paIICDilojilogg4paI4paIICDilojilogg4paI4paI4paI4paI4paI4paAIOKWiOKWiOKWiOKWiOKWiOKWiCDilojiloggIOKWiOKWiCDilojilojilojilojilojiloBcblx0XHQqL1xuXHRcdHNldHVwUGFyc2VycyA6IGZ1bmN0aW9uKCBjLCAkdGJvZGllcyApIHtcblx0XHRcdHZhciByb3dzLCBsaXN0LCBzcGFuLCBtYXgsIGNvbEluZGV4LCBpbmR4LCBoZWFkZXIsIGNvbmZpZ0hlYWRlcnMsXG5cdFx0XHRcdG5vUGFyc2VyLCBwYXJzZXIsIGV4dHJhY3RvciwgdGltZSwgdGJvZHksIGxlbixcblx0XHRcdFx0dGFibGUgPSBjLnRhYmxlLFxuXHRcdFx0XHR0Ym9keUluZGV4ID0gMCxcblx0XHRcdFx0ZGVidWcgPSB0cy5kZWJ1ZyhjLCAnY29yZScpLFxuXHRcdFx0XHRkZWJ1Z091dHB1dCA9IHt9O1xuXHRcdFx0Ly8gdXBkYXRlIHRhYmxlIGJvZGllcyBpbiBjYXNlIHdlIHN0YXJ0IHdpdGggYW4gZW1wdHkgdGFibGVcblx0XHRcdGMuJHRib2RpZXMgPSBjLiR0YWJsZS5jaGlsZHJlbiggJ3Rib2R5Om5vdCguJyArIGMuY3NzSW5mb0Jsb2NrICsgJyknICk7XG5cdFx0XHR0Ym9keSA9IHR5cGVvZiAkdGJvZGllcyA9PT0gJ3VuZGVmaW5lZCcgPyBjLiR0Ym9kaWVzIDogJHRib2RpZXM7XG5cdFx0XHRsZW4gPSB0Ym9keS5sZW5ndGg7XG5cdFx0XHRpZiAoIGxlbiA9PT0gMCApIHtcblx0XHRcdFx0cmV0dXJuIGRlYnVnID8gY29uc29sZS53YXJuKCAnV2FybmluZzogKkVtcHR5IHRhYmxlISogTm90IGJ1aWxkaW5nIGEgcGFyc2VyIGNhY2hlJyApIDogJyc7XG5cdFx0XHR9IGVsc2UgaWYgKCBkZWJ1ZyApIHtcblx0XHRcdFx0dGltZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHRcdGNvbnNvbGVbIGNvbnNvbGUuZ3JvdXAgPyAnZ3JvdXAnIDogJ2xvZycgXSggJ0RldGVjdGluZyBwYXJzZXJzIGZvciBlYWNoIGNvbHVtbicgKTtcblx0XHRcdH1cblx0XHRcdGxpc3QgPSB7XG5cdFx0XHRcdGV4dHJhY3RvcnM6IFtdLFxuXHRcdFx0XHRwYXJzZXJzOiBbXVxuXHRcdFx0fTtcblx0XHRcdHdoaWxlICggdGJvZHlJbmRleCA8IGxlbiApIHtcblx0XHRcdFx0cm93cyA9IHRib2R5WyB0Ym9keUluZGV4IF0ucm93cztcblx0XHRcdFx0aWYgKCByb3dzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRjb2xJbmRleCA9IDA7XG5cdFx0XHRcdFx0bWF4ID0gYy5jb2x1bW5zO1xuXHRcdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbWF4OyBpbmR4KysgKSB7XG5cdFx0XHRcdFx0XHRoZWFkZXIgPSBjLiRoZWFkZXJJbmRleGVkWyBjb2xJbmRleCBdO1xuXHRcdFx0XHRcdFx0aWYgKCBoZWFkZXIgJiYgaGVhZGVyLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0IGNvbHVtbiBpbmRleGVkIHRhYmxlIGNlbGw7IGFkZGluZyB0cnVlIHBhcmFtZXRlciBmaXhlcyAjMTM2MiBidXRcblx0XHRcdFx0XHRcdFx0Ly8gaXQgd291bGQgYnJlYWsgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuLi5cblx0XHRcdFx0XHRcdFx0Y29uZmlnSGVhZGVycyA9IHRzLmdldENvbHVtbkRhdGEoIHRhYmxlLCBjLmhlYWRlcnMsIGNvbEluZGV4ICk7IC8vICwgdHJ1ZSApO1xuXHRcdFx0XHRcdFx0XHQvLyBnZXQgY29sdW1uIHBhcnNlci9leHRyYWN0b3Jcblx0XHRcdFx0XHRcdFx0ZXh0cmFjdG9yID0gdHMuZ2V0UGFyc2VyQnlJZCggdHMuZ2V0RGF0YSggaGVhZGVyLCBjb25maWdIZWFkZXJzLCAnZXh0cmFjdG9yJyApICk7XG5cdFx0XHRcdFx0XHRcdHBhcnNlciA9IHRzLmdldFBhcnNlckJ5SWQoIHRzLmdldERhdGEoIGhlYWRlciwgY29uZmlnSGVhZGVycywgJ3NvcnRlcicgKSApO1xuXHRcdFx0XHRcdFx0XHRub1BhcnNlciA9IHRzLmdldERhdGEoIGhlYWRlciwgY29uZmlnSGVhZGVycywgJ3BhcnNlcicgKSA9PT0gJ2ZhbHNlJztcblx0XHRcdFx0XHRcdFx0Ly8gZW1wdHkgY2VsbHMgYmVoYXZpb3VyIC0ga2VlcGluZyBlbXB0eVRvQm90dG9tIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRjLmVtcHRpZXNbY29sSW5kZXhdID0gKFxuXHRcdFx0XHRcdFx0XHRcdHRzLmdldERhdGEoIGhlYWRlciwgY29uZmlnSGVhZGVycywgJ2VtcHR5JyApIHx8XG5cdFx0XHRcdFx0XHRcdFx0Yy5lbXB0eVRvIHx8ICggYy5lbXB0eVRvQm90dG9tID8gJ2JvdHRvbScgOiAndG9wJyApICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdFx0Ly8gdGV4dCBzdHJpbmdzIGJlaGF2aW91ciBpbiBudW1lcmljYWwgc29ydHNcblx0XHRcdFx0XHRcdFx0Yy5zdHJpbmdzW2NvbEluZGV4XSA9IChcblx0XHRcdFx0XHRcdFx0XHR0cy5nZXREYXRhKCBoZWFkZXIsIGNvbmZpZ0hlYWRlcnMsICdzdHJpbmcnICkgfHxcblx0XHRcdFx0XHRcdFx0XHRjLnN0cmluZ1RvIHx8XG5cdFx0XHRcdFx0XHRcdFx0J21heCcgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5vUGFyc2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdHBhcnNlciA9IHRzLmdldFBhcnNlckJ5SWQoICduby1wYXJzZXInICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCAhZXh0cmFjdG9yICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIEZvciBub3csIG1heWJlIGRldGVjdCBzb21lZGF5XG5cdFx0XHRcdFx0XHRcdFx0ZXh0cmFjdG9yID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCAhcGFyc2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdHBhcnNlciA9IHRzLmRldGVjdFBhcnNlckZvckNvbHVtbiggYywgcm93cywgLTEsIGNvbEluZGV4ICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCBkZWJ1ZyApIHtcblx0XHRcdFx0XHRcdFx0XHRkZWJ1Z091dHB1dFsgJygnICsgY29sSW5kZXggKyAnKSAnICsgaGVhZGVyLnRleHQoKSBdID0ge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VyIDogcGFyc2VyLmlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZXh0cmFjdG9yIDogZXh0cmFjdG9yID8gZXh0cmFjdG9yLmlkIDogJ25vbmUnLFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RyaW5nIDogYy5zdHJpbmdzWyBjb2xJbmRleCBdLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZW1wdHkgIDogYy5lbXB0aWVzWyBjb2xJbmRleCBdXG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRsaXN0LnBhcnNlcnNbIGNvbEluZGV4IF0gPSBwYXJzZXI7XG5cdFx0XHRcdFx0XHRcdGxpc3QuZXh0cmFjdG9yc1sgY29sSW5kZXggXSA9IGV4dHJhY3Rvcjtcblx0XHRcdFx0XHRcdFx0c3BhbiA9IGhlYWRlclsgMCBdLmNvbFNwYW4gLSAxO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwYW4gPiAwICkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbEluZGV4ICs9IHNwYW47XG5cdFx0XHRcdFx0XHRcdFx0bWF4ICs9IHNwYW47XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCBzcGFuICsgMSA+IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBzZXQgY29sc3BhbiBjb2x1bW5zIHRvIHVzZSB0aGUgc2FtZSBwYXJzZXJzICYgZXh0cmFjdG9yc1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wYXJzZXJzWyBjb2xJbmRleCAtIHNwYW4gXSA9IHBhcnNlcjtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QuZXh0cmFjdG9yc1sgY29sSW5kZXggLSBzcGFuIF0gPSBleHRyYWN0b3I7XG5cdFx0XHRcdFx0XHRcdFx0XHRzcGFuLS07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb2xJbmRleCsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0Ym9keUluZGV4ICs9ICggbGlzdC5wYXJzZXJzLmxlbmd0aCApID8gbGVuIDogMTtcblx0XHRcdH1cblx0XHRcdGlmICggZGVidWcgKSB7XG5cdFx0XHRcdGlmICggIXRzLmlzRW1wdHlPYmplY3QoIGRlYnVnT3V0cHV0ICkgKSB7XG5cdFx0XHRcdFx0Y29uc29sZVsgY29uc29sZS50YWJsZSA/ICd0YWJsZScgOiAnbG9nJyBdKCBkZWJ1Z091dHB1dCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJyAgTm8gcGFyc2VycyBkZXRlY3RlZCEnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc29sZS5sb2coICdDb21wbGV0ZWQgZGV0ZWN0aW5nIHBhcnNlcnMnICsgdHMuYmVuY2htYXJrKCB0aW1lICkgKTtcblx0XHRcdFx0aWYgKCBjb25zb2xlLmdyb3VwRW5kICkgeyBjb25zb2xlLmdyb3VwRW5kKCk7IH1cblx0XHRcdH1cblx0XHRcdGMucGFyc2VycyA9IGxpc3QucGFyc2Vycztcblx0XHRcdGMuZXh0cmFjdG9ycyA9IGxpc3QuZXh0cmFjdG9ycztcblx0XHR9LFxuXG5cdFx0YWRkUGFyc2VyIDogZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBpbmR4LFxuXHRcdFx0XHRsZW4gPSB0cy5wYXJzZXJzLmxlbmd0aCxcblx0XHRcdFx0YWRkID0gdHJ1ZTtcblx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XG5cdFx0XHRcdGlmICggdHMucGFyc2Vyc1sgaW5keCBdLmlkLnRvTG93ZXJDYXNlKCkgPT09IHBhcnNlci5pZC50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdGFkZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGFkZCApIHtcblx0XHRcdFx0dHMucGFyc2Vyc1sgdHMucGFyc2Vycy5sZW5ndGggXSA9IHBhcnNlcjtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0UGFyc2VyQnlJZCA6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdFx0Lypqc2hpbnQgZXFlcWVxOmZhbHNlICovIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdGlmICggbmFtZSA9PSAnZmFsc2UnICkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdHZhciBpbmR4LFxuXHRcdFx0XHRsZW4gPSB0cy5wYXJzZXJzLmxlbmd0aDtcblx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XG5cdFx0XHRcdGlmICggdHMucGFyc2Vyc1sgaW5keCBdLmlkLnRvTG93ZXJDYXNlKCkgPT09ICggbmFtZS50b1N0cmluZygpICkudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHMucGFyc2Vyc1sgaW5keCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdGRldGVjdFBhcnNlckZvckNvbHVtbiA6IGZ1bmN0aW9uKCBjLCByb3dzLCByb3dJbmRleCwgY2VsbEluZGV4ICkge1xuXHRcdFx0dmFyIGN1ciwgJG5vZGUsIHJvdyxcblx0XHRcdFx0aW5keCA9IHRzLnBhcnNlcnMubGVuZ3RoLFxuXHRcdFx0XHRub2RlID0gZmFsc2UsXG5cdFx0XHRcdG5vZGVWYWx1ZSA9ICcnLFxuXHRcdFx0XHRkZWJ1ZyA9IHRzLmRlYnVnKGMsICdjb3JlJyksXG5cdFx0XHRcdGtlZXBMb29raW5nID0gdHJ1ZTtcblx0XHRcdHdoaWxlICggbm9kZVZhbHVlID09PSAnJyAmJiBrZWVwTG9va2luZyApIHtcblx0XHRcdFx0cm93SW5kZXgrKztcblx0XHRcdFx0cm93ID0gcm93c1sgcm93SW5kZXggXTtcblx0XHRcdFx0Ly8gc3RvcCBsb29raW5nIGFmdGVyIDUwIGVtcHR5IHJvd3Ncblx0XHRcdFx0aWYgKCByb3cgJiYgcm93SW5kZXggPCA1MCApIHtcblx0XHRcdFx0XHRpZiAoIHJvdy5jbGFzc05hbWUuaW5kZXhPZiggdHMuY3NzSWdub3JlUm93ICkgPCAwICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IHJvd3NbIHJvd0luZGV4IF0uY2VsbHNbIGNlbGxJbmRleCBdO1xuXHRcdFx0XHRcdFx0bm9kZVZhbHVlID0gdHMuZ2V0RWxlbWVudFRleHQoIGMsIG5vZGUsIGNlbGxJbmRleCApO1xuXHRcdFx0XHRcdFx0JG5vZGUgPSAkKCBub2RlICk7XG5cdFx0XHRcdFx0XHRpZiAoIGRlYnVnICkge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyggJ0NoZWNraW5nIGlmIHZhbHVlIHdhcyBlbXB0eSBvbiByb3cgJyArIHJvd0luZGV4ICsgJywgY29sdW1uOiAnICtcblx0XHRcdFx0XHRcdFx0XHRjZWxsSW5kZXggKyAnOiBcIicgKyBub2RlVmFsdWUgKyAnXCInICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGtlZXBMb29raW5nID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdoaWxlICggLS1pbmR4ID49IDAgKSB7XG5cdFx0XHRcdGN1ciA9IHRzLnBhcnNlcnNbIGluZHggXTtcblx0XHRcdFx0Ly8gaWdub3JlIHRoZSBkZWZhdWx0IHRleHQgcGFyc2VyIGJlY2F1c2UgaXQgd2lsbCBhbHdheXMgYmUgdHJ1ZVxuXHRcdFx0XHRpZiAoIGN1ciAmJiBjdXIuaWQgIT09ICd0ZXh0JyAmJiBjdXIuaXMgJiYgY3VyLmlzKCBub2RlVmFsdWUsIGMudGFibGUsIG5vZGUsICRub2RlICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGN1cjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gbm90aGluZyBmb3VuZCwgcmV0dXJuIHRoZSBnZW5lcmljIHBhcnNlciAodGV4dClcblx0XHRcdHJldHVybiB0cy5nZXRQYXJzZXJCeUlkKCAndGV4dCcgKTtcblx0XHR9LFxuXG5cdFx0Z2V0RWxlbWVudFRleHQgOiBmdW5jdGlvbiggYywgbm9kZSwgY2VsbEluZGV4ICkge1xuXHRcdFx0aWYgKCAhbm9kZSApIHsgcmV0dXJuICcnOyB9XG5cdFx0XHR2YXIgdG1wLFxuXHRcdFx0XHRleHRyYWN0ID0gYy50ZXh0RXh0cmFjdGlvbiB8fCAnJyxcblx0XHRcdFx0Ly8gbm9kZSBjb3VsZCBiZSBhIGpxdWVyeSBvYmplY3Rcblx0XHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vanF1ZXJ5LXZzLWluc3RhbmNlb2YtanF1ZXJ5LzJcblx0XHRcdFx0JG5vZGUgPSBub2RlLmpxdWVyeSA/IG5vZGUgOiAkKCBub2RlICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBleHRyYWN0ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0Ly8gY2hlY2sgZGF0YS1hdHRyaWJ1dGUgZmlyc3Qgd2hlbiBzZXQgdG8gJ2Jhc2ljJzsgZG9uJ3QgdXNlIG5vZGUuaW5uZXJUZXh0IC0gaXQncyByZWFsbHkgc2xvdyFcblx0XHRcdFx0Ly8gaHR0cDovL3d3dy5rZWxsZWdvdXMuY29tL2ovMjAxMy8wMi8yNy9pbm5lcnRleHQtdnMtdGV4dGNvbnRlbnQvXG5cdFx0XHRcdGlmICggZXh0cmFjdCA9PT0gJ2Jhc2ljJyAmJiB0eXBlb2YgKCB0bXAgPSAkbm9kZS5hdHRyKCBjLnRleHRBdHRyaWJ1dGUgKSApICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0XHRyZXR1cm4gJC50cmltKCB0bXAgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gJC50cmltKCBub2RlLnRleHRDb250ZW50IHx8ICRub2RlLnRleHQoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCB0eXBlb2YgZXh0cmFjdCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRyZXR1cm4gJC50cmltKCBleHRyYWN0KCAkbm9kZVsgMCBdLCBjLnRhYmxlLCBjZWxsSW5kZXggKSApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgKCB0bXAgPSB0cy5nZXRDb2x1bW5EYXRhKCBjLnRhYmxlLCBleHRyYWN0LCBjZWxsSW5kZXggKSApID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdHJldHVybiAkLnRyaW0oIHRtcCggJG5vZGVbIDAgXSwgYy50YWJsZSwgY2VsbEluZGV4ICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gZmFsbGJhY2tcblx0XHRcdHJldHVybiAkLnRyaW0oICRub2RlWyAwIF0udGV4dENvbnRlbnQgfHwgJG5vZGUudGV4dCgpICk7XG5cdFx0fSxcblxuXHRcdC8vIGNlbnRyYWxpemVkIGZ1bmN0aW9uIHRvIGV4dHJhY3QvcGFyc2UgY2VsbCBjb250ZW50c1xuXHRcdGdldFBhcnNlZFRleHQgOiBmdW5jdGlvbiggYywgY2VsbCwgY29sSW5kZXgsIHR4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIHR4dCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdHR4dCA9IHRzLmdldEVsZW1lbnRUZXh0KCBjLCBjZWxsLCBjb2xJbmRleCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgbm8gcGFyc2VyLCBtYWtlIHN1cmUgdG8gcmV0dXJuIHRoZSB0eHRcblx0XHRcdHZhciB2YWwgPSAnJyArIHR4dCxcblx0XHRcdFx0cGFyc2VyID0gYy5wYXJzZXJzWyBjb2xJbmRleCBdLFxuXHRcdFx0XHRleHRyYWN0b3IgPSBjLmV4dHJhY3RvcnNbIGNvbEluZGV4IF07XG5cdFx0XHRpZiAoIHBhcnNlciApIHtcblx0XHRcdFx0Ly8gZG8gZXh0cmFjdCBiZWZvcmUgcGFyc2luZywgaWYgdGhlcmUgaXMgb25lXG5cdFx0XHRcdGlmICggZXh0cmFjdG9yICYmIHR5cGVvZiBleHRyYWN0b3IuZm9ybWF0ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdHR4dCA9IGV4dHJhY3Rvci5mb3JtYXQoIHR4dCwgYy50YWJsZSwgY2VsbCwgY29sSW5kZXggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBhbGxvdyBwYXJzaW5nIGlmIHRoZSBzdHJpbmcgaXMgZW1wdHksIHByZXZpb3VzbHkgcGFyc2luZyB3b3VsZCBjaGFuZ2UgaXQgdG8gemVybyxcblx0XHRcdFx0Ly8gaW4gY2FzZSB0aGUgcGFyc2VyIG5lZWRzIHRvIGV4dHJhY3QgZGF0YSBmcm9tIHRoZSB0YWJsZSBjZWxsIGF0dHJpYnV0ZXNcblx0XHRcdFx0dmFsID0gcGFyc2VyLmlkID09PSAnbm8tcGFyc2VyJyA/ICcnIDpcblx0XHRcdFx0XHQvLyBtYWtlIHN1cmUgdHh0IGlzIGEgc3RyaW5nIChleHRyYWN0b3IgbWF5IGhhdmUgY29udmVydGVkIGl0KVxuXHRcdFx0XHRcdHBhcnNlci5mb3JtYXQoICcnICsgdHh0LCBjLnRhYmxlLCBjZWxsLCBjb2xJbmRleCApO1xuXHRcdFx0XHRpZiAoIGMuaWdub3JlQ2FzZSAmJiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHR2YWwgPSB2YWwudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9LFxuXG5cdFx0Lypcblx0XHTiloTilojilojilojilojiloQg4paE4paI4paI4paI4paI4paEIOKWhOKWiOKWiOKWiOKWiOKWhCDilojiloggIOKWiOKWiCDilojilojilojilojilojilohcblx0XHTilojiloggIOKWgOKWgCDilojilojiloTiloTilojilogg4paI4paIICDiloDiloAg4paI4paI4paE4paE4paI4paIIOKWiOKWiOKWhOKWhFxuXHRcdOKWiOKWiCAg4paE4paEIOKWiOKWiOKWgOKWgOKWiOKWiCDilojiloggIOKWhOKWhCDilojilojiloDiloDilojilogg4paI4paI4paA4paAXG5cdFx04paA4paI4paI4paI4paI4paAIOKWiOKWiCAg4paI4paIIOKWgOKWiOKWiOKWiOKWiOKWgCDilojiloggIOKWiOKWiCDilojilojilojilojilojilohcblx0XHQqL1xuXHRcdGJ1aWxkQ2FjaGUgOiBmdW5jdGlvbiggYywgY2FsbGJhY2ssICR0Ym9kaWVzICkge1xuXHRcdFx0dmFyIGNhY2hlLCB2YWwsIHR4dCwgcm93SW5kZXgsIGNvbEluZGV4LCB0Ym9keUluZGV4LCAkdGJvZHksICRyb3csXG5cdFx0XHRcdGNvbHMsICRjZWxscywgY2VsbCwgY2FjaGVUaW1lLCB0b3RhbFJvd3MsIHJvd0RhdGEsIHByZXZSb3dEYXRhLFxuXHRcdFx0XHRjb2xNYXgsIHNwYW4sIGNhY2hlSW5kZXgsIGhhc1BhcnNlciwgbWF4LCBsZW4sIGluZGV4LFxuXHRcdFx0XHR0YWJsZSA9IGMudGFibGUsXG5cdFx0XHRcdHBhcnNlcnMgPSBjLnBhcnNlcnMsXG5cdFx0XHRcdGRlYnVnID0gdHMuZGVidWcoYywgJ2NvcmUnKTtcblx0XHRcdC8vIHVwZGF0ZSB0Ym9keSB2YXJpYWJsZVxuXHRcdFx0Yy4kdGJvZGllcyA9IGMuJHRhYmxlLmNoaWxkcmVuKCAndGJvZHk6bm90KC4nICsgYy5jc3NJbmZvQmxvY2sgKyAnKScgKTtcblx0XHRcdCR0Ym9keSA9IHR5cGVvZiAkdGJvZGllcyA9PT0gJ3VuZGVmaW5lZCcgPyBjLiR0Ym9kaWVzIDogJHRib2RpZXMsXG5cdFx0XHRjLmNhY2hlID0ge307XG5cdFx0XHRjLnRvdGFsUm93cyA9IDA7XG5cdFx0XHQvLyBpZiBubyBwYXJzZXJzIGZvdW5kLCByZXR1cm4gLSBpdCdzIGFuIGVtcHR5IHRhYmxlLlxuXHRcdFx0aWYgKCAhcGFyc2VycyApIHtcblx0XHRcdFx0cmV0dXJuIGRlYnVnID8gY29uc29sZS53YXJuKCAnV2FybmluZzogKkVtcHR5IHRhYmxlISogTm90IGJ1aWxkaW5nIGEgY2FjaGUnICkgOiAnJztcblx0XHRcdH1cblx0XHRcdGlmICggZGVidWcgKSB7XG5cdFx0XHRcdGNhY2hlVGltZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBwcm9jZXNzaW5nIGljb25cblx0XHRcdGlmICggYy5zaG93UHJvY2Vzc2luZyApIHtcblx0XHRcdFx0dHMuaXNQcm9jZXNzaW5nKCB0YWJsZSwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggdGJvZHlJbmRleCA9IDA7IHRib2R5SW5kZXggPCAkdGJvZHkubGVuZ3RoOyB0Ym9keUluZGV4KysgKSB7XG5cdFx0XHRcdGNvbE1heCA9IFtdOyAvLyBjb2x1bW4gbWF4IHZhbHVlIHBlciB0Ym9keVxuXHRcdFx0XHRjYWNoZSA9IGMuY2FjaGVbIHRib2R5SW5kZXggXSA9IHtcblx0XHRcdFx0XHRub3JtYWxpemVkOiBbXSAvLyBhcnJheSBvZiBub3JtYWxpemVkIHJvdyBkYXRhOyBsYXN0IGVudHJ5IGNvbnRhaW5zICdyb3dEYXRhJyBhYm92ZVxuXHRcdFx0XHRcdC8vIGNvbE1heDogIyAgIC8vIGFkZGVkIGF0IHRoZSBlbmRcblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0b3RhbFJvd3MgPSAoICR0Ym9keVsgdGJvZHlJbmRleCBdICYmICR0Ym9keVsgdGJvZHlJbmRleCBdLnJvd3MubGVuZ3RoICkgfHwgMDtcblx0XHRcdFx0Zm9yICggcm93SW5kZXggPSAwOyByb3dJbmRleCA8IHRvdGFsUm93czsgKytyb3dJbmRleCApIHtcblx0XHRcdFx0XHRyb3dEYXRhID0ge1xuXHRcdFx0XHRcdFx0Ly8gb3JkZXI6IG9yaWdpbmFsIHJvdyBvcmRlciAjXG5cdFx0XHRcdFx0XHQvLyAkcm93IDogalF1ZXJ5IE9iamVjdFtdXG5cdFx0XHRcdFx0XHRjaGlsZDogW10sIC8vIGNoaWxkIHJvdyB0ZXh0IChmaWx0ZXIgd2lkZ2V0KVxuXHRcdFx0XHRcdFx0cmF3OiBbXSAgICAvLyBvcmlnaW5hbCByb3cgdGV4dFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0LyoqIEFkZCB0aGUgdGFibGUgZGF0YSB0byBtYWluIGRhdGEgYXJyYXkgKi9cblx0XHRcdFx0XHQkcm93ID0gJCggJHRib2R5WyB0Ym9keUluZGV4IF0ucm93c1sgcm93SW5kZXggXSApO1xuXHRcdFx0XHRcdGNvbHMgPSBbXTtcblx0XHRcdFx0XHQvLyBpZ25vcmUgXCJyZW1vdmUtbWVcIiByb3dzXG5cdFx0XHRcdFx0aWYgKCAkcm93Lmhhc0NsYXNzKCBjLnNlbGVjdG9yUmVtb3ZlLnNsaWNlKDEpICkgKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gaWYgdGhpcyBpcyBhIGNoaWxkIHJvdywgYWRkIGl0IHRvIHRoZSBsYXN0IHJvdydzIGNoaWxkcmVuIGFuZCBjb250aW51ZSB0byB0aGUgbmV4dCByb3dcblx0XHRcdFx0XHQvLyBpZ25vcmUgY2hpbGQgcm93IGNsYXNzLCBpZiBpdCBpcyB0aGUgZmlyc3Qgcm93XG5cdFx0XHRcdFx0aWYgKCAkcm93Lmhhc0NsYXNzKCBjLmNzc0NoaWxkUm93ICkgJiYgcm93SW5kZXggIT09IDAgKSB7XG5cdFx0XHRcdFx0XHRsZW4gPSBjYWNoZS5ub3JtYWxpemVkLmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRwcmV2Um93RGF0YSA9IGNhY2hlLm5vcm1hbGl6ZWRbIGxlbiBdWyBjLmNvbHVtbnMgXTtcblx0XHRcdFx0XHRcdHByZXZSb3dEYXRhLiRyb3cgPSBwcmV2Um93RGF0YS4kcm93LmFkZCggJHJvdyApO1xuXHRcdFx0XHRcdFx0Ly8gYWRkICdoYXNDaGlsZCcgY2xhc3MgbmFtZSB0byBwYXJlbnQgcm93XG5cdFx0XHRcdFx0XHRpZiAoICEkcm93LnByZXYoKS5oYXNDbGFzcyggYy5jc3NDaGlsZFJvdyApICkge1xuXHRcdFx0XHRcdFx0XHQkcm93LnByZXYoKS5hZGRDbGFzcyggdHMuY3NzLmNzc0hhc0NoaWxkICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBzYXZlIGNoaWxkIHJvdyBjb250ZW50ICh1bi1wYXJzZWQhKVxuXHRcdFx0XHRcdFx0JGNlbGxzID0gJHJvdy5jaGlsZHJlbiggJ3RoLCB0ZCcgKTtcblx0XHRcdFx0XHRcdGxlbiA9IHByZXZSb3dEYXRhLmNoaWxkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHByZXZSb3dEYXRhLmNoaWxkWyBsZW4gXSA9IFtdO1xuXHRcdFx0XHRcdFx0Ly8gY2hpbGQgcm93IGNvbnRlbnQgZG9lcyBub3QgYWNjb3VudCBmb3IgY29sc3BhbnMvcm93c3BhbnM7IHNvIGluZGV4aW5nIG1heSBiZSBvZmZcblx0XHRcdFx0XHRcdGNhY2hlSW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0bWF4ID0gYy5jb2x1bW5zO1xuXHRcdFx0XHRcdFx0Zm9yICggY29sSW5kZXggPSAwOyBjb2xJbmRleCA8IG1heDsgY29sSW5kZXgrKyApIHtcblx0XHRcdFx0XHRcdFx0Y2VsbCA9ICRjZWxsc1sgY29sSW5kZXggXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjZWxsICkge1xuXHRcdFx0XHRcdFx0XHRcdHByZXZSb3dEYXRhLmNoaWxkWyBsZW4gXVsgY29sSW5kZXggXSA9IHRzLmdldFBhcnNlZFRleHQoIGMsIGNlbGwsIGNvbEluZGV4ICk7XG5cdFx0XHRcdFx0XHRcdFx0c3BhbiA9ICRjZWxsc1sgY29sSW5kZXggXS5jb2xTcGFuIC0gMTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwYW4gPiAwICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FjaGVJbmRleCArPSBzcGFuO1xuXHRcdFx0XHRcdFx0XHRcdFx0bWF4ICs9IHNwYW47XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGNhY2hlSW5kZXgrKztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGdvIHRvIHRoZSBuZXh0IGZvciBsb29wXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cm93RGF0YS4kcm93ID0gJHJvdztcblx0XHRcdFx0XHRyb3dEYXRhLm9yZGVyID0gcm93SW5kZXg7IC8vIGFkZCBvcmlnaW5hbCByb3cgcG9zaXRpb24gdG8gcm93Q2FjaGVcblx0XHRcdFx0XHRjYWNoZUluZGV4ID0gMDtcblx0XHRcdFx0XHRtYXggPSBjLmNvbHVtbnM7XG5cdFx0XHRcdFx0Zm9yICggY29sSW5kZXggPSAwOyBjb2xJbmRleCA8IG1heDsgKytjb2xJbmRleCApIHtcblx0XHRcdFx0XHRcdGNlbGwgPSAkcm93WyAwIF0uY2VsbHNbIGNvbEluZGV4IF07XG5cdFx0XHRcdFx0XHRpZiAoIGNlbGwgJiYgY2FjaGVJbmRleCA8IGMuY29sdW1ucyApIHtcblx0XHRcdFx0XHRcdFx0aGFzUGFyc2VyID0gdHlwZW9mIHBhcnNlcnNbIGNhY2hlSW5kZXggXSAhPT0gJ3VuZGVmaW5lZCc7XG5cdFx0XHRcdFx0XHRcdGlmICggIWhhc1BhcnNlciAmJiBkZWJ1ZyApIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdObyBwYXJzZXIgZm91bmQgZm9yIHJvdzogJyArIHJvd0luZGV4ICsgJywgY29sdW1uOiAnICsgY29sSW5kZXggK1xuXHRcdFx0XHRcdFx0XHRcdFx0JzsgY2VsbCBjb250YWluaW5nOiBcIicgKyAkKGNlbGwpLnRleHQoKSArICdcIjsgZG9lcyBpdCBoYXZlIGEgaGVhZGVyPycgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR2YWwgPSB0cy5nZXRFbGVtZW50VGV4dCggYywgY2VsbCwgY2FjaGVJbmRleCApO1xuXHRcdFx0XHRcdFx0XHRyb3dEYXRhLnJhd1sgY2FjaGVJbmRleCBdID0gdmFsOyAvLyBzYXZlIG9yaWdpbmFsIHJvdyB0ZXh0XG5cdFx0XHRcdFx0XHRcdC8vIHNhdmUgcmF3IGNvbHVtbiB0ZXh0IGV2ZW4gaWYgdGhlcmUgaXMgbm8gcGFyc2VyIHNldFxuXHRcdFx0XHRcdFx0XHR0eHQgPSB0cy5nZXRQYXJzZWRUZXh0KCBjLCBjZWxsLCBjYWNoZUluZGV4LCB2YWwgKTtcblx0XHRcdFx0XHRcdFx0Y29sc1sgY2FjaGVJbmRleCBdID0gdHh0O1xuXHRcdFx0XHRcdFx0XHRpZiAoIGhhc1BhcnNlciAmJiAoIHBhcnNlcnNbIGNhY2hlSW5kZXggXS50eXBlIHx8ICcnICkudG9Mb3dlckNhc2UoKSA9PT0gJ251bWVyaWMnICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGRldGVybWluZSBjb2x1bW4gbWF4IHZhbHVlIChpZ25vcmUgc2lnbilcblx0XHRcdFx0XHRcdFx0XHRjb2xNYXhbIGNhY2hlSW5kZXggXSA9IE1hdGgubWF4KCBNYXRoLmFicyggdHh0ICkgfHwgMCwgY29sTWF4WyBjYWNoZUluZGV4IF0gfHwgMCApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8vIGFsbG93IGNvbFNwYW4gaW4gdGJvZHlcblx0XHRcdFx0XHRcdFx0c3BhbiA9IGNlbGwuY29sU3BhbiAtIDE7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BhbiA+IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggaW5kZXggPD0gc3BhbiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGR1cGxpY2F0ZSB0ZXh0IChvciBub3QpIHRvIHNwYW5uZWQgY29sdW1uc1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaW5zdGVhZCBvZiBzZXR0aW5nIGR1cGxpY2F0ZSBzcGFuIHRvIGVtcHR5IHN0cmluZywgdXNlIHRleHRFeHRyYWN0aW9uIHRvIHRyeSB0byBnZXQgYSB2YWx1ZVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzM2NDQ5NzExLzE0NTM0NlxuXHRcdFx0XHRcdFx0XHRcdFx0dHh0ID0gYy5kdXBsaWNhdGVTcGFuIHx8IGluZGV4ID09PSAwID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIGMudGV4dEV4dHJhY3Rpb24gIT09ICdzdHJpbmcnID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0cy5nZXRFbGVtZW50VGV4dCggYywgY2VsbCwgY2FjaGVJbmRleCArIGluZGV4ICkgfHwgJycgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCcnO1xuXHRcdFx0XHRcdFx0XHRcdFx0cm93RGF0YS5yYXdbIGNhY2hlSW5kZXggKyBpbmRleCBdID0gdHh0O1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29sc1sgY2FjaGVJbmRleCArIGluZGV4IF0gPSB0eHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRjYWNoZUluZGV4ICs9IHNwYW47XG5cdFx0XHRcdFx0XHRcdFx0bWF4ICs9IHNwYW47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNhY2hlSW5kZXgrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gZW5zdXJlIHJvd0RhdGEgaXMgYWx3YXlzIGluIHRoZSBzYW1lIGxvY2F0aW9uIChhZnRlciB0aGUgbGFzdCBjb2x1bW4pXG5cdFx0XHRcdFx0Y29sc1sgYy5jb2x1bW5zIF0gPSByb3dEYXRhO1xuXHRcdFx0XHRcdGNhY2hlLm5vcm1hbGl6ZWRbIGNhY2hlLm5vcm1hbGl6ZWQubGVuZ3RoIF0gPSBjb2xzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhY2hlLmNvbE1heCA9IGNvbE1heDtcblx0XHRcdFx0Ly8gdG90YWwgdXAgcm93cywgbm90IGluY2x1ZGluZyBjaGlsZCByb3dzXG5cdFx0XHRcdGMudG90YWxSb3dzICs9IGNhY2hlLm5vcm1hbGl6ZWQubGVuZ3RoO1xuXG5cdFx0XHR9XG5cdFx0XHRpZiAoIGMuc2hvd1Byb2Nlc3NpbmcgKSB7XG5cdFx0XHRcdHRzLmlzUHJvY2Vzc2luZyggdGFibGUgKTsgLy8gcmVtb3ZlIHByb2Nlc3NpbmcgaWNvblxuXHRcdFx0fVxuXHRcdFx0aWYgKCBkZWJ1ZyApIHtcblx0XHRcdFx0bGVuID0gTWF0aC5taW4oIDUsIGMuY2FjaGVbIDAgXS5ub3JtYWxpemVkLmxlbmd0aCApO1xuXHRcdFx0XHRjb25zb2xlWyBjb25zb2xlLmdyb3VwID8gJ2dyb3VwJyA6ICdsb2cnIF0oICdCdWlsZGluZyBjYWNoZSBmb3IgJyArIGMudG90YWxSb3dzICtcblx0XHRcdFx0XHQnIHJvd3MgKHNob3dpbmcgJyArIGxlbiArICcgcm93cyBpbiBsb2cpIGFuZCAnICsgYy5jb2x1bW5zICsgJyBjb2x1bW5zJyArXG5cdFx0XHRcdFx0dHMuYmVuY2htYXJrKCBjYWNoZVRpbWUgKSApO1xuXHRcdFx0XHR2YWwgPSB7fTtcblx0XHRcdFx0Zm9yICggY29sSW5kZXggPSAwOyBjb2xJbmRleCA8IGMuY29sdW1uczsgY29sSW5kZXgrKyApIHtcblx0XHRcdFx0XHRmb3IgKCBjYWNoZUluZGV4ID0gMDsgY2FjaGVJbmRleCA8IGxlbjsgY2FjaGVJbmRleCsrICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhdmFsWyAncm93OiAnICsgY2FjaGVJbmRleCBdICkge1xuXHRcdFx0XHRcdFx0XHR2YWxbICdyb3c6ICcgKyBjYWNoZUluZGV4IF0gPSB7fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhbFsgJ3JvdzogJyArIGNhY2hlSW5kZXggXVsgYy4kaGVhZGVySW5kZXhlZFsgY29sSW5kZXggXS50ZXh0KCkgXSA9XG5cdFx0XHRcdFx0XHRcdGMuY2FjaGVbIDAgXS5ub3JtYWxpemVkWyBjYWNoZUluZGV4IF1bIGNvbEluZGV4IF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnNvbGVbIGNvbnNvbGUudGFibGUgPyAndGFibGUnIDogJ2xvZycgXSggdmFsICk7XG5cdFx0XHRcdGlmICggY29uc29sZS5ncm91cEVuZCApIHsgY29uc29sZS5ncm91cEVuZCgpOyB9XG5cdFx0XHR9XG5cdFx0XHRpZiAoICQuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSApIHtcblx0XHRcdFx0Y2FsbGJhY2soIHRhYmxlICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdldENvbHVtblRleHQgOiBmdW5jdGlvbiggdGFibGUsIGNvbHVtbiwgY2FsbGJhY2ssIHJvd0ZpbHRlciApIHtcblx0XHRcdHRhYmxlID0gJCggdGFibGUgKVswXTtcblx0XHRcdHZhciB0Ym9keUluZGV4LCByb3dJbmRleCwgY2FjaGUsIHJvdywgdGJvZHlMZW4sIHJvd0xlbiwgcmF3LCBwYXJzZWQsICRjZWxsLCByZXN1bHQsXG5cdFx0XHRcdGhhc0NhbGxiYWNrID0gdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLFxuXHRcdFx0XHRhbGxDb2x1bW5zID0gY29sdW1uID09PSAnYWxsJyxcblx0XHRcdFx0ZGF0YSA9IHsgcmF3IDogW10sIHBhcnNlZDogW10sICRjZWxsOiBbXSB9LFxuXHRcdFx0XHRjID0gdGFibGUuY29uZmlnO1xuXHRcdFx0aWYgKCB0cy5pc0VtcHR5T2JqZWN0KCBjICkgKSB7XG5cdFx0XHRcdGlmICggdHMuZGVidWcoYywgJ2NvcmUnKSApIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdObyBjYWNoZSBmb3VuZCAtIGFib3J0aW5nIGdldENvbHVtblRleHQgZnVuY3Rpb24hJyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0Ym9keUxlbiA9IGMuJHRib2RpZXMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCB0Ym9keUluZGV4ID0gMDsgdGJvZHlJbmRleCA8IHRib2R5TGVuOyB0Ym9keUluZGV4KysgKSB7XG5cdFx0XHRcdFx0Y2FjaGUgPSBjLmNhY2hlWyB0Ym9keUluZGV4IF0ubm9ybWFsaXplZDtcblx0XHRcdFx0XHRyb3dMZW4gPSBjYWNoZS5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yICggcm93SW5kZXggPSAwOyByb3dJbmRleCA8IHJvd0xlbjsgcm93SW5kZXgrKyApIHtcblx0XHRcdFx0XHRcdHJvdyA9IGNhY2hlWyByb3dJbmRleCBdO1xuXHRcdFx0XHRcdFx0aWYgKCByb3dGaWx0ZXIgJiYgIXJvd1sgYy5jb2x1bW5zIF0uJHJvdy5pcyggcm93RmlsdGVyICkgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzdWx0ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHBhcnNlZCA9ICggYWxsQ29sdW1ucyApID8gcm93LnNsaWNlKCAwLCBjLmNvbHVtbnMgKSA6IHJvd1sgY29sdW1uIF07XG5cdFx0XHRcdFx0XHRyb3cgPSByb3dbIGMuY29sdW1ucyBdO1xuXHRcdFx0XHRcdFx0cmF3ID0gKCBhbGxDb2x1bW5zICkgPyByb3cucmF3IDogcm93LnJhd1sgY29sdW1uIF07XG5cdFx0XHRcdFx0XHQkY2VsbCA9ICggYWxsQ29sdW1ucyApID8gcm93LiRyb3cuY2hpbGRyZW4oKSA6IHJvdy4kcm93LmNoaWxkcmVuKCkuZXEoIGNvbHVtbiApO1xuXHRcdFx0XHRcdFx0aWYgKCBoYXNDYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gY2FsbGJhY2soe1xuXHRcdFx0XHRcdFx0XHRcdHRib2R5SW5kZXggOiB0Ym9keUluZGV4LFxuXHRcdFx0XHRcdFx0XHRcdHJvd0luZGV4IDogcm93SW5kZXgsXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VkIDogcGFyc2VkLFxuXHRcdFx0XHRcdFx0XHRcdHJhdyA6IHJhdyxcblx0XHRcdFx0XHRcdFx0XHQkcm93IDogcm93LiRyb3csXG5cdFx0XHRcdFx0XHRcdFx0JGNlbGwgOiAkY2VsbFxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggcmVzdWx0ICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZGF0YS5wYXJzZWRbIGRhdGEucGFyc2VkLmxlbmd0aCBdID0gcGFyc2VkO1xuXHRcdFx0XHRcdFx0XHRkYXRhLnJhd1sgZGF0YS5yYXcubGVuZ3RoIF0gPSByYXc7XG5cdFx0XHRcdFx0XHRcdGRhdGEuJGNlbGxbIGRhdGEuJGNlbGwubGVuZ3RoIF0gPSAkY2VsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gcmV0dXJuIGV2ZXJ5dGhpbmdcblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx04paI4paIICDilojilogg4paI4paI4paI4paI4paI4paEIOKWiOKWiOKWiOKWiOKWiOKWhCDiloTilojilojilojilojiloQg4paI4paI4paI4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiFxuXHRcdOKWiOKWiCAg4paI4paIIOKWiOKWiOKWhOKWhOKWiOKWiCDilojiloggIOKWiOKWiCDilojilojiloTiloTilojiloggICDilojiloggICDilojilojiloTiloRcblx0XHTilojiloggIOKWiOKWiCDilojilojiloDiloDiloAgIOKWiOKWiCAg4paI4paIIOKWiOKWiOKWgOKWgOKWiOKWiCAgIOKWiOKWiCAgIOKWiOKWiOKWgOKWgFxuXHRcdOKWgOKWiOKWiOKWiOKWiOKWgCDilojiloggICAgIOKWiOKWiOKWiOKWiOKWiOKWgCDilojiloggIOKWiOKWiCAgIOKWiOKWiCAgIOKWiOKWiOKWiOKWiOKWiOKWiFxuXHRcdCovXG5cdFx0c2V0SGVhZGVyc0NzcyA6IGZ1bmN0aW9uKCBjICkge1xuXHRcdFx0dmFyIGluZHgsIGNvbHVtbixcblx0XHRcdFx0bGlzdCA9IGMuc29ydExpc3QsXG5cdFx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoLFxuXHRcdFx0XHRub25lID0gdHMuY3NzLnNvcnROb25lICsgJyAnICsgYy5jc3NOb25lLFxuXHRcdFx0XHRjc3MgPSBbIHRzLmNzcy5zb3J0QXNjICsgJyAnICsgYy5jc3NBc2MsIHRzLmNzcy5zb3J0RGVzYyArICcgJyArIGMuY3NzRGVzYyBdLFxuXHRcdFx0XHRjc3NJY29uID0gWyBjLmNzc0ljb25Bc2MsIGMuY3NzSWNvbkRlc2MsIGMuY3NzSWNvbk5vbmUgXSxcblx0XHRcdFx0YXJpYSA9IFsgJ2FzY2VuZGluZycsICdkZXNjZW5kaW5nJyBdLFxuXHRcdFx0XHR1cGRhdGVDb2x1bW5Tb3J0ID0gZnVuY3Rpb24oJGVsLCBpbmRleCkge1xuXHRcdFx0XHRcdCRlbFxuXHRcdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBub25lIClcblx0XHRcdFx0XHRcdC5hZGRDbGFzcyggY3NzWyBpbmRleCBdIClcblx0XHRcdFx0XHRcdC5hdHRyKCAnYXJpYS1zb3J0JywgYXJpYVsgaW5kZXggXSApXG5cdFx0XHRcdFx0XHQuZmluZCggJy4nICsgdHMuY3NzLmljb24gKVxuXHRcdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBjc3NJY29uWyAyIF0gKVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBjc3NJY29uWyBpbmRleCBdICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIGZpbmQgdGhlIGZvb3RlclxuXHRcdFx0XHQkZXh0cmFzID0gYy4kdGFibGVcblx0XHRcdFx0XHQuZmluZCggJ3Rmb290IHRyJyApXG5cdFx0XHRcdFx0LmNoaWxkcmVuKCAndGQsIHRoJyApXG5cdFx0XHRcdFx0LmFkZCggJCggYy5uYW1lc3BhY2UgKyAnX2V4dHJhX2hlYWRlcnMnICkgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggY3NzLmpvaW4oICcgJyApICksXG5cdFx0XHRcdC8vIHJlbW92ZSBhbGwgaGVhZGVyIGluZm9ybWF0aW9uXG5cdFx0XHRcdCRzb3J0ZWQgPSBjLiRoZWFkZXJzXG5cdFx0XHRcdFx0LmFkZCggJCggJ3RoZWFkICcgKyBjLm5hbWVzcGFjZSArICdfZXh0cmFfaGVhZGVycycgKSApXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBjc3Muam9pbiggJyAnICkgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggbm9uZSApXG5cdFx0XHRcdFx0LmF0dHIoICdhcmlhLXNvcnQnLCAnbm9uZScgKVxuXHRcdFx0XHRcdC5maW5kKCAnLicgKyB0cy5jc3MuaWNvbiApXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBjc3NJY29uLmpvaW4oICcgJyApIClcblx0XHRcdFx0XHQuZW5kKCk7XG5cdFx0XHQvLyBhZGQgY3NzIG5vbmUgdG8gYWxsIHNvcnRhYmxlIGhlYWRlcnNcblx0XHRcdCRzb3J0ZWRcblx0XHRcdFx0Lm5vdCggJy5zb3J0ZXItZmFsc2UnIClcblx0XHRcdFx0LmZpbmQoICcuJyArIHRzLmNzcy5pY29uIClcblx0XHRcdFx0LmFkZENsYXNzKCBjc3NJY29uWyAyIF0gKTtcblx0XHRcdC8vIGFkZCBkaXNhYmxlZCBjc3MgaWNvbiBjbGFzc1xuXHRcdFx0aWYgKCBjLmNzc0ljb25EaXNhYmxlZCApIHtcblx0XHRcdFx0JHNvcnRlZFxuXHRcdFx0XHRcdC5maWx0ZXIoICcuc29ydGVyLWZhbHNlJyApXG5cdFx0XHRcdFx0LmZpbmQoICcuJyArIHRzLmNzcy5pY29uIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIGMuY3NzSWNvbkRpc2FibGVkICk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGxlbjsgaW5keCsrICkge1xuXHRcdFx0XHQvLyBkaXJlY3Rpb24gPSAyIG1lYW5zIHJlc2V0IVxuXHRcdFx0XHRpZiAoIGxpc3RbIGluZHggXVsgMSBdICE9PSAyICkge1xuXHRcdFx0XHRcdC8vIG11bHRpY29sdW1uIHNvcnRpbmcgdXBkYXRpbmcgLSBzZWUgIzEwMDVcblx0XHRcdFx0XHQvLyAubm90KGZ1bmN0aW9uKCkge30pIG5lZWRzIGpRdWVyeSAxLjRcblx0XHRcdFx0XHQvLyBmaWx0ZXIoZnVuY3Rpb24oaSwgZWwpIHt9KSA8LSBlbCBpcyB1bmRlZmluZWQgaW4galF1ZXJ5IHYxLjIuNlxuXHRcdFx0XHRcdCRzb3J0ZWQgPSBjLiRoZWFkZXJzLmZpbHRlciggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0XHQvLyBvbmx5IGluY2x1ZGUgaGVhZGVycyB0aGF0IGFyZSBpbiB0aGUgc29ydExpc3QgKHRoaXMgaW5jbHVkZXMgY29sc3BhbnMpXG5cdFx0XHRcdFx0XHR2YXIgaW5jbHVkZSA9IHRydWUsXG5cdFx0XHRcdFx0XHRcdCRlbCA9IGMuJGhlYWRlcnMuZXEoIGkgKSxcblx0XHRcdFx0XHRcdFx0Y29sID0gcGFyc2VJbnQoICRlbC5hdHRyKCAnZGF0YS1jb2x1bW4nICksIDEwICksXG5cdFx0XHRcdFx0XHRcdGVuZCA9IGNvbCArIHRzLmdldENsb3Nlc3QoICRlbCwgJ3RoLCB0ZCcgKVswXS5jb2xTcGFuO1xuXHRcdFx0XHRcdFx0Zm9yICggOyBjb2wgPCBlbmQ7IGNvbCsrICkge1xuXHRcdFx0XHRcdFx0XHRpbmNsdWRlID0gaW5jbHVkZSA/IGluY2x1ZGUgfHwgdHMuaXNWYWx1ZUluQXJyYXkoIGNvbCwgYy5zb3J0TGlzdCApID4gLTEgOiBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBpbmNsdWRlO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Ly8gY2hvb3NlIHRoZSA6bGFzdCBpbiBjYXNlIHRoZXJlIGFyZSBuZXN0ZWQgY29sdW1uc1xuXHRcdFx0XHRcdCRzb3J0ZWQgPSAkc29ydGVkXG5cdFx0XHRcdFx0XHQubm90KCAnLnNvcnRlci1mYWxzZScgKVxuXHRcdFx0XHRcdFx0LmZpbHRlciggJ1tkYXRhLWNvbHVtbj1cIicgKyBsaXN0WyBpbmR4IF1bIDAgXSArICdcIl0nICsgKCBsZW4gPT09IDEgPyAnOmxhc3QnIDogJycgKSApO1xuXHRcdFx0XHRcdGlmICggJHNvcnRlZC5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBjb2x1bW4gPSAwOyBjb2x1bW4gPCAkc29ydGVkLmxlbmd0aDsgY29sdW1uKysgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISRzb3J0ZWRbIGNvbHVtbiBdLnNvcnREaXNhYmxlZCApIHtcblx0XHRcdFx0XHRcdFx0XHR1cGRhdGVDb2x1bW5Tb3J0KCAkc29ydGVkLmVxKCBjb2x1bW4gKSwgbGlzdFsgaW5keCBdWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBhZGQgc29ydGVkIGNsYXNzIHRvIGZvb3RlciAmIGV4dHJhIGhlYWRlcnMsIGlmIHRoZXkgZXhpc3Rcblx0XHRcdFx0XHRpZiAoICRleHRyYXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0dXBkYXRlQ29sdW1uU29ydCggJGV4dHJhcy5maWx0ZXIoICdbZGF0YS1jb2x1bW49XCInICsgbGlzdFsgaW5keCBdWyAwIF0gKyAnXCJdJyApLCBsaXN0WyBpbmR4IF1bIDEgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gYWRkIHZlcmJvc2UgYXJpYSBsYWJlbHNcblx0XHRcdGxlbiA9IGMuJGhlYWRlcnMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKyApIHtcblx0XHRcdFx0dHMuc2V0Q29sdW1uQXJpYUxhYmVsKCBjLCBjLiRoZWFkZXJzLmVxKCBpbmR4ICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0Q2xvc2VzdCA6IGZ1bmN0aW9uKCAkZWwsIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8galF1ZXJ5IHYxLjIuNiBkb2Vzbid0IGhhdmUgY2xvc2VzdCgpXG5cdFx0XHRpZiAoICQuZm4uY2xvc2VzdCApIHtcblx0XHRcdFx0cmV0dXJuICRlbC5jbG9zZXN0KCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICRlbC5pcyggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdCRlbCA6XG5cdFx0XHRcdCRlbC5wYXJlbnRzKCBzZWxlY3RvciApLmZpbHRlciggJzpmaXJzdCcgKTtcblx0XHR9LFxuXG5cdFx0Ly8gbmV4dFNvcnQgKG9wdGlvbmFsKSwgbGV0cyB5b3UgZGlzYWJsZSBuZXh0IHNvcnQgdGV4dFxuXHRcdHNldENvbHVtbkFyaWFMYWJlbCA6IGZ1bmN0aW9uKCBjLCAkaGVhZGVyLCBuZXh0U29ydCApIHtcblx0XHRcdGlmICggJGhlYWRlci5sZW5ndGggKSB7XG5cdFx0XHRcdHZhciBjb2x1bW4gPSBwYXJzZUludCggJGhlYWRlci5hdHRyKCAnZGF0YS1jb2x1bW4nICksIDEwICksXG5cdFx0XHRcdFx0dmFycyA9IGMuc29ydFZhcnNbIGNvbHVtbiBdLFxuXHRcdFx0XHRcdHRtcCA9ICRoZWFkZXIuaGFzQ2xhc3MoIHRzLmNzcy5zb3J0QXNjICkgP1xuXHRcdFx0XHRcdFx0J3NvcnRBc2MnIDpcblx0XHRcdFx0XHRcdCRoZWFkZXIuaGFzQ2xhc3MoIHRzLmNzcy5zb3J0RGVzYyApID8gJ3NvcnREZXNjJyA6ICdzb3J0Tm9uZScsXG5cdFx0XHRcdFx0dHh0ID0gJC50cmltKCAkaGVhZGVyLnRleHQoKSApICsgJzogJyArIHRzLmxhbmd1YWdlWyB0bXAgXTtcblx0XHRcdFx0aWYgKCAkaGVhZGVyLmhhc0NsYXNzKCAnc29ydGVyLWZhbHNlJyApIHx8IG5leHRTb3J0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHR0eHQgKz0gdHMubGFuZ3VhZ2Uuc29ydERpc2FibGVkO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRtcCA9ICggdmFycy5jb3VudCArIDEgKSAlIHZhcnMub3JkZXIubGVuZ3RoO1xuXHRcdFx0XHRcdG5leHRTb3J0ID0gdmFycy5vcmRlclsgdG1wIF07XG5cdFx0XHRcdFx0Ly8gaWYgbmV4dFNvcnRcblx0XHRcdFx0XHR0eHQgKz0gdHMubGFuZ3VhZ2VbIG5leHRTb3J0ID09PSAwID8gJ25leHRBc2MnIDogbmV4dFNvcnQgPT09IDEgPyAnbmV4dERlc2MnIDogJ25leHROb25lJyBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCRoZWFkZXIuYXR0ciggJ2FyaWEtbGFiZWwnLCB0eHQgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dXBkYXRlSGVhZGVyIDogZnVuY3Rpb24oIGMgKSB7XG5cdFx0XHR2YXIgaW5kZXgsIGlzRGlzYWJsZWQsICRoZWFkZXIsIGNvbCxcblx0XHRcdFx0dGFibGUgPSBjLnRhYmxlLFxuXHRcdFx0XHRsZW4gPSBjLiRoZWFkZXJzLmxlbmd0aDtcblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KysgKSB7XG5cdFx0XHRcdCRoZWFkZXIgPSBjLiRoZWFkZXJzLmVxKCBpbmRleCApO1xuXHRcdFx0XHRjb2wgPSB0cy5nZXRDb2x1bW5EYXRhKCB0YWJsZSwgYy5oZWFkZXJzLCBpbmRleCwgdHJ1ZSApO1xuXHRcdFx0XHQvLyBhZGQgJ3NvcnRlci1mYWxzZScgY2xhc3MgaWYgJ3BhcnNlci1mYWxzZScgaXMgc2V0XG5cdFx0XHRcdGlzRGlzYWJsZWQgPSB0cy5nZXREYXRhKCAkaGVhZGVyLCBjb2wsICdzb3J0ZXInICkgPT09ICdmYWxzZScgfHwgdHMuZ2V0RGF0YSggJGhlYWRlciwgY29sLCAncGFyc2VyJyApID09PSAnZmFsc2UnO1xuXHRcdFx0XHR0cy5zZXRDb2x1bW5Tb3J0KCBjLCAkaGVhZGVyLCBpc0Rpc2FibGVkICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldENvbHVtblNvcnQgOiBmdW5jdGlvbiggYywgJGhlYWRlciwgaXNEaXNhYmxlZCApIHtcblx0XHRcdHZhciBpZCA9IGMudGFibGUuaWQ7XG5cdFx0XHQkaGVhZGVyWyAwIF0uc29ydERpc2FibGVkID0gaXNEaXNhYmxlZDtcblx0XHRcdCRoZWFkZXJbIGlzRGlzYWJsZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJyBdKCAnc29ydGVyLWZhbHNlJyApXG5cdFx0XHRcdC5hdHRyKCAnYXJpYS1kaXNhYmxlZCcsICcnICsgaXNEaXNhYmxlZCApO1xuXHRcdFx0Ly8gZGlzYWJsZSB0YWIgaW5kZXggb24gZGlzYWJsZWQgY2VsbHNcblx0XHRcdGlmICggYy50YWJJbmRleCApIHtcblx0XHRcdFx0aWYgKCBpc0Rpc2FibGVkICkge1xuXHRcdFx0XHRcdCRoZWFkZXIucmVtb3ZlQXR0ciggJ3RhYmluZGV4JyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCRoZWFkZXIuYXR0ciggJ3RhYmluZGV4JywgJzAnICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGFyaWEtY29udHJvbHMgLSByZXF1aXJlcyB0YWJsZSBJRFxuXHRcdFx0aWYgKCBpZCApIHtcblx0XHRcdFx0aWYgKCBpc0Rpc2FibGVkICkge1xuXHRcdFx0XHRcdCRoZWFkZXIucmVtb3ZlQXR0ciggJ2FyaWEtY29udHJvbHMnICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JGhlYWRlci5hdHRyKCAnYXJpYS1jb250cm9scycsIGlkICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dXBkYXRlSGVhZGVyU29ydENvdW50IDogZnVuY3Rpb24oIGMsIGxpc3QgKSB7XG5cdFx0XHR2YXIgY29sLCBkaXIsIGdyb3VwLCBpbmR4LCBwcmltYXJ5LCB0ZW1wLCB2YWwsIG9yZGVyLFxuXHRcdFx0XHRzb3J0TGlzdCA9IGxpc3QgfHwgYy5zb3J0TGlzdCxcblx0XHRcdFx0bGVuID0gc29ydExpc3QubGVuZ3RoO1xuXHRcdFx0Yy5zb3J0TGlzdCA9IFtdO1xuXHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKyApIHtcblx0XHRcdFx0dmFsID0gc29ydExpc3RbIGluZHggXTtcblx0XHRcdFx0Ly8gZW5zdXJlIGFsbCBzb3J0TGlzdCB2YWx1ZXMgYXJlIG51bWVyaWMgLSBmaXhlcyAjMTI3XG5cdFx0XHRcdGNvbCA9IHBhcnNlSW50KCB2YWxbIDAgXSwgMTAgKTtcblx0XHRcdFx0Ly8gcHJldmVudHMgZXJyb3IgaWYgc29ydG9uIGFycmF5IGlzIHdyb25nXG5cdFx0XHRcdGlmICggY29sIDwgYy5jb2x1bW5zICkge1xuXG5cdFx0XHRcdFx0Ly8gc2V0IG9yZGVyIGlmIG5vdCBhbHJlYWR5IGRlZmluZWQgLSBkdWUgdG8gY29sc3BhbiBoZWFkZXIgd2l0aG91dCBhc3NvY2lhdGVkIGhlYWRlciBjZWxsXG5cdFx0XHRcdFx0Ly8gYWRkaW5nIHRoaXMgY2hlY2sgcHJldmVudHMgYSBqYXZhc2NyaXB0IGVycm9yXG5cdFx0XHRcdFx0aWYgKCAhYy5zb3J0VmFyc1sgY29sIF0ub3JkZXIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHRzLmdldE9yZGVyKCBjLnNvcnRJbml0aWFsT3JkZXIgKSApIHtcblx0XHRcdFx0XHRcdFx0b3JkZXIgPSBjLnNvcnRSZXNldCA/IFsgMSwgMCwgMiBdIDogWyAxLCAwIF07XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRvcmRlciA9IGMuc29ydFJlc2V0ID8gWyAwLCAxLCAyIF0gOiBbIDAsIDEgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGMuc29ydFZhcnNbIGNvbCBdLm9yZGVyID0gb3JkZXI7XG5cdFx0XHRcdFx0XHRjLnNvcnRWYXJzWyBjb2wgXS5jb3VudCA9IDA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3JkZXIgPSBjLnNvcnRWYXJzWyBjb2wgXS5vcmRlcjtcblx0XHRcdFx0XHRkaXIgPSAoICcnICsgdmFsWyAxIF0gKS5tYXRjaCggL14oMXxkfHN8b3xuKS8gKTtcblx0XHRcdFx0XHRkaXIgPSBkaXIgPyBkaXJbIDAgXSA6ICcnO1xuXHRcdFx0XHRcdC8vIDAvKGEpc2MgKGRlZmF1bHQpLCAxLyhkKWVzYywgKHMpYW1lLCAobylwcG9zaXRlLCAobilleHRcblx0XHRcdFx0XHRzd2l0Y2ggKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRjYXNlICcxJyA6IGNhc2UgJ2QnIDogLy8gZGVzY2VuZGluZ1xuXHRcdFx0XHRcdFx0XHRkaXIgPSAxO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3MnIDogLy8gc2FtZSBkaXJlY3Rpb24gKGFzIHByaW1hcnkgY29sdW1uKVxuXHRcdFx0XHRcdFx0XHQvLyBpZiBwcmltYXJ5IHNvcnQgaXMgc2V0IHRvICdzJywgbWFrZSBpdCBhc2NlbmRpbmdcblx0XHRcdFx0XHRcdFx0ZGlyID0gcHJpbWFyeSB8fCAwO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ28nIDpcblx0XHRcdFx0XHRcdFx0dGVtcCA9IG9yZGVyWyAoIHByaW1hcnkgfHwgMCApICUgb3JkZXIubGVuZ3RoIF07XG5cdFx0XHRcdFx0XHRcdC8vIG9wcG9zaXRlIG9mIHByaW1hcnkgY29sdW1uOyBidXQgcmVzZXRzIGlmIHByaW1hcnkgcmVzZXRzXG5cdFx0XHRcdFx0XHRcdGRpciA9IHRlbXAgPT09IDAgPyAxIDogdGVtcCA9PT0gMSA/IDAgOiAyO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ24nIDpcblx0XHRcdFx0XHRcdFx0ZGlyID0gb3JkZXJbICggKytjLnNvcnRWYXJzWyBjb2wgXS5jb3VudCApICUgb3JkZXIubGVuZ3RoIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdCA6IC8vIGFzY2VuZGluZ1xuXHRcdFx0XHRcdFx0XHRkaXIgPSAwO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHJpbWFyeSA9IGluZHggPT09IDAgPyBkaXIgOiBwcmltYXJ5O1xuXHRcdFx0XHRcdGdyb3VwID0gWyBjb2wsIHBhcnNlSW50KCBkaXIsIDEwICkgfHwgMCBdO1xuXHRcdFx0XHRcdGMuc29ydExpc3RbIGMuc29ydExpc3QubGVuZ3RoIF0gPSBncm91cDtcblx0XHRcdFx0XHRkaXIgPSAkLmluQXJyYXkoIGdyb3VwWyAxIF0sIG9yZGVyICk7IC8vIGZpeGVzIGlzc3VlICMxNjdcblx0XHRcdFx0XHRjLnNvcnRWYXJzWyBjb2wgXS5jb3VudCA9IGRpciA+PSAwID8gZGlyIDogZ3JvdXBbIDEgXSAlIG9yZGVyLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR1cGRhdGVBbGwgOiBmdW5jdGlvbiggYywgcmVzb3J0LCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB0YWJsZSA9IGMudGFibGU7XG5cdFx0XHR0YWJsZS5pc1VwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdHRzLnJlZnJlc2hXaWRnZXRzKCB0YWJsZSwgdHJ1ZSwgdHJ1ZSApO1xuXHRcdFx0dHMuYnVpbGRIZWFkZXJzKCBjICk7XG5cdFx0XHR0cy5iaW5kRXZlbnRzKCB0YWJsZSwgYy4kaGVhZGVycywgdHJ1ZSApO1xuXHRcdFx0dHMuYmluZE1ldGhvZHMoIGMgKTtcblx0XHRcdHRzLmNvbW1vblVwZGF0ZSggYywgcmVzb3J0LCBjYWxsYmFjayApO1xuXHRcdH0sXG5cblx0XHR1cGRhdGUgOiBmdW5jdGlvbiggYywgcmVzb3J0LCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB0YWJsZSA9IGMudGFibGU7XG5cdFx0XHR0YWJsZS5pc1VwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdC8vIHVwZGF0ZSBzb3J0aW5nIChpZiBlbmFibGVkL2Rpc2FibGVkKVxuXHRcdFx0dHMudXBkYXRlSGVhZGVyKCBjICk7XG5cdFx0XHR0cy5jb21tb25VcGRhdGUoIGMsIHJlc29ydCwgY2FsbGJhY2sgKTtcblx0XHR9LFxuXG5cdFx0Ly8gc2ltcGxlIGhlYWRlciB1cGRhdGUgLSBzZWUgIzk4OVxuXHRcdHVwZGF0ZUhlYWRlcnMgOiBmdW5jdGlvbiggYywgY2FsbGJhY2sgKSB7XG5cdFx0XHRjLnRhYmxlLmlzVXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0dHMuYnVpbGRIZWFkZXJzKCBjICk7XG5cdFx0XHR0cy5iaW5kRXZlbnRzKCBjLnRhYmxlLCBjLiRoZWFkZXJzLCB0cnVlICk7XG5cdFx0XHR0cy5yZXNvcnRDb21wbGV0ZSggYywgY2FsbGJhY2sgKTtcblx0XHR9LFxuXG5cdFx0dXBkYXRlQ2VsbCA6IGZ1bmN0aW9uKCBjLCBjZWxsLCByZXNvcnQsIGNhbGxiYWNrICkge1xuXHRcdFx0Ly8gdXBkYXRlQ2VsbCBmb3IgY2hpbGQgcm93cyBpcyBhIG1lc3MgLSB3ZSdsbCBpZ25vcmUgdGhlbSBmb3Igbm93XG5cdFx0XHQvLyBldmVudHVhbGx5IEknbGwgYnJlYWsgb3V0IHRoZSBcInVwZGF0ZVwiIHJvdyBjYWNoZSBjb2RlIHRvIG1ha2UgZXZlcnl0aGluZyBjb25zaXN0ZW50XG5cdFx0XHRpZiAoICQoIGNlbGwgKS5jbG9zZXN0KCAndHInICkuaGFzQ2xhc3MoIGMuY3NzQ2hpbGRSb3cgKSApIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUYWJsZXNvcnRlciBXYXJuaW5nISBcInVwZGF0ZUNlbGxcIiBmb3IgY2hpbGQgcm93IGNvbnRlbnQgaGFzIGJlZW4gZGlzYWJsZWQsIHVzZSBcInVwZGF0ZVwiIGluc3RlYWQnKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0cy5pc0VtcHR5T2JqZWN0KCBjLmNhY2hlICkgKSB7XG5cdFx0XHRcdC8vIGVtcHR5IHRhYmxlLCBkbyBhbiB1cGRhdGUgaW5zdGVhZCAtIGZpeGVzICMxMDk5XG5cdFx0XHRcdHRzLnVwZGF0ZUhlYWRlciggYyApO1xuXHRcdFx0XHR0cy5jb21tb25VcGRhdGUoIGMsIHJlc29ydCwgY2FsbGJhY2sgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Yy50YWJsZS5pc1VwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdGMuJHRhYmxlLmZpbmQoIGMuc2VsZWN0b3JSZW1vdmUgKS5yZW1vdmUoKTtcblx0XHRcdC8vIGdldCBwb3NpdGlvbiBmcm9tIHRoZSBkb21cblx0XHRcdHZhciB0bXAsIGluZHgsIHJvdywgaWNlbGwsIGNhY2hlLCBsZW4sXG5cdFx0XHRcdCR0Ym9kaWVzID0gYy4kdGJvZGllcyxcblx0XHRcdFx0JGNlbGwgPSAkKCBjZWxsICksXG5cdFx0XHRcdC8vIHVwZGF0ZSBjYWNoZSAtIGZvcm1hdDogZnVuY3Rpb24oIHMsIHRhYmxlLCBjZWxsLCBjZWxsSW5kZXggKVxuXHRcdFx0XHQvLyBubyBjbG9zZXN0IGluIGpRdWVyeSB2MS4yLjZcblx0XHRcdFx0dGJvZHlJbmRleCA9ICR0Ym9kaWVzLmluZGV4KCB0cy5nZXRDbG9zZXN0KCAkY2VsbCwgJ3Rib2R5JyApICksXG5cdFx0XHRcdHRiY2FjaGUgPSBjLmNhY2hlWyB0Ym9keUluZGV4IF0sXG5cdFx0XHRcdCRyb3cgPSB0cy5nZXRDbG9zZXN0KCAkY2VsbCwgJ3RyJyApO1xuXHRcdFx0Y2VsbCA9ICRjZWxsWyAwIF07IC8vIGluIGNhc2UgY2VsbCBpcyBhIGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHRib2R5IG1heSBub3QgZXhpc3QgaWYgdXBkYXRlIGlzIGluaXRpYWxpemVkIHdoaWxlIHRib2R5IGlzIHJlbW92ZWQgZm9yIHByb2Nlc3Npbmdcblx0XHRcdGlmICggJHRib2RpZXMubGVuZ3RoICYmIHRib2R5SW5kZXggPj0gMCApIHtcblx0XHRcdFx0cm93ID0gJHRib2RpZXMuZXEoIHRib2R5SW5kZXggKS5maW5kKCAndHInICkubm90KCAnLicgKyBjLmNzc0NoaWxkUm93ICkuaW5kZXgoICRyb3cgKTtcblx0XHRcdFx0Y2FjaGUgPSB0YmNhY2hlLm5vcm1hbGl6ZWRbIHJvdyBdO1xuXHRcdFx0XHRsZW4gPSAkcm93WyAwIF0uY2VsbHMubGVuZ3RoO1xuXHRcdFx0XHRpZiAoIGxlbiAhPT0gYy5jb2x1bW5zICkge1xuXHRcdFx0XHRcdC8vIGNvbHNwYW4gaW4gaGVyZSBzb21ld2hlcmUhXG5cdFx0XHRcdFx0aWNlbGwgPSAwO1xuXHRcdFx0XHRcdHRtcCA9IGZhbHNlO1xuXHRcdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICF0bXAgJiYgJHJvd1sgMCBdLmNlbGxzWyBpbmR4IF0gIT09IGNlbGwgKSB7XG5cdFx0XHRcdFx0XHRcdGljZWxsICs9ICRyb3dbIDAgXS5jZWxsc1sgaW5keCBdLmNvbFNwYW47XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0bXAgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpY2VsbCA9ICRjZWxsLmluZGV4KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dG1wID0gdHMuZ2V0RWxlbWVudFRleHQoIGMsIGNlbGwsIGljZWxsICk7IC8vIHJhd1xuXHRcdFx0XHRjYWNoZVsgYy5jb2x1bW5zIF0ucmF3WyBpY2VsbCBdID0gdG1wO1xuXHRcdFx0XHR0bXAgPSB0cy5nZXRQYXJzZWRUZXh0KCBjLCBjZWxsLCBpY2VsbCwgdG1wICk7XG5cdFx0XHRcdGNhY2hlWyBpY2VsbCBdID0gdG1wOyAvLyBwYXJzZWRcblx0XHRcdFx0aWYgKCAoIGMucGFyc2Vyc1sgaWNlbGwgXS50eXBlIHx8ICcnICkudG9Mb3dlckNhc2UoKSA9PT0gJ251bWVyaWMnICkge1xuXHRcdFx0XHRcdC8vIHVwZGF0ZSBjb2x1bW4gbWF4IHZhbHVlIChpZ25vcmUgc2lnbilcblx0XHRcdFx0XHR0YmNhY2hlLmNvbE1heFsgaWNlbGwgXSA9IE1hdGgubWF4KCBNYXRoLmFicyggdG1wICkgfHwgMCwgdGJjYWNoZS5jb2xNYXhbIGljZWxsIF0gfHwgMCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRtcCA9IHJlc29ydCAhPT0gJ3VuZGVmaW5lZCcgPyByZXNvcnQgOiBjLnJlc29ydDtcblx0XHRcdFx0aWYgKCB0bXAgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdC8vIHdpZGdldHMgd2lsbCBiZSByZWFwcGxpZWRcblx0XHRcdFx0XHR0cy5jaGVja1Jlc29ydCggYywgdG1wLCBjYWxsYmFjayApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGRvbid0IHJlYXBwbHkgd2lkZ2V0cyBpcyByZXNvcnQgaXMgZmFsc2UsIGp1c3QgaW4gY2FzZSBpdCBjYXVzZXNcblx0XHRcdFx0XHQvLyBwcm9ibGVtcyB3aXRoIGVsZW1lbnQgZm9jdXNcblx0XHRcdFx0XHR0cy5yZXNvcnRDb21wbGV0ZSggYywgY2FsbGJhY2sgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCB0cy5kZWJ1ZyhjLCAnY29yZScpICkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICd1cGRhdGVDZWxsIGFib3J0ZWQsIHRib2R5IG1pc3Npbmcgb3Igbm90IHdpdGhpbiB0aGUgaW5kaWNhdGVkIHRhYmxlJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGMudGFibGUuaXNVcGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRhZGRSb3dzIDogZnVuY3Rpb24oIGMsICRyb3csIHJlc29ydCwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdHh0LCB2YWwsIHRib2R5SW5kZXgsIHJvd0luZGV4LCByb3dzLCBjZWxsSW5kZXgsIGxlbiwgb3JkZXIsXG5cdFx0XHRcdGNhY2hlSW5kZXgsIHJvd0RhdGEsIGNlbGxzLCBjZWxsLCBzcGFuLFxuXHRcdFx0XHQvLyBhbGxvdyBwYXNzaW5nIGEgcm93IHN0cmluZyBpZiBvbmx5IG9uZSBub24taW5mbyB0Ym9keSBleGlzdHMgaW4gdGhlIHRhYmxlXG5cdFx0XHRcdHZhbGlkID0gdHlwZW9mICRyb3cgPT09ICdzdHJpbmcnICYmIGMuJHRib2RpZXMubGVuZ3RoID09PSAxICYmIC88dHIvLnRlc3QoICRyb3cgfHwgJycgKSxcblx0XHRcdFx0dGFibGUgPSBjLnRhYmxlO1xuXHRcdFx0aWYgKCB2YWxpZCApIHtcblx0XHRcdFx0JHJvdyA9ICQoICRyb3cgKTtcblx0XHRcdFx0Yy4kdGJvZGllcy5hcHBlbmQoICRyb3cgKTtcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdCEkcm93IHx8XG5cdFx0XHRcdC8vIHJvdyBpcyBhIGpRdWVyeSBvYmplY3Q/XG5cdFx0XHRcdCEoICRyb3cgaW5zdGFuY2VvZiAkICkgfHxcblx0XHRcdFx0Ly8gcm93IGNvbnRhaW5lZCBpbiB0aGUgdGFibGU/XG5cdFx0XHRcdCggdHMuZ2V0Q2xvc2VzdCggJHJvdywgJ3RhYmxlJyApWyAwIF0gIT09IGMudGFibGUgKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmICggdHMuZGVidWcoYywgJ2NvcmUnKSApIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnYWRkUm93cyBtZXRob2QgcmVxdWlyZXMgKDEpIGEgalF1ZXJ5IHNlbGVjdG9yIHJlZmVyZW5jZSB0byByb3dzIHRoYXQgaGF2ZSBhbHJlYWR5ICcgK1xuXHRcdFx0XHRcdFx0J2JlZW4gYWRkZWQgdG8gdGhlIHRhYmxlLCBvciAoMikgcm93IEhUTUwgc3RyaW5nIHRvIGJlIGFkZGVkIHRvIGEgdGFibGUgd2l0aCBvbmx5IG9uZSB0Ym9keScgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0YWJsZS5pc1VwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdGlmICggdHMuaXNFbXB0eU9iamVjdCggYy5jYWNoZSApICkge1xuXHRcdFx0XHQvLyBlbXB0eSB0YWJsZSwgZG8gYW4gdXBkYXRlIGluc3RlYWQgLSBmaXhlcyAjNDUwXG5cdFx0XHRcdHRzLnVwZGF0ZUhlYWRlciggYyApO1xuXHRcdFx0XHR0cy5jb21tb25VcGRhdGUoIGMsIHJlc29ydCwgY2FsbGJhY2sgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJvd3MgPSAkcm93LmZpbHRlciggJ3RyJyApLmF0dHIoICdyb2xlJywgJ3JvdycgKS5sZW5ndGg7XG5cdFx0XHRcdHRib2R5SW5kZXggPSBjLiR0Ym9kaWVzLmluZGV4KCAkcm93LnBhcmVudHMoICd0Ym9keScgKS5maWx0ZXIoICc6Zmlyc3QnICkgKTtcblx0XHRcdFx0Ly8gZml4ZXMgYWRkaW5nIHJvd3MgdG8gYW4gZW1wdHkgdGFibGUgLSBzZWUgaXNzdWUgIzE3OVxuXHRcdFx0XHRpZiAoICEoIGMucGFyc2VycyAmJiBjLnBhcnNlcnMubGVuZ3RoICkgKSB7XG5cdFx0XHRcdFx0dHMuc2V0dXBQYXJzZXJzKCBjICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gYWRkIGVhY2ggcm93XG5cdFx0XHRcdGZvciAoIHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCByb3dzOyByb3dJbmRleCsrICkge1xuXHRcdFx0XHRcdGNhY2hlSW5kZXggPSAwO1xuXHRcdFx0XHRcdGxlbiA9ICRyb3dbIHJvd0luZGV4IF0uY2VsbHMubGVuZ3RoO1xuXHRcdFx0XHRcdG9yZGVyID0gYy5jYWNoZVsgdGJvZHlJbmRleCBdLm5vcm1hbGl6ZWQubGVuZ3RoO1xuXHRcdFx0XHRcdGNlbGxzID0gW107XG5cdFx0XHRcdFx0cm93RGF0YSA9IHtcblx0XHRcdFx0XHRcdGNoaWxkIDogW10sXG5cdFx0XHRcdFx0XHRyYXcgOiBbXSxcblx0XHRcdFx0XHRcdCRyb3cgOiAkcm93LmVxKCByb3dJbmRleCApLFxuXHRcdFx0XHRcdFx0b3JkZXIgOiBvcmRlclxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Ly8gYWRkIGVhY2ggY2VsbFxuXHRcdFx0XHRcdGZvciAoIGNlbGxJbmRleCA9IDA7IGNlbGxJbmRleCA8IGxlbjsgY2VsbEluZGV4KysgKSB7XG5cdFx0XHRcdFx0XHRjZWxsID0gJHJvd1sgcm93SW5kZXggXS5jZWxsc1sgY2VsbEluZGV4IF07XG5cdFx0XHRcdFx0XHR0eHQgPSB0cy5nZXRFbGVtZW50VGV4dCggYywgY2VsbCwgY2FjaGVJbmRleCApO1xuXHRcdFx0XHRcdFx0cm93RGF0YS5yYXdbIGNhY2hlSW5kZXggXSA9IHR4dDtcblx0XHRcdFx0XHRcdHZhbCA9IHRzLmdldFBhcnNlZFRleHQoIGMsIGNlbGwsIGNhY2hlSW5kZXgsIHR4dCApO1xuXHRcdFx0XHRcdFx0Y2VsbHNbIGNhY2hlSW5kZXggXSA9IHZhbDtcblx0XHRcdFx0XHRcdGlmICggKCBjLnBhcnNlcnNbIGNhY2hlSW5kZXggXS50eXBlIHx8ICcnICkudG9Mb3dlckNhc2UoKSA9PT0gJ251bWVyaWMnICkge1xuXHRcdFx0XHRcdFx0XHQvLyB1cGRhdGUgY29sdW1uIG1heCB2YWx1ZSAoaWdub3JlIHNpZ24pXG5cdFx0XHRcdFx0XHRcdGMuY2FjaGVbIHRib2R5SW5kZXggXS5jb2xNYXhbIGNhY2hlSW5kZXggXSA9XG5cdFx0XHRcdFx0XHRcdFx0TWF0aC5tYXgoIE1hdGguYWJzKCB2YWwgKSB8fCAwLCBjLmNhY2hlWyB0Ym9keUluZGV4IF0uY29sTWF4WyBjYWNoZUluZGV4IF0gfHwgMCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c3BhbiA9IGNlbGwuY29sU3BhbiAtIDE7XG5cdFx0XHRcdFx0XHRpZiAoIHNwYW4gPiAwICkge1xuXHRcdFx0XHRcdFx0XHRjYWNoZUluZGV4ICs9IHNwYW47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYWNoZUluZGV4Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGFkZCB0aGUgcm93IGRhdGEgdG8gdGhlIGVuZFxuXHRcdFx0XHRcdGNlbGxzWyBjLmNvbHVtbnMgXSA9IHJvd0RhdGE7XG5cdFx0XHRcdFx0Ly8gdXBkYXRlIGNhY2hlXG5cdFx0XHRcdFx0Yy5jYWNoZVsgdGJvZHlJbmRleCBdLm5vcm1hbGl6ZWRbIG9yZGVyIF0gPSBjZWxscztcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyByZXNvcnQgdXNpbmcgY3VycmVudCBzZXR0aW5nc1xuXHRcdFx0XHR0cy5jaGVja1Jlc29ydCggYywgcmVzb3J0LCBjYWxsYmFjayApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR1cGRhdGVDYWNoZSA6IGZ1bmN0aW9uKCBjLCBjYWxsYmFjaywgJHRib2RpZXMgKSB7XG5cdFx0XHQvLyByZWJ1aWxkIHBhcnNlcnNcblx0XHRcdGlmICggISggYy5wYXJzZXJzICYmIGMucGFyc2Vycy5sZW5ndGggKSApIHtcblx0XHRcdFx0dHMuc2V0dXBQYXJzZXJzKCBjLCAkdGJvZGllcyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcmVidWlsZCB0aGUgY2FjaGUgbWFwXG5cdFx0XHR0cy5idWlsZENhY2hlKCBjLCBjYWxsYmFjaywgJHRib2RpZXMgKTtcblx0XHR9LFxuXG5cdFx0Ly8gaW5pdCBmbGFnICh0cnVlKSB1c2VkIGJ5IHBhZ2VyIHBsdWdpbiB0byBwcmV2ZW50IHdpZGdldCBhcHBsaWNhdGlvblxuXHRcdC8vIHJlbmFtZWQgZnJvbSBhcHBlbmRUb1RhYmxlXG5cdFx0YXBwZW5kQ2FjaGUgOiBmdW5jdGlvbiggYywgaW5pdCApIHtcblx0XHRcdHZhciBwYXJzZWQsIHRvdGFsUm93cywgJHRib2R5LCAkY3VyVGJvZHksIHJvd0luZGV4LCB0Ym9keUluZGV4LCBhcHBlbmRUaW1lLFxuXHRcdFx0XHR0YWJsZSA9IGMudGFibGUsXG5cdFx0XHRcdCR0Ym9kaWVzID0gYy4kdGJvZGllcyxcblx0XHRcdFx0cm93cyA9IFtdLFxuXHRcdFx0XHRjYWNoZSA9IGMuY2FjaGU7XG5cdFx0XHQvLyBlbXB0eSB0YWJsZSAtIGZpeGVzICMyMDYvIzM0NlxuXHRcdFx0aWYgKCB0cy5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXHRcdFx0XHQvLyBydW4gcGFnZXIgYXBwZW5kZXIgaW4gY2FzZSB0aGUgdGFibGUgd2FzIGp1c3QgZW1wdGllZFxuXHRcdFx0XHRyZXR1cm4gYy5hcHBlbmRlciA/IGMuYXBwZW5kZXIoIHRhYmxlLCByb3dzICkgOlxuXHRcdFx0XHRcdHRhYmxlLmlzVXBkYXRpbmcgPyBjLiR0YWJsZS50cmlnZ2VySGFuZGxlciggJ3VwZGF0ZUNvbXBsZXRlJywgdGFibGUgKSA6ICcnOyAvLyBGaXhlcyAjNTMyXG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRzLmRlYnVnKGMsICdjb3JlJykgKSB7XG5cdFx0XHRcdGFwcGVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggdGJvZHlJbmRleCA9IDA7IHRib2R5SW5kZXggPCAkdGJvZGllcy5sZW5ndGg7IHRib2R5SW5kZXgrKyApIHtcblx0XHRcdFx0JHRib2R5ID0gJHRib2RpZXMuZXEoIHRib2R5SW5kZXggKTtcblx0XHRcdFx0aWYgKCAkdGJvZHkubGVuZ3RoICkge1xuXHRcdFx0XHRcdC8vIGRldGFjaCB0Ym9keSBmb3IgbWFuaXB1bGF0aW9uXG5cdFx0XHRcdFx0JGN1clRib2R5ID0gdHMucHJvY2Vzc1Rib2R5KCB0YWJsZSwgJHRib2R5LCB0cnVlICk7XG5cdFx0XHRcdFx0cGFyc2VkID0gY2FjaGVbIHRib2R5SW5kZXggXS5ub3JtYWxpemVkO1xuXHRcdFx0XHRcdHRvdGFsUm93cyA9IHBhcnNlZC5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yICggcm93SW5kZXggPSAwOyByb3dJbmRleCA8IHRvdGFsUm93czsgcm93SW5kZXgrKyApIHtcblx0XHRcdFx0XHRcdHJvd3Nbcm93cy5sZW5ndGhdID0gcGFyc2VkWyByb3dJbmRleCBdWyBjLmNvbHVtbnMgXS4kcm93O1xuXHRcdFx0XHRcdFx0Ly8gcmVtb3ZlUm93cyB1c2VkIGJ5IHRoZSBwYWdlciBwbHVnaW47IGRvbid0IHJlbmRlciBpZiB1c2luZyBhamF4IC0gZml4ZXMgIzQxMVxuXHRcdFx0XHRcdFx0aWYgKCAhYy5hcHBlbmRlciB8fCAoIGMucGFnZXIgJiYgIWMucGFnZXIucmVtb3ZlUm93cyAmJiAhYy5wYWdlci5hamF4ICkgKSB7XG5cdFx0XHRcdFx0XHRcdCRjdXJUYm9keS5hcHBlbmQoIHBhcnNlZFsgcm93SW5kZXggXVsgYy5jb2x1bW5zIF0uJHJvdyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyByZXN0b3JlIHRib2R5XG5cdFx0XHRcdFx0dHMucHJvY2Vzc1Rib2R5KCB0YWJsZSwgJGN1clRib2R5LCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGMuYXBwZW5kZXIgKSB7XG5cdFx0XHRcdGMuYXBwZW5kZXIoIHRhYmxlLCByb3dzICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRzLmRlYnVnKGMsICdjb3JlJykgKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCAnUmVidWlsdCB0YWJsZScgKyB0cy5iZW5jaG1hcmsoIGFwcGVuZFRpbWUgKSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYXBwbHkgdGFibGUgd2lkZ2V0czsgYnV0IG5vdCBiZWZvcmUgYWpheCBjb21wbGV0ZXNcblx0XHRcdGlmICggIWluaXQgJiYgIWMuYXBwZW5kZXIgKSB7XG5cdFx0XHRcdHRzLmFwcGx5V2lkZ2V0KCB0YWJsZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0YWJsZS5pc1VwZGF0aW5nICkge1xuXHRcdFx0XHRjLiR0YWJsZS50cmlnZ2VySGFuZGxlciggJ3VwZGF0ZUNvbXBsZXRlJywgdGFibGUgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y29tbW9uVXBkYXRlIDogZnVuY3Rpb24oIGMsIHJlc29ydCwgY2FsbGJhY2sgKSB7XG5cdFx0XHQvLyByZW1vdmUgcm93cy9lbGVtZW50cyBiZWZvcmUgdXBkYXRlXG5cdFx0XHRjLiR0YWJsZS5maW5kKCBjLnNlbGVjdG9yUmVtb3ZlICkucmVtb3ZlKCk7XG5cdFx0XHQvLyByZWJ1aWxkIHBhcnNlcnNcblx0XHRcdHRzLnNldHVwUGFyc2VycyggYyApO1xuXHRcdFx0Ly8gcmVidWlsZCB0aGUgY2FjaGUgbWFwXG5cdFx0XHR0cy5idWlsZENhY2hlKCBjICk7XG5cdFx0XHR0cy5jaGVja1Jlc29ydCggYywgcmVzb3J0LCBjYWxsYmFjayApO1xuXHRcdH0sXG5cblx0XHQvKlxuXHRcdOKWhOKWiOKWiOKWiOKWiOKWiCDiloTilojilojilojilojiloQg4paI4paI4paI4paI4paI4paEIOKWiOKWiOKWiOKWiOKWiOKWiCDilojilogg4paI4paI4paI4paI4paI4paEIOKWhOKWiOKWiOKWiOKWiOKWhFxuXHRcdOKWgOKWiOKWhCAgICDilojiloggIOKWiOKWiCDilojilojiloTiloTilojiloggICDilojiloggICDilojilogg4paI4paIICDilojilogg4paI4paIIOKWhOKWhOKWhFxuXHRcdCAgIOKWgOKWiOKWhCDilojiloggIOKWiOKWiCDilojilojiloDilojiloggICAg4paI4paIICAg4paI4paIIOKWiOKWiCAg4paI4paIIOKWiOKWiCDiloDilojilohcblx0XHTilojilojilojilojilojiloAg4paA4paI4paI4paI4paI4paAIOKWiOKWiCAg4paI4paIICAg4paI4paIICAg4paI4paIIOKWiOKWiCAg4paI4paIIOKWgOKWiOKWiOKWiOKWiOKWgFxuXHRcdCovXG5cdFx0aW5pdFNvcnQgOiBmdW5jdGlvbiggYywgY2VsbCwgZXZlbnQgKSB7XG5cdFx0XHRpZiAoIGMudGFibGUuaXNVcGRhdGluZyApIHtcblx0XHRcdFx0Ly8gbGV0IGFueSB1cGRhdGVzIGNvbXBsZXRlIGJlZm9yZSBpbml0aWFsaXppbmcgYSBzb3J0XG5cdFx0XHRcdHJldHVybiBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0cy5pbml0U29ydCggYywgY2VsbCwgZXZlbnQgKTtcblx0XHRcdFx0fSwgNTAgKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGFycnksIGluZHgsIGhlYWRlckluZHgsIGRpciwgdGVtcCwgdG1wLCAkaGVhZGVyLFxuXHRcdFx0XHRub3RNdWx0aVNvcnQgPSAhZXZlbnRbIGMuc29ydE11bHRpU29ydEtleSBdLFxuXHRcdFx0XHR0YWJsZSA9IGMudGFibGUsXG5cdFx0XHRcdGxlbiA9IGMuJGhlYWRlcnMubGVuZ3RoLFxuXHRcdFx0XHR0aCA9IHRzLmdldENsb3Nlc3QoICQoIGNlbGwgKSwgJ3RoLCB0ZCcgKSxcblx0XHRcdFx0Y29sID0gcGFyc2VJbnQoIHRoLmF0dHIoICdkYXRhLWNvbHVtbicgKSwgMTAgKSxcblx0XHRcdFx0b3JkZXIgPSBjLnNvcnRWYXJzWyBjb2wgXS5vcmRlcjtcblx0XHRcdHRoID0gdGhbMF07XG5cdFx0XHQvLyBPbmx5IGNhbGwgc29ydFN0YXJ0IGlmIHNvcnRpbmcgaXMgZW5hYmxlZFxuXHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoICdzb3J0U3RhcnQnLCB0YWJsZSApO1xuXHRcdFx0Ly8gZ2V0IGN1cnJlbnQgY29sdW1uIHNvcnQgb3JkZXJcblx0XHRcdHRtcCA9ICggYy5zb3J0VmFyc1sgY29sIF0uY291bnQgKyAxICkgJSBvcmRlci5sZW5ndGg7XG5cdFx0XHRjLnNvcnRWYXJzWyBjb2wgXS5jb3VudCA9IGV2ZW50WyBjLnNvcnRSZXNldEtleSBdID8gMiA6IHRtcDtcblx0XHRcdC8vIHJlc2V0IGFsbCBzb3J0cyBvbiBub24tY3VycmVudCBjb2x1bW4gLSBpc3N1ZSAjMzBcblx0XHRcdGlmICggYy5zb3J0UmVzdGFydCApIHtcblx0XHRcdFx0Zm9yICggaGVhZGVySW5keCA9IDA7IGhlYWRlckluZHggPCBsZW47IGhlYWRlckluZHgrKyApIHtcblx0XHRcdFx0XHQkaGVhZGVyID0gYy4kaGVhZGVycy5lcSggaGVhZGVySW5keCApO1xuXHRcdFx0XHRcdHRtcCA9IHBhcnNlSW50KCAkaGVhZGVyLmF0dHIoICdkYXRhLWNvbHVtbicgKSwgMTAgKTtcblx0XHRcdFx0XHQvLyBvbmx5IHJlc2V0IGNvdW50cyBvbiBjb2x1bW5zIHRoYXQgd2VyZW4ndCBqdXN0IGNsaWNrZWQgb24gYW5kIGlmIG5vdCBpbmNsdWRlZCBpbiBhIG11bHRpc29ydFxuXHRcdFx0XHRcdGlmICggY29sICE9PSB0bXAgJiYgKCBub3RNdWx0aVNvcnQgfHwgJGhlYWRlci5oYXNDbGFzcyggdHMuY3NzLnNvcnROb25lICkgKSApIHtcblx0XHRcdFx0XHRcdGMuc29ydFZhcnNbIHRtcCBdLmNvdW50ID0gLTE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyB1c2VyIG9ubHkgd2FudHMgdG8gc29ydCBvbiBvbmUgY29sdW1uXG5cdFx0XHRpZiAoIG5vdE11bHRpU29ydCApIHtcblx0XHRcdFx0Ly8gZmx1c2ggdGhlIHNvcnQgbGlzdFxuXHRcdFx0XHRjLnNvcnRMaXN0ID0gW107XG5cdFx0XHRcdGMubGFzdC5zb3J0TGlzdCA9IFtdO1xuXHRcdFx0XHRpZiAoIGMuc29ydEZvcmNlICE9PSBudWxsICkge1xuXHRcdFx0XHRcdGFycnkgPSBjLnNvcnRGb3JjZTtcblx0XHRcdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGFycnkubGVuZ3RoOyBpbmR4KysgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGFycnlbIGluZHggXVsgMCBdICE9PSBjb2wgKSB7XG5cdFx0XHRcdFx0XHRcdGMuc29ydExpc3RbIGMuc29ydExpc3QubGVuZ3RoIF0gPSBhcnJ5WyBpbmR4IF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGFkZCBjb2x1bW4gdG8gc29ydCBsaXN0XG5cdFx0XHRcdGRpciA9IG9yZGVyWyBjLnNvcnRWYXJzWyBjb2wgXS5jb3VudCBdO1xuXHRcdFx0XHRpZiAoIGRpciA8IDIgKSB7XG5cdFx0XHRcdFx0Yy5zb3J0TGlzdFsgYy5zb3J0TGlzdC5sZW5ndGggXSA9IFsgY29sLCBkaXIgXTtcblx0XHRcdFx0XHQvLyBhZGQgb3RoZXIgY29sdW1ucyBpZiBoZWFkZXIgc3BhbnMgYWNyb3NzIG11bHRpcGxlXG5cdFx0XHRcdFx0aWYgKCB0aC5jb2xTcGFuID4gMSApIHtcblx0XHRcdFx0XHRcdGZvciAoIGluZHggPSAxOyBpbmR4IDwgdGguY29sU3BhbjsgaW5keCsrICkge1xuXHRcdFx0XHRcdFx0XHRjLnNvcnRMaXN0WyBjLnNvcnRMaXN0Lmxlbmd0aCBdID0gWyBjb2wgKyBpbmR4LCBkaXIgXTtcblx0XHRcdFx0XHRcdFx0Ly8gdXBkYXRlIGNvdW50IG9uIGNvbHVtbnMgaW4gY29sU3BhblxuXHRcdFx0XHRcdFx0XHRjLnNvcnRWYXJzWyBjb2wgKyBpbmR4IF0uY291bnQgPSAkLmluQXJyYXkoIGRpciwgb3JkZXIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gbXVsdGkgY29sdW1uIHNvcnRpbmdcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGdldCByaWQgb2YgdGhlIHNvcnRBcHBlbmQgYmVmb3JlIGFkZGluZyBtb3JlIC0gZml4ZXMgaXNzdWUgIzExNSAmICM1MjNcblx0XHRcdFx0Yy5zb3J0TGlzdCA9ICQuZXh0ZW5kKCBbXSwgYy5sYXN0LnNvcnRMaXN0ICk7XG5cblx0XHRcdFx0Ly8gdGhlIHVzZXIgaGFzIGNsaWNrZWQgb24gYW4gYWxyZWFkeSBzb3J0ZWQgY29sdW1uXG5cdFx0XHRcdGlmICggdHMuaXNWYWx1ZUluQXJyYXkoIGNvbCwgYy5zb3J0TGlzdCApID49IDAgKSB7XG5cdFx0XHRcdFx0Ly8gcmV2ZXJzZSB0aGUgc29ydGluZyBkaXJlY3Rpb25cblx0XHRcdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGMuc29ydExpc3QubGVuZ3RoOyBpbmR4KysgKSB7XG5cdFx0XHRcdFx0XHR0bXAgPSBjLnNvcnRMaXN0WyBpbmR4IF07XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMCBdID09PSBjb2wgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIG9yZGVyLmNvdW50IHNlZW1zIHRvIGJlIGluY29ycmVjdCB3aGVuIGNvbXBhcmVkIHRvIGNlbGwuY291bnRcblx0XHRcdFx0XHRcdFx0dG1wWyAxIF0gPSBvcmRlclsgYy5zb3J0VmFyc1sgY29sIF0uY291bnQgXTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0bXBbMV0gPT09IDIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Yy5zb3J0TGlzdC5zcGxpY2UoIGluZHgsIDEgKTtcblx0XHRcdFx0XHRcdFx0XHRjLnNvcnRWYXJzWyBjb2wgXS5jb3VudCA9IC0xO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGFkZCBjb2x1bW4gdG8gc29ydCBsaXN0IGFycmF5XG5cdFx0XHRcdFx0ZGlyID0gb3JkZXJbIGMuc29ydFZhcnNbIGNvbCBdLmNvdW50IF07XG5cdFx0XHRcdFx0aWYgKCBkaXIgPCAyICkge1xuXHRcdFx0XHRcdFx0Yy5zb3J0TGlzdFsgYy5zb3J0TGlzdC5sZW5ndGggXSA9IFsgY29sLCBkaXIgXTtcblx0XHRcdFx0XHRcdC8vIGFkZCBvdGhlciBjb2x1bW5zIGlmIGhlYWRlciBzcGFucyBhY3Jvc3MgbXVsdGlwbGVcblx0XHRcdFx0XHRcdGlmICggdGguY29sU3BhbiA+IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGluZHggPSAxOyBpbmR4IDwgdGguY29sU3BhbjsgaW5keCsrICkge1xuXHRcdFx0XHRcdFx0XHRcdGMuc29ydExpc3RbIGMuc29ydExpc3QubGVuZ3RoIF0gPSBbIGNvbCArIGluZHgsIGRpciBdO1xuXHRcdFx0XHRcdFx0XHRcdC8vIHVwZGF0ZSBjb3VudCBvbiBjb2x1bW5zIGluIGNvbFNwYW5cblx0XHRcdFx0XHRcdFx0XHRjLnNvcnRWYXJzWyBjb2wgKyBpbmR4IF0uY291bnQgPSAkLmluQXJyYXkoIGRpciwgb3JkZXIgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gc2F2ZSBzb3J0IGJlZm9yZSBhcHBseWluZyBzb3J0QXBwZW5kXG5cdFx0XHRjLmxhc3Quc29ydExpc3QgPSAkLmV4dGVuZCggW10sIGMuc29ydExpc3QgKTtcblx0XHRcdGlmICggYy5zb3J0TGlzdC5sZW5ndGggJiYgYy5zb3J0QXBwZW5kICkge1xuXHRcdFx0XHRhcnJ5ID0gJC5pc0FycmF5KCBjLnNvcnRBcHBlbmQgKSA/IGMuc29ydEFwcGVuZCA6IGMuc29ydEFwcGVuZFsgYy5zb3J0TGlzdFsgMCBdWyAwIF0gXTtcblx0XHRcdFx0aWYgKCAhdHMuaXNFbXB0eU9iamVjdCggYXJyeSApICkge1xuXHRcdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgYXJyeS5sZW5ndGg7IGluZHgrKyApIHtcblx0XHRcdFx0XHRcdGlmICggYXJyeVsgaW5keCBdWyAwIF0gIT09IGNvbCAmJiB0cy5pc1ZhbHVlSW5BcnJheSggYXJyeVsgaW5keCBdWyAwIF0sIGMuc29ydExpc3QgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGRpciA9IGFycnlbIGluZHggXVsgMSBdO1xuXHRcdFx0XHRcdFx0XHR0ZW1wID0gKCAnJyArIGRpciApLm1hdGNoKCAvXihhfGR8c3xvfG4pLyApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHRlbXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wID0gYy5zb3J0TGlzdFsgMCBdWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0c3dpdGNoICggdGVtcFsgMCBdICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnZCcgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkaXIgPSAxO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3MnIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGlyID0gdG1wO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ28nIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGlyID0gdG1wID09PSAwID8gMSA6IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnbicgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkaXIgPSAoIHRtcCArIDEgKSAlIG9yZGVyLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkaXIgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Yy5zb3J0TGlzdFsgYy5zb3J0TGlzdC5sZW5ndGggXSA9IFsgYXJyeVsgaW5keCBdWyAwIF0sIGRpciBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gc29ydEJlZ2luIGV2ZW50IHRyaWdnZXJlZCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIHNvcnRcblx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAnc29ydEJlZ2luJywgdGFibGUgKTtcblx0XHRcdC8vIHNldFRpbWVvdXQgbmVlZGVkIHNvIHRoZSBwcm9jZXNzaW5nIGljb24gc2hvd3MgdXBcblx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBzZXQgY3NzIGZvciBoZWFkZXJzXG5cdFx0XHRcdHRzLnNldEhlYWRlcnNDc3MoIGMgKTtcblx0XHRcdFx0dHMubXVsdGlzb3J0KCBjICk7XG5cdFx0XHRcdHRzLmFwcGVuZENhY2hlKCBjICk7XG5cdFx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAnc29ydEJlZm9yZUVuZCcsIHRhYmxlICk7XG5cdFx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAnc29ydEVuZCcsIHRhYmxlICk7XG5cdFx0XHR9LCAxICk7XG5cdFx0fSxcblxuXHRcdC8vIHNvcnQgbXVsdGlwbGUgY29sdW1uc1xuXHRcdG11bHRpc29ydCA6IGZ1bmN0aW9uKCBjICkgeyAvKmpzaGludCBsb29wZnVuYzp0cnVlICovXG5cdFx0XHR2YXIgdGJvZHlJbmRleCwgc29ydFRpbWUsIGNvbE1heCwgcm93cywgdG1wLFxuXHRcdFx0XHR0YWJsZSA9IGMudGFibGUsXG5cdFx0XHRcdHNvcnRlciA9IFtdLFxuXHRcdFx0XHRkaXIgPSAwLFxuXHRcdFx0XHR0ZXh0U29ydGVyID0gYy50ZXh0U29ydGVyIHx8ICcnLFxuXHRcdFx0XHRzb3J0TGlzdCA9IGMuc29ydExpc3QsXG5cdFx0XHRcdHNvcnRMZW4gPSBzb3J0TGlzdC5sZW5ndGgsXG5cdFx0XHRcdGxlbiA9IGMuJHRib2RpZXMubGVuZ3RoO1xuXHRcdFx0aWYgKCBjLnNlcnZlclNpZGVTb3J0aW5nIHx8IHRzLmlzRW1wdHlPYmplY3QoIGMuY2FjaGUgKSApIHtcblx0XHRcdFx0Ly8gZW1wdHkgdGFibGUgLSBmaXhlcyAjMjA2LyMzNDZcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0cy5kZWJ1ZyhjLCAnY29yZScpICkgeyBzb3J0VGltZSA9IG5ldyBEYXRlKCk7IH1cblx0XHRcdC8vIGNhY2hlIHRleHRTb3J0ZXIgdG8gb3B0aW1pemUgc3BlZWRcblx0XHRcdGlmICggdHlwZW9mIHRleHRTb3J0ZXIgPT09ICdvYmplY3QnICkge1xuXHRcdFx0XHRjb2xNYXggPSBjLmNvbHVtbnM7XG5cdFx0XHRcdHdoaWxlICggY29sTWF4LS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdHMuZ2V0Q29sdW1uRGF0YSggdGFibGUsIHRleHRTb3J0ZXIsIGNvbE1heCApO1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIHRtcCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdHNvcnRlclsgY29sTWF4IF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCB0Ym9keUluZGV4ID0gMDsgdGJvZHlJbmRleCA8IGxlbjsgdGJvZHlJbmRleCsrICkge1xuXHRcdFx0XHRjb2xNYXggPSBjLmNhY2hlWyB0Ym9keUluZGV4IF0uY29sTWF4O1xuXHRcdFx0XHRyb3dzID0gYy5jYWNoZVsgdGJvZHlJbmRleCBdLm5vcm1hbGl6ZWQ7XG5cblx0XHRcdFx0cm93cy5zb3J0KCBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdFx0XHR2YXIgc29ydEluZGV4LCBudW0sIGNvbCwgb3JkZXIsIHNvcnQsIHgsIHk7XG5cdFx0XHRcdFx0Ly8gcm93cyBpcyB1bmRlZmluZWQgaGVyZSBpbiBJRSwgc28gZG9uJ3QgdXNlIGl0IVxuXHRcdFx0XHRcdGZvciAoIHNvcnRJbmRleCA9IDA7IHNvcnRJbmRleCA8IHNvcnRMZW47IHNvcnRJbmRleCsrICkge1xuXHRcdFx0XHRcdFx0Y29sID0gc29ydExpc3RbIHNvcnRJbmRleCBdWyAwIF07XG5cdFx0XHRcdFx0XHRvcmRlciA9IHNvcnRMaXN0WyBzb3J0SW5kZXggXVsgMSBdO1xuXHRcdFx0XHRcdFx0Ly8gc29ydCBkaXJlY3Rpb24sIHRydWUgPSBhc2MsIGZhbHNlID0gZGVzY1xuXHRcdFx0XHRcdFx0ZGlyID0gb3JkZXIgPT09IDA7XG5cblx0XHRcdFx0XHRcdGlmICggYy5zb3J0U3RhYmxlICYmIGFbIGNvbCBdID09PSBiWyBjb2wgXSAmJiBzb3J0TGVuID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYVsgYy5jb2x1bW5zIF0ub3JkZXIgLSBiWyBjLmNvbHVtbnMgXS5vcmRlcjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gZmFsbGJhY2sgdG8gbmF0dXJhbCBzb3J0IHNpbmNlIGl0IGlzIG1vcmUgcm9idXN0XG5cdFx0XHRcdFx0XHRudW0gPSAvbi9pLnRlc3QoIHRzLmdldFNvcnRUeXBlKCBjLnBhcnNlcnMsIGNvbCApICk7XG5cdFx0XHRcdFx0XHRpZiAoIG51bSAmJiBjLnN0cmluZ3NbIGNvbCBdICkge1xuXHRcdFx0XHRcdFx0XHQvLyBzb3J0IHN0cmluZ3MgaW4gbnVtZXJpY2FsIGNvbHVtbnNcblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgKCB0cy5zdHJpbmdbIGMuc3RyaW5nc1sgY29sIF0gXSApID09PSAnYm9vbGVhbicgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bnVtID0gKCBkaXIgPyAxIDogLTEgKSAqICggdHMuc3RyaW5nWyBjLnN0cmluZ3NbIGNvbCBdIF0gPyAtMSA6IDEgKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRudW0gPSAoIGMuc3RyaW5nc1sgY29sIF0gKSA/IHRzLnN0cmluZ1sgYy5zdHJpbmdzWyBjb2wgXSBdIHx8IDAgOiAwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8vIGZhbGwgYmFjayB0byBidWlsdC1pbiBudW1lcmljIHNvcnRcblx0XHRcdFx0XHRcdFx0Ly8gdmFyIHNvcnQgPSAkLnRhYmxlc29ydGVyWydzb3J0JyArIHNdKCBhW2NvbF0sIGJbY29sXSwgZGlyLCBjb2xNYXhbY29sXSwgdGFibGUgKTtcblx0XHRcdFx0XHRcdFx0c29ydCA9IGMubnVtYmVyU29ydGVyID8gYy5udW1iZXJTb3J0ZXIoIGFbIGNvbCBdLCBiWyBjb2wgXSwgZGlyLCBjb2xNYXhbIGNvbCBdLCB0YWJsZSApIDpcblx0XHRcdFx0XHRcdFx0XHR0c1sgJ3NvcnROdW1lcmljJyArICggZGlyID8gJ0FzYycgOiAnRGVzYycgKSBdKCBhWyBjb2wgXSwgYlsgY29sIF0sIG51bSwgY29sTWF4WyBjb2wgXSwgY29sLCBjICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBzZXQgYSAmIGIgZGVwZW5kaW5nIG9uIHNvcnQgZGlyZWN0aW9uXG5cdFx0XHRcdFx0XHRcdHggPSBkaXIgPyBhIDogYjtcblx0XHRcdFx0XHRcdFx0eSA9IGRpciA/IGIgOiBhO1xuXHRcdFx0XHRcdFx0XHQvLyB0ZXh0IHNvcnQgZnVuY3Rpb25cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgdGV4dFNvcnRlciA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBjdXN0b20gT1ZFUkFMTCB0ZXh0IHNvcnRlclxuXHRcdFx0XHRcdFx0XHRcdHNvcnQgPSB0ZXh0U29ydGVyKCB4WyBjb2wgXSwgeVsgY29sIF0sIGRpciwgY29sLCB0YWJsZSApO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2Ygc29ydGVyWyBjb2wgXSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBjdXN0b20gdGV4dCBzb3J0ZXIgZm9yIGEgU1BFQ0lGSUMgQ09MVU1OXG5cdFx0XHRcdFx0XHRcdFx0c29ydCA9IHNvcnRlclsgY29sIF0oIHhbIGNvbCBdLCB5WyBjb2wgXSwgZGlyLCBjb2wsIHRhYmxlICk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gZmFsbCBiYWNrIHRvIG5hdHVyYWwgc29ydFxuXHRcdFx0XHRcdFx0XHRcdHNvcnQgPSB0c1sgJ3NvcnROYXR1cmFsJyArICggZGlyID8gJ0FzYycgOiAnRGVzYycgKSBdKCBhWyBjb2wgXSwgYlsgY29sIF0sIGNvbCwgYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIHNvcnQgKSB7IHJldHVybiBzb3J0OyB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBhWyBjLmNvbHVtbnMgXS5vcmRlciAtIGJbIGMuY29sdW1ucyBdLm9yZGVyO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGlmICggdHMuZGVidWcoYywgJ2NvcmUnKSApIHtcblx0XHRcdFx0Y29uc29sZS5sb2coICdBcHBseWluZyBzb3J0ICcgKyBzb3J0TGlzdC50b1N0cmluZygpICsgdHMuYmVuY2htYXJrKCBzb3J0VGltZSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHJlc29ydENvbXBsZXRlIDogZnVuY3Rpb24oIGMsIGNhbGxiYWNrICkge1xuXHRcdFx0aWYgKCBjLnRhYmxlLmlzVXBkYXRpbmcgKSB7XG5cdFx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAndXBkYXRlQ29tcGxldGUnLCBjLnRhYmxlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICQuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSApIHtcblx0XHRcdFx0Y2FsbGJhY2soIGMudGFibGUgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y2hlY2tSZXNvcnQgOiBmdW5jdGlvbiggYywgcmVzb3J0LCBjYWxsYmFjayApIHtcblx0XHRcdHZhciBzb3J0TGlzdCA9ICQuaXNBcnJheSggcmVzb3J0ICkgPyByZXNvcnQgOiBjLnNvcnRMaXN0LFxuXHRcdFx0XHQvLyBpZiBubyByZXNvcnQgcGFyYW1ldGVyIGlzIHBhc3NlZCwgZmFsbGJhY2sgdG8gY29uZmlnLnJlc29ydCAodHJ1ZSBieSBkZWZhdWx0KVxuXHRcdFx0XHRyZXNydCA9IHR5cGVvZiByZXNvcnQgPT09ICd1bmRlZmluZWQnID8gYy5yZXNvcnQgOiByZXNvcnQ7XG5cdFx0XHQvLyBkb24ndCB0cnkgdG8gcmVzb3J0IGlmIHRoZSB0YWJsZSBpcyBzdGlsbCBwcm9jZXNzaW5nXG5cdFx0XHQvLyB0aGlzIHdpbGwgY2F0Y2ggc3BhbW1pbmcgb2YgdGhlIHVwZGF0ZUNlbGwgbWV0aG9kXG5cdFx0XHRpZiAoIHJlc3J0ICE9PSBmYWxzZSAmJiAhYy5zZXJ2ZXJTaWRlU29ydGluZyAmJiAhYy50YWJsZS5pc1Byb2Nlc3NpbmcgKSB7XG5cdFx0XHRcdGlmICggc29ydExpc3QubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRzLnNvcnRPbiggYywgc29ydExpc3QsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dHMucmVzb3J0Q29tcGxldGUoIGMsIGNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fSwgdHJ1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRzLnNvcnRSZXNldCggYywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0cy5yZXNvcnRDb21wbGV0ZSggYywgY2FsbGJhY2sgKTtcblx0XHRcdFx0XHRcdHRzLmFwcGx5V2lkZ2V0KCBjLnRhYmxlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHMucmVzb3J0Q29tcGxldGUoIGMsIGNhbGxiYWNrICk7XG5cdFx0XHRcdHRzLmFwcGx5V2lkZ2V0KCBjLnRhYmxlLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzb3J0T24gOiBmdW5jdGlvbiggYywgbGlzdCwgY2FsbGJhY2ssIGluaXQgKSB7XG5cdFx0XHR2YXIgdGFibGUgPSBjLnRhYmxlO1xuXHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoICdzb3J0U3RhcnQnLCB0YWJsZSApO1xuXHRcdFx0Ly8gdXBkYXRlIGhlYWRlciBjb3VudCBpbmRleFxuXHRcdFx0dHMudXBkYXRlSGVhZGVyU29ydENvdW50KCBjLCBsaXN0ICk7XG5cdFx0XHQvLyBzZXQgY3NzIGZvciBoZWFkZXJzXG5cdFx0XHR0cy5zZXRIZWFkZXJzQ3NzKCBjICk7XG5cdFx0XHQvLyBmaXhlcyAjMzQ2XG5cdFx0XHRpZiAoIGMuZGVsYXlJbml0ICYmIHRzLmlzRW1wdHlPYmplY3QoIGMuY2FjaGUgKSApIHtcblx0XHRcdFx0dHMuYnVpbGRDYWNoZSggYyApO1xuXHRcdFx0fVxuXHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoICdzb3J0QmVnaW4nLCB0YWJsZSApO1xuXHRcdFx0Ly8gc29ydCB0aGUgdGFibGUgYW5kIGFwcGVuZCBpdCB0byB0aGUgZG9tXG5cdFx0XHR0cy5tdWx0aXNvcnQoIGMgKTtcblx0XHRcdHRzLmFwcGVuZENhY2hlKCBjLCBpbml0ICk7XG5cdFx0XHRjLiR0YWJsZS50cmlnZ2VySGFuZGxlciggJ3NvcnRCZWZvcmVFbmQnLCB0YWJsZSApO1xuXHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoICdzb3J0RW5kJywgdGFibGUgKTtcblx0XHRcdHRzLmFwcGx5V2lkZ2V0KCB0YWJsZSApO1xuXHRcdFx0aWYgKCAkLmlzRnVuY3Rpb24oIGNhbGxiYWNrICkgKSB7XG5cdFx0XHRcdGNhbGxiYWNrKCB0YWJsZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzb3J0UmVzZXQgOiBmdW5jdGlvbiggYywgY2FsbGJhY2sgKSB7XG5cdFx0XHRjLnNvcnRMaXN0ID0gW107XG5cdFx0XHR0cy5zZXRIZWFkZXJzQ3NzKCBjICk7XG5cdFx0XHR0cy5tdWx0aXNvcnQoIGMgKTtcblx0XHRcdHRzLmFwcGVuZENhY2hlKCBjICk7XG5cdFx0XHR2YXIgaW5keDtcblx0XHRcdGZvciAoaW5keCA9IDA7IGluZHggPCBjLmNvbHVtbnM7IGluZHgrKykge1xuXHRcdFx0XHRjLnNvcnRWYXJzWyBpbmR4IF0uY291bnQgPSAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggJC5pc0Z1bmN0aW9uKCBjYWxsYmFjayApICkge1xuXHRcdFx0XHRjYWxsYmFjayggYy50YWJsZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRTb3J0VHlwZSA6IGZ1bmN0aW9uKCBwYXJzZXJzLCBjb2x1bW4gKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZXJzICYmIHBhcnNlcnNbIGNvbHVtbiBdICkgPyBwYXJzZXJzWyBjb2x1bW4gXS50eXBlIHx8ICcnIDogJyc7XG5cdFx0fSxcblxuXHRcdGdldE9yZGVyIDogZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdC8vIGxvb2sgZm9yICdkJyBpbiAnZGVzYycgb3JkZXI7IHJldHVybiB0cnVlXG5cdFx0XHRyZXR1cm4gKCAvXmQvaS50ZXN0KCB2YWwgKSB8fCB2YWwgPT09IDEgKTtcblx0XHR9LFxuXG5cdFx0Ly8gTmF0dXJhbCBzb3J0IC0gaHR0cHM6Ly9naXRodWIuY29tL292ZXJzZXQvamF2YXNjcmlwdC1uYXR1cmFsLXNvcnQgKGRhdGUgc29ydGluZyByZW1vdmVkKVxuXHRcdHNvcnROYXR1cmFsIDogZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGEgPT09IGIgKSB7IHJldHVybiAwOyB9XG5cdFx0XHRhID0gYS50b1N0cmluZygpO1xuXHRcdFx0YiA9IGIudG9TdHJpbmcoKTtcblx0XHRcdHZhciBhTnVtLCBiTnVtLCBhRmxvYXQsIGJGbG9hdCwgaW5keCwgbWF4LFxuXHRcdFx0XHRyZWdleCA9IHRzLnJlZ2V4O1xuXHRcdFx0Ly8gZmlyc3QgdHJ5IGFuZCBzb3J0IEhleCBjb2Rlc1xuXHRcdFx0aWYgKCByZWdleC5oZXgudGVzdCggYiApICkge1xuXHRcdFx0XHRhTnVtID0gcGFyc2VJbnQoICggYSB8fCAnJyApLm1hdGNoKCByZWdleC5oZXggKSwgMTYgKTtcblx0XHRcdFx0Yk51bSA9IHBhcnNlSW50KCAoIGIgfHwgJycgKS5tYXRjaCggcmVnZXguaGV4ICksIDE2ICk7XG5cdFx0XHRcdGlmICggYU51bSA8IGJOdW0gKSB7IHJldHVybiAtMTsgfVxuXHRcdFx0XHRpZiAoIGFOdW0gPiBiTnVtICkgeyByZXR1cm4gMTsgfVxuXHRcdFx0fVxuXHRcdFx0Ly8gY2h1bmsvdG9rZW5pemVcblx0XHRcdGFOdW0gPSAoIGEgfHwgJycgKS5yZXBsYWNlKCByZWdleC5jaHVuaywgJ1xcXFwwJDFcXFxcMCcgKS5yZXBsYWNlKCByZWdleC5jaHVua3MsICcnICkuc3BsaXQoICdcXFxcMCcgKTtcblx0XHRcdGJOdW0gPSAoIGIgfHwgJycgKS5yZXBsYWNlKCByZWdleC5jaHVuaywgJ1xcXFwwJDFcXFxcMCcgKS5yZXBsYWNlKCByZWdleC5jaHVua3MsICcnICkuc3BsaXQoICdcXFxcMCcgKTtcblx0XHRcdG1heCA9IE1hdGgubWF4KCBhTnVtLmxlbmd0aCwgYk51bS5sZW5ndGggKTtcblx0XHRcdC8vIG5hdHVyYWwgc29ydGluZyB0aHJvdWdoIHNwbGl0IG51bWVyaWMgc3RyaW5ncyBhbmQgZGVmYXVsdCBzdHJpbmdzXG5cdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IG1heDsgaW5keCsrICkge1xuXHRcdFx0XHQvLyBmaW5kIGZsb2F0cyBub3Qgc3RhcnRpbmcgd2l0aCAnMCcsIHN0cmluZyBvciAwIGlmIG5vdCBkZWZpbmVkXG5cdFx0XHRcdGFGbG9hdCA9IGlzTmFOKCBhTnVtWyBpbmR4IF0gKSA/IGFOdW1bIGluZHggXSB8fCAwIDogcGFyc2VGbG9hdCggYU51bVsgaW5keCBdICkgfHwgMDtcblx0XHRcdFx0YkZsb2F0ID0gaXNOYU4oIGJOdW1bIGluZHggXSApID8gYk51bVsgaW5keCBdIHx8IDAgOiBwYXJzZUZsb2F0KCBiTnVtWyBpbmR4IF0gKSB8fCAwO1xuXHRcdFx0XHQvLyBoYW5kbGUgbnVtZXJpYyB2cyBzdHJpbmcgY29tcGFyaXNvbiAtIG51bWJlciA8IHN0cmluZyAtIChLeWxlIEFkYW1zKVxuXHRcdFx0XHRpZiAoIGlzTmFOKCBhRmxvYXQgKSAhPT0gaXNOYU4oIGJGbG9hdCApICkgeyByZXR1cm4gaXNOYU4oIGFGbG9hdCApID8gMSA6IC0xOyB9XG5cdFx0XHRcdC8vIHJlbHkgb24gc3RyaW5nIGNvbXBhcmlzb24gaWYgZGlmZmVyZW50IHR5cGVzIC0gaS5lLiAnMDInIDwgMiAhPSAnMDInIDwgJzInXG5cdFx0XHRcdGlmICggdHlwZW9mIGFGbG9hdCAhPT0gdHlwZW9mIGJGbG9hdCApIHtcblx0XHRcdFx0XHRhRmxvYXQgKz0gJyc7XG5cdFx0XHRcdFx0YkZsb2F0ICs9ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggYUZsb2F0IDwgYkZsb2F0ICkgeyByZXR1cm4gLTE7IH1cblx0XHRcdFx0aWYgKCBhRmxvYXQgPiBiRmxvYXQgKSB7IHJldHVybiAxOyB9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9LFxuXG5cdFx0c29ydE5hdHVyYWxBc2MgOiBmdW5jdGlvbiggYSwgYiwgY29sLCBjICkge1xuXHRcdFx0aWYgKCBhID09PSBiICkgeyByZXR1cm4gMDsgfVxuXHRcdFx0dmFyIGVtcHR5ID0gdHMuc3RyaW5nWyAoIGMuZW1wdGllc1sgY29sIF0gfHwgYy5lbXB0eVRvICkgXTtcblx0XHRcdGlmICggYSA9PT0gJycgJiYgZW1wdHkgIT09IDAgKSB7IHJldHVybiB0eXBlb2YgZW1wdHkgPT09ICdib29sZWFuJyA/ICggZW1wdHkgPyAtMSA6IDEgKSA6IC1lbXB0eSB8fCAtMTsgfVxuXHRcdFx0aWYgKCBiID09PSAnJyAmJiBlbXB0eSAhPT0gMCApIHsgcmV0dXJuIHR5cGVvZiBlbXB0eSA9PT0gJ2Jvb2xlYW4nID8gKCBlbXB0eSA/IDEgOiAtMSApIDogZW1wdHkgfHwgMTsgfVxuXHRcdFx0cmV0dXJuIHRzLnNvcnROYXR1cmFsKCBhLCBiICk7XG5cdFx0fSxcblxuXHRcdHNvcnROYXR1cmFsRGVzYyA6IGZ1bmN0aW9uKCBhLCBiLCBjb2wsIGMgKSB7XG5cdFx0XHRpZiAoIGEgPT09IGIgKSB7IHJldHVybiAwOyB9XG5cdFx0XHR2YXIgZW1wdHkgPSB0cy5zdHJpbmdbICggYy5lbXB0aWVzWyBjb2wgXSB8fCBjLmVtcHR5VG8gKSBdO1xuXHRcdFx0aWYgKCBhID09PSAnJyAmJiBlbXB0eSAhPT0gMCApIHsgcmV0dXJuIHR5cGVvZiBlbXB0eSA9PT0gJ2Jvb2xlYW4nID8gKCBlbXB0eSA/IC0xIDogMSApIDogZW1wdHkgfHwgMTsgfVxuXHRcdFx0aWYgKCBiID09PSAnJyAmJiBlbXB0eSAhPT0gMCApIHsgcmV0dXJuIHR5cGVvZiBlbXB0eSA9PT0gJ2Jvb2xlYW4nID8gKCBlbXB0eSA/IDEgOiAtMSApIDogLWVtcHR5IHx8IC0xOyB9XG5cdFx0XHRyZXR1cm4gdHMuc29ydE5hdHVyYWwoIGIsIGEgKTtcblx0XHR9LFxuXG5cdFx0Ly8gYmFzaWMgYWxwaGFiZXRpY2FsIHNvcnRcblx0XHRzb3J0VGV4dCA6IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0cmV0dXJuIGEgPiBiID8gMSA6ICggYSA8IGIgPyAtMSA6IDAgKTtcblx0XHR9LFxuXG5cdFx0Ly8gcmV0dXJuIHRleHQgc3RyaW5nIHZhbHVlIGJ5IGFkZGluZyB1cCBhc2NpaSB2YWx1ZVxuXHRcdC8vIHNvIHRoZSB0ZXh0IGlzIHNvbWV3aGF0IHNvcnRlZCB3aGVuIHVzaW5nIGEgZGlnaXRhbCBzb3J0XG5cdFx0Ly8gdGhpcyBpcyBOT1QgYW4gYWxwaGFudW1lcmljIHNvcnRcblx0XHRnZXRUZXh0VmFsdWUgOiBmdW5jdGlvbiggdmFsLCBudW0sIG1heCApIHtcblx0XHRcdGlmICggbWF4ICkge1xuXHRcdFx0XHQvLyBtYWtlIHN1cmUgdGhlIHRleHQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXggbnVtZXJpY2FsIHZhbHVlIChtYXgpXG5cdFx0XHRcdHZhciBpbmR4LFxuXHRcdFx0XHRcdGxlbiA9IHZhbCA/IHZhbC5sZW5ndGggOiAwLFxuXHRcdFx0XHRcdG4gPSBtYXggKyBudW07XG5cdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XG5cdFx0XHRcdFx0biArPSB2YWwuY2hhckNvZGVBdCggaW5keCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudW0gKiBuO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fSxcblxuXHRcdHNvcnROdW1lcmljQXNjIDogZnVuY3Rpb24oIGEsIGIsIG51bSwgbWF4LCBjb2wsIGMgKSB7XG5cdFx0XHRpZiAoIGEgPT09IGIgKSB7IHJldHVybiAwOyB9XG5cdFx0XHR2YXIgZW1wdHkgPSB0cy5zdHJpbmdbICggYy5lbXB0aWVzWyBjb2wgXSB8fCBjLmVtcHR5VG8gKSBdO1xuXHRcdFx0aWYgKCBhID09PSAnJyAmJiBlbXB0eSAhPT0gMCApIHsgcmV0dXJuIHR5cGVvZiBlbXB0eSA9PT0gJ2Jvb2xlYW4nID8gKCBlbXB0eSA/IC0xIDogMSApIDogLWVtcHR5IHx8IC0xOyB9XG5cdFx0XHRpZiAoIGIgPT09ICcnICYmIGVtcHR5ICE9PSAwICkgeyByZXR1cm4gdHlwZW9mIGVtcHR5ID09PSAnYm9vbGVhbicgPyAoIGVtcHR5ID8gMSA6IC0xICkgOiBlbXB0eSB8fCAxOyB9XG5cdFx0XHRpZiAoIGlzTmFOKCBhICkgKSB7IGEgPSB0cy5nZXRUZXh0VmFsdWUoIGEsIG51bSwgbWF4ICk7IH1cblx0XHRcdGlmICggaXNOYU4oIGIgKSApIHsgYiA9IHRzLmdldFRleHRWYWx1ZSggYiwgbnVtLCBtYXggKTsgfVxuXHRcdFx0cmV0dXJuIGEgLSBiO1xuXHRcdH0sXG5cblx0XHRzb3J0TnVtZXJpY0Rlc2MgOiBmdW5jdGlvbiggYSwgYiwgbnVtLCBtYXgsIGNvbCwgYyApIHtcblx0XHRcdGlmICggYSA9PT0gYiApIHsgcmV0dXJuIDA7IH1cblx0XHRcdHZhciBlbXB0eSA9IHRzLnN0cmluZ1sgKCBjLmVtcHRpZXNbIGNvbCBdIHx8IGMuZW1wdHlUbyApIF07XG5cdFx0XHRpZiAoIGEgPT09ICcnICYmIGVtcHR5ICE9PSAwICkgeyByZXR1cm4gdHlwZW9mIGVtcHR5ID09PSAnYm9vbGVhbicgPyAoIGVtcHR5ID8gLTEgOiAxICkgOiBlbXB0eSB8fCAxOyB9XG5cdFx0XHRpZiAoIGIgPT09ICcnICYmIGVtcHR5ICE9PSAwICkgeyByZXR1cm4gdHlwZW9mIGVtcHR5ID09PSAnYm9vbGVhbicgPyAoIGVtcHR5ID8gMSA6IC0xICkgOiAtZW1wdHkgfHwgLTE7IH1cblx0XHRcdGlmICggaXNOYU4oIGEgKSApIHsgYSA9IHRzLmdldFRleHRWYWx1ZSggYSwgbnVtLCBtYXggKTsgfVxuXHRcdFx0aWYgKCBpc05hTiggYiApICkgeyBiID0gdHMuZ2V0VGV4dFZhbHVlKCBiLCBudW0sIG1heCApOyB9XG5cdFx0XHRyZXR1cm4gYiAtIGE7XG5cdFx0fSxcblxuXHRcdHNvcnROdW1lcmljIDogZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRyZXR1cm4gYSAtIGI7XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx04paI4paIIOKWiOKWiCDilojilogg4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWhCDiloTilojilojilojilojiloQg4paI4paI4paI4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiCDiloTilojilojilojilojilohcblx0XHTilojilogg4paI4paIIOKWiOKWiCDilojilogg4paI4paIICDilojilogg4paI4paIIOKWhOKWhOKWhCDilojilojiloTiloQgICAgIOKWiOKWiCAgIOKWgOKWiOKWhFxuXHRcdOKWiOKWiCDilojilogg4paI4paIIOKWiOKWiCDilojiloggIOKWiOKWiCDilojilogg4paA4paI4paIIOKWiOKWiOKWgOKWgCAgICAg4paI4paIICAgICAg4paA4paI4paEXG5cdFx04paI4paI4paI4paI4paI4paI4paI4paAIOKWiOKWiCDilojilojilojilojilojiloAg4paA4paI4paI4paI4paI4paAIOKWiOKWiOKWiOKWiOKWiOKWiCAgIOKWiOKWiCAgIOKWiOKWiOKWiOKWiOKWiOKWgFxuXHRcdCovXG5cdFx0YWRkV2lkZ2V0IDogZnVuY3Rpb24oIHdpZGdldCApIHtcblx0XHRcdGlmICggd2lkZ2V0LmlkICYmICF0cy5pc0VtcHR5T2JqZWN0KCB0cy5nZXRXaWRnZXRCeUlkKCB3aWRnZXQuaWQgKSApICkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oICdcIicgKyB3aWRnZXQuaWQgKyAnXCIgd2lkZ2V0IHdhcyBsb2FkZWQgbW9yZSB0aGFuIG9uY2UhJyApO1xuXHRcdFx0fVxuXHRcdFx0dHMud2lkZ2V0c1sgdHMud2lkZ2V0cy5sZW5ndGggXSA9IHdpZGdldDtcblx0XHR9LFxuXG5cdFx0aGFzV2lkZ2V0IDogZnVuY3Rpb24oICR0YWJsZSwgbmFtZSApIHtcblx0XHRcdCR0YWJsZSA9ICQoICR0YWJsZSApO1xuXHRcdFx0cmV0dXJuICR0YWJsZS5sZW5ndGggJiYgJHRhYmxlWyAwIF0uY29uZmlnICYmICR0YWJsZVsgMCBdLmNvbmZpZy53aWRnZXRJbml0WyBuYW1lIF0gfHwgZmFsc2U7XG5cdFx0fSxcblxuXHRcdGdldFdpZGdldEJ5SWQgOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRcdHZhciBpbmR4LCB3aWRnZXQsXG5cdFx0XHRcdGxlbiA9IHRzLndpZGdldHMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKyApIHtcblx0XHRcdFx0d2lkZ2V0ID0gdHMud2lkZ2V0c1sgaW5keCBdO1xuXHRcdFx0XHRpZiAoIHdpZGdldCAmJiB3aWRnZXQuaWQgJiYgd2lkZ2V0LmlkLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gd2lkZ2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGFwcGx5V2lkZ2V0T3B0aW9ucyA6IGZ1bmN0aW9uKCB0YWJsZSApIHtcblx0XHRcdHZhciBpbmR4LCB3aWRnZXQsIHdvLFxuXHRcdFx0XHRjID0gdGFibGUuY29uZmlnLFxuXHRcdFx0XHRsZW4gPSBjLndpZGdldHMubGVuZ3RoO1xuXHRcdFx0aWYgKCBsZW4gKSB7XG5cdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XG5cdFx0XHRcdFx0d2lkZ2V0ID0gdHMuZ2V0V2lkZ2V0QnlJZCggYy53aWRnZXRzWyBpbmR4IF0gKTtcblx0XHRcdFx0XHRpZiAoIHdpZGdldCAmJiB3aWRnZXQub3B0aW9ucyApIHtcblx0XHRcdFx0XHRcdHdvID0gJC5leHRlbmQoIHRydWUsIHt9LCB3aWRnZXQub3B0aW9ucyApO1xuXHRcdFx0XHRcdFx0Yy53aWRnZXRPcHRpb25zID0gJC5leHRlbmQoIHRydWUsIHdvLCBjLndpZGdldE9wdGlvbnMgKTtcblx0XHRcdFx0XHRcdC8vIGFkZCB3aWRnZXRPcHRpb25zIHRvIGRlZmF1bHRzIGZvciBvcHRpb24gdmFsaWRhdG9yXG5cdFx0XHRcdFx0XHQkLmV4dGVuZCggdHJ1ZSwgdHMuZGVmYXVsdHMud2lkZ2V0T3B0aW9ucywgd2lkZ2V0Lm9wdGlvbnMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YWRkV2lkZ2V0RnJvbUNsYXNzIDogZnVuY3Rpb24oIHRhYmxlICkge1xuXHRcdFx0dmFyIGxlbiwgaW5keCxcblx0XHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdFx0Ly8gbG9vayBmb3Igd2lkZ2V0cyB0byBhcHBseSBmcm9tIHRhYmxlIGNsYXNzXG5cdFx0XHRcdC8vIGRvbid0IG1hdGNoIGZyb20gJ3VpLXdpZGdldC1jb250ZW50JzsgdXNlIFxcUyBpbnN0ZWFkIG9mIFxcdyB0byBpbmNsdWRlIHdpZGdldHNcblx0XHRcdFx0Ly8gd2l0aCBkYXNoZXMgaW4gdGhlIG5hbWUsIGUuZy4gXCJ3aWRnZXQtdGVzdC0yXCIgZXh0cmFjdHMgb3V0IFwidGVzdC0yXCJcblx0XHRcdFx0cmVnZXggPSAnXicgKyBjLndpZGdldENsYXNzLnJlcGxhY2UoIHRzLnJlZ2V4LnRlbXBsYXRlTmFtZSwgJyhcXFxcUyspKycgKSArICckJyxcblx0XHRcdFx0d2lkZ2V0Q2xhc3MgPSBuZXcgUmVnRXhwKCByZWdleCwgJ2cnICksXG5cdFx0XHRcdC8vIHNwbGl0IHVwIHRhYmxlIGNsYXNzICh3aWRnZXQgaWQncyBjYW4gaW5jbHVkZSBkYXNoZXMpIC0gc3RvcCB1c2luZyBtYXRjaFxuXHRcdFx0XHQvLyBvdGhlcndpc2Ugb25seSBvbmUgd2lkZ2V0IGdldHMgZXh0cmFjdGVkLCBzZWUgIzExMDlcblx0XHRcdFx0d2lkZ2V0cyA9ICggdGFibGUuY2xhc3NOYW1lIHx8ICcnICkuc3BsaXQoIHRzLnJlZ2V4LnNwYWNlcyApO1xuXHRcdFx0aWYgKCB3aWRnZXRzLmxlbmd0aCApIHtcblx0XHRcdFx0bGVuID0gd2lkZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XG5cdFx0XHRcdFx0aWYgKCB3aWRnZXRzWyBpbmR4IF0ubWF0Y2goIHdpZGdldENsYXNzICkgKSB7XG5cdFx0XHRcdFx0XHRjLndpZGdldHNbIGMud2lkZ2V0cy5sZW5ndGggXSA9IHdpZGdldHNbIGluZHggXS5yZXBsYWNlKCB3aWRnZXRDbGFzcywgJyQxJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRhcHBseVdpZGdldElkIDogZnVuY3Rpb24oIHRhYmxlLCBpZCwgaW5pdCApIHtcblx0XHRcdHRhYmxlID0gJCh0YWJsZSlbMF07XG5cdFx0XHR2YXIgYXBwbGllZCwgdGltZSwgbmFtZSxcblx0XHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdFx0d28gPSBjLndpZGdldE9wdGlvbnMsXG5cdFx0XHRcdGRlYnVnID0gdHMuZGVidWcoYywgJ2NvcmUnKSxcblx0XHRcdFx0d2lkZ2V0ID0gdHMuZ2V0V2lkZ2V0QnlJZCggaWQgKTtcblx0XHRcdGlmICggd2lkZ2V0ICkge1xuXHRcdFx0XHRuYW1lID0gd2lkZ2V0LmlkO1xuXHRcdFx0XHRhcHBsaWVkID0gZmFsc2U7XG5cdFx0XHRcdC8vIGFkZCB3aWRnZXQgbmFtZSB0byBvcHRpb24gbGlzdCBzbyBpdCBnZXRzIHJlYXBwbGllZCBhZnRlciBzb3J0aW5nLCBmaWx0ZXJpbmcsIGV0Y1xuXHRcdFx0XHRpZiAoICQuaW5BcnJheSggbmFtZSwgYy53aWRnZXRzICkgPCAwICkge1xuXHRcdFx0XHRcdGMud2lkZ2V0c1sgYy53aWRnZXRzLmxlbmd0aCBdID0gbmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGRlYnVnICkgeyB0aW1lID0gbmV3IERhdGUoKTsgfVxuXG5cdFx0XHRcdGlmICggaW5pdCB8fCAhKCBjLndpZGdldEluaXRbIG5hbWUgXSApICkge1xuXHRcdFx0XHRcdC8vIHNldCBpbml0IGZsYWcgZmlyc3QgdG8gcHJldmVudCBjYWxsaW5nIGluaXQgbW9yZSB0aGFuIG9uY2UgKGUuZy4gcGFnZXIpXG5cdFx0XHRcdFx0Yy53aWRnZXRJbml0WyBuYW1lIF0gPSB0cnVlO1xuXHRcdFx0XHRcdGlmICggdGFibGUuaGFzSW5pdGlhbGl6ZWQgKSB7XG5cdFx0XHRcdFx0XHQvLyBkb24ndCByZWFwcGx5IHdpZGdldCBvcHRpb25zIG9uIHRhYmxlc29ydGVyIGluaXRcblx0XHRcdFx0XHRcdHRzLmFwcGx5V2lkZ2V0T3B0aW9ucyggdGFibGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2Ygd2lkZ2V0LmluaXQgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0XHRhcHBsaWVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmICggZGVidWcgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGVbIGNvbnNvbGUuZ3JvdXAgPyAnZ3JvdXAnIDogJ2xvZycgXSggJ0luaXRpYWxpemluZyAnICsgbmFtZSArICcgd2lkZ2V0JyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0d2lkZ2V0LmluaXQoIHRhYmxlLCB3aWRnZXQsIGMsIHdvICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIWluaXQgJiYgdHlwZW9mIHdpZGdldC5mb3JtYXQgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0YXBwbGllZCA9IHRydWU7XG5cdFx0XHRcdFx0aWYgKCBkZWJ1ZyApIHtcblx0XHRcdFx0XHRcdGNvbnNvbGVbIGNvbnNvbGUuZ3JvdXAgPyAnZ3JvdXAnIDogJ2xvZycgXSggJ1VwZGF0aW5nICcgKyBuYW1lICsgJyB3aWRnZXQnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdpZGdldC5mb3JtYXQoIHRhYmxlLCBjLCB3bywgZmFsc2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGRlYnVnICkge1xuXHRcdFx0XHRcdGlmICggYXBwbGllZCApIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCAnQ29tcGxldGVkICcgKyAoIGluaXQgPyAnaW5pdGlhbGl6aW5nICcgOiAnYXBwbHlpbmcgJyApICsgbmFtZSArICcgd2lkZ2V0JyArIHRzLmJlbmNobWFyayggdGltZSApICk7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbnNvbGUuZ3JvdXBFbmQgKSB7IGNvbnNvbGUuZ3JvdXBFbmQoKTsgfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRhcHBseVdpZGdldCA6IGZ1bmN0aW9uKCB0YWJsZSwgaW5pdCwgY2FsbGJhY2sgKSB7XG5cdFx0XHR0YWJsZSA9ICQoIHRhYmxlIClbIDAgXTsgLy8gaW4gY2FzZSB0aGlzIGlzIGNhbGxlZCBleHRlcm5hbGx5XG5cdFx0XHR2YXIgaW5keCwgbGVuLCBuYW1lcywgd2lkZ2V0LCB0aW1lLFxuXHRcdFx0XHRjID0gdGFibGUuY29uZmlnLFxuXHRcdFx0XHRkZWJ1ZyA9IHRzLmRlYnVnKGMsICdjb3JlJyksXG5cdFx0XHRcdHdpZGdldHMgPSBbXTtcblx0XHRcdC8vIHByZXZlbnQgbnVtZXJvdXMgY29uc2VjdXRpdmUgd2lkZ2V0IGFwcGxpY2F0aW9uc1xuXHRcdFx0aWYgKCBpbml0ICE9PSBmYWxzZSAmJiB0YWJsZS5oYXNJbml0aWFsaXplZCAmJiAoIHRhYmxlLmlzQXBwbHlpbmdXaWRnZXRzIHx8IHRhYmxlLmlzVXBkYXRpbmcgKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBkZWJ1ZyApIHsgdGltZSA9IG5ldyBEYXRlKCk7IH1cblx0XHRcdHRzLmFkZFdpZGdldEZyb21DbGFzcyggdGFibGUgKTtcblx0XHRcdC8vIHByZXZlbnQgXCJ0YWJsZXNvcnRlci1yZWFkeVwiIGZyb20gZmlyaW5nIG11bHRpcGxlIHRpbWVzIGluIGEgcm93XG5cdFx0XHRjbGVhclRpbWVvdXQoIGMudGltZXJSZWFkeSApO1xuXHRcdFx0aWYgKCBjLndpZGdldHMubGVuZ3RoICkge1xuXHRcdFx0XHR0YWJsZS5pc0FwcGx5aW5nV2lkZ2V0cyA9IHRydWU7XG5cdFx0XHRcdC8vIGVuc3VyZSB1bmlxdWUgd2lkZ2V0IGlkc1xuXHRcdFx0XHRjLndpZGdldHMgPSAkLmdyZXAoIGMud2lkZ2V0cywgZnVuY3Rpb24oIHZhbCwgaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuaW5BcnJheSggdmFsLCBjLndpZGdldHMgKSA9PT0gaW5kZXg7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRuYW1lcyA9IGMud2lkZ2V0cyB8fCBbXTtcblx0XHRcdFx0bGVuID0gbmFtZXMubGVuZ3RoO1xuXHRcdFx0XHQvLyBidWlsZCB3aWRnZXQgYXJyYXkgJiBhZGQgcHJpb3JpdHkgYXMgbmVlZGVkXG5cdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XG5cdFx0XHRcdFx0d2lkZ2V0ID0gdHMuZ2V0V2lkZ2V0QnlJZCggbmFtZXNbIGluZHggXSApO1xuXHRcdFx0XHRcdGlmICggd2lkZ2V0ICYmIHdpZGdldC5pZCApIHtcblx0XHRcdFx0XHRcdC8vIHNldCBwcmlvcml0eSB0byAxMCBpZiBub3QgZGVmaW5lZFxuXHRcdFx0XHRcdFx0aWYgKCAhd2lkZ2V0LnByaW9yaXR5ICkgeyB3aWRnZXQucHJpb3JpdHkgPSAxMDsgfVxuXHRcdFx0XHRcdFx0d2lkZ2V0c1sgaW5keCBdID0gd2lkZ2V0O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGRlYnVnICkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnXCInICsgbmFtZXNbIGluZHggXSArICdcIiB3YXMgZW5hYmxlZCwgYnV0IHRoZSB3aWRnZXQgY29kZSBoYXMgbm90IGJlZW4gbG9hZGVkIScgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc29ydCB3aWRnZXRzIGJ5IHByaW9yaXR5XG5cdFx0XHRcdHdpZGdldHMuc29ydCggZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGEucHJpb3JpdHkgPCBiLnByaW9yaXR5ID8gLTEgOiBhLnByaW9yaXR5ID09PSBiLnByaW9yaXR5ID8gMCA6IDE7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQvLyBhZGQvdXBkYXRlIHNlbGVjdGVkIHdpZGdldHNcblx0XHRcdFx0bGVuID0gd2lkZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdGlmICggZGVidWcgKSB7XG5cdFx0XHRcdFx0Y29uc29sZVsgY29uc29sZS5ncm91cCA/ICdncm91cCcgOiAnbG9nJyBdKCAnU3RhcnQgJyArICggaW5pdCA/ICdpbml0aWFsaXppbmcnIDogJ2FwcGx5aW5nJyApICsgJyB3aWRnZXRzJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XG5cdFx0XHRcdFx0d2lkZ2V0ID0gd2lkZ2V0c1sgaW5keCBdO1xuXHRcdFx0XHRcdGlmICggd2lkZ2V0ICYmIHdpZGdldC5pZCApIHtcblx0XHRcdFx0XHRcdHRzLmFwcGx5V2lkZ2V0SWQoIHRhYmxlLCB3aWRnZXQuaWQsIGluaXQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBkZWJ1ZyAmJiBjb25zb2xlLmdyb3VwRW5kICkgeyBjb25zb2xlLmdyb3VwRW5kKCk7IH1cblx0XHRcdH1cblx0XHRcdGMudGltZXJSZWFkeSA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0YWJsZS5pc0FwcGx5aW5nV2lkZ2V0cyA9IGZhbHNlO1xuXHRcdFx0XHQkLmRhdGEoIHRhYmxlLCAnbGFzdFdpZGdldEFwcGxpY2F0aW9uJywgbmV3IERhdGUoKSApO1xuXHRcdFx0XHRjLiR0YWJsZS50cmlnZ2VySGFuZGxlciggJ3RhYmxlc29ydGVyLXJlYWR5JyApO1xuXHRcdFx0XHQvLyBjYWxsYmFjayBleGVjdXRlZCBvbiBpbml0IG9ubHlcblx0XHRcdFx0aWYgKCAhaW5pdCAmJiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soIHRhYmxlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBkZWJ1ZyApIHtcblx0XHRcdFx0XHR3aWRnZXQgPSBjLndpZGdldHMubGVuZ3RoO1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCAnQ29tcGxldGVkICcgK1xuXHRcdFx0XHRcdFx0KCBpbml0ID09PSB0cnVlID8gJ2luaXRpYWxpemluZyAnIDogJ2FwcGx5aW5nICcgKSArIHdpZGdldCArXG5cdFx0XHRcdFx0XHQnIHdpZGdldCcgKyAoIHdpZGdldCAhPT0gMSA/ICdzJyA6ICcnICkgKyB0cy5iZW5jaG1hcmsoIHRpbWUgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCAxMCApO1xuXHRcdH0sXG5cblx0XHRyZW1vdmVXaWRnZXQgOiBmdW5jdGlvbiggdGFibGUsIG5hbWUsIHJlZnJlc2hpbmcgKSB7XG5cdFx0XHR0YWJsZSA9ICQoIHRhYmxlIClbIDAgXTtcblx0XHRcdHZhciBpbmRleCwgd2lkZ2V0LCBpbmR4LCBsZW4sXG5cdFx0XHRcdGMgPSB0YWJsZS5jb25maWc7XG5cdFx0XHQvLyBpZiBuYW1lID09PSB0cnVlLCBhZGQgYWxsIHdpZGdldHMgZnJvbSAkLnRhYmxlc29ydGVyLndpZGdldHNcblx0XHRcdGlmICggbmFtZSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0bmFtZSA9IFtdO1xuXHRcdFx0XHRsZW4gPSB0cy53aWRnZXRzLmxlbmd0aDtcblx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKyApIHtcblx0XHRcdFx0XHR3aWRnZXQgPSB0cy53aWRnZXRzWyBpbmR4IF07XG5cdFx0XHRcdFx0aWYgKCB3aWRnZXQgJiYgd2lkZ2V0LmlkICkge1xuXHRcdFx0XHRcdFx0bmFtZVsgbmFtZS5sZW5ndGggXSA9IHdpZGdldC5pZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIG5hbWUgY2FuIGJlIGVpdGhlciBhbiBhcnJheSBvZiB3aWRnZXRzIG5hbWVzLFxuXHRcdFx0XHQvLyBvciBhIHNwYWNlL2NvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIHdpZGdldCBuYW1lc1xuXHRcdFx0XHRuYW1lID0gKCAkLmlzQXJyYXkoIG5hbWUgKSA/IG5hbWUuam9pbiggJywnICkgOiBuYW1lIHx8ICcnICkudG9Mb3dlckNhc2UoKS5zcGxpdCggL1tcXHMsXSsvICk7XG5cdFx0XHR9XG5cdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KysgKSB7XG5cdFx0XHRcdHdpZGdldCA9IHRzLmdldFdpZGdldEJ5SWQoIG5hbWVbIGluZGV4IF0gKTtcblx0XHRcdFx0aW5keCA9ICQuaW5BcnJheSggbmFtZVsgaW5kZXggXSwgYy53aWRnZXRzICk7XG5cdFx0XHRcdC8vIGRvbid0IHJlbW92ZSB0aGUgd2lkZ2V0IGZyb20gY29uZmlnLndpZGdldCBpZiByZWZyZXNoaW5nXG5cdFx0XHRcdGlmICggaW5keCA+PSAwICYmIHJlZnJlc2hpbmcgIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0Yy53aWRnZXRzLnNwbGljZSggaW5keCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggd2lkZ2V0ICYmIHdpZGdldC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0aWYgKCB0cy5kZWJ1ZyhjLCAnY29yZScpICkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coICggcmVmcmVzaGluZyA/ICdSZWZyZXNoaW5nJyA6ICdSZW1vdmluZycgKSArICcgXCInICsgbmFtZVsgaW5kZXggXSArICdcIiB3aWRnZXQnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdpZGdldC5yZW1vdmUoIHRhYmxlLCBjLCBjLndpZGdldE9wdGlvbnMsIHJlZnJlc2hpbmcgKTtcblx0XHRcdFx0XHRjLndpZGdldEluaXRbIG5hbWVbIGluZGV4IF0gXSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjLiR0YWJsZS50cmlnZ2VySGFuZGxlciggJ3dpZGdldFJlbW92ZUVuZCcsIHRhYmxlICk7XG5cdFx0fSxcblxuXHRcdHJlZnJlc2hXaWRnZXRzIDogZnVuY3Rpb24oIHRhYmxlLCBkb0FsbCwgZG9udGFwcGx5ICkge1xuXHRcdFx0dGFibGUgPSAkKCB0YWJsZSApWyAwIF07IC8vIHNlZSBpc3N1ZSAjMjQzXG5cdFx0XHR2YXIgaW5keCwgd2lkZ2V0LFxuXHRcdFx0XHRjID0gdGFibGUuY29uZmlnLFxuXHRcdFx0XHRjdXJXaWRnZXRzID0gYy53aWRnZXRzLFxuXHRcdFx0XHR3aWRnZXRzID0gdHMud2lkZ2V0cyxcblx0XHRcdFx0bGVuID0gd2lkZ2V0cy5sZW5ndGgsXG5cdFx0XHRcdGxpc3QgPSBbXSxcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdGFibGUgKSB7XG5cdFx0XHRcdFx0JCggdGFibGUgKS50cmlnZ2VySGFuZGxlciggJ3JlZnJlc2hDb21wbGV0ZScgKTtcblx0XHRcdFx0fTtcblx0XHRcdC8vIHJlbW92ZSB3aWRnZXRzIG5vdCBkZWZpbmVkIGluIGNvbmZpZy53aWRnZXRzLCB1bmxlc3MgZG9BbGwgaXMgdHJ1ZVxuXHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKyApIHtcblx0XHRcdFx0d2lkZ2V0ID0gd2lkZ2V0c1sgaW5keCBdO1xuXHRcdFx0XHRpZiAoIHdpZGdldCAmJiB3aWRnZXQuaWQgJiYgKCBkb0FsbCB8fCAkLmluQXJyYXkoIHdpZGdldC5pZCwgY3VyV2lkZ2V0cyApIDwgMCApICkge1xuXHRcdFx0XHRcdGxpc3RbIGxpc3QubGVuZ3RoIF0gPSB3aWRnZXQuaWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRzLnJlbW92ZVdpZGdldCggdGFibGUsIGxpc3Quam9pbiggJywnICksIHRydWUgKTtcblx0XHRcdGlmICggZG9udGFwcGx5ICE9PSB0cnVlICkge1xuXHRcdFx0XHQvLyBjYWxsIHdpZGdldCBpbml0IGlmXG5cdFx0XHRcdHRzLmFwcGx5V2lkZ2V0KCB0YWJsZSwgZG9BbGwgfHwgZmFsc2UsIGNhbGxiYWNrICk7XG5cdFx0XHRcdGlmICggZG9BbGwgKSB7XG5cdFx0XHRcdFx0Ly8gYXBwbHkgd2lkZ2V0IGZvcm1hdFxuXHRcdFx0XHRcdHRzLmFwcGx5V2lkZ2V0KCB0YWJsZSwgZmFsc2UsIGNhbGxiYWNrICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbGxiYWNrKCB0YWJsZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKlxuXHRcdOKWiOKWiCAg4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiCDilojilogg4paI4paIICAgICDilojilogg4paI4paI4paI4paI4paI4paIIOKWiOKWiCDilojilojilojilojilojilogg4paE4paI4paI4paI4paI4paIXG5cdFx04paI4paIICDilojiloggICDilojiloggICDilojilogg4paI4paIICAgICDilojiloggICDilojiloggICDilojilogg4paI4paI4paE4paEICAg4paA4paI4paEXG5cdFx04paI4paIICDilojiloggICDilojiloggICDilojilogg4paI4paIICAgICDilojiloggICDilojiloggICDilojilogg4paI4paI4paA4paAICAgICAg4paA4paI4paEXG5cdFx04paA4paI4paI4paI4paI4paAICAg4paI4paIICAg4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiCDilojiloggICDilojiloggICDilojilogg4paI4paI4paI4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWgFxuXHRcdCovXG5cdFx0YmVuY2htYXJrIDogZnVuY3Rpb24oIGRpZmYgKSB7XG5cdFx0XHRyZXR1cm4gKCAnICgnICsgKCBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGRpZmYuZ2V0VGltZSgpICkgKyAnIG1zKScgKTtcblx0XHR9LFxuXHRcdC8vIGRlcHJlY2F0ZWQgdHMubG9nXG5cdFx0bG9nIDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zb2xlLmxvZyggYXJndW1lbnRzICk7XG5cdFx0fSxcblx0XHRkZWJ1ZyA6IGZ1bmN0aW9uKGMsIG5hbWUpIHtcblx0XHRcdHJldHVybiBjICYmIChcblx0XHRcdFx0Yy5kZWJ1ZyA9PT0gdHJ1ZSB8fFxuXHRcdFx0XHR0eXBlb2YgYy5kZWJ1ZyA9PT0gJ3N0cmluZycgJiYgYy5kZWJ1Zy5pbmRleE9mKG5hbWUpID4gLTFcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdC8vICQuaXNFbXB0eU9iamVjdCBmcm9tIGpRdWVyeSB2MS40XG5cdFx0aXNFbXB0eU9iamVjdCA6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHQvKmpzaGludCBmb3JpbjogZmFsc2UgKi9cblx0XHRcdGZvciAoIHZhciBuYW1lIGluIG9iaiApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdGlzVmFsdWVJbkFycmF5IDogZnVuY3Rpb24oIGNvbHVtbiwgYXJyeSApIHtcblx0XHRcdHZhciBpbmR4LFxuXHRcdFx0XHRsZW4gPSBhcnJ5ICYmIGFycnkubGVuZ3RoIHx8IDA7XG5cdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGxlbjsgaW5keCsrICkge1xuXHRcdFx0XHRpZiAoIGFycnlbIGluZHggXVsgMCBdID09PSBjb2x1bW4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGluZHg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiAtMTtcblx0XHR9LFxuXG5cdFx0Zm9ybWF0RmxvYXQgOiBmdW5jdGlvbiggc3RyLCB0YWJsZSApIHtcblx0XHRcdGlmICggdHlwZW9mIHN0ciAhPT0gJ3N0cmluZycgfHwgc3RyID09PSAnJyApIHsgcmV0dXJuIHN0cjsgfVxuXHRcdFx0Ly8gYWxsb3cgdXNpbmcgZm9ybWF0RmxvYXQgd2l0aG91dCBhIHRhYmxlOyBkZWZhdWx0cyB0byBVUyBudW1iZXIgZm9ybWF0XG5cdFx0XHR2YXIgbnVtLFxuXHRcdFx0XHR1c0Zvcm1hdCA9IHRhYmxlICYmIHRhYmxlLmNvbmZpZyA/IHRhYmxlLmNvbmZpZy51c051bWJlckZvcm1hdCAhPT0gZmFsc2UgOlxuXHRcdFx0XHRcdHR5cGVvZiB0YWJsZSAhPT0gJ3VuZGVmaW5lZCcgPyB0YWJsZSA6IHRydWU7XG5cdFx0XHRpZiAoIHVzRm9ybWF0ICkge1xuXHRcdFx0XHQvLyBVUyBGb3JtYXQgLSAxLDIzNCw1NjcuODkgLT4gMTIzNDU2Ny44OVxuXHRcdFx0XHRzdHIgPSBzdHIucmVwbGFjZSggdHMucmVnZXguY29tbWEsICcnICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBHZXJtYW4gRm9ybWF0ID0gMS4yMzQuNTY3LDg5IC0+IDEyMzQ1NjcuODlcblx0XHRcdFx0Ly8gRnJlbmNoIEZvcm1hdCA9IDEgMjM0IDU2Nyw4OSAtPiAxMjM0NTY3Ljg5XG5cdFx0XHRcdHN0ciA9IHN0ci5yZXBsYWNlKCB0cy5yZWdleC5kaWdpdE5vblVTLCAnJyApLnJlcGxhY2UoIHRzLnJlZ2V4LmNvbW1hLCAnLicgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdHMucmVnZXguZGlnaXROZWdhdGl2ZVRlc3QudGVzdCggc3RyICkgKSB7XG5cdFx0XHRcdC8vIG1ha2UgKCMpIGludG8gYSBuZWdhdGl2ZSBudW1iZXIgLT4gKDEwKSA9IC0xMFxuXHRcdFx0XHRzdHIgPSBzdHIucmVwbGFjZSggdHMucmVnZXguZGlnaXROZWdhdGl2ZVJlcGxhY2UsICctJDEnICk7XG5cdFx0XHR9XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCBzdHIgKTtcblx0XHRcdC8vIHJldHVybiB0aGUgdGV4dCBpbnN0ZWFkIG9mIHplcm9cblx0XHRcdHJldHVybiBpc05hTiggbnVtICkgPyAkLnRyaW0oIHN0ciApIDogbnVtO1xuXHRcdH0sXG5cblx0XHRpc0RpZ2l0IDogZnVuY3Rpb24oIHN0ciApIHtcblx0XHRcdC8vIHJlcGxhY2UgYWxsIHVud2FudGVkIGNoYXJzIGFuZCBtYXRjaFxuXHRcdFx0cmV0dXJuIGlzTmFOKCBzdHIgKSA/XG5cdFx0XHRcdHRzLnJlZ2V4LmRpZ2l0VGVzdC50ZXN0KCBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKCB0cy5yZWdleC5kaWdpdFJlcGxhY2UsICcnICkgKSA6XG5cdFx0XHRcdHN0ciAhPT0gJyc7XG5cdFx0fSxcblxuXHRcdC8vIGNvbXB1dGVUYWJsZUhlYWRlckNlbGxJbmRleGVzIGZyb206XG5cdFx0Ly8gaHR0cDovL3d3dy5qYXZhc2NyaXB0dG9vbGJveC5jb20vbGliL3RhYmxlL2V4YW1wbGVzLnBocFxuXHRcdC8vIGh0dHA6Ly93d3cuamF2YXNjcmlwdHRvb2xib3guY29tL3RlbXAvdGFibGVfY2VsbGluZGV4Lmh0bWxcblx0XHRjb21wdXRlQ29sdW1uSW5kZXggOiBmdW5jdGlvbiggJHJvd3MsIGMgKSB7XG5cdFx0XHR2YXIgaSwgaiwgaywgbCwgY2VsbCwgY2VsbHMsIHJvd0luZGV4LCByb3dTcGFuLCBjb2xTcGFuLCBmaXJzdEF2YWlsQ29sLFxuXHRcdFx0XHQvLyB0b3RhbCBjb2x1bW5zIGhhcyBiZWVuIGNhbGN1bGF0ZWQsIHVzZSBpdCB0byBzZXQgdGhlIG1hdHJpeHJvd1xuXHRcdFx0XHRjb2x1bW5zID0gYyAmJiBjLmNvbHVtbnMgfHwgMCxcblx0XHRcdFx0bWF0cml4ID0gW10sXG5cdFx0XHRcdG1hdHJpeHJvdyA9IG5ldyBBcnJheSggY29sdW1ucyApO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCAkcm93cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0Y2VsbHMgPSAkcm93c1sgaSBdLmNlbGxzO1xuXHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IGNlbGxzLmxlbmd0aDsgaisrICkge1xuXHRcdFx0XHRcdGNlbGwgPSBjZWxsc1sgaiBdO1xuXHRcdFx0XHRcdHJvd0luZGV4ID0gaTtcblx0XHRcdFx0XHRyb3dTcGFuID0gY2VsbC5yb3dTcGFuIHx8IDE7XG5cdFx0XHRcdFx0Y29sU3BhbiA9IGNlbGwuY29sU3BhbiB8fCAxO1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIG1hdHJpeFsgcm93SW5kZXggXSA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdFx0XHRtYXRyaXhbIHJvd0luZGV4IF0gPSBbXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gRmluZCBmaXJzdCBhdmFpbGFibGUgY29sdW1uIGluIHRoZSBmaXJzdCByb3dcblx0XHRcdFx0XHRmb3IgKCBrID0gMDsgayA8IG1hdHJpeFsgcm93SW5kZXggXS5sZW5ndGggKyAxOyBrKysgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiBtYXRyaXhbIHJvd0luZGV4IF1bIGsgXSA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdFx0XHRcdGZpcnN0QXZhaWxDb2wgPSBrO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8ganNjczpkaXNhYmxlIGRpc2FsbG93RW1wdHlCbG9ja3Ncblx0XHRcdFx0XHRpZiAoIGNvbHVtbnMgJiYgY2VsbC5jZWxsSW5kZXggPT09IGZpcnN0QXZhaWxDb2wgKSB7XG5cdFx0XHRcdFx0XHQvLyBkb24ndCB0byBhbnl0aGluZ1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNlbGwuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdFx0Ly8ganNjczplbmFibGUgZGlzYWxsb3dFbXB0eUJsb2Nrc1xuXHRcdFx0XHRcdFx0Ly8gYWRkIGRhdGEtY29sdW1uIChzZXRBdHRyaWJ1dGUgPSBJRTgrKVxuXHRcdFx0XHRcdFx0Y2VsbC5zZXRBdHRyaWJ1dGUoICdkYXRhLWNvbHVtbicsIGZpcnN0QXZhaWxDb2wgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gcmVtb3ZlIG9uY2Ugd2UgZHJvcCBzdXBwb3J0IGZvciBJRTcgLSAxLzEyLzIwMTZcblx0XHRcdFx0XHRcdCQoIGNlbGwgKS5hdHRyKCAnZGF0YS1jb2x1bW4nLCBmaXJzdEF2YWlsQ29sICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZvciAoIGsgPSByb3dJbmRleDsgayA8IHJvd0luZGV4ICsgcm93U3BhbjsgaysrICkge1xuXHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgbWF0cml4WyBrIF0gPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdFx0XHRtYXRyaXhbIGsgXSA9IFtdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0cml4cm93ID0gbWF0cml4WyBrIF07XG5cdFx0XHRcdFx0XHRmb3IgKCBsID0gZmlyc3RBdmFpbENvbDsgbCA8IGZpcnN0QXZhaWxDb2wgKyBjb2xTcGFuOyBsKysgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdHJpeHJvd1sgbCBdID0gJ3gnO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dHMuY2hlY2tDb2x1bW5Db3VudCgkcm93cywgbWF0cml4LCBtYXRyaXhyb3cubGVuZ3RoKTtcblx0XHRcdHJldHVybiBtYXRyaXhyb3cubGVuZ3RoO1xuXHRcdH0sXG5cblx0XHRjaGVja0NvbHVtbkNvdW50IDogZnVuY3Rpb24oJHJvd3MsIG1hdHJpeCwgY29sdW1ucykge1xuXHRcdFx0Ly8gdGhpcyBET0VTIE5PVCByZXBvcnQgYW55IHRib2R5IGNvbHVtbiBpc3N1ZXMsIGV4Y2VwdCBmb3IgdGhlIG1hdGggYW5kXG5cdFx0XHQvLyBhbmQgY29sdW1uIHNlbGVjdG9yIHdpZGdldHNcblx0XHRcdHZhciBpLCBsZW4sXG5cdFx0XHRcdHZhbGlkID0gdHJ1ZSxcblx0XHRcdFx0Y2VsbHMgPSBbXTtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbWF0cml4Lmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHQvLyBzb21lIG1hdHJpeCBlbnRyaWVzIGFyZSB1bmRlZmluZWQgd2hlbiB0ZXN0aW5nIHRoZSBmb290ZXIgYmVjYXVzZVxuXHRcdFx0XHQvLyBpdCBpcyB1c2luZyB0aGUgcm93SW5kZXggcHJvcGVydHlcblx0XHRcdFx0aWYgKCBtYXRyaXhbaV0gKSB7XG5cdFx0XHRcdFx0bGVuID0gbWF0cml4W2ldLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAoIG1hdHJpeFtpXS5sZW5ndGggIT09IGNvbHVtbnMgKSB7XG5cdFx0XHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoICF2YWxpZCApIHtcblx0XHRcdFx0JHJvd3MuZWFjaCggZnVuY3Rpb24oIGluZHgsIGVsICkge1xuXHRcdFx0XHRcdHZhciBjZWxsID0gZWwucGFyZW50RWxlbWVudC5ub2RlTmFtZTtcblx0XHRcdFx0XHRpZiAoIGNlbGxzLmluZGV4T2YoIGNlbGwgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRjZWxscy5wdXNoKCBjZWxsICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0XHQnSW52YWxpZCBvciBpbmNvcnJlY3QgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlICcgK1xuXHRcdFx0XHRcdGNlbGxzLmpvaW4oICcgb3IgJyApICsgJzsgZXhwZWN0ZWQgJyArIGNvbHVtbnMgK1xuXHRcdFx0XHRcdCcsIGJ1dCBmb3VuZCAnICsgbGVuICsgJyBjb2x1bW5zJ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBhdXRvbWF0aWNhbGx5IGFkZCBhIGNvbGdyb3VwIHdpdGggY29sIGVsZW1lbnRzIHNldCB0byBhIHBlcmNlbnRhZ2Ugd2lkdGhcblx0XHRmaXhDb2x1bW5XaWR0aCA6IGZ1bmN0aW9uKCB0YWJsZSApIHtcblx0XHRcdHRhYmxlID0gJCggdGFibGUgKVsgMCBdO1xuXHRcdFx0dmFyIG92ZXJhbGxXaWR0aCwgcGVyY2VudCwgJHRib2RpZXMsIGxlbiwgaW5kZXgsXG5cdFx0XHRcdGMgPSB0YWJsZS5jb25maWcsXG5cdFx0XHRcdCRjb2xncm91cCA9IGMuJHRhYmxlLmNoaWxkcmVuKCAnY29sZ3JvdXAnICk7XG5cdFx0XHQvLyByZW1vdmUgcGx1Z2luLWFkZGVkIGNvbGdyb3VwLCBpbiBjYXNlIHdlIG5lZWQgdG8gcmVmcmVzaCB0aGUgd2lkdGhzXG5cdFx0XHRpZiAoICRjb2xncm91cC5sZW5ndGggJiYgJGNvbGdyb3VwLmhhc0NsYXNzKCB0cy5jc3MuY29sZ3JvdXAgKSApIHtcblx0XHRcdFx0JGNvbGdyb3VwLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBjLndpZHRoRml4ZWQgJiYgYy4kdGFibGUuY2hpbGRyZW4oICdjb2xncm91cCcgKS5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdCRjb2xncm91cCA9ICQoICc8Y29sZ3JvdXAgY2xhc3M9XCInICsgdHMuY3NzLmNvbGdyb3VwICsgJ1wiPicgKTtcblx0XHRcdFx0b3ZlcmFsbFdpZHRoID0gYy4kdGFibGUud2lkdGgoKTtcblx0XHRcdFx0Ly8gb25seSBhZGQgY29sIGZvciB2aXNpYmxlIGNvbHVtbnMgLSBmaXhlcyAjMzcxXG5cdFx0XHRcdCR0Ym9kaWVzID0gYy4kdGJvZGllcy5maW5kKCAndHI6Zmlyc3QnICkuY2hpbGRyZW4oICc6dmlzaWJsZScgKTtcblx0XHRcdFx0bGVuID0gJHRib2RpZXMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdHBlcmNlbnQgPSBwYXJzZUludCggKCAkdGJvZGllcy5lcSggaW5kZXggKS53aWR0aCgpIC8gb3ZlcmFsbFdpZHRoICkgKiAxMDAwLCAxMCApIC8gMTAgKyAnJSc7XG5cdFx0XHRcdFx0JGNvbGdyb3VwLmFwcGVuZCggJCggJzxjb2w+JyApLmNzcyggJ3dpZHRoJywgcGVyY2VudCApICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Yy4kdGFibGUucHJlcGVuZCggJGNvbGdyb3VwICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIGdldCBzb3J0ZXIsIHN0cmluZywgZW1wdHksIGV0YyBvcHRpb25zIGZvciBlYWNoIGNvbHVtbiBmcm9tXG5cdFx0Ly8galF1ZXJ5IGRhdGEsIG1ldGFkYXRhLCBoZWFkZXIgb3B0aW9uIG9yIGhlYWRlciBjbGFzcyBuYW1lICgnc29ydGVyLWZhbHNlJylcblx0XHQvLyBwcmlvcml0eSA9IGpRdWVyeSBkYXRhID4gbWV0YSA+IGhlYWRlcnMgb3B0aW9uID4gaGVhZGVyIGNsYXNzIG5hbWVcblx0XHRnZXREYXRhIDogZnVuY3Rpb24oIGhlYWRlciwgY29uZmlnSGVhZGVyLCBrZXkgKSB7XG5cdFx0XHR2YXIgbWV0YSwgY2w0c3MsXG5cdFx0XHRcdHZhbCA9ICcnLFxuXHRcdFx0XHQkaGVhZGVyID0gJCggaGVhZGVyICk7XG5cdFx0XHRpZiAoICEkaGVhZGVyLmxlbmd0aCApIHsgcmV0dXJuICcnOyB9XG5cdFx0XHRtZXRhID0gJC5tZXRhZGF0YSA/ICRoZWFkZXIubWV0YWRhdGEoKSA6IGZhbHNlO1xuXHRcdFx0Y2w0c3MgPSAnICcgKyAoICRoZWFkZXIuYXR0ciggJ2NsYXNzJyApIHx8ICcnICk7XG5cdFx0XHRpZiAoIHR5cGVvZiAkaGVhZGVyLmRhdGEoIGtleSApICE9PSAndW5kZWZpbmVkJyB8fFxuXHRcdFx0XHR0eXBlb2YgJGhlYWRlci5kYXRhKCBrZXkudG9Mb3dlckNhc2UoKSApICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0Ly8gJ2RhdGEtbG9ja2VkT3JkZXInIGlzIGFzc2lnbmVkIHRvICdsb2NrZWRvcmRlcic7IGJ1dCAnZGF0YS1sb2NrZWQtb3JkZXInIGlzIGFzc2lnbmVkIHRvICdsb2NrZWRPcmRlcidcblx0XHRcdFx0Ly8gJ2RhdGEtc29ydC1pbml0aWFsLW9yZGVyJyBpcyBhc3NpZ25lZCB0byAnc29ydEluaXRpYWxPcmRlcidcblx0XHRcdFx0dmFsICs9ICRoZWFkZXIuZGF0YSgga2V5ICkgfHwgJGhlYWRlci5kYXRhKCBrZXkudG9Mb3dlckNhc2UoKSApO1xuXHRcdFx0fSBlbHNlIGlmICggbWV0YSAmJiB0eXBlb2YgbWV0YVsga2V5IF0gIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHR2YWwgKz0gbWV0YVsga2V5IF07XG5cdFx0XHR9IGVsc2UgaWYgKCBjb25maWdIZWFkZXIgJiYgdHlwZW9mIGNvbmZpZ0hlYWRlclsga2V5IF0gIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHR2YWwgKz0gY29uZmlnSGVhZGVyWyBrZXkgXTtcblx0XHRcdH0gZWxzZSBpZiAoIGNsNHNzICE9PSAnICcgJiYgY2w0c3MubWF0Y2goICcgJyArIGtleSArICctJyApICkge1xuXHRcdFx0XHQvLyBpbmNsdWRlIHNvcnRlciBjbGFzcyBuYW1lICdzb3J0ZXItdGV4dCcsIGV0Yzsgbm93IHdvcmtzIHdpdGggJ3NvcnRlci1teS1jdXN0b20tcGFyc2VyJ1xuXHRcdFx0XHR2YWwgPSBjbDRzcy5tYXRjaCggbmV3IFJlZ0V4cCggJ1xcXFxzJyArIGtleSArICctKFtcXFxcdy1dKyknICkgKVsgMSBdIHx8ICcnO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICQudHJpbSggdmFsICk7XG5cdFx0fSxcblxuXHRcdGdldENvbHVtbkRhdGEgOiBmdW5jdGlvbiggdGFibGUsIG9iaiwgaW5keCwgZ2V0Q2VsbCwgJGhlYWRlcnMgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH1cblx0XHRcdHRhYmxlID0gJCggdGFibGUgKVsgMCBdO1xuXHRcdFx0dmFyICRoZWFkZXIsIGtleSxcblx0XHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdFx0JGNlbGxzID0gKCAkaGVhZGVycyB8fCBjLiRoZWFkZXJzICksXG5cdFx0XHRcdC8vIGMuJGhlYWRlckluZGV4ZWQgaXMgbm90IGRlZmluZWQgaW5pdGlhbGx5XG5cdFx0XHRcdCRjZWxsID0gYy4kaGVhZGVySW5kZXhlZCAmJiBjLiRoZWFkZXJJbmRleGVkWyBpbmR4IF0gfHxcblx0XHRcdFx0XHQkY2VsbHMuZmluZCggJ1tkYXRhLWNvbHVtbj1cIicgKyBpbmR4ICsgJ1wiXTpsYXN0JyApO1xuXHRcdFx0aWYgKCB0eXBlb2Ygb2JqWyBpbmR4IF0gIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRyZXR1cm4gZ2V0Q2VsbCA/IG9ialsgaW5keCBdIDogb2JqWyAkY2VsbHMuaW5kZXgoICRjZWxsICkgXTtcblx0XHRcdH1cblx0XHRcdGZvciAoIGtleSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0JGhlYWRlciA9ICRjZWxsXG5cdFx0XHRcdFx0XHQvLyBoZWFkZXIgY2VsbCB3aXRoIGNsYXNzL2lkXG5cdFx0XHRcdFx0XHQuZmlsdGVyKCBrZXkgKVxuXHRcdFx0XHRcdFx0Ly8gZmluZCBlbGVtZW50cyB3aXRoaW4gdGhlIGhlYWRlciBjZWxsIHdpdGggY2VsbC9pZFxuXHRcdFx0XHRcdFx0LmFkZCggJGNlbGwuZmluZCgga2V5ICkgKTtcblx0XHRcdFx0XHRpZiAoICRoZWFkZXIubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9ialsga2V5IF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fSxcblxuXHRcdC8vICoqKiBQcm9jZXNzIHRhYmxlICoqKlxuXHRcdC8vIGFkZCBwcm9jZXNzaW5nIGluZGljYXRvclxuXHRcdGlzUHJvY2Vzc2luZyA6IGZ1bmN0aW9uKCAkdGFibGUsIHRvZ2dsZSwgJGhlYWRlcnMgKSB7XG5cdFx0XHQkdGFibGUgPSAkKCAkdGFibGUgKTtcblx0XHRcdHZhciBjID0gJHRhYmxlWyAwIF0uY29uZmlnLFxuXHRcdFx0XHQvLyBkZWZhdWx0IHRvIGFsbCBoZWFkZXJzXG5cdFx0XHRcdCRoZWFkZXIgPSAkaGVhZGVycyB8fCAkdGFibGUuZmluZCggJy4nICsgdHMuY3NzLmhlYWRlciApO1xuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdC8vIGRvbid0IHVzZSBzb3J0TGlzdCBpZiBjdXN0b20gJGhlYWRlcnMgdXNlZFxuXHRcdFx0XHRpZiAoIHR5cGVvZiAkaGVhZGVycyAhPT0gJ3VuZGVmaW5lZCcgJiYgYy5zb3J0TGlzdC5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRcdC8vIGdldCBoZWFkZXJzIGZyb20gdGhlIHNvcnRMaXN0XG5cdFx0XHRcdFx0JGhlYWRlciA9ICRoZWFkZXIuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdC8vIGdldCBkYXRhLWNvbHVtbiBmcm9tIGF0dHIgdG8ga2VlcCBjb21wYXRpYmlsaXR5IHdpdGggalF1ZXJ5IDEuMi42XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zb3J0RGlzYWJsZWQgP1xuXHRcdFx0XHRcdFx0XHRmYWxzZSA6XG5cdFx0XHRcdFx0XHRcdHRzLmlzVmFsdWVJbkFycmF5KCBwYXJzZUZsb2F0KCAkKCB0aGlzICkuYXR0ciggJ2RhdGEtY29sdW1uJyApICksIGMuc29ydExpc3QgKSA+PSAwO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCR0YWJsZS5hZGQoICRoZWFkZXIgKS5hZGRDbGFzcyggdHMuY3NzLnByb2Nlc3NpbmcgKyAnICcgKyBjLmNzc1Byb2Nlc3NpbmcgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCR0YWJsZS5hZGQoICRoZWFkZXIgKS5yZW1vdmVDbGFzcyggdHMuY3NzLnByb2Nlc3NpbmcgKyAnICcgKyBjLmNzc1Byb2Nlc3NpbmcgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gZGV0YWNoIHRib2R5IGJ1dCBzYXZlIHRoZSBwb3NpdGlvblxuXHRcdC8vIGRvbid0IHVzZSB0Ym9keSBiZWNhdXNlIHRoZXJlIGFyZSBwb3J0aW9ucyB0aGF0IGxvb2sgZm9yIGEgdGJvZHkgaW5kZXggKHVwZGF0ZUNlbGwpXG5cdFx0cHJvY2Vzc1Rib2R5IDogZnVuY3Rpb24oIHRhYmxlLCAkdGIsIGdldEl0ICkge1xuXHRcdFx0dGFibGUgPSAkKCB0YWJsZSApWyAwIF07XG5cdFx0XHRpZiAoIGdldEl0ICkge1xuXHRcdFx0XHR0YWJsZS5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuXHRcdFx0XHQkdGIuYmVmb3JlKCAnPGNvbGdyb3VwIGNsYXNzPVwidGFibGVzb3J0ZXItc2F2ZW15cGxhY2VcIi8+JyApO1xuXHRcdFx0XHRyZXR1cm4gJC5mbi5kZXRhY2ggPyAkdGIuZGV0YWNoKCkgOiAkdGIucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgaG9sZHIgPSAkKCB0YWJsZSApLmZpbmQoICdjb2xncm91cC50YWJsZXNvcnRlci1zYXZlbXlwbGFjZScgKTtcblx0XHRcdCR0Yi5pbnNlcnRBZnRlciggaG9sZHIgKTtcblx0XHRcdGhvbGRyLnJlbW92ZSgpO1xuXHRcdFx0dGFibGUuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG5cdFx0fSxcblxuXHRcdGNsZWFyVGFibGVCb2R5IDogZnVuY3Rpb24oIHRhYmxlICkge1xuXHRcdFx0JCggdGFibGUgKVsgMCBdLmNvbmZpZy4kdGJvZGllcy5jaGlsZHJlbigpLmRldGFjaCgpO1xuXHRcdH0sXG5cblx0XHQvLyB1c2VkIHdoZW4gcmVwbGFjaW5nIGFjY2VudGVkIGNoYXJhY3RlcnMgZHVyaW5nIHNvcnRpbmdcblx0XHRjaGFyYWN0ZXJFcXVpdmFsZW50cyA6IHtcblx0XHRcdCdhJyA6ICdcXHUwMGUxXFx1MDBlMFxcdTAwZTJcXHUwMGUzXFx1MDBlNFxcdTAxMDVcXHUwMGU1JywgLy8gw6HDoMOiw6PDpMSFw6Vcblx0XHRcdCdBJyA6ICdcXHUwMGMxXFx1MDBjMFxcdTAwYzJcXHUwMGMzXFx1MDBjNFxcdTAxMDRcXHUwMGM1JywgLy8gw4HDgMOCw4PDhMSEw4Vcblx0XHRcdCdjJyA6ICdcXHUwMGU3XFx1MDEwN1xcdTAxMGQnLCAvLyDDp8SHxI1cblx0XHRcdCdDJyA6ICdcXHUwMGM3XFx1MDEwNlxcdTAxMGMnLCAvLyDDh8SGxIxcblx0XHRcdCdlJyA6ICdcXHUwMGU5XFx1MDBlOFxcdTAwZWFcXHUwMGViXFx1MDExYlxcdTAxMTknLCAvLyDDqcOow6rDq8SbxJlcblx0XHRcdCdFJyA6ICdcXHUwMGM5XFx1MDBjOFxcdTAwY2FcXHUwMGNiXFx1MDExYVxcdTAxMTgnLCAvLyDDicOIw4rDi8SaxJhcblx0XHRcdCdpJyA6ICdcXHUwMGVkXFx1MDBlY1xcdTAxMzBcXHUwMGVlXFx1MDBlZlxcdTAxMzEnLCAvLyDDrcOsxLDDrsOvxLFcblx0XHRcdCdJJyA6ICdcXHUwMGNkXFx1MDBjY1xcdTAxMzBcXHUwMGNlXFx1MDBjZicsIC8vIMONw4zEsMOOw49cblx0XHRcdCdvJyA6ICdcXHUwMGYzXFx1MDBmMlxcdTAwZjRcXHUwMGY1XFx1MDBmNlxcdTAxNGQnLCAvLyDDs8Oyw7TDtcO2xY1cblx0XHRcdCdPJyA6ICdcXHUwMGQzXFx1MDBkMlxcdTAwZDRcXHUwMGQ1XFx1MDBkNlxcdTAxNGMnLCAvLyDDk8OSw5TDlcOWxYxcblx0XHRcdCdzcyc6ICdcXHUwMGRmJywgLy8gw58gKHMgc2hhcnApXG5cdFx0XHQnU1MnOiAnXFx1MWU5ZScsIC8vIOG6niAoQ2FwaXRhbCBzaGFycCBzKVxuXHRcdFx0J3UnIDogJ1xcdTAwZmFcXHUwMGY5XFx1MDBmYlxcdTAwZmNcXHUwMTZmJywgLy8gw7rDucO7w7zFr1xuXHRcdFx0J1UnIDogJ1xcdTAwZGFcXHUwMGQ5XFx1MDBkYlxcdTAwZGNcXHUwMTZlJyAvLyDDmsOZw5vDnMWuXG5cdFx0fSxcblxuXHRcdHJlcGxhY2VBY2NlbnRzIDogZnVuY3Rpb24oIHN0ciApIHtcblx0XHRcdHZhciBjaHIsXG5cdFx0XHRcdGFjYyA9ICdbJyxcblx0XHRcdFx0ZXEgPSB0cy5jaGFyYWN0ZXJFcXVpdmFsZW50cztcblx0XHRcdGlmICggIXRzLmNoYXJhY3RlclJlZ2V4ICkge1xuXHRcdFx0XHR0cy5jaGFyYWN0ZXJSZWdleEFycmF5ID0ge307XG5cdFx0XHRcdGZvciAoIGNociBpbiBlcSApIHtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBjaHIgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0YWNjICs9IGVxWyBjaHIgXTtcblx0XHRcdFx0XHRcdHRzLmNoYXJhY3RlclJlZ2V4QXJyYXlbIGNociBdID0gbmV3IFJlZ0V4cCggJ1snICsgZXFbIGNociBdICsgJ10nLCAnZycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dHMuY2hhcmFjdGVyUmVnZXggPSBuZXcgUmVnRXhwKCBhY2MgKyAnXScgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdHMuY2hhcmFjdGVyUmVnZXgudGVzdCggc3RyICkgKSB7XG5cdFx0XHRcdGZvciAoIGNociBpbiBlcSApIHtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBjaHIgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0c3RyID0gc3RyLnJlcGxhY2UoIHRzLmNoYXJhY3RlclJlZ2V4QXJyYXlbIGNociBdLCBjaHIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBzdHI7XG5cdFx0fSxcblxuXHRcdHZhbGlkYXRlT3B0aW9ucyA6IGZ1bmN0aW9uKCBjICkge1xuXHRcdFx0dmFyIHNldHRpbmcsIHNldHRpbmcyLCB0eXAsIHRpbWVyLFxuXHRcdFx0XHQvLyBpZ25vcmUgb3B0aW9ucyBjb250YWluaW5nIGFuIGFycmF5XG5cdFx0XHRcdGlnbm9yZSA9ICdoZWFkZXJzIHNvcnRGb3JjZSBzb3J0TGlzdCBzb3J0QXBwZW5kIHdpZGdldHMnLnNwbGl0KCAnICcgKSxcblx0XHRcdFx0b3JpZyA9IGMub3JpZ2luYWxTZXR0aW5ncztcblx0XHRcdGlmICggb3JpZyApIHtcblx0XHRcdFx0aWYgKCB0cy5kZWJ1ZyhjLCAnY29yZScpICkge1xuXHRcdFx0XHRcdHRpbWVyID0gbmV3IERhdGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCBzZXR0aW5nIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0dHlwID0gdHlwZW9mIHRzLmRlZmF1bHRzW3NldHRpbmddO1xuXHRcdFx0XHRcdGlmICggdHlwID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RhYmxlc29ydGVyIFdhcm5pbmchIFwidGFibGUuY29uZmlnLicgKyBzZXR0aW5nICsgJ1wiIG9wdGlvbiBub3QgcmVjb2duaXplZCcgKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXAgPT09ICdvYmplY3QnICkge1xuXHRcdFx0XHRcdFx0Zm9yICggc2V0dGluZzIgaW4gb3JpZ1tzZXR0aW5nXSApIHtcblx0XHRcdFx0XHRcdFx0dHlwID0gdHMuZGVmYXVsdHNbc2V0dGluZ10gJiYgdHlwZW9mIHRzLmRlZmF1bHRzW3NldHRpbmddW3NldHRpbmcyXTtcblx0XHRcdFx0XHRcdFx0aWYgKCAkLmluQXJyYXkoIHNldHRpbmcsIGlnbm9yZSApIDwgMCAmJiB0eXAgPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RhYmxlc29ydGVyIFdhcm5pbmchIFwidGFibGUuY29uZmlnLicgKyBzZXR0aW5nICsgJy4nICsgc2V0dGluZzIgKyAnXCIgb3B0aW9uIG5vdCByZWNvZ25pemVkJyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdHMuZGVidWcoYywgJ2NvcmUnKSApIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyggJ3ZhbGlkYXRlIG9wdGlvbnMgdGltZTonICsgdHMuYmVuY2htYXJrKCB0aW1lciApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gcmVzdG9yZSBoZWFkZXJzXG5cdFx0cmVzdG9yZUhlYWRlcnMgOiBmdW5jdGlvbiggdGFibGUgKSB7XG5cdFx0XHR2YXIgaW5kZXgsICRjZWxsLFxuXHRcdFx0XHRjID0gJCggdGFibGUgKVsgMCBdLmNvbmZpZyxcblx0XHRcdFx0JGhlYWRlcnMgPSBjLiR0YWJsZS5maW5kKCBjLnNlbGVjdG9ySGVhZGVycyApLFxuXHRcdFx0XHRsZW4gPSAkaGVhZGVycy5sZW5ndGg7XG5cdFx0XHQvLyBkb24ndCB1c2UgYy4kaGVhZGVycyBoZXJlIGluIGNhc2UgaGVhZGVyIGNlbGxzIHdlcmUgc3dhcHBlZFxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbjsgaW5kZXgrKyApIHtcblx0XHRcdFx0JGNlbGwgPSAkaGVhZGVycy5lcSggaW5kZXggKTtcblx0XHRcdFx0Ly8gb25seSByZXN0b3JlIGhlYWRlciBjZWxscyBpZiBpdCBpcyB3cmFwcGVkXG5cdFx0XHRcdC8vIGJlY2F1c2UgdGhpcyBpcyBhbHNvIHVzZWQgYnkgdGhlIHVwZGF0ZUFsbCBtZXRob2Rcblx0XHRcdFx0aWYgKCAkY2VsbC5maW5kKCAnLicgKyB0cy5jc3MuaGVhZGVySW4gKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0JGNlbGwuaHRtbCggYy5oZWFkZXJDb250ZW50WyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0ZGVzdHJveSA6IGZ1bmN0aW9uKCB0YWJsZSwgcmVtb3ZlQ2xhc3NlcywgY2FsbGJhY2sgKSB7XG5cdFx0XHR0YWJsZSA9ICQoIHRhYmxlIClbIDAgXTtcblx0XHRcdGlmICggIXRhYmxlLmhhc0luaXRpYWxpemVkICkgeyByZXR1cm47IH1cblx0XHRcdC8vIHJlbW92ZSBhbGwgd2lkZ2V0c1xuXHRcdFx0dHMucmVtb3ZlV2lkZ2V0KCB0YWJsZSwgdHJ1ZSwgZmFsc2UgKTtcblx0XHRcdHZhciBldmVudHMsXG5cdFx0XHRcdCR0ID0gJCggdGFibGUgKSxcblx0XHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdFx0JGggPSAkdC5maW5kKCAndGhlYWQ6Zmlyc3QnICksXG5cdFx0XHRcdCRyID0gJGguZmluZCggJ3RyLicgKyB0cy5jc3MuaGVhZGVyUm93ICkucmVtb3ZlQ2xhc3MoIHRzLmNzcy5oZWFkZXJSb3cgKyAnICcgKyBjLmNzc0hlYWRlclJvdyApLFxuXHRcdFx0XHQkZiA9ICR0LmZpbmQoICd0Zm9vdDpmaXJzdCA+IHRyJyApLmNoaWxkcmVuKCAndGgsIHRkJyApO1xuXHRcdFx0aWYgKCByZW1vdmVDbGFzc2VzID09PSBmYWxzZSAmJiAkLmluQXJyYXkoICd1aXRoZW1lJywgYy53aWRnZXRzICkgPj0gMCApIHtcblx0XHRcdFx0Ly8gcmVhcHBseSB1aXRoZW1lIGNsYXNzZXMsIGluIGNhc2Ugd2Ugd2FudCB0byBtYWludGFpbiBhcHBlYXJhbmNlXG5cdFx0XHRcdCR0LnRyaWdnZXJIYW5kbGVyKCAnYXBwbHlXaWRnZXRJZCcsIFsgJ3VpdGhlbWUnIF0gKTtcblx0XHRcdFx0JHQudHJpZ2dlckhhbmRsZXIoICdhcHBseVdpZGdldElkJywgWyAnemVicmEnIF0gKTtcblx0XHRcdH1cblx0XHRcdC8vIHJlbW92ZSB3aWRnZXQgYWRkZWQgcm93cywganVzdCBpbiBjYXNlXG5cdFx0XHQkaC5maW5kKCAndHInICkubm90KCAkciApLnJlbW92ZSgpO1xuXHRcdFx0Ly8gZGlzYWJsZSB0YWJsZXNvcnRlciAtIG5vdCB1c2luZyAudW5iaW5kKCBuYW1lc3BhY2UgKSBiZWNhdXNlIG5hbWVzcGFjaW5nIHdhc1xuXHRcdFx0Ly8gYWRkZWQgaW4galF1ZXJ5IHYxLjQuMyAtIHNlZSBodHRwOi8vYXBpLmpxdWVyeS5jb20vZXZlbnQubmFtZXNwYWNlL1xuXHRcdFx0ZXZlbnRzID0gJ3NvcnRSZXNldCB1cGRhdGUgdXBkYXRlUm93cyB1cGRhdGVBbGwgdXBkYXRlSGVhZGVycyB1cGRhdGVDZWxsIGFkZFJvd3MgdXBkYXRlQ29tcGxldGUgc29ydG9uICcgK1xuXHRcdFx0XHQnYXBwZW5kQ2FjaGUgdXBkYXRlQ2FjaGUgYXBwbHlXaWRnZXRJZCBhcHBseVdpZGdldHMgcmVmcmVzaFdpZGdldHMgcmVtb3ZlV2lkZ2V0IGRlc3Ryb3kgbW91c2V1cCBtb3VzZWxlYXZlICcgK1xuXHRcdFx0XHQna2V5cHJlc3Mgc29ydEJlZ2luIHNvcnRFbmQgcmVzZXRUb0xvYWRTdGF0ZSAnLnNwbGl0KCAnICcgKVxuXHRcdFx0XHQuam9pbiggYy5uYW1lc3BhY2UgKyAnICcgKTtcblx0XHRcdCR0XG5cdFx0XHRcdC5yZW1vdmVEYXRhKCAndGFibGVzb3J0ZXInIClcblx0XHRcdFx0LnVuYmluZCggZXZlbnRzLnJlcGxhY2UoIHRzLnJlZ2V4LnNwYWNlcywgJyAnICkgKTtcblx0XHRcdGMuJGhlYWRlcnNcblx0XHRcdFx0LmFkZCggJGYgKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFsgdHMuY3NzLmhlYWRlciwgYy5jc3NIZWFkZXIsIGMuY3NzQXNjLCBjLmNzc0Rlc2MsIHRzLmNzcy5zb3J0QXNjLCB0cy5jc3Muc29ydERlc2MsIHRzLmNzcy5zb3J0Tm9uZSBdLmpvaW4oICcgJyApIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoICdkYXRhLWNvbHVtbicgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggJ2FyaWEtbGFiZWwnIClcblx0XHRcdFx0LmF0dHIoICdhcmlhLWRpc2FibGVkJywgJ3RydWUnICk7XG5cdFx0XHQkclxuXHRcdFx0XHQuZmluZCggYy5zZWxlY3RvclNvcnQgKVxuXHRcdFx0XHQudW5iaW5kKCAoICdtb3VzZWRvd24gbW91c2V1cCBrZXlwcmVzcyAnLnNwbGl0KCAnICcgKS5qb2luKCBjLm5hbWVzcGFjZSArICcgJyApICkucmVwbGFjZSggdHMucmVnZXguc3BhY2VzLCAnICcgKSApO1xuXHRcdFx0dHMucmVzdG9yZUhlYWRlcnMoIHRhYmxlICk7XG5cdFx0XHQkdC50b2dnbGVDbGFzcyggdHMuY3NzLnRhYmxlICsgJyAnICsgYy50YWJsZUNsYXNzICsgJyB0YWJsZXNvcnRlci0nICsgYy50aGVtZSwgcmVtb3ZlQ2xhc3NlcyA9PT0gZmFsc2UgKTtcblx0XHRcdCR0LnJlbW92ZUNsYXNzKGMubmFtZXNwYWNlLnNsaWNlKDEpKTtcblx0XHRcdC8vIGNsZWFyIGZsYWcgaW4gY2FzZSB0aGUgcGx1Z2luIGlzIGluaXRpYWxpemVkIGFnYWluXG5cdFx0XHR0YWJsZS5oYXNJbml0aWFsaXplZCA9IGZhbHNlO1xuXHRcdFx0ZGVsZXRlIHRhYmxlLmNvbmZpZy5jYWNoZTtcblx0XHRcdGlmICggdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRjYWxsYmFjayggdGFibGUgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdHMuZGVidWcoYywgJ2NvcmUnKSApIHtcblx0XHRcdFx0Y29uc29sZS5sb2coICd0YWJsZXNvcnRlciBoYXMgYmVlbiByZW1vdmVkJyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9O1xuXG5cdCQuZm4udGFibGVzb3J0ZXIgPSBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGFibGUgPSB0aGlzLFxuXHRcdFx0Ly8gbWVyZ2UgJiBleHRlbmQgY29uZmlnIG9wdGlvbnNcblx0XHRcdGMgPSAkLmV4dGVuZCggdHJ1ZSwge30sIHRzLmRlZmF1bHRzLCBzZXR0aW5ncywgdHMuaW5zdGFuY2VNZXRob2RzICk7XG5cdFx0XHQvLyBzYXZlIGluaXRpYWwgc2V0dGluZ3Ncblx0XHRcdGMub3JpZ2luYWxTZXR0aW5ncyA9IHNldHRpbmdzO1xuXHRcdFx0Ly8gY3JlYXRlIGEgdGFibGUgZnJvbSBkYXRhIChidWlsZCB0YWJsZSB3aWRnZXQpXG5cdFx0XHRpZiAoICF0YWJsZS5oYXNJbml0aWFsaXplZCAmJiB0cy5idWlsZFRhYmxlICYmIHRoaXMubm9kZU5hbWUgIT09ICdUQUJMRScgKSB7XG5cdFx0XHRcdC8vIHJldHVybiB0aGUgdGFibGUgKGluIGNhc2UgdGhlIG9yaWdpbmFsIHRhcmdldCBpcyB0aGUgdGFibGUncyBjb250YWluZXIpXG5cdFx0XHRcdHRzLmJ1aWxkVGFibGUoIHRhYmxlLCBjICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0cy5zZXR1cCggdGFibGUsIGMgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHQvLyBzZXQgdXAgZGVidWcgbG9nc1xuXHRpZiAoICEoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmxvZyApICkge1xuXHRcdC8vIGFjY2VzcyAkLnRhYmxlc29ydGVyLmxvZ3MgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3QgaGF2ZSBhIGNvbnNvbGUuLi5cblx0XHR0cy5sb2dzID0gW107XG5cdFx0Lypqc2hpbnQgLVcwMjAgKi9cblx0XHRjb25zb2xlID0ge307XG5cdFx0Y29uc29sZS5sb2cgPSBjb25zb2xlLndhcm4gPSBjb25zb2xlLmVycm9yID0gY29uc29sZS50YWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzIDogYXJndW1lbnRzWzBdO1xuXHRcdFx0dHMubG9nc1sgdHMubG9ncy5sZW5ndGggXSA9IHsgZGF0ZTogRGF0ZS5ub3coKSwgbG9nOiBhcmcgfTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gYWRkIGRlZmF1bHQgcGFyc2Vyc1xuXHR0cy5hZGRQYXJzZXIoe1xuXHRcdGlkIDogJ25vLXBhcnNlcicsXG5cdFx0aXMgOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGZvcm1hdCA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH0sXG5cdFx0dHlwZSA6ICd0ZXh0J1xuXHR9KTtcblxuXHR0cy5hZGRQYXJzZXIoe1xuXHRcdGlkIDogJ3RleHQnLFxuXHRcdGlzIDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdGZvcm1hdCA6IGZ1bmN0aW9uKCBzdHIsIHRhYmxlICkge1xuXHRcdFx0dmFyIGMgPSB0YWJsZS5jb25maWc7XG5cdFx0XHRpZiAoIHN0ciApIHtcblx0XHRcdFx0c3RyID0gJC50cmltKCBjLmlnbm9yZUNhc2UgPyBzdHIudG9Mb2NhbGVMb3dlckNhc2UoKSA6IHN0ciApO1xuXHRcdFx0XHRzdHIgPSBjLnNvcnRMb2NhbGVDb21wYXJlID8gdHMucmVwbGFjZUFjY2VudHMoIHN0ciApIDogc3RyO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9LFxuXHRcdHR5cGUgOiAndGV4dCdcblx0fSk7XG5cblx0dHMucmVnZXgubm9uZGlnaXQgPSAvW15cXHcsLiBcXC0oKV0vZztcblx0dHMuYWRkUGFyc2VyKHtcblx0XHRpZCA6ICdkaWdpdCcsXG5cdFx0aXMgOiBmdW5jdGlvbiggc3RyICkge1xuXHRcdFx0cmV0dXJuIHRzLmlzRGlnaXQoIHN0ciApO1xuXHRcdH0sXG5cdFx0Zm9ybWF0IDogZnVuY3Rpb24oIHN0ciwgdGFibGUgKSB7XG5cdFx0XHR2YXIgbnVtID0gdHMuZm9ybWF0RmxvYXQoICggc3RyIHx8ICcnICkucmVwbGFjZSggdHMucmVnZXgubm9uZGlnaXQsICcnICksIHRhYmxlICk7XG5cdFx0XHRyZXR1cm4gc3RyICYmIHR5cGVvZiBudW0gPT09ICdudW1iZXInID8gbnVtIDpcblx0XHRcdFx0c3RyID8gJC50cmltKCBzdHIgJiYgdGFibGUuY29uZmlnLmlnbm9yZUNhc2UgPyBzdHIudG9Mb2NhbGVMb3dlckNhc2UoKSA6IHN0ciApIDogc3RyO1xuXHRcdH0sXG5cdFx0dHlwZSA6ICdudW1lcmljJ1xuXHR9KTtcblxuXHR0cy5yZWdleC5jdXJyZW5jeVJlcGxhY2UgPSAvWytcXC0sLiBdL2c7XG5cdHRzLnJlZ2V4LmN1cnJlbmN5VGVzdCA9IC9eXFwoP1xcZCtbXFx1MDBhMyRcXHUyMGFjXFx1MDBhNFxcdTAwYTVcXHUwMGEyPy5dfFtcXHUwMGEzJFxcdTIwYWNcXHUwMGE0XFx1MDBhNVxcdTAwYTI/Ll1cXGQrXFwpPyQvO1xuXHR0cy5hZGRQYXJzZXIoe1xuXHRcdGlkIDogJ2N1cnJlbmN5Jyxcblx0XHRpcyA6IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0XHRzdHIgPSAoIHN0ciB8fCAnJyApLnJlcGxhY2UoIHRzLnJlZ2V4LmN1cnJlbmN5UmVwbGFjZSwgJycgKTtcblx0XHRcdC8vIHRlc3QgZm9yIMKjJOKCrMKkwqXColxuXHRcdFx0cmV0dXJuIHRzLnJlZ2V4LmN1cnJlbmN5VGVzdC50ZXN0KCBzdHIgKTtcblx0XHR9LFxuXHRcdGZvcm1hdCA6IGZ1bmN0aW9uKCBzdHIsIHRhYmxlICkge1xuXHRcdFx0dmFyIG51bSA9IHRzLmZvcm1hdEZsb2F0KCAoIHN0ciB8fCAnJyApLnJlcGxhY2UoIHRzLnJlZ2V4Lm5vbmRpZ2l0LCAnJyApLCB0YWJsZSApO1xuXHRcdFx0cmV0dXJuIHN0ciAmJiB0eXBlb2YgbnVtID09PSAnbnVtYmVyJyA/IG51bSA6XG5cdFx0XHRcdHN0ciA/ICQudHJpbSggc3RyICYmIHRhYmxlLmNvbmZpZy5pZ25vcmVDYXNlID8gc3RyLnRvTG9jYWxlTG93ZXJDYXNlKCkgOiBzdHIgKSA6IHN0cjtcblx0XHR9LFxuXHRcdHR5cGUgOiAnbnVtZXJpYydcblx0fSk7XG5cblx0Ly8gdG9vIG1hbnkgcHJvdG9jb2xzIHRvIGFkZCB0aGVtIGFsbCBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VUklfc2NoZW1lXG5cdC8vIG5vdywgdGhpcyByZWdleCBjYW4gYmUgdXBkYXRlZCBiZWZvcmUgaW5pdGlhbGl6YXRpb25cblx0dHMucmVnZXgudXJsUHJvdG9jb2xUZXN0ID0gL14oaHR0cHM/fGZ0cHxmaWxlKTpcXC9cXC8vO1xuXHR0cy5yZWdleC51cmxQcm90b2NvbFJlcGxhY2UgPSAvKGh0dHBzP3xmdHB8ZmlsZSk6XFwvXFwvKHd3d1xcLik/Lztcblx0dHMuYWRkUGFyc2VyKHtcblx0XHRpZCA6ICd1cmwnLFxuXHRcdGlzIDogZnVuY3Rpb24oIHN0ciApIHtcblx0XHRcdHJldHVybiB0cy5yZWdleC51cmxQcm90b2NvbFRlc3QudGVzdCggc3RyICk7XG5cdFx0fSxcblx0XHRmb3JtYXQgOiBmdW5jdGlvbiggc3RyICkge1xuXHRcdFx0cmV0dXJuIHN0ciA/ICQudHJpbSggc3RyLnJlcGxhY2UoIHRzLnJlZ2V4LnVybFByb3RvY29sUmVwbGFjZSwgJycgKSApIDogc3RyO1xuXHRcdH0sXG5cdFx0dHlwZSA6ICd0ZXh0J1xuXHR9KTtcblxuXHR0cy5yZWdleC5kYXNoID0gLy0vZztcblx0dHMucmVnZXguaXNvRGF0ZSA9IC9eXFxkezR9W1xcL1xcLV1cXGR7MSwyfVtcXC9cXC1dXFxkezEsMn0vO1xuXHR0cy5hZGRQYXJzZXIoe1xuXHRcdGlkIDogJ2lzb0RhdGUnLFxuXHRcdGlzIDogZnVuY3Rpb24oIHN0ciApIHtcblx0XHRcdHJldHVybiB0cy5yZWdleC5pc29EYXRlLnRlc3QoIHN0ciApO1xuXHRcdH0sXG5cdFx0Zm9ybWF0IDogZnVuY3Rpb24oIHN0ciApIHtcblx0XHRcdHZhciBkYXRlID0gc3RyID8gbmV3IERhdGUoIHN0ci5yZXBsYWNlKCB0cy5yZWdleC5kYXNoLCAnLycgKSApIDogc3RyO1xuXHRcdFx0cmV0dXJuIGRhdGUgaW5zdGFuY2VvZiBEYXRlICYmIGlzRmluaXRlKCBkYXRlICkgPyBkYXRlLmdldFRpbWUoKSA6IHN0cjtcblx0XHR9LFxuXHRcdHR5cGUgOiAnbnVtZXJpYydcblx0fSk7XG5cblx0dHMucmVnZXgucGVyY2VudCA9IC8lL2c7XG5cdHRzLnJlZ2V4LnBlcmNlbnRUZXN0ID0gLyhcXGRcXHMqPyV8JVxccyo/XFxkKS87XG5cdHRzLmFkZFBhcnNlcih7XG5cdFx0aWQgOiAncGVyY2VudCcsXG5cdFx0aXMgOiBmdW5jdGlvbiggc3RyICkge1xuXHRcdFx0cmV0dXJuIHRzLnJlZ2V4LnBlcmNlbnRUZXN0LnRlc3QoIHN0ciApICYmIHN0ci5sZW5ndGggPCAxNTtcblx0XHR9LFxuXHRcdGZvcm1hdCA6IGZ1bmN0aW9uKCBzdHIsIHRhYmxlICkge1xuXHRcdFx0cmV0dXJuIHN0ciA/IHRzLmZvcm1hdEZsb2F0KCBzdHIucmVwbGFjZSggdHMucmVnZXgucGVyY2VudCwgJycgKSwgdGFibGUgKSA6IHN0cjtcblx0XHR9LFxuXHRcdHR5cGUgOiAnbnVtZXJpYydcblx0fSk7XG5cblx0Ly8gYWRkZWQgaW1hZ2UgcGFyc2VyIHRvIGNvcmUgdjIuMTcuOVxuXHR0cy5hZGRQYXJzZXIoe1xuXHRcdGlkIDogJ2ltYWdlJyxcblx0XHRpcyA6IGZ1bmN0aW9uKCBzdHIsIHRhYmxlLCBub2RlLCAkbm9kZSApIHtcblx0XHRcdHJldHVybiAkbm9kZS5maW5kKCAnaW1nJyApLmxlbmd0aCA+IDA7XG5cdFx0fSxcblx0XHRmb3JtYXQgOiBmdW5jdGlvbiggc3RyLCB0YWJsZSwgY2VsbCApIHtcblx0XHRcdHJldHVybiAkKCBjZWxsICkuZmluZCggJ2ltZycgKS5hdHRyKCB0YWJsZS5jb25maWcuaW1nQXR0ciB8fCAnYWx0JyApIHx8IHN0cjtcblx0XHR9LFxuXHRcdHBhcnNlZCA6IHRydWUsIC8vIGZpbHRlciB3aWRnZXQgZmxhZ1xuXHRcdHR5cGUgOiAndGV4dCdcblx0fSk7XG5cblx0dHMucmVnZXguZGF0ZVJlcGxhY2UgPSAvKFxcUykoW0FQXU0pJC9pOyAvLyB1c2VkIGJ5IHVzTG9uZ0RhdGUgJiB0aW1lIHBhcnNlclxuXHR0cy5yZWdleC51c0xvbmdEYXRlVGVzdDEgPSAvXltBLVpdezMsMTB9XFwuP1xccytcXGR7MSwyfSw/XFxzKyhcXGR7NH0pKFxccytcXGR7MSwyfTpcXGR7Mn0oOlxcZHsyfSk/KFxccytbQVBdTSk/KT8kL2k7XG5cdHRzLnJlZ2V4LnVzTG9uZ0RhdGVUZXN0MiA9IC9eXFxkezEsMn1cXHMrW0EtWl17MywxMH1cXHMrXFxkezR9L2k7XG5cdHRzLmFkZFBhcnNlcih7XG5cdFx0aWQgOiAndXNMb25nRGF0ZScsXG5cdFx0aXMgOiBmdW5jdGlvbiggc3RyICkge1xuXHRcdFx0Ly8gdHdvIGRpZ2l0IHllYXJzIGFyZSBub3QgYWxsb3dlZCBjcm9zcy1icm93c2VyXG5cdFx0XHQvLyBKYW4gMDEsIDIwMTMgMTI6MzQ6NTYgUE0gb3IgMDEgSmFuIDIwMTNcblx0XHRcdHJldHVybiB0cy5yZWdleC51c0xvbmdEYXRlVGVzdDEudGVzdCggc3RyICkgfHwgdHMucmVnZXgudXNMb25nRGF0ZVRlc3QyLnRlc3QoIHN0ciApO1xuXHRcdH0sXG5cdFx0Zm9ybWF0IDogZnVuY3Rpb24oIHN0ciApIHtcblx0XHRcdHZhciBkYXRlID0gc3RyID8gbmV3IERhdGUoIHN0ci5yZXBsYWNlKCB0cy5yZWdleC5kYXRlUmVwbGFjZSwgJyQxICQyJyApICkgOiBzdHI7XG5cdFx0XHRyZXR1cm4gZGF0ZSBpbnN0YW5jZW9mIERhdGUgJiYgaXNGaW5pdGUoIGRhdGUgKSA/IGRhdGUuZ2V0VGltZSgpIDogc3RyO1xuXHRcdH0sXG5cdFx0dHlwZSA6ICdudW1lcmljJ1xuXHR9KTtcblxuXHQvLyB0ZXN0aW5nIGZvciAjIy0jIy0jIyMjIG9yICMjIyMtIyMtIyMsIHNvIGl0J3Mgbm90IHBlcmZlY3Q7IHRpbWUgY2FuIGJlIGluY2x1ZGVkXG5cdHRzLnJlZ2V4LnNob3J0RGF0ZVRlc3QgPSAvKF5cXGR7MSwyfVtcXC9cXHNdXFxkezEsMn1bXFwvXFxzXVxcZHs0fSl8KF5cXGR7NH1bXFwvXFxzXVxcZHsxLDJ9W1xcL1xcc11cXGR7MSwyfSkvO1xuXHQvLyBlc2NhcGVkIFwiLVwiIGJlY2F1c2UgSlNIaW50IGluIEZpcmVmb3ggd2FzIHNob3dpbmcgaXQgYXMgYW4gZXJyb3Jcblx0dHMucmVnZXguc2hvcnREYXRlUmVwbGFjZSA9IC9bXFwtLixdL2c7XG5cdC8vIFhYWSBjb3ZlcnMgTURZICYgRE1ZIGZvcm1hdHNcblx0dHMucmVnZXguc2hvcnREYXRlWFhZID0gLyhcXGR7MSwyfSlbXFwvXFxzXShcXGR7MSwyfSlbXFwvXFxzXShcXGR7NH0pLztcblx0dHMucmVnZXguc2hvcnREYXRlWU1EID0gLyhcXGR7NH0pW1xcL1xcc10oXFxkezEsMn0pW1xcL1xcc10oXFxkezEsMn0pLztcblx0dHMuY29udmVydEZvcm1hdCA9IGZ1bmN0aW9uKCBkYXRlU3RyaW5nLCBmb3JtYXQgKSB7XG5cdFx0ZGF0ZVN0cmluZyA9ICggZGF0ZVN0cmluZyB8fCAnJyApXG5cdFx0XHQucmVwbGFjZSggdHMucmVnZXguc3BhY2VzLCAnICcgKVxuXHRcdFx0LnJlcGxhY2UoIHRzLnJlZ2V4LnNob3J0RGF0ZVJlcGxhY2UsICcvJyApO1xuXHRcdGlmICggZm9ybWF0ID09PSAnbW1kZHl5eXknICkge1xuXHRcdFx0ZGF0ZVN0cmluZyA9IGRhdGVTdHJpbmcucmVwbGFjZSggdHMucmVnZXguc2hvcnREYXRlWFhZLCAnJDMvJDEvJDInICk7XG5cdFx0fSBlbHNlIGlmICggZm9ybWF0ID09PSAnZGRtbXl5eXknICkge1xuXHRcdFx0ZGF0ZVN0cmluZyA9IGRhdGVTdHJpbmcucmVwbGFjZSggdHMucmVnZXguc2hvcnREYXRlWFhZLCAnJDMvJDIvJDEnICk7XG5cdFx0fSBlbHNlIGlmICggZm9ybWF0ID09PSAneXl5eW1tZGQnICkge1xuXHRcdFx0ZGF0ZVN0cmluZyA9IGRhdGVTdHJpbmcucmVwbGFjZSggdHMucmVnZXguc2hvcnREYXRlWU1ELCAnJDEvJDIvJDMnICk7XG5cdFx0fVxuXHRcdHZhciBkYXRlID0gbmV3IERhdGUoIGRhdGVTdHJpbmcgKTtcblx0XHRyZXR1cm4gZGF0ZSBpbnN0YW5jZW9mIERhdGUgJiYgaXNGaW5pdGUoIGRhdGUgKSA/IGRhdGUuZ2V0VGltZSgpIDogJyc7XG5cdH07XG5cblx0dHMuYWRkUGFyc2VyKHtcblx0XHRpZCA6ICdzaG9ydERhdGUnLCAvLyAnbW1kZHl5eXknLCAnZGRtbXl5eXknIG9yICd5eXl5bW1kZCdcblx0XHRpcyA6IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0XHRzdHIgPSAoIHN0ciB8fCAnJyApLnJlcGxhY2UoIHRzLnJlZ2V4LnNwYWNlcywgJyAnICkucmVwbGFjZSggdHMucmVnZXguc2hvcnREYXRlUmVwbGFjZSwgJy8nICk7XG5cdFx0XHRyZXR1cm4gdHMucmVnZXguc2hvcnREYXRlVGVzdC50ZXN0KCBzdHIgKTtcblx0XHR9LFxuXHRcdGZvcm1hdCA6IGZ1bmN0aW9uKCBzdHIsIHRhYmxlLCBjZWxsLCBjZWxsSW5kZXggKSB7XG5cdFx0XHRpZiAoIHN0ciApIHtcblx0XHRcdFx0dmFyIGMgPSB0YWJsZS5jb25maWcsXG5cdFx0XHRcdFx0JGhlYWRlciA9IGMuJGhlYWRlckluZGV4ZWRbIGNlbGxJbmRleCBdLFxuXHRcdFx0XHRcdGZvcm1hdCA9ICRoZWFkZXIubGVuZ3RoICYmICRoZWFkZXIuZGF0YSggJ2RhdGVGb3JtYXQnICkgfHxcblx0XHRcdFx0XHRcdHRzLmdldERhdGEoICRoZWFkZXIsIHRzLmdldENvbHVtbkRhdGEoIHRhYmxlLCBjLmhlYWRlcnMsIGNlbGxJbmRleCApLCAnZGF0ZUZvcm1hdCcgKSB8fFxuXHRcdFx0XHRcdFx0Yy5kYXRlRm9ybWF0O1xuXHRcdFx0XHQvLyBzYXZlIGZvcm1hdCBiZWNhdXNlIGdldERhdGEgY2FuIGJlIHNsb3cuLi5cblx0XHRcdFx0aWYgKCAkaGVhZGVyLmxlbmd0aCApIHtcblx0XHRcdFx0XHQkaGVhZGVyLmRhdGEoICdkYXRlRm9ybWF0JywgZm9ybWF0ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRzLmNvbnZlcnRGb3JtYXQoIHN0ciwgZm9ybWF0ICkgfHwgc3RyO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9LFxuXHRcdHR5cGUgOiAnbnVtZXJpYydcblx0fSk7XG5cblx0Ly8gbWF0Y2ggMjQgaG91ciB0aW1lICYgMTIgaG91cnMgdGltZSArIGFtL3BtIC0gc2VlIGh0dHA6Ly9yZWdleHIuY29tLzNjM3RrXG5cdHRzLnJlZ2V4LnRpbWVUZXN0ID0gL14oMD9bMS05XXwxWzAtMl0pOihbMC01XVxcZCkoXFxzW0FQXU0pJHxeKCg/OlswMV1cXGR8WzJdWzAtNF0pOlswLTVdXFxkKSQvaTtcblx0dHMucmVnZXgudGltZU1hdGNoID0gLygwP1sxLTldfDFbMC0yXSk6KFswLTVdXFxkKShcXHNbQVBdTSl8KCg/OlswMV1cXGR8WzJdWzAtNF0pOlswLTVdXFxkKS9pO1xuXHR0cy5hZGRQYXJzZXIoe1xuXHRcdGlkIDogJ3RpbWUnLFxuXHRcdGlzIDogZnVuY3Rpb24oIHN0ciApIHtcblx0XHRcdHJldHVybiB0cy5yZWdleC50aW1lVGVzdC50ZXN0KCBzdHIgKTtcblx0XHR9LFxuXHRcdGZvcm1hdCA6IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0XHQvLyBpc29sYXRlIHRpbWUuLi4gaWdub3JlIG1vbnRoLCBkYXkgYW5kIHllYXJcblx0XHRcdHZhciB0ZW1wLFxuXHRcdFx0XHR0aW1lUGFydCA9ICggc3RyIHx8ICcnICkubWF0Y2goIHRzLnJlZ2V4LnRpbWVNYXRjaCApLFxuXHRcdFx0XHRvcmlnID0gbmV3IERhdGUoIHN0ciApLFxuXHRcdFx0XHQvLyBubyB0aW1lIGNvbXBvbmVudD8gZGVmYXVsdCB0byAwMDowMCBieSBsZWF2aW5nIGl0IG91dCwgYnV0IG9ubHkgaWYgc3RyIGlzIGRlZmluZWRcblx0XHRcdFx0dGltZSA9IHN0ciAmJiAoIHRpbWVQYXJ0ICE9PSBudWxsID8gdGltZVBhcnRbIDAgXSA6ICcwMDowMCBBTScgKSxcblx0XHRcdFx0ZGF0ZSA9IHRpbWUgPyBuZXcgRGF0ZSggJzIwMDAvMDEvMDEgJyArIHRpbWUucmVwbGFjZSggdHMucmVnZXguZGF0ZVJlcGxhY2UsICckMSAkMicgKSApIDogdGltZTtcblx0XHRcdGlmICggZGF0ZSBpbnN0YW5jZW9mIERhdGUgJiYgaXNGaW5pdGUoIGRhdGUgKSApIHtcblx0XHRcdFx0dGVtcCA9IG9yaWcgaW5zdGFuY2VvZiBEYXRlICYmIGlzRmluaXRlKCBvcmlnICkgPyBvcmlnLmdldFRpbWUoKSA6IDA7XG5cdFx0XHRcdC8vIGlmIG9yaWdpbmFsIHN0cmluZyB3YXMgYSB2YWxpZCBkYXRlLCBhZGQgaXQgdG8gdGhlIGRlY2ltYWwgc28gdGhlIGNvbHVtbiBzb3J0cyBpbiBzb21lIGtpbmQgb2Ygb3JkZXJcblx0XHRcdFx0Ly8gbHVja2lseSBuZXcgRGF0ZSgpIGlnbm9yZXMgdGhlIGRlY2ltYWxzXG5cdFx0XHRcdHJldHVybiB0ZW1wID8gcGFyc2VGbG9hdCggZGF0ZS5nZXRUaW1lKCkgKyAnLicgKyBvcmlnLmdldFRpbWUoKSApIDogZGF0ZS5nZXRUaW1lKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyO1xuXHRcdH0sXG5cdFx0dHlwZSA6ICdudW1lcmljJ1xuXHR9KTtcblxuXHR0cy5hZGRQYXJzZXIoe1xuXHRcdGlkIDogJ21ldGFkYXRhJyxcblx0XHRpcyA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0Zm9ybWF0IDogZnVuY3Rpb24oIHN0ciwgdGFibGUsIGNlbGwgKSB7XG5cdFx0XHR2YXIgYyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdHAgPSAoICFjLnBhcnNlck1ldGFkYXRhTmFtZSApID8gJ3NvcnRWYWx1ZScgOiBjLnBhcnNlck1ldGFkYXRhTmFtZTtcblx0XHRcdHJldHVybiAkKCBjZWxsICkubWV0YWRhdGEoKVsgcCBdO1xuXHRcdH0sXG5cdFx0dHlwZSA6ICdudW1lcmljJ1xuXHR9KTtcblxuXHQvKlxuXHRcdOKWiOKWiOKWiOKWiOKWiOKWiCDilojilojilojilojilojilogg4paI4paI4paI4paI4paI4paEIOKWiOKWiOKWiOKWiOKWiOKWhCDiloTilojilojilojilojiloRcblx0XHQgIOKWhOKWiOKWgCAg4paI4paI4paE4paEICAg4paI4paI4paE4paE4paI4paIIOKWiOKWiOKWhOKWhOKWiOKWiCDilojilojiloTiloTilojilohcblx0XHTiloTilojiloAgICAg4paI4paI4paA4paAICAg4paI4paI4paA4paA4paI4paIIOKWiOKWiOKWgOKWgOKWiCAg4paI4paI4paA4paA4paI4paIXG5cdFx04paI4paI4paI4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiCDilojilojilojilojilojiloAg4paI4paIICDilojilogg4paI4paIICDilojilohcblx0XHQqL1xuXHQvLyBhZGQgZGVmYXVsdCB3aWRnZXRzXG5cdHRzLmFkZFdpZGdldCh7XG5cdFx0aWQgOiAnemVicmEnLFxuXHRcdHByaW9yaXR5IDogOTAsXG5cdFx0Zm9ybWF0IDogZnVuY3Rpb24oIHRhYmxlLCBjLCB3byApIHtcblx0XHRcdHZhciAkdmlzaWJsZVJvd3MsICRyb3csIGNvdW50LCBpc0V2ZW4sIHRib2R5SW5kZXgsIHJvd0luZGV4LCBsZW4sXG5cdFx0XHRcdGNoaWxkID0gbmV3IFJlZ0V4cCggYy5jc3NDaGlsZFJvdywgJ2knICksXG5cdFx0XHRcdCR0Ym9kaWVzID0gYy4kdGJvZGllcy5hZGQoICQoIGMubmFtZXNwYWNlICsgJ19leHRyYV90YWJsZScgKS5jaGlsZHJlbiggJ3Rib2R5Om5vdCguJyArIGMuY3NzSW5mb0Jsb2NrICsgJyknICkgKTtcblx0XHRcdGZvciAoIHRib2R5SW5kZXggPSAwOyB0Ym9keUluZGV4IDwgJHRib2RpZXMubGVuZ3RoOyB0Ym9keUluZGV4KysgKSB7XG5cdFx0XHRcdC8vIGxvb3AgdGhyb3VnaCB0aGUgdmlzaWJsZSByb3dzXG5cdFx0XHRcdGNvdW50ID0gMDtcblx0XHRcdFx0JHZpc2libGVSb3dzID0gJHRib2RpZXMuZXEoIHRib2R5SW5kZXggKS5jaGlsZHJlbiggJ3RyOnZpc2libGUnICkubm90KCBjLnNlbGVjdG9yUmVtb3ZlICk7XG5cdFx0XHRcdGxlbiA9ICR2aXNpYmxlUm93cy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCBsZW47IHJvd0luZGV4KysgKSB7XG5cdFx0XHRcdFx0JHJvdyA9ICR2aXNpYmxlUm93cy5lcSggcm93SW5kZXggKTtcblx0XHRcdFx0XHQvLyBzdHlsZSBjaGlsZCByb3dzIHRoZSBzYW1lIHdheSB0aGUgcGFyZW50IHJvdyB3YXMgc3R5bGVkXG5cdFx0XHRcdFx0aWYgKCAhY2hpbGQudGVzdCggJHJvd1sgMCBdLmNsYXNzTmFtZSApICkgeyBjb3VudCsrOyB9XG5cdFx0XHRcdFx0aXNFdmVuID0gKCBjb3VudCAlIDIgPT09IDAgKTtcblx0XHRcdFx0XHQkcm93XG5cdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIHdvLnplYnJhWyBpc0V2ZW4gPyAxIDogMCBdIClcblx0XHRcdFx0XHRcdC5hZGRDbGFzcyggd28uemVicmFbIGlzRXZlbiA/IDAgOiAxIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cmVtb3ZlIDogZnVuY3Rpb24oIHRhYmxlLCBjLCB3bywgcmVmcmVzaGluZyApIHtcblx0XHRcdGlmICggcmVmcmVzaGluZyApIHsgcmV0dXJuOyB9XG5cdFx0XHR2YXIgdGJvZHlJbmRleCwgJHRib2R5LFxuXHRcdFx0XHQkdGJvZGllcyA9IGMuJHRib2RpZXMsXG5cdFx0XHRcdHRvUmVtb3ZlID0gKCB3by56ZWJyYSB8fCBbICdldmVuJywgJ29kZCcgXSApLmpvaW4oICcgJyApO1xuXHRcdFx0Zm9yICggdGJvZHlJbmRleCA9IDA7IHRib2R5SW5kZXggPCAkdGJvZGllcy5sZW5ndGg7IHRib2R5SW5kZXgrKyApIHtcblx0XHRcdFx0JHRib2R5ID0gdHMucHJvY2Vzc1Rib2R5KCB0YWJsZSwgJHRib2RpZXMuZXEoIHRib2R5SW5kZXggKSwgdHJ1ZSApOyAvLyByZW1vdmUgdGJvZHlcblx0XHRcdFx0JHRib2R5LmNoaWxkcmVuKCkucmVtb3ZlQ2xhc3MoIHRvUmVtb3ZlICk7XG5cdFx0XHRcdHRzLnByb2Nlc3NUYm9keSggdGFibGUsICR0Ym9keSwgZmFsc2UgKTsgLy8gcmVzdG9yZSB0Ym9keVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cbn0pKCBqUXVlcnkgKTtcblxuLyohIFdpZGdldDogc3RvcmFnZSAtIHVwZGF0ZWQgMjAxOC0wMy0xOCAodjIuMzAuMCkgKi9cbi8qZ2xvYmFsIEpTT046ZmFsc2UgKi9cbjsoZnVuY3Rpb24gKCQsIHdpbmRvdywgZG9jdW1lbnQpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciB0cyA9ICQudGFibGVzb3J0ZXIgfHwge307XG5cblx0Ly8gdXBkYXRlIGRlZmF1bHRzIGZvciB2YWxpZGF0b3I7IHRoZXNlIHZhbHVlcyBtdXN0IGJlIGZhbHN5IVxuXHQkLmV4dGVuZCh0cnVlLCB0cy5kZWZhdWx0cywge1xuXHRcdGZpeGVkVXJsOiAnJyxcblx0XHR3aWRnZXRPcHRpb25zOiB7XG5cdFx0XHRzdG9yYWdlX2ZpeGVkVXJsOiAnJyxcblx0XHRcdHN0b3JhZ2VfZ3JvdXA6ICcnLFxuXHRcdFx0c3RvcmFnZV9wYWdlOiAnJyxcblx0XHRcdHN0b3JhZ2Vfc3RvcmFnZVR5cGU6ICcnLFxuXHRcdFx0c3RvcmFnZV90YWJsZUlkOiAnJyxcblx0XHRcdHN0b3JhZ2VfdXNlU2Vzc2lvblN0b3JhZ2U6ICcnXG5cdFx0fVxuXHR9KTtcblxuXHQvLyAqKiogU3RvcmUgZGF0YSBpbiBsb2NhbCBzdG9yYWdlLCB3aXRoIGEgY29va2llIGZhbGxiYWNrICoqKlxuXHQvKiBJRTcgbmVlZHMgSlNPTiBsaWJyYXJ5IGZvciBKU09OLnN0cmluZ2lmeSAtIChodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1qc29uKVxuXHQgICBpZiB5b3UgbmVlZCBpdCwgdGhlbiBpbmNsdWRlIGh0dHBzOi8vZ2l0aHViLmNvbS9kb3VnbGFzY3JvY2tmb3JkL0pTT04tanNcblxuXHQgICAkLnBhcnNlSlNPTiBpcyBub3QgYXZhaWxhYmxlIGlzIGpRdWVyeSB2ZXJzaW9ucyBvbGRlciB0aGFuIDEuNC4xLCB1c2luZyBvbGRlclxuXHQgICB2ZXJzaW9ucyB3aWxsIG9ubHkgYWxsb3cgc3RvcmluZyBpbmZvcm1hdGlvbiBmb3Igb25lIHBhZ2UgYXQgYSB0aW1lXG5cblx0ICAgLy8gKioqIFNhdmUgZGF0YSAoSlNPTiBmb3JtYXQgb25seSkgKioqXG5cdCAgIC8vIHZhbCBtdXN0IGJlIHZhbGlkIEpTT04uLi4gdXNlIGh0dHA6Ly9qc29ubGludC5jb20vIHRvIGVuc3VyZSBpdCBpcyB2YWxpZFxuXHQgICB2YXIgdmFsID0geyBcIm15d2lkZ2V0XCIgOiBcImRhdGExXCIgfTsgLy8gdmFsaWQgSlNPTiB1c2VzIGRvdWJsZSBxdW90ZXNcblx0ICAgLy8gJC50YWJsZXNvcnRlci5zdG9yYWdlKHRhYmxlLCBrZXksIHZhbCk7XG5cdCAgICQudGFibGVzb3J0ZXIuc3RvcmFnZSh0YWJsZSwgJ3RhYmxlc29ydGVyLW15d2lkZ2V0JywgdmFsKTtcblxuXHQgICAvLyAqKiogR2V0IGRhdGE6ICQudGFibGVzb3J0ZXIuc3RvcmFnZSh0YWJsZSwga2V5KTsgKioqXG5cdCAgIHYgPSAkLnRhYmxlc29ydGVyLnN0b3JhZ2UodGFibGUsICd0YWJsZXNvcnRlci1teXdpZGdldCcpO1xuXHQgICAvLyB2YWwgbWF5IGJlIGVtcHR5LCBzbyBhbHNvIGNoZWNrIGZvciB5b3VyIGRhdGFcblx0ICAgdmFsID0gKHYgJiYgdi5oYXNPd25Qcm9wZXJ0eSgnbXl3aWRnZXQnKSkgPyB2Lm15d2lkZ2V0IDogJyc7XG5cdCAgIGFsZXJ0KHZhbCk7IC8vICdkYXRhMScgaWYgc2F2ZWQsIG9yICcnIGlmIG5vdFxuXHQqL1xuXHR0cy5zdG9yYWdlID0gZnVuY3Rpb24odGFibGUsIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcblx0XHR0YWJsZSA9ICQodGFibGUpWzBdO1xuXHRcdHZhciBjb29raWVJbmRleCwgY29va2llcywgZGF0ZSxcblx0XHRcdGhhc1N0b3JhZ2UgPSBmYWxzZSxcblx0XHRcdHZhbHVlcyA9IHt9LFxuXHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdHdvID0gYyAmJiBjLndpZGdldE9wdGlvbnMsXG5cdFx0XHRkZWJ1ZyA9IHRzLmRlYnVnKGMsICdzdG9yYWdlJyksXG5cdFx0XHRzdG9yYWdlVHlwZSA9IChcblx0XHRcdFx0KCBvcHRpb25zICYmIG9wdGlvbnMuc3RvcmFnZVR5cGUgKSB8fCAoIHdvICYmIHdvLnN0b3JhZ2Vfc3RvcmFnZVR5cGUgKVxuXHRcdFx0KS50b1N0cmluZygpLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0Ly8gZGVwcmVjYXRpbmcgXCJ1c2VTZXNzaW9uU3RvcmFnZVwiOyBhbnkgc3RvcmFnZVR5cGUgc2V0dGluZyBvdmVycmlkZXMgaXRcblx0XHRcdHNlc3Npb24gPSBzdG9yYWdlVHlwZSA/ICcnIDpcblx0XHRcdFx0KCBvcHRpb25zICYmIG9wdGlvbnMudXNlU2Vzc2lvblN0b3JhZ2UgKSB8fCAoIHdvICYmIHdvLnN0b3JhZ2VfdXNlU2Vzc2lvblN0b3JhZ2UgKSxcblx0XHRcdCR0YWJsZSA9ICQodGFibGUpLFxuXHRcdFx0Ly8gaWQgZnJvbSAoMSkgb3B0aW9ucyBJRCwgKDIpIHRhYmxlICdkYXRhLXRhYmxlLWdyb3VwJyBhdHRyaWJ1dGUsICgzKSB3aWRnZXRPcHRpb25zLnN0b3JhZ2VfdGFibGVJZCxcblx0XHRcdC8vICg0KSB0YWJsZSBJRCwgdGhlbiAoNSkgdGFibGUgaW5kZXhcblx0XHRcdGlkID0gb3B0aW9ucyAmJiBvcHRpb25zLmlkIHx8XG5cdFx0XHRcdCR0YWJsZS5hdHRyKCBvcHRpb25zICYmIG9wdGlvbnMuZ3JvdXAgfHwgd28gJiYgd28uc3RvcmFnZV9ncm91cCB8fCAnZGF0YS10YWJsZS1ncm91cCcpIHx8XG5cdFx0XHRcdHdvICYmIHdvLnN0b3JhZ2VfdGFibGVJZCB8fCB0YWJsZS5pZCB8fCAkKCcudGFibGVzb3J0ZXInKS5pbmRleCggJHRhYmxlICksXG5cdFx0XHQvLyB1cmwgZnJvbSAoMSkgb3B0aW9ucyB1cmwsICgyKSB0YWJsZSAnZGF0YS10YWJsZS1wYWdlJyBhdHRyaWJ1dGUsICgzKSB3aWRnZXRPcHRpb25zLnN0b3JhZ2VfZml4ZWRVcmwsXG5cdFx0XHQvLyAoNCkgdGFibGUuY29uZmlnLmZpeGVkVXJsIChkZXByZWNhdGVkKSwgdGhlbiAoNSkgd2luZG93IGxvY2F0aW9uIHBhdGhcblx0XHRcdHVybCA9IG9wdGlvbnMgJiYgb3B0aW9ucy51cmwgfHxcblx0XHRcdFx0JHRhYmxlLmF0dHIob3B0aW9ucyAmJiBvcHRpb25zLnBhZ2UgfHwgd28gJiYgd28uc3RvcmFnZV9wYWdlIHx8ICdkYXRhLXRhYmxlLXBhZ2UnKSB8fFxuXHRcdFx0XHR3byAmJiB3by5zdG9yYWdlX2ZpeGVkVXJsIHx8IGMgJiYgYy5maXhlZFVybCB8fCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG5cblx0XHQvLyBza2lwIGlmIHVzaW5nIGNvb2tpZXNcblx0XHRpZiAoc3RvcmFnZVR5cGUgIT09ICdjJykge1xuXHRcdFx0c3RvcmFnZVR5cGUgPSAoc3RvcmFnZVR5cGUgPT09ICdzJyB8fCBzZXNzaW9uKSA/ICdzZXNzaW9uU3RvcmFnZScgOiAnbG9jYWxTdG9yYWdlJztcblx0XHRcdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81NTU4NTU3XG5cdFx0XHRpZiAoc3RvcmFnZVR5cGUgaW4gd2luZG93KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0d2luZG93W3N0b3JhZ2VUeXBlXS5zZXRJdGVtKCdfdG1wdGVzdCcsICd0ZW1wJyk7XG5cdFx0XHRcdFx0aGFzU3RvcmFnZSA9IHRydWU7XG5cdFx0XHRcdFx0d2luZG93W3N0b3JhZ2VUeXBlXS5yZW1vdmVJdGVtKCdfdG1wdGVzdCcpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdGNvbnNvbGUud2Fybiggc3RvcmFnZVR5cGUgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChkZWJ1Zykge1xuXHRcdFx0Y29uc29sZS5sb2coJ1N0b3JhZ2UgPj4gVXNpbmcnLCBoYXNTdG9yYWdlID8gc3RvcmFnZVR5cGUgOiAnY29va2llcycpO1xuXHRcdH1cblx0XHQvLyAqKiogZ2V0IHZhbHVlICoqKlxuXHRcdGlmICgkLnBhcnNlSlNPTikge1xuXHRcdFx0aWYgKGhhc1N0b3JhZ2UpIHtcblx0XHRcdFx0dmFsdWVzID0gJC5wYXJzZUpTT04oIHdpbmRvd1tzdG9yYWdlVHlwZV1ba2V5XSB8fCAnbnVsbCcgKSB8fCB7fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIG9sZCBicm93c2VyLCB1c2luZyBjb29raWVzXG5cdFx0XHRcdGNvb2tpZXMgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoL1s7XFxzfD1dLyk7XG5cdFx0XHRcdC8vIGFkZCBvbmUgdG8gZ2V0IGZyb20gdGhlIGtleSB0byB0aGUgdmFsdWVcblx0XHRcdFx0Y29va2llSW5kZXggPSAkLmluQXJyYXkoa2V5LCBjb29raWVzKSArIDE7XG5cdFx0XHRcdHZhbHVlcyA9IChjb29raWVJbmRleCAhPT0gMCkgPyAkLnBhcnNlSlNPTihjb29raWVzW2Nvb2tpZUluZGV4XSB8fCAnbnVsbCcpIHx8IHt9IDoge307XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIGFsbG93IHZhbHVlIHRvIGJlIGFuIGVtcHR5IHN0cmluZyB0b29cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuSlNPTiAmJiBKU09OLmhhc093blByb3BlcnR5KCdzdHJpbmdpZnknKSkge1xuXHRcdFx0Ly8gYWRkIHVuaXF1ZSBpZGVudGlmaWVycyA9IHVybCBwYXRobmFtZSA+IHRhYmxlIElEL2luZGV4IG9uIHBhZ2UgPiBkYXRhXG5cdFx0XHRpZiAoIXZhbHVlc1t1cmxdKSB7XG5cdFx0XHRcdHZhbHVlc1t1cmxdID0ge307XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZXNbdXJsXVtpZF0gPSB2YWx1ZTtcblx0XHRcdC8vICoqKiBzZXQgdmFsdWUgKioqXG5cdFx0XHRpZiAoaGFzU3RvcmFnZSkge1xuXHRcdFx0XHR3aW5kb3dbc3RvcmFnZVR5cGVdW2tleV0gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHRcdGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArICgzMTUzNmUrNikpOyAvLyAzNjUgZGF5c1xuXHRcdFx0XHRkb2N1bWVudC5jb29raWUgPSBrZXkgKyAnPScgKyAoSlNPTi5zdHJpbmdpZnkodmFsdWVzKSkucmVwbGFjZSgvXFxcIi9nLCAnXFxcIicpICsgJzsgZXhwaXJlcz0nICsgZGF0ZS50b0dNVFN0cmluZygpICsgJzsgcGF0aD0vJztcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHZhbHVlcyAmJiB2YWx1ZXNbdXJsXSA/IHZhbHVlc1t1cmxdW2lkXSA6ICcnO1xuXHRcdH1cblx0fTtcblxufSkoalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcblxuLyohIFdpZGdldDogdWl0aGVtZSAtIHVwZGF0ZWQgMjAxOC0wMy0xOCAodjIuMzAuMCkgKi9cbjsoZnVuY3Rpb24gKCQpIHtcblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgdHMgPSAkLnRhYmxlc29ydGVyIHx8IHt9O1xuXG5cdHRzLnRoZW1lcyA9IHtcblx0XHQnYm9vdHN0cmFwJyA6IHtcblx0XHRcdHRhYmxlICAgICAgICA6ICd0YWJsZSB0YWJsZS1ib3JkZXJlZCB0YWJsZS1zdHJpcGVkJyxcblx0XHRcdGNhcHRpb24gICAgICA6ICdjYXB0aW9uJyxcblx0XHRcdC8vIGhlYWRlciBjbGFzcyBuYW1lc1xuXHRcdFx0aGVhZGVyICAgICAgIDogJ2Jvb3RzdHJhcC1oZWFkZXInLCAvLyBnaXZlIHRoZSBoZWFkZXIgYSBncmFkaWVudCBiYWNrZ3JvdW5kICh0aGVtZS5ib290c3RyYXBfMi5jc3MpXG5cdFx0XHRzb3J0Tm9uZSAgICAgOiAnJyxcblx0XHRcdHNvcnRBc2MgICAgICA6ICcnLFxuXHRcdFx0c29ydERlc2MgICAgIDogJycsXG5cdFx0XHRhY3RpdmUgICAgICAgOiAnJywgLy8gYXBwbGllZCB3aGVuIGNvbHVtbiBpcyBzb3J0ZWRcblx0XHRcdGhvdmVyICAgICAgICA6ICcnLCAvLyBjdXN0b20gY3NzIHJlcXVpcmVkIC0gYSBkZWZpbmVkIGJvb3RzdHJhcCBzdHlsZSBtYXkgbm90IG92ZXJyaWRlIG90aGVyIGNsYXNzZXNcblx0XHRcdC8vIGljb24gY2xhc3MgbmFtZXNcblx0XHRcdGljb25zICAgICAgICA6ICcnLCAvLyBhZGQgJ2Jvb3RzdHJhcC1pY29uLXdoaXRlJyB0byBtYWtlIHRoZW0gd2hpdGU7IHRoaXMgaWNvbiBjbGFzcyBpcyBhZGRlZCB0byB0aGUgPGk+IGluIHRoZSBoZWFkZXJcblx0XHRcdGljb25Tb3J0Tm9uZSA6ICdib290c3RyYXAtaWNvbi11bnNvcnRlZCcsIC8vIGNsYXNzIG5hbWUgYWRkZWQgdG8gaWNvbiB3aGVuIGNvbHVtbiBpcyBub3Qgc29ydGVkXG5cdFx0XHRpY29uU29ydEFzYyAgOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXVwJywgLy8gY2xhc3MgbmFtZSBhZGRlZCB0byBpY29uIHdoZW4gY29sdW1uIGhhcyBhc2NlbmRpbmcgc29ydFxuXHRcdFx0aWNvblNvcnREZXNjIDogJ2dseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1kb3duJywgLy8gY2xhc3MgbmFtZSBhZGRlZCB0byBpY29uIHdoZW4gY29sdW1uIGhhcyBkZXNjZW5kaW5nIHNvcnRcblx0XHRcdGZpbHRlclJvdyAgICA6ICcnLCAvLyBmaWx0ZXIgcm93IGNsYXNzXG5cdFx0XHRmb290ZXJSb3cgICAgOiAnJyxcblx0XHRcdGZvb3RlckNlbGxzICA6ICcnLFxuXHRcdFx0ZXZlbiAgICAgICAgIDogJycsIC8vIGV2ZW4gcm93IHplYnJhIHN0cmlwaW5nXG5cdFx0XHRvZGQgICAgICAgICAgOiAnJyAgLy8gb2RkIHJvdyB6ZWJyYSBzdHJpcGluZ1xuXHRcdH0sXG5cdFx0J2p1aScgOiB7XG5cdFx0XHR0YWJsZSAgICAgICAgOiAndWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwnLCAvLyB0YWJsZSBjbGFzc2VzXG5cdFx0XHRjYXB0aW9uICAgICAgOiAndWktd2lkZ2V0LWNvbnRlbnQnLFxuXHRcdFx0Ly8gaGVhZGVyIGNsYXNzIG5hbWVzXG5cdFx0XHRoZWFkZXIgICAgICAgOiAndWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItYWxsIHVpLXN0YXRlLWRlZmF1bHQnLCAvLyBoZWFkZXIgY2xhc3Nlc1xuXHRcdFx0c29ydE5vbmUgICAgIDogJycsXG5cdFx0XHRzb3J0QXNjICAgICAgOiAnJyxcblx0XHRcdHNvcnREZXNjICAgICA6ICcnLFxuXHRcdFx0YWN0aXZlICAgICAgIDogJ3VpLXN0YXRlLWFjdGl2ZScsIC8vIGFwcGxpZWQgd2hlbiBjb2x1bW4gaXMgc29ydGVkXG5cdFx0XHRob3ZlciAgICAgICAgOiAndWktc3RhdGUtaG92ZXInLCAgLy8gaG92ZXIgY2xhc3Ncblx0XHRcdC8vIGljb24gY2xhc3MgbmFtZXNcblx0XHRcdGljb25zICAgICAgICA6ICd1aS1pY29uJywgLy8gaWNvbiBjbGFzcyBhZGRlZCB0byB0aGUgPGk+IGluIHRoZSBoZWFkZXJcblx0XHRcdGljb25Tb3J0Tm9uZSA6ICd1aS1pY29uLWNhcmF0LTItbi1zIHVpLWljb24tY2FyZXQtMi1uLXMnLCAvLyBjbGFzcyBuYW1lIGFkZGVkIHRvIGljb24gd2hlbiBjb2x1bW4gaXMgbm90IHNvcnRlZFxuXHRcdFx0aWNvblNvcnRBc2MgIDogJ3VpLWljb24tY2FyYXQtMS1uIHVpLWljb24tY2FyZXQtMS1uJywgLy8gY2xhc3MgbmFtZSBhZGRlZCB0byBpY29uIHdoZW4gY29sdW1uIGhhcyBhc2NlbmRpbmcgc29ydFxuXHRcdFx0aWNvblNvcnREZXNjIDogJ3VpLWljb24tY2FyYXQtMS1zIHVpLWljb24tY2FyZXQtMS1zJywgLy8gY2xhc3MgbmFtZSBhZGRlZCB0byBpY29uIHdoZW4gY29sdW1uIGhhcyBkZXNjZW5kaW5nIHNvcnRcblx0XHRcdGZpbHRlclJvdyAgICA6ICcnLFxuXHRcdFx0Zm9vdGVyUm93ICAgIDogJycsXG5cdFx0XHRmb290ZXJDZWxscyAgOiAnJyxcblx0XHRcdGV2ZW4gICAgICAgICA6ICd1aS13aWRnZXQtY29udGVudCcsIC8vIGV2ZW4gcm93IHplYnJhIHN0cmlwaW5nXG5cdFx0XHRvZGQgICAgICAgICAgOiAndWktc3RhdGUtZGVmYXVsdCcgICAvLyBvZGQgcm93IHplYnJhIHN0cmlwaW5nXG5cdFx0fVxuXHR9O1xuXG5cdCQuZXh0ZW5kKHRzLmNzcywge1xuXHRcdHdyYXBwZXIgOiAndGFibGVzb3J0ZXItd3JhcHBlcicgLy8gdWkgdGhlbWUgJiByZXNpemFibGVcblx0fSk7XG5cblx0dHMuYWRkV2lkZ2V0KHtcblx0XHRpZDogJ3VpdGhlbWUnLFxuXHRcdHByaW9yaXR5OiAxMCxcblx0XHRmb3JtYXQ6IGZ1bmN0aW9uKHRhYmxlLCBjLCB3bykge1xuXHRcdFx0dmFyIGksIHRtcCwgaGRyLCBpY29uLCB0aW1lLCAkaGVhZGVyLCAkaWNvbiwgJHRmb290LCAkaCwgb2xkdGhlbWUsIG9sZHJlbW92ZSwgb2xkSWNvblJtdiwgaGFzT2xkVGhlbWUsXG5cdFx0XHRcdHRoZW1lc0FsbCA9IHRzLnRoZW1lcyxcblx0XHRcdFx0JHRhYmxlID0gYy4kdGFibGUuYWRkKCAkKCBjLm5hbWVzcGFjZSArICdfZXh0cmFfdGFibGUnICkgKSxcblx0XHRcdFx0JGhlYWRlcnMgPSBjLiRoZWFkZXJzLmFkZCggJCggYy5uYW1lc3BhY2UgKyAnX2V4dHJhX2hlYWRlcnMnICkgKSxcblx0XHRcdFx0dGhlbWUgPSBjLnRoZW1lIHx8ICdqdWknLFxuXHRcdFx0XHR0aGVtZXMgPSB0aGVtZXNBbGxbdGhlbWVdIHx8IHt9LFxuXHRcdFx0XHRyZW1vdmUgPSAkLnRyaW0oIFsgdGhlbWVzLnNvcnROb25lLCB0aGVtZXMuc29ydERlc2MsIHRoZW1lcy5zb3J0QXNjLCB0aGVtZXMuYWN0aXZlIF0uam9pbiggJyAnICkgKSxcblx0XHRcdFx0aWNvblJtdiA9ICQudHJpbSggWyB0aGVtZXMuaWNvblNvcnROb25lLCB0aGVtZXMuaWNvblNvcnREZXNjLCB0aGVtZXMuaWNvblNvcnRBc2MgXS5qb2luKCAnICcgKSApLFxuXHRcdFx0XHRkZWJ1ZyA9IHRzLmRlYnVnKGMsICd1aXRoZW1lJyk7XG5cdFx0XHRpZiAoZGVidWcpIHsgdGltZSA9IG5ldyBEYXRlKCk7IH1cblx0XHRcdC8vIGluaXRpYWxpemF0aW9uIGNvZGUgLSBydW4gb25jZVxuXHRcdFx0aWYgKCEkdGFibGUuaGFzQ2xhc3MoJ3RhYmxlc29ydGVyLScgKyB0aGVtZSkgfHwgYy50aGVtZSAhPT0gYy5hcHBsaWVkVGhlbWUgfHwgIXdvLnVpdGhlbWVfYXBwbGllZCkge1xuXHRcdFx0XHR3by51aXRoZW1lX2FwcGxpZWQgPSB0cnVlO1xuXHRcdFx0XHRvbGR0aGVtZSA9IHRoZW1lc0FsbFtjLmFwcGxpZWRUaGVtZV0gfHwge307XG5cdFx0XHRcdGhhc09sZFRoZW1lID0gISQuaXNFbXB0eU9iamVjdChvbGR0aGVtZSk7XG5cdFx0XHRcdG9sZHJlbW92ZSA9ICBoYXNPbGRUaGVtZSA/IFsgb2xkdGhlbWUuc29ydE5vbmUsIG9sZHRoZW1lLnNvcnREZXNjLCBvbGR0aGVtZS5zb3J0QXNjLCBvbGR0aGVtZS5hY3RpdmUgXS5qb2luKCAnICcgKSA6ICcnO1xuXHRcdFx0XHRvbGRJY29uUm12ID0gaGFzT2xkVGhlbWUgPyBbIG9sZHRoZW1lLmljb25Tb3J0Tm9uZSwgb2xkdGhlbWUuaWNvblNvcnREZXNjLCBvbGR0aGVtZS5pY29uU29ydEFzYyBdLmpvaW4oICcgJyApIDogJyc7XG5cdFx0XHRcdGlmIChoYXNPbGRUaGVtZSkge1xuXHRcdFx0XHRcdHdvLnplYnJhWzBdID0gJC50cmltKCAnICcgKyB3by56ZWJyYVswXS5yZXBsYWNlKCcgJyArIG9sZHRoZW1lLmV2ZW4sICcnKSApO1xuXHRcdFx0XHRcdHdvLnplYnJhWzFdID0gJC50cmltKCAnICcgKyB3by56ZWJyYVsxXS5yZXBsYWNlKCcgJyArIG9sZHRoZW1lLm9kZCwgJycpICk7XG5cdFx0XHRcdFx0Yy4kdGJvZGllcy5jaGlsZHJlbigpLnJlbW92ZUNsYXNzKCBbIG9sZHRoZW1lLmV2ZW4sIG9sZHRoZW1lLm9kZCBdLmpvaW4oJyAnKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHVwZGF0ZSB6ZWJyYSBzdHJpcGVzXG5cdFx0XHRcdGlmICh0aGVtZXMuZXZlbikgeyB3by56ZWJyYVswXSArPSAnICcgKyB0aGVtZXMuZXZlbjsgfVxuXHRcdFx0XHRpZiAodGhlbWVzLm9kZCkgeyB3by56ZWJyYVsxXSArPSAnICcgKyB0aGVtZXMub2RkOyB9XG5cdFx0XHRcdC8vIGFkZCBjYXB0aW9uIHN0eWxlXG5cdFx0XHRcdCR0YWJsZS5jaGlsZHJlbignY2FwdGlvbicpXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKG9sZHRoZW1lLmNhcHRpb24gfHwgJycpXG5cdFx0XHRcdFx0LmFkZENsYXNzKHRoZW1lcy5jYXB0aW9uKTtcblx0XHRcdFx0Ly8gYWRkIHRhYmxlL2Zvb3RlciBjbGFzcyBuYW1lc1xuXHRcdFx0XHQkdGZvb3QgPSAkdGFibGVcblx0XHRcdFx0XHQvLyByZW1vdmUgb3RoZXIgc2VsZWN0ZWQgdGhlbWVzXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCAoYy5hcHBsaWVkVGhlbWUgPyAndGFibGVzb3J0ZXItJyArIChjLmFwcGxpZWRUaGVtZSB8fCAnJykgOiAnJykgKyAnICcgKyAob2xkdGhlbWUudGFibGUgfHwgJycpIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoJ3RhYmxlc29ydGVyLScgKyB0aGVtZSArICcgJyArICh0aGVtZXMudGFibGUgfHwgJycpKSAvLyBhZGQgdGhlbWUgd2lkZ2V0IGNsYXNzIG5hbWVcblx0XHRcdFx0XHQuY2hpbGRyZW4oJ3Rmb290Jyk7XG5cdFx0XHRcdGMuYXBwbGllZFRoZW1lID0gYy50aGVtZTtcblxuXHRcdFx0XHRpZiAoJHRmb290Lmxlbmd0aCkge1xuXHRcdFx0XHRcdCR0Zm9vdFxuXHRcdFx0XHRcdFx0Ly8gaWYgb2xkdGhlbWUuZm9vdGVyUm93IG9yIG9sZHRoZW1lLmZvb3RlckNlbGxzIGFyZSB1bmRlZmluZWQsIGFsbCBjbGFzcyBuYW1lcyBhcmUgcmVtb3ZlZFxuXHRcdFx0XHRcdFx0LmNoaWxkcmVuKCd0cicpLnJlbW92ZUNsYXNzKG9sZHRoZW1lLmZvb3RlclJvdyB8fCAnJykuYWRkQ2xhc3ModGhlbWVzLmZvb3RlclJvdylcblx0XHRcdFx0XHRcdC5jaGlsZHJlbigndGgsIHRkJykucmVtb3ZlQ2xhc3Mob2xkdGhlbWUuZm9vdGVyQ2VsbHMgfHwgJycpLmFkZENsYXNzKHRoZW1lcy5mb290ZXJDZWxscyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdXBkYXRlIGhlYWRlciBjbGFzc2VzXG5cdFx0XHRcdCRoZWFkZXJzXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCAoaGFzT2xkVGhlbWUgPyBbIG9sZHRoZW1lLmhlYWRlciwgb2xkdGhlbWUuaG92ZXIsIG9sZHJlbW92ZSBdLmpvaW4oJyAnKSA6ICcnKSB8fCAnJyApXG5cdFx0XHRcdFx0LmFkZENsYXNzKHRoZW1lcy5oZWFkZXIpXG5cdFx0XHRcdFx0Lm5vdCgnLnNvcnRlci1mYWxzZScpXG5cdFx0XHRcdFx0LnVuYmluZCgnbW91c2VlbnRlci50c3VpdGhlbWUgbW91c2VsZWF2ZS50c3VpdGhlbWUnKVxuXHRcdFx0XHRcdC5iaW5kKCdtb3VzZWVudGVyLnRzdWl0aGVtZSBtb3VzZWxlYXZlLnRzdWl0aGVtZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdFx0XHQvLyB0b2dnbGVDbGFzcyB3aXRoIHN3aXRjaCBhZGRlZCBpbiBqUXVlcnkgMS4zXG5cdFx0XHRcdFx0XHQkKHRoaXMpWyBldmVudC50eXBlID09PSAnbW91c2VlbnRlcicgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJyBdKHRoZW1lcy5ob3ZlciB8fCAnJyk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0JGhlYWRlcnMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXHRcdFx0XHRcdGlmICghJHRoaXMuZmluZCgnLicgKyB0cy5jc3Mud3JhcHBlcikubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQvLyBGaXJlZm94IG5lZWRzIHRoaXMgaW5uZXIgZGl2IHRvIHBvc2l0aW9uIHRoZSBpY29uICYgcmVzaXplciBjb3JyZWN0bHlcblx0XHRcdFx0XHRcdCR0aGlzLndyYXBJbm5lcignPGRpdiBjbGFzcz1cIicgKyB0cy5jc3Mud3JhcHBlciArICdcIiBzdHlsZT1cInBvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDoxMDAlO3dpZHRoOjEwMCVcIj48L2Rpdj4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAoYy5jc3NJY29uKSB7XG5cdFx0XHRcdFx0Ly8gaWYgYy5jc3NJY29uIGlzICcnLCB0aGVuIG5vIDxpPiBpcyBhZGRlZCB0byB0aGUgaGVhZGVyXG5cdFx0XHRcdFx0JGhlYWRlcnNcblx0XHRcdFx0XHRcdC5maW5kKCcuJyArIHRzLmNzcy5pY29uKVxuXHRcdFx0XHRcdFx0LnJlbW92ZUNsYXNzKGhhc09sZFRoZW1lID8gWyBvbGR0aGVtZS5pY29ucywgb2xkSWNvblJtdiBdLmpvaW4oJyAnKSA6ICcnKVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKHRoZW1lcy5pY29ucyB8fCAnJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gZmlsdGVyIHdpZGdldCBpbml0aWFsaXplcyBhZnRlciB1aXRoZW1lXG5cdFx0XHRcdGlmICh0cy5oYXNXaWRnZXQoIGMudGFibGUsICdmaWx0ZXInICkpIHtcblx0XHRcdFx0XHR0bXAgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdCR0YWJsZS5jaGlsZHJlbigndGhlYWQnKS5jaGlsZHJlbignLicgKyB0cy5jc3MuZmlsdGVyUm93KVxuXHRcdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoaGFzT2xkVGhlbWUgPyBvbGR0aGVtZS5maWx0ZXJSb3cgfHwgJycgOiAnJylcblx0XHRcdFx0XHRcdFx0LmFkZENsYXNzKHRoZW1lcy5maWx0ZXJSb3cgfHwgJycpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYgKHdvLmZpbHRlcl9pbml0aWFsaXplZCkge1xuXHRcdFx0XHRcdFx0dG1wKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdCR0YWJsZS5vbmUoJ2ZpbHRlckluaXQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dG1wKCk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBjLmNvbHVtbnM7IGkrKykge1xuXHRcdFx0XHQkaGVhZGVyID0gYy4kaGVhZGVyc1xuXHRcdFx0XHRcdC5hZGQoJChjLm5hbWVzcGFjZSArICdfZXh0cmFfaGVhZGVycycpKVxuXHRcdFx0XHRcdC5ub3QoJy5zb3J0ZXItZmFsc2UnKVxuXHRcdFx0XHRcdC5maWx0ZXIoJ1tkYXRhLWNvbHVtbj1cIicgKyBpICsgJ1wiXScpO1xuXHRcdFx0XHQkaWNvbiA9ICh0cy5jc3MuaWNvbikgPyAkaGVhZGVyLmZpbmQoJy4nICsgdHMuY3NzLmljb24pIDogJCgpO1xuXHRcdFx0XHQkaCA9ICRoZWFkZXJzLm5vdCgnLnNvcnRlci1mYWxzZScpLmZpbHRlcignW2RhdGEtY29sdW1uPVwiJyArIGkgKyAnXCJdOmxhc3QnKTtcblx0XHRcdFx0aWYgKCRoLmxlbmd0aCkge1xuXHRcdFx0XHRcdCRoZWFkZXIucmVtb3ZlQ2xhc3MocmVtb3ZlKTtcblx0XHRcdFx0XHQkaWNvbi5yZW1vdmVDbGFzcyhpY29uUm12KTtcblx0XHRcdFx0XHRpZiAoJGhbMF0uc29ydERpc2FibGVkKSB7XG5cdFx0XHRcdFx0XHQvLyBubyBzb3J0IGFycm93cyBmb3IgZGlzYWJsZWQgY29sdW1ucyFcblx0XHRcdFx0XHRcdCRpY29uLnJlbW92ZUNsYXNzKHRoZW1lcy5pY29ucyB8fCAnJyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGhkciA9IHRoZW1lcy5zb3J0Tm9uZTtcblx0XHRcdFx0XHRcdGljb24gPSB0aGVtZXMuaWNvblNvcnROb25lO1xuXHRcdFx0XHRcdFx0aWYgKCRoLmhhc0NsYXNzKHRzLmNzcy5zb3J0QXNjKSkge1xuXHRcdFx0XHRcdFx0XHRoZHIgPSBbIHRoZW1lcy5zb3J0QXNjLCB0aGVtZXMuYWN0aXZlIF0uam9pbignICcpO1xuXHRcdFx0XHRcdFx0XHRpY29uID0gdGhlbWVzLmljb25Tb3J0QXNjO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICgkaC5oYXNDbGFzcyh0cy5jc3Muc29ydERlc2MpKSB7XG5cdFx0XHRcdFx0XHRcdGhkciA9IFsgdGhlbWVzLnNvcnREZXNjLCB0aGVtZXMuYWN0aXZlIF0uam9pbignICcpO1xuXHRcdFx0XHRcdFx0XHRpY29uID0gdGhlbWVzLmljb25Tb3J0RGVzYztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdCRoZWFkZXIuYWRkQ2xhc3MoaGRyKTtcblx0XHRcdFx0XHRcdCRpY29uLmFkZENsYXNzKGljb24gfHwgJycpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRlYnVnKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCd1aXRoZW1lID4+IEFwcGxpZWQgJyArIHRoZW1lICsgJyB0aGVtZScgKyB0cy5iZW5jaG1hcmsodGltZSkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbih0YWJsZSwgYywgd28sIHJlZnJlc2hpbmcpIHtcblx0XHRcdGlmICghd28udWl0aGVtZV9hcHBsaWVkKSB7IHJldHVybjsgfVxuXHRcdFx0dmFyICR0YWJsZSA9IGMuJHRhYmxlLFxuXHRcdFx0XHR0aGVtZSA9IGMuYXBwbGllZFRoZW1lIHx8ICdqdWknLFxuXHRcdFx0XHR0aGVtZXMgPSB0cy50aGVtZXNbIHRoZW1lIF0gfHwgdHMudGhlbWVzLmp1aSxcblx0XHRcdFx0JGhlYWRlcnMgPSAkdGFibGUuY2hpbGRyZW4oJ3RoZWFkJykuY2hpbGRyZW4oKSxcblx0XHRcdFx0cmVtb3ZlID0gdGhlbWVzLnNvcnROb25lICsgJyAnICsgdGhlbWVzLnNvcnREZXNjICsgJyAnICsgdGhlbWVzLnNvcnRBc2MsXG5cdFx0XHRcdGljb25SbXYgPSB0aGVtZXMuaWNvblNvcnROb25lICsgJyAnICsgdGhlbWVzLmljb25Tb3J0RGVzYyArICcgJyArIHRoZW1lcy5pY29uU29ydEFzYztcblx0XHRcdCR0YWJsZS5yZW1vdmVDbGFzcygndGFibGVzb3J0ZXItJyArIHRoZW1lICsgJyAnICsgdGhlbWVzLnRhYmxlKTtcblx0XHRcdHdvLnVpdGhlbWVfYXBwbGllZCA9IGZhbHNlO1xuXHRcdFx0aWYgKHJlZnJlc2hpbmcpIHsgcmV0dXJuOyB9XG5cdFx0XHQkdGFibGUuZmluZCh0cy5jc3MuaGVhZGVyKS5yZW1vdmVDbGFzcyh0aGVtZXMuaGVhZGVyKTtcblx0XHRcdCRoZWFkZXJzXG5cdFx0XHRcdC51bmJpbmQoJ21vdXNlZW50ZXIudHN1aXRoZW1lIG1vdXNlbGVhdmUudHN1aXRoZW1lJykgLy8gcmVtb3ZlIGhvdmVyXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyh0aGVtZXMuaG92ZXIgKyAnICcgKyByZW1vdmUgKyAnICcgKyB0aGVtZXMuYWN0aXZlKVxuXHRcdFx0XHQuZmlsdGVyKCcuJyArIHRzLmNzcy5maWx0ZXJSb3cpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyh0aGVtZXMuZmlsdGVyUm93KTtcblx0XHRcdCRoZWFkZXJzLmZpbmQoJy4nICsgdHMuY3NzLmljb24pLnJlbW92ZUNsYXNzKHRoZW1lcy5pY29ucyArICcgJyArIGljb25SbXYpO1xuXHRcdH1cblx0fSk7XG5cbn0pKGpRdWVyeSk7XG5cbi8qISBXaWRnZXQ6IGNvbHVtbnMgLSB1cGRhdGVkIDUvMjQvMjAxNyAodjIuMjguMTEpICovXG47KGZ1bmN0aW9uICgkKSB7XG5cdCd1c2Ugc3RyaWN0Jztcblx0dmFyIHRzID0gJC50YWJsZXNvcnRlciB8fCB7fTtcblxuXHR0cy5hZGRXaWRnZXQoe1xuXHRcdGlkOiAnY29sdW1ucycsXG5cdFx0cHJpb3JpdHk6IDY1LFxuXHRcdG9wdGlvbnMgOiB7XG5cdFx0XHRjb2x1bW5zIDogWyAncHJpbWFyeScsICdzZWNvbmRhcnknLCAndGVydGlhcnknIF1cblx0XHR9LFxuXHRcdGZvcm1hdDogZnVuY3Rpb24odGFibGUsIGMsIHdvKSB7XG5cdFx0XHR2YXIgJHRib2R5LCB0Ym9keUluZGV4LCAkcm93cywgcm93cywgJHJvdywgJGNlbGxzLCByZW1vdmUsIGluZHgsXG5cdFx0XHQkdGFibGUgPSBjLiR0YWJsZSxcblx0XHRcdCR0Ym9kaWVzID0gYy4kdGJvZGllcyxcblx0XHRcdHNvcnRMaXN0ID0gYy5zb3J0TGlzdCxcblx0XHRcdGxlbiA9IHNvcnRMaXN0Lmxlbmd0aCxcblx0XHRcdC8vIHJlbW92ZWQgYy53aWRnZXRDb2x1bW5zIHN1cHBvcnRcblx0XHRcdGNzcyA9IHdvICYmIHdvLmNvbHVtbnMgfHwgWyAncHJpbWFyeScsICdzZWNvbmRhcnknLCAndGVydGlhcnknIF0sXG5cdFx0XHRsYXN0ID0gY3NzLmxlbmd0aCAtIDE7XG5cdFx0XHRyZW1vdmUgPSBjc3Muam9pbignICcpO1xuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlcmUgaXMgYSBzb3J0IChvbiBpbml0aWFsaXphdGlvbiB0aGVyZSBtYXkgbm90IGJlIG9uZSlcblx0XHRcdGZvciAodGJvZHlJbmRleCA9IDA7IHRib2R5SW5kZXggPCAkdGJvZGllcy5sZW5ndGg7IHRib2R5SW5kZXgrKyApIHtcblx0XHRcdFx0JHRib2R5ID0gdHMucHJvY2Vzc1Rib2R5KHRhYmxlLCAkdGJvZGllcy5lcSh0Ym9keUluZGV4KSwgdHJ1ZSk7IC8vIGRldGFjaCB0Ym9keVxuXHRcdFx0XHQkcm93cyA9ICR0Ym9keS5jaGlsZHJlbigndHInKTtcblx0XHRcdFx0Ly8gbG9vcCB0aHJvdWdoIHRoZSB2aXNpYmxlIHJvd3Ncblx0XHRcdFx0JHJvd3MuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkcm93ID0gJCh0aGlzKTtcblx0XHRcdFx0XHRpZiAodGhpcy5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcblx0XHRcdFx0XHRcdC8vIHJlbW92ZSBhbGwgY29sdW1ucyBjbGFzcyBuYW1lc1xuXHRcdFx0XHRcdFx0JGNlbGxzID0gJHJvdy5jaGlsZHJlbigpLnJlbW92ZUNsYXNzKHJlbW92ZSk7XG5cdFx0XHRcdFx0XHQvLyBhZGQgYXBwcm9wcmlhdGUgY29sdW1uIGNsYXNzIG5hbWVzXG5cdFx0XHRcdFx0XHRpZiAoc29ydExpc3QgJiYgc29ydExpc3RbMF0pIHtcblx0XHRcdFx0XHRcdFx0Ly8gcHJpbWFyeSBzb3J0IGNvbHVtbiBjbGFzc1xuXHRcdFx0XHRcdFx0XHQkY2VsbHMuZXEoc29ydExpc3RbMF1bMF0pLmFkZENsYXNzKGNzc1swXSk7XG5cdFx0XHRcdFx0XHRcdGlmIChsZW4gPiAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpbmR4ID0gMTsgaW5keCA8IGxlbjsgaW5keCsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBzZWNvbmRhcnksIHRlcnRpYXJ5LCBldGMgc29ydCBjb2x1bW4gY2xhc3Nlc1xuXHRcdFx0XHRcdFx0XHRcdFx0JGNlbGxzLmVxKHNvcnRMaXN0W2luZHhdWzBdKS5hZGRDbGFzcyggY3NzW2luZHhdIHx8IGNzc1tsYXN0XSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRzLnByb2Nlc3NUYm9keSh0YWJsZSwgJHRib2R5LCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBhZGQgY2xhc3NlcyB0byB0aGVhZCBhbmQgdGZvb3Rcblx0XHRcdHJvd3MgPSB3by5jb2x1bW5zX3RoZWFkICE9PSBmYWxzZSA/IFsgJ3RoZWFkIHRyJyBdIDogW107XG5cdFx0XHRpZiAod28uY29sdW1uc190Zm9vdCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0cm93cy5wdXNoKCd0Zm9vdCB0cicpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJvd3MubGVuZ3RoKSB7XG5cdFx0XHRcdCRyb3dzID0gJHRhYmxlLmZpbmQoIHJvd3Muam9pbignLCcpICkuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcyhyZW1vdmUpO1xuXHRcdFx0XHRpZiAobGVuKSB7XG5cdFx0XHRcdFx0Zm9yIChpbmR4ID0gMDsgaW5keCA8IGxlbjsgaW5keCsrKSB7XG5cdFx0XHRcdFx0XHQvLyBhZGQgcHJpbWFyeS4gc2Vjb25kYXJ5LCB0ZXJ0aWFyeSwgZXRjIHNvcnQgY29sdW1uIGNsYXNzZXNcblx0XHRcdFx0XHRcdCRyb3dzLmZpbHRlcignW2RhdGEtY29sdW1uPVwiJyArIHNvcnRMaXN0W2luZHhdWzBdICsgJ1wiXScpLmFkZENsYXNzKGNzc1tpbmR4XSB8fCBjc3NbbGFzdF0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbih0YWJsZSwgYywgd28pIHtcblx0XHRcdHZhciB0Ym9keUluZGV4LCAkdGJvZHksXG5cdFx0XHRcdCR0Ym9kaWVzID0gYy4kdGJvZGllcyxcblx0XHRcdFx0cmVtb3ZlID0gKHdvLmNvbHVtbnMgfHwgWyAncHJpbWFyeScsICdzZWNvbmRhcnknLCAndGVydGlhcnknIF0pLmpvaW4oJyAnKTtcblx0XHRcdGMuJGhlYWRlcnMucmVtb3ZlQ2xhc3MocmVtb3ZlKTtcblx0XHRcdGMuJHRhYmxlLmNoaWxkcmVuKCd0Zm9vdCcpLmNoaWxkcmVuKCd0cicpLmNoaWxkcmVuKCd0aCwgdGQnKS5yZW1vdmVDbGFzcyhyZW1vdmUpO1xuXHRcdFx0Zm9yICh0Ym9keUluZGV4ID0gMDsgdGJvZHlJbmRleCA8ICR0Ym9kaWVzLmxlbmd0aDsgdGJvZHlJbmRleCsrICkge1xuXHRcdFx0XHQkdGJvZHkgPSB0cy5wcm9jZXNzVGJvZHkodGFibGUsICR0Ym9kaWVzLmVxKHRib2R5SW5kZXgpLCB0cnVlKTsgLy8gcmVtb3ZlIHRib2R5XG5cdFx0XHRcdCR0Ym9keS5jaGlsZHJlbigndHInKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCQodGhpcykuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcyhyZW1vdmUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0dHMucHJvY2Vzc1Rib2R5KHRhYmxlLCAkdGJvZHksIGZhbHNlKTsgLy8gcmVzdG9yZSB0Ym9keVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cbn0pKGpRdWVyeSk7XG5cbi8qISBXaWRnZXQ6IGZpbHRlciAtIHVwZGF0ZWQgMjAxOC0wMy0xOCAodjIuMzAuMCkgKi8vKlxuICogUmVxdWlyZXMgdGFibGVzb3J0ZXIgdjIuOCsgYW5kIGpRdWVyeSAxLjcrXG4gKiBieSBSb2IgR2Fycmlzb25cbiAqL1xuOyggZnVuY3Rpb24gKCAkICkge1xuXHQndXNlIHN0cmljdCc7XG5cdHZhciB0c2YsIHRzZlJlZ2V4LFxuXHRcdHRzID0gJC50YWJsZXNvcnRlciB8fCB7fSxcblx0XHR0c2NzcyA9IHRzLmNzcyxcblx0XHR0c2tleUNvZGVzID0gdHMua2V5Q29kZXM7XG5cblx0JC5leHRlbmQoIHRzY3NzLCB7XG5cdFx0ZmlsdGVyUm93ICAgICAgOiAndGFibGVzb3J0ZXItZmlsdGVyLXJvdycsXG5cdFx0ZmlsdGVyICAgICAgICAgOiAndGFibGVzb3J0ZXItZmlsdGVyJyxcblx0XHRmaWx0ZXJEaXNhYmxlZCA6ICdkaXNhYmxlZCcsXG5cdFx0ZmlsdGVyUm93SGlkZSAgOiAnaGlkZW1lJ1xuXHR9KTtcblxuXHQkLmV4dGVuZCggdHNrZXlDb2Rlcywge1xuXHRcdGJhY2tTcGFjZSA6IDgsXG5cdFx0ZXNjYXBlIDogMjcsXG5cdFx0c3BhY2UgOiAzMixcblx0XHRsZWZ0IDogMzcsXG5cdFx0ZG93biA6IDQwXG5cdH0pO1xuXG5cdHRzLmFkZFdpZGdldCh7XG5cdFx0aWQ6ICdmaWx0ZXInLFxuXHRcdHByaW9yaXR5OiA1MCxcblx0XHRvcHRpb25zIDoge1xuXHRcdFx0ZmlsdGVyX2NlbGxGaWx0ZXIgICAgOiAnJywgICAgLy8gY3NzIGNsYXNzIG5hbWUgYWRkZWQgdG8gdGhlIGZpbHRlciBjZWxsICggc3RyaW5nIG9yIGFycmF5IClcblx0XHRcdGZpbHRlcl9jaGlsZFJvd3MgICAgIDogZmFsc2UsIC8vIGlmIHRydWUsIGZpbHRlciBpbmNsdWRlcyBjaGlsZCByb3cgY29udGVudCBpbiB0aGUgc2VhcmNoXG5cdFx0XHRmaWx0ZXJfY2hpbGRCeUNvbHVtbiA6IGZhbHNlLCAvLyAoIGZpbHRlcl9jaGlsZFJvd3MgbXVzdCBiZSB0cnVlICkgaWYgdHJ1ZSA9IHNlYXJjaCBjaGlsZCByb3dzIGJ5IGNvbHVtbjsgZmFsc2UgPSBzZWFyY2ggYWxsIGNoaWxkIHJvdyB0ZXh0IGdyb3VwZWRcblx0XHRcdGZpbHRlcl9jaGlsZFdpdGhTaWJzIDogdHJ1ZSwgIC8vIGlmIHRydWUsIGluY2x1ZGUgbWF0Y2hpbmcgY2hpbGQgcm93IHNpYmxpbmdzXG5cdFx0XHRmaWx0ZXJfY29sdW1uQW55TWF0Y2g6IHRydWUsICAvLyBpZiB0cnVlLCBhbGxvd3MgdXNpbmcgJyM6e3F1ZXJ5fScgaW4gQW55TWF0Y2ggc2VhcmNoZXMgKCBjb2x1bW46cXVlcnkgKVxuXHRcdFx0ZmlsdGVyX2NvbHVtbkZpbHRlcnMgOiB0cnVlLCAgLy8gaWYgdHJ1ZSwgYSBmaWx0ZXIgd2lsbCBiZSBhZGRlZCB0byB0aGUgdG9wIG9mIGVhY2ggdGFibGUgY29sdW1uXG5cdFx0XHRmaWx0ZXJfY3NzRmlsdGVyICAgICA6ICcnLCAgICAvLyBjc3MgY2xhc3MgbmFtZSBhZGRlZCB0byB0aGUgZmlsdGVyIHJvdyAmIGVhY2ggaW5wdXQgaW4gdGhlIHJvdyAoIHRhYmxlc29ydGVyLWZpbHRlciBpcyBBTFdBWVMgYWRkZWQgKVxuXHRcdFx0ZmlsdGVyX2RlZmF1bHRBdHRyaWIgOiAnZGF0YS12YWx1ZScsIC8vIGRhdGEgYXR0cmlidXRlIGluIHRoZSBoZWFkZXIgY2VsbCB0aGF0IGNvbnRhaW5zIHRoZSBkZWZhdWx0IGZpbHRlciB2YWx1ZVxuXHRcdFx0ZmlsdGVyX2RlZmF1bHRGaWx0ZXIgOiB7fSwgICAgLy8gYWRkIGEgZGVmYXVsdCBjb2x1bW4gZmlsdGVyIHR5cGUgJ357cXVlcnl9JyB0byBtYWtlIGZ1enp5IHNlYXJjaGVzIGRlZmF1bHQ7ICd7cTF9IEFORCB7cTJ9JyB0byBtYWtlIGFsbCBzZWFyY2hlcyB1c2UgYSBsb2dpY2FsIEFORC5cblx0XHRcdGZpbHRlcl9leGNsdWRlRmlsdGVyIDoge30sICAgIC8vIGZpbHRlcnMgdG8gZXhjbHVkZSwgcGVyIGNvbHVtblxuXHRcdFx0ZmlsdGVyX2V4dGVybmFsICAgICAgOiAnJywgICAgLy8galF1ZXJ5IHNlbGVjdG9yIHN0cmluZyAoIG9yIGpRdWVyeSBvYmplY3QgKSBvZiBleHRlcm5hbCBmaWx0ZXJzXG5cdFx0XHRmaWx0ZXJfZmlsdGVyZWRSb3cgICA6ICdmaWx0ZXJlZCcsIC8vIGNsYXNzIGFkZGVkIHRvIGZpbHRlcmVkIHJvd3M7IGRlZmluZSBpbiBjc3Mgd2l0aCBcImRpc3BsYXk6bm9uZVwiIHRvIGhpZGUgdGhlIGZpbHRlcmVkLW91dCByb3dzXG5cdFx0XHRmaWx0ZXJfZmlsdGVyTGFiZWwgICA6ICdGaWx0ZXIgXCJ7e2xhYmVsfX1cIiBjb2x1bW4gYnkuLi4nLCAvLyBBcmlhLWxhYmVsIGFkZGVkIHRvIGZpbHRlciBpbnB1dC9zZWxlY3Q7IHNlZSAjMTQ5NVxuXHRcdFx0ZmlsdGVyX2Zvcm1hdHRlciAgICAgOiBudWxsLCAgLy8gYWRkIGN1c3RvbSBmaWx0ZXIgZWxlbWVudHMgdG8gdGhlIGZpbHRlciByb3dcblx0XHRcdGZpbHRlcl9mdW5jdGlvbnMgICAgIDogbnVsbCwgIC8vIGFkZCBjdXN0b20gZmlsdGVyIGZ1bmN0aW9ucyB1c2luZyB0aGlzIG9wdGlvblxuXHRcdFx0ZmlsdGVyX2hpZGVFbXB0eSAgICAgOiB0cnVlLCAgLy8gaGlkZSBmaWx0ZXIgcm93IHdoZW4gdGFibGUgaXMgZW1wdHlcblx0XHRcdGZpbHRlcl9oaWRlRmlsdGVycyAgIDogZmFsc2UsIC8vIGNvbGxhcHNlIGZpbHRlciByb3cgd2hlbiBtb3VzZSBsZWF2ZXMgdGhlIGFyZWFcblx0XHRcdGZpbHRlcl9pZ25vcmVDYXNlICAgIDogdHJ1ZSwgIC8vIGlmIHRydWUsIG1ha2UgYWxsIHNlYXJjaGVzIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdGZpbHRlcl9saXZlU2VhcmNoICAgIDogdHJ1ZSwgIC8vIGlmIHRydWUsIHNlYXJjaCBjb2x1bW4gY29udGVudCB3aGlsZSB0aGUgdXNlciB0eXBlcyAoIHdpdGggYSBkZWxheSApXG5cdFx0XHRmaWx0ZXJfbWF0Y2hUeXBlICAgICA6IHsgJ2lucHV0JzogJ2V4YWN0JywgJ3NlbGVjdCc6ICdleGFjdCcgfSwgLy8gZ2xvYmFsIHF1ZXJ5IHNldHRpbmdzICgnZXhhY3QnIG9yICdtYXRjaCcpOyBvdmVycmlkZGVuIGJ5IFwiZmlsdGVyLW1hdGNoXCIgb3IgXCJmaWx0ZXItZXhhY3RcIiBjbGFzc1xuXHRcdFx0ZmlsdGVyX29ubHlBdmFpbCAgICAgOiAnZmlsdGVyLW9ubHlBdmFpbCcsIC8vIGEgaGVhZGVyIHdpdGggYSBzZWxlY3QgZHJvcGRvd24gJiB0aGlzIGNsYXNzIG5hbWUgd2lsbCBvbmx5IHNob3cgYXZhaWxhYmxlICggdmlzaWJsZSApIG9wdGlvbnMgd2l0aGluIHRoZSBkcm9wIGRvd25cblx0XHRcdGZpbHRlcl9wbGFjZWhvbGRlciAgIDogeyBzZWFyY2ggOiAnJywgc2VsZWN0IDogJycgfSwgLy8gZGVmYXVsdCBwbGFjZWhvbGRlciB0ZXh0ICggb3ZlcnJpZGRlbiBieSBhbnkgaGVhZGVyICdkYXRhLXBsYWNlaG9sZGVyJyBzZXR0aW5nIClcblx0XHRcdGZpbHRlcl9yZXNldCAgICAgICAgIDogbnVsbCwgIC8vIGpRdWVyeSBzZWxlY3RvciBzdHJpbmcgb2YgYW4gZWxlbWVudCB1c2VkIHRvIHJlc2V0IHRoZSBmaWx0ZXJzXG5cdFx0XHRmaWx0ZXJfcmVzZXRPbkVzYyAgICA6IHRydWUsICAvLyBSZXNldCBmaWx0ZXIgaW5wdXQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGVzY2FwZSAtIG5vcm1hbGl6ZWQgYWNyb3NzIGJyb3dzZXJzXG5cdFx0XHRmaWx0ZXJfc2F2ZUZpbHRlcnMgICA6IGZhbHNlLCAvLyBVc2UgdGhlICQudGFibGVzb3J0ZXIuc3RvcmFnZSB1dGlsaXR5IHRvIHNhdmUgdGhlIG1vc3QgcmVjZW50IGZpbHRlcnNcblx0XHRcdGZpbHRlcl9zZWFyY2hEZWxheSAgIDogMzAwLCAgIC8vIHR5cGluZyBkZWxheSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIHN0YXJ0aW5nIGEgc2VhcmNoXG5cdFx0XHRmaWx0ZXJfc2VhcmNoRmlsdGVyZWQ6IHRydWUsICAvLyBhbGxvdyBzZWFyY2hpbmcgdGhyb3VnaCBhbHJlYWR5IGZpbHRlcmVkIHJvd3MgaW4gc3BlY2lhbCBjaXJjdW1zdGFuY2VzOyB3aWxsIHNwZWVkIHVwIHNlYXJjaGluZyBpbiBsYXJnZSB0YWJsZXMgaWYgdHJ1ZVxuXHRcdFx0ZmlsdGVyX3NlbGVjdFNvdXJjZSAgOiBudWxsLCAgLy8gaW5jbHVkZSBhIGZ1bmN0aW9uIHRvIHJldHVybiBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gYmUgYWRkZWQgdG8gdGhlIGNvbHVtbiBmaWx0ZXIgc2VsZWN0XG5cdFx0XHRmaWx0ZXJfc2VsZWN0U291cmNlU2VwYXJhdG9yIDogJ3wnLCAvLyBmaWx0ZXJfc2VsZWN0U291cmNlIGFycmF5IHRleHQgbGVmdCBvZiB0aGUgc2VwYXJhdG9yIGlzIGFkZGVkIHRvIHRoZSBvcHRpb24gdmFsdWUsIHJpZ2h0IGludG8gdGhlIG9wdGlvbiB0ZXh0XG5cdFx0XHRmaWx0ZXJfc2VydmVyc2lkZUZpbHRlcmluZyA6IGZhbHNlLCAvLyBpZiB0cnVlLCBtdXN0IHBlcmZvcm0gc2VydmVyLXNpZGUgZmlsdGVyaW5nIGIvYyBjbGllbnQtc2lkZSBmaWx0ZXJpbmcgaXMgZGlzYWJsZWQsIGJ1dCB0aGUgdWkgYW5kIGV2ZW50cyB3aWxsIHN0aWxsIGJlIHVzZWQuXG5cdFx0XHRmaWx0ZXJfc3RhcnRzV2l0aCAgICA6IGZhbHNlLCAvLyBpZiB0cnVlLCBmaWx0ZXIgc3RhcnQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjZWxsIGNvbnRlbnRzXG5cdFx0XHRmaWx0ZXJfdXNlUGFyc2VkRGF0YSA6IGZhbHNlICAvLyBmaWx0ZXIgYWxsIGRhdGEgdXNpbmcgcGFyc2VkIGNvbnRlbnRcblx0XHR9LFxuXHRcdGZvcm1hdDogZnVuY3Rpb24oIHRhYmxlLCBjLCB3byApIHtcblx0XHRcdGlmICggIWMuJHRhYmxlLmhhc0NsYXNzKCAnaGFzRmlsdGVycycgKSApIHtcblx0XHRcdFx0dHNmLmluaXQoIHRhYmxlLCBjLCB3byApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiggdGFibGUsIGMsIHdvLCByZWZyZXNoaW5nICkge1xuXHRcdFx0dmFyIHRib2R5SW5kZXgsICR0Ym9keSxcblx0XHRcdFx0JHRhYmxlID0gYy4kdGFibGUsXG5cdFx0XHRcdCR0Ym9kaWVzID0gYy4kdGJvZGllcyxcblx0XHRcdFx0ZXZlbnRzID0gKFxuXHRcdFx0XHRcdCdhZGRSb3dzIHVwZGF0ZUNlbGwgdXBkYXRlIHVwZGF0ZVJvd3MgdXBkYXRlQ29tcGxldGUgYXBwZW5kQ2FjaGUgZmlsdGVyUmVzZXQgJyArXG5cdFx0XHRcdFx0J2ZpbHRlckFuZFNvcnRSZXNldCBmaWx0ZXJGb21hdHRlclVwZGF0ZSBmaWx0ZXJFbmQgc2VhcmNoIHN0aWNreUhlYWRlcnNJbml0ICdcblx0XHRcdFx0KS5zcGxpdCggJyAnICkuam9pbiggYy5uYW1lc3BhY2UgKyAnZmlsdGVyICcgKTtcblx0XHRcdCR0YWJsZVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoICdoYXNGaWx0ZXJzJyApXG5cdFx0XHRcdC8vIGFkZCBmaWx0ZXIgbmFtZXNwYWNlIHRvIGFsbCBCVVQgc2VhcmNoXG5cdFx0XHRcdC51bmJpbmQoIGV2ZW50cy5yZXBsYWNlKCB0cy5yZWdleC5zcGFjZXMsICcgJyApIClcblx0XHRcdFx0Ly8gcmVtb3ZlIHRoZSBmaWx0ZXIgcm93IGV2ZW4gaWYgcmVmcmVzaGluZywgYmVjYXVzZSB0aGUgY29sdW1uIG1pZ2h0IGhhdmUgYmVlbiBtb3ZlZFxuXHRcdFx0XHQuZmluZCggJy4nICsgdHNjc3MuZmlsdGVyUm93ICkucmVtb3ZlKCk7XG5cdFx0XHR3by5maWx0ZXJfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblx0XHRcdGlmICggcmVmcmVzaGluZyApIHsgcmV0dXJuOyB9XG5cdFx0XHRmb3IgKCB0Ym9keUluZGV4ID0gMDsgdGJvZHlJbmRleCA8ICR0Ym9kaWVzLmxlbmd0aDsgdGJvZHlJbmRleCsrICkge1xuXHRcdFx0XHQkdGJvZHkgPSB0cy5wcm9jZXNzVGJvZHkoIHRhYmxlLCAkdGJvZGllcy5lcSggdGJvZHlJbmRleCApLCB0cnVlICk7IC8vIHJlbW92ZSB0Ym9keVxuXHRcdFx0XHQkdGJvZHkuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcyggd28uZmlsdGVyX2ZpbHRlcmVkUm93ICkuc2hvdygpO1xuXHRcdFx0XHR0cy5wcm9jZXNzVGJvZHkoIHRhYmxlLCAkdGJvZHksIGZhbHNlICk7IC8vIHJlc3RvcmUgdGJvZHlcblx0XHRcdH1cblx0XHRcdGlmICggd28uZmlsdGVyX3Jlc2V0ICkge1xuXHRcdFx0XHQkKCBkb2N1bWVudCApLnVuZGVsZWdhdGUoIHdvLmZpbHRlcl9yZXNldCwgJ2NsaWNrJyArIGMubmFtZXNwYWNlICsgJ2ZpbHRlcicgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHRzZiA9IHRzLmZpbHRlciA9IHtcblxuXHRcdC8vIHJlZ2V4IHVzZWQgaW4gZmlsdGVyICdjaGVjaycgZnVuY3Rpb25zIC0gbm90IGZvciBnZW5lcmFsIHVzZSBhbmQgbm90IGRvY3VtZW50ZWRcblx0XHRyZWdleDoge1xuXHRcdFx0cmVnZXggICAgIDogL15cXC8oKD86XFxcXFxcL3xbXlxcL10pKylcXC8oW21pZ3l1XXswLDV9KT8kLywgLy8gcmVnZXggdG8gdGVzdCBmb3IgcmVnZXhcblx0XHRcdGNoaWxkICAgICA6IC90YWJsZXNvcnRlci1jaGlsZFJvdy8sIC8vIGNoaWxkIHJvdyBjbGFzcyBuYW1lOyB0aGlzIGdldHMgdXBkYXRlZCBpbiB0aGUgc2NyaXB0XG5cdFx0XHRmaWx0ZXJlZCAgOiAvZmlsdGVyZWQvLCAvLyBmaWx0ZXJlZCAoaGlkZGVuKSByb3cgY2xhc3MgbmFtZTsgdXBkYXRlZCBpbiB0aGUgc2NyaXB0XG5cdFx0XHR0eXBlICAgICAgOiAvdW5kZWZpbmVkfG51bWJlci8sIC8vIGNoZWNrIHR5cGVcblx0XHRcdGV4YWN0ICAgICA6IC8oXltcXFwiXFwnPV0rKXwoW1xcXCJcXCc9XSskKS9nLCAvLyBleGFjdCBtYXRjaCAoYWxsb3cgJz09Jylcblx0XHRcdG9wZXJhdG9ycyA6IC9bPD49XS9nLCAvLyByZXBsYWNlIG9wZXJhdG9yc1xuXHRcdFx0cXVlcnkgICAgIDogJyhxfHF1ZXJ5KScsIC8vIHJlcGxhY2UgZmlsdGVyIHF1ZXJpZXNcblx0XHRcdHdpbGQwMSAgICA6IC9cXD8vZywgLy8gd2lsZCBjYXJkIG1hdGNoIDAgb3IgMVxuXHRcdFx0d2lsZDBNb3JlIDogL1xcKi9nLCAvLyB3aWxkIGNhcmUgbWF0Y2ggMCBvciBtb3JlXG5cdFx0XHRxdW90ZSAgICAgOiAvXFxcIi9nLFxuXHRcdFx0aXNOZWcxICAgIDogLyg+PT9cXHMqLVxcZCkvLFxuXHRcdFx0aXNOZWcyICAgIDogLyg8PT9cXHMqXFxkKS9cblx0XHR9LFxuXHRcdC8vIGZ1bmN0aW9uKCBjLCBkYXRhICkgeyB9XG5cdFx0Ly8gYyA9IHRhYmxlLmNvbmZpZ1xuXHRcdC8vIGRhdGEuJHJvdyA9IGpRdWVyeSBvYmplY3Qgb2YgdGhlIHJvdyBjdXJyZW50bHkgYmVpbmcgcHJvY2Vzc2VkXG5cdFx0Ly8gZGF0YS4kY2VsbHMgPSBqUXVlcnkgb2JqZWN0IG9mIGFsbCBjZWxscyB3aXRoaW4gdGhlIGN1cnJlbnQgcm93XG5cdFx0Ly8gZGF0YS5maWx0ZXJzID0gYXJyYXkgb2YgZmlsdGVycyBmb3IgYWxsIGNvbHVtbnMgKCBzb21lIG1heSBiZSB1bmRlZmluZWQgKVxuXHRcdC8vIGRhdGEuZmlsdGVyID0gZmlsdGVyIGZvciB0aGUgY3VycmVudCBjb2x1bW5cblx0XHQvLyBkYXRhLmlGaWx0ZXIgPSBzYW1lIGFzIGRhdGEuZmlsdGVyLCBleGNlcHQgbG93ZXJjYXNlICggaWYgd28uZmlsdGVyX2lnbm9yZUNhc2UgaXMgdHJ1ZSApXG5cdFx0Ly8gZGF0YS5leGFjdCA9IHRhYmxlIGNlbGwgdGV4dCAoIG9yIHBhcnNlZCBkYXRhIGlmIGNvbHVtbiBwYXJzZXIgZW5hYmxlZDsgbWF5IGJlIGEgbnVtYmVyICYgbm90IGEgc3RyaW5nIClcblx0XHQvLyBkYXRhLmlFeGFjdCA9IHNhbWUgYXMgZGF0YS5leGFjdCwgZXhjZXB0IGxvd2VyY2FzZSAoIGlmIHdvLmZpbHRlcl9pZ25vcmVDYXNlIGlzIHRydWU7IG1heSBiZSBhIG51bWJlciAmIG5vdCBhIHN0cmluZyApXG5cdFx0Ly8gZGF0YS5jYWNoZSA9IHRhYmxlIGNlbGwgdGV4dCBmcm9tIGNhY2hlLCBzbyBpdCBoYXMgYmVlbiBwYXJzZWQgKCAmIGluIGFsbCBsb3dlciBjYXNlIGlmIGMuaWdub3JlQ2FzZSBpcyB0cnVlIClcblx0XHQvLyBkYXRhLmNhY2hlQXJyYXkgPSBBbiBhcnJheSBvZiBwYXJzZWQgY29udGVudCBmcm9tIGVhY2ggdGFibGUgY2VsbCBpbiB0aGUgcm93IGJlaW5nIHByb2Nlc3NlZFxuXHRcdC8vIGRhdGEuaW5kZXggPSBjb2x1bW4gaW5kZXg7IHRhYmxlID0gdGFibGUgZWxlbWVudCAoIERPTSApXG5cdFx0Ly8gZGF0YS5wYXJzZWQgPSBhcnJheSAoIGJ5IGNvbHVtbiApIG9mIGJvb2xlYW4gdmFsdWVzICggZnJvbSBmaWx0ZXJfdXNlUGFyc2VkRGF0YSBvciAnZmlsdGVyLXBhcnNlZCcgY2xhc3MgKVxuXHRcdHR5cGVzOiB7XG5cdFx0XHRvciA6IGZ1bmN0aW9uKCBjLCBkYXRhLCB2YXJzICkge1xuXHRcdFx0XHQvLyBsb29rIGZvciBcInxcIiwgYnV0IG5vdCBpZiBpdCBpcyBpbnNpZGUgb2YgYSByZWd1bGFyIGV4cHJlc3Npb25cblx0XHRcdFx0aWYgKCAoIHRzZlJlZ2V4Lm9yVGVzdC50ZXN0KCBkYXRhLmlGaWx0ZXIgKSB8fCB0c2ZSZWdleC5vclNwbGl0LnRlc3QoIGRhdGEuZmlsdGVyICkgKSAmJlxuXHRcdFx0XHRcdC8vIHRoaXMgdGVzdCBmb3IgcmVnZXggaGFzIHBvdGVudGlhbCB0byBzbG93IGRvd24gdGhlIG92ZXJhbGwgc2VhcmNoXG5cdFx0XHRcdFx0IXRzZlJlZ2V4LnJlZ2V4LnRlc3QoIGRhdGEuZmlsdGVyICkgKSB7XG5cdFx0XHRcdFx0dmFyIGluZHgsIGZpbHRlck1hdGNoZWQsIHF1ZXJ5LCByZWdleCxcblx0XHRcdFx0XHRcdC8vIGR1cGxpY2F0ZSBkYXRhIGJ1dCBzcGxpdCBmaWx0ZXJcblx0XHRcdFx0XHRcdGRhdGEyID0gJC5leHRlbmQoIHt9LCBkYXRhICksXG5cdFx0XHRcdFx0XHRmaWx0ZXIgPSBkYXRhLmZpbHRlci5zcGxpdCggdHNmUmVnZXgub3JTcGxpdCApLFxuXHRcdFx0XHRcdFx0aUZpbHRlciA9IGRhdGEuaUZpbHRlci5zcGxpdCggdHNmUmVnZXgub3JTcGxpdCApLFxuXHRcdFx0XHRcdFx0bGVuID0gZmlsdGVyLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGxlbjsgaW5keCsrICkge1xuXHRcdFx0XHRcdFx0ZGF0YTIubmVzdGVkRmlsdGVycyA9IHRydWU7XG5cdFx0XHRcdFx0XHRkYXRhMi5maWx0ZXIgPSAnJyArICggdHNmLnBhcnNlRmlsdGVyKCBjLCBmaWx0ZXJbIGluZHggXSwgZGF0YSApIHx8ICcnICk7XG5cdFx0XHRcdFx0XHRkYXRhMi5pRmlsdGVyID0gJycgKyAoIHRzZi5wYXJzZUZpbHRlciggYywgaUZpbHRlclsgaW5keCBdLCBkYXRhICkgfHwgJycgKTtcblx0XHRcdFx0XHRcdHF1ZXJ5ID0gJygnICsgKCB0c2YucGFyc2VGaWx0ZXIoIGMsIGRhdGEyLmZpbHRlciwgZGF0YSApIHx8ICcnICkgKyAnKSc7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHQvLyB1c2UgdHJ5L2NhdGNoLCBiZWNhdXNlIHF1ZXJ5IG1heSBub3QgYmUgYSB2YWxpZCByZWdleCBpZiBcInxcIiBpcyBjb250YWluZWQgd2l0aGluIGEgcGFydGlhbCByZWdleCBzZWFyY2gsXG5cdFx0XHRcdFx0XHRcdC8vIGUuZyBcIi8oQWxleHxBYXJcIiAtPiBVbmNhdWdodCBTeW50YXhFcnJvcjogSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC8oLyhBbGV4KS86IFVudGVybWluYXRlZCBncm91cFxuXHRcdFx0XHRcdFx0XHRyZWdleCA9IG5ldyBSZWdFeHAoIGRhdGEuaXNNYXRjaCA/IHF1ZXJ5IDogJ14nICsgcXVlcnkgKyAnJCcsIGMud2lkZ2V0T3B0aW9ucy5maWx0ZXJfaWdub3JlQ2FzZSA/ICdpJyA6ICcnICk7XG5cdFx0XHRcdFx0XHRcdC8vIGZpbHRlck1hdGNoZWQgPSBkYXRhMi5maWx0ZXIgPT09ICcnICYmIGluZHggPiAwID8gdHJ1ZVxuXHRcdFx0XHRcdFx0XHQvLyBsb29rIGZvciBhbiBleGFjdCBtYXRjaCB3aXRoIHRoZSAnb3InIHVubGVzcyB0aGUgJ2ZpbHRlci1tYXRjaCcgY2xhc3MgaXMgZm91bmRcblx0XHRcdFx0XHRcdFx0ZmlsdGVyTWF0Y2hlZCA9IHJlZ2V4LnRlc3QoIGRhdGEyLmV4YWN0ICkgfHwgdHNmLnByb2Nlc3NUeXBlcyggYywgZGF0YTIsIHZhcnMgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCBmaWx0ZXJNYXRjaGVkICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBmaWx0ZXJNYXRjaGVkO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBtYXkgYmUgbnVsbCBmcm9tIHByb2Nlc3NpbmcgdHlwZXNcblx0XHRcdFx0XHRyZXR1cm4gZmlsdGVyTWF0Y2hlZCB8fCBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHQvLyBMb29rIGZvciBhbiBBTkQgb3IgJiYgb3BlcmF0b3IgKCBsb2dpY2FsIGFuZCApXG5cdFx0XHRhbmQgOiBmdW5jdGlvbiggYywgZGF0YSwgdmFycyApIHtcblx0XHRcdFx0aWYgKCB0c2ZSZWdleC5hbmRUZXN0LnRlc3QoIGRhdGEuZmlsdGVyICkgKSB7XG5cdFx0XHRcdFx0dmFyIGluZHgsIGZpbHRlck1hdGNoZWQsIHJlc3VsdCwgcXVlcnksIHJlZ2V4LFxuXHRcdFx0XHRcdFx0Ly8gZHVwbGljYXRlIGRhdGEgYnV0IHNwbGl0IGZpbHRlclxuXHRcdFx0XHRcdFx0ZGF0YTIgPSAkLmV4dGVuZCgge30sIGRhdGEgKSxcblx0XHRcdFx0XHRcdGZpbHRlciA9IGRhdGEuZmlsdGVyLnNwbGl0KCB0c2ZSZWdleC5hbmRTcGxpdCApLFxuXHRcdFx0XHRcdFx0aUZpbHRlciA9IGRhdGEuaUZpbHRlci5zcGxpdCggdHNmUmVnZXguYW5kU3BsaXQgKSxcblx0XHRcdFx0XHRcdGxlbiA9IGZpbHRlci5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKyApIHtcblx0XHRcdFx0XHRcdGRhdGEyLm5lc3RlZEZpbHRlcnMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0ZGF0YTIuZmlsdGVyID0gJycgKyAoIHRzZi5wYXJzZUZpbHRlciggYywgZmlsdGVyWyBpbmR4IF0sIGRhdGEgKSB8fCAnJyApO1xuXHRcdFx0XHRcdFx0ZGF0YTIuaUZpbHRlciA9ICcnICsgKCB0c2YucGFyc2VGaWx0ZXIoIGMsIGlGaWx0ZXJbIGluZHggXSwgZGF0YSApIHx8ICcnICk7XG5cdFx0XHRcdFx0XHRxdWVyeSA9ICggJygnICsgKCB0c2YucGFyc2VGaWx0ZXIoIGMsIGRhdGEyLmZpbHRlciwgZGF0YSApIHx8ICcnICkgKyAnKScgKVxuXHRcdFx0XHRcdFx0XHQvLyByZXBsYWNlIHdpbGQgY2FyZHMgc2luY2UgLyhhKikvaSB3aWxsIG1hdGNoIGFueXRoaW5nXG5cdFx0XHRcdFx0XHRcdC5yZXBsYWNlKCB0c2ZSZWdleC53aWxkMDEsICdcXFxcU3sxfScgKS5yZXBsYWNlKCB0c2ZSZWdleC53aWxkME1vcmUsICdcXFxcUyonICk7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHQvLyB1c2UgdHJ5L2NhdGNoIGp1c3QgaW4gY2FzZSBSZWdFeHAgaXMgaW52YWxpZFxuXHRcdFx0XHRcdFx0XHRyZWdleCA9IG5ldyBSZWdFeHAoIGRhdGEuaXNNYXRjaCA/IHF1ZXJ5IDogJ14nICsgcXVlcnkgKyAnJCcsIGMud2lkZ2V0T3B0aW9ucy5maWx0ZXJfaWdub3JlQ2FzZSA/ICdpJyA6ICcnICk7XG5cdFx0XHRcdFx0XHRcdC8vIGxvb2sgZm9yIGFuIGV4YWN0IG1hdGNoIHdpdGggdGhlICdhbmQnIHVubGVzcyB0aGUgJ2ZpbHRlci1tYXRjaCcgY2xhc3MgaXMgZm91bmRcblx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gKCByZWdleC50ZXN0KCBkYXRhMi5leGFjdCApIHx8IHRzZi5wcm9jZXNzVHlwZXMoIGMsIGRhdGEyLCB2YXJzICkgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCBpbmR4ID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdGZpbHRlck1hdGNoZWQgPSByZXN1bHQ7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0ZmlsdGVyTWF0Y2hlZCA9IGZpbHRlck1hdGNoZWQgJiYgcmVzdWx0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBtYXkgYmUgbnVsbCBmcm9tIHByb2Nlc3NpbmcgdHlwZXNcblx0XHRcdFx0XHRyZXR1cm4gZmlsdGVyTWF0Y2hlZCB8fCBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHQvLyBMb29rIGZvciByZWdleFxuXHRcdFx0cmVnZXg6IGZ1bmN0aW9uKCBjLCBkYXRhICkge1xuXHRcdFx0XHRpZiAoIHRzZlJlZ2V4LnJlZ2V4LnRlc3QoIGRhdGEuZmlsdGVyICkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdFx0XHQvLyBjYWNoZSByZWdleCBwZXIgY29sdW1uIGZvciBvcHRpbWFsIHNwZWVkXG5cdFx0XHRcdFx0XHRyZWdleCA9IGRhdGEuZmlsdGVyX3JlZ2V4Q2FjaGVbIGRhdGEuaW5kZXggXSB8fCB0c2ZSZWdleC5yZWdleC5leGVjKCBkYXRhLmZpbHRlciApLFxuXHRcdFx0XHRcdFx0aXNSZWdleCA9IHJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwO1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRpZiAoICFpc1JlZ2V4ICkge1xuXHRcdFx0XHRcdFx0XHQvLyBmb3JjZSBjYXNlIGluc2Vuc2l0aXZlIHNlYXJjaCBpZiBpZ25vcmVDYXNlIG9wdGlvbiBzZXQ/XG5cdFx0XHRcdFx0XHRcdC8vIGlmICggYy5pZ25vcmVDYXNlICYmICFyZWdleFsyXSApIHsgcmVnZXhbMl0gPSAnaSc7IH1cblx0XHRcdFx0XHRcdFx0ZGF0YS5maWx0ZXJfcmVnZXhDYWNoZVsgZGF0YS5pbmRleCBdID0gcmVnZXggPSBuZXcgUmVnRXhwKCByZWdleFsxXSwgcmVnZXhbMl0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoZXMgPSByZWdleC50ZXN0KCBkYXRhLmV4YWN0ICk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlcyA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlcztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHQvLyBMb29rIGZvciBvcGVyYXRvcnMgPiwgPj0sIDwgb3IgPD1cblx0XHRcdG9wZXJhdG9yczogZnVuY3Rpb24oIGMsIGRhdGEgKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzLi4uIGJlY2F1c2UgJycgPCAxMCBpcyB0cnVlXG5cdFx0XHRcdGlmICggdHNmUmVnZXgub3BlclRlc3QudGVzdCggZGF0YS5pRmlsdGVyICkgJiYgZGF0YS5pRXhhY3QgIT09ICcnICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZWRWYWx1ZSwgcmVzdWx0LCB0eHQsXG5cdFx0XHRcdFx0XHR0YWJsZSA9IGMudGFibGUsXG5cdFx0XHRcdFx0XHRwYXJzZWQgPSBkYXRhLnBhcnNlZFsgZGF0YS5pbmRleCBdLFxuXHRcdFx0XHRcdFx0cXVlcnkgPSB0cy5mb3JtYXRGbG9hdCggZGF0YS5pRmlsdGVyLnJlcGxhY2UoIHRzZlJlZ2V4Lm9wZXJhdG9ycywgJycgKSwgdGFibGUgKSxcblx0XHRcdFx0XHRcdHBhcnNlciA9IGMucGFyc2Vyc1sgZGF0YS5pbmRleCBdIHx8IHt9LFxuXHRcdFx0XHRcdFx0c2F2ZWRTZWFyY2ggPSBxdWVyeTtcblx0XHRcdFx0XHQvLyBwYXJzZSBmaWx0ZXIgdmFsdWUgaW4gY2FzZSB3ZSdyZSBjb21wYXJpbmcgbnVtYmVycyAoIGRhdGVzIClcblx0XHRcdFx0XHRpZiAoIHBhcnNlZCB8fCBwYXJzZXIudHlwZSA9PT0gJ251bWVyaWMnICkge1xuXHRcdFx0XHRcdFx0dHh0ID0gJC50cmltKCAnJyArIGRhdGEuaUZpbHRlci5yZXBsYWNlKCB0c2ZSZWdleC5vcGVyYXRvcnMsICcnICkgKTtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHRzZi5wYXJzZUZpbHRlciggYywgdHh0LCBkYXRhLCB0cnVlICk7XG5cdFx0XHRcdFx0XHRxdWVyeSA9ICggdHlwZW9mIHJlc3VsdCA9PT0gJ251bWJlcicgJiYgcmVzdWx0ICE9PSAnJyAmJiAhaXNOYU4oIHJlc3VsdCApICkgPyByZXN1bHQgOiBxdWVyeTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gaUV4YWN0IG1heSBiZSBudW1lcmljIC0gc2VlIGlzc3VlICMxNDk7XG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgY2FjaGVkIGlzIGRlZmluZWQsIGJlY2F1c2Ugc29tZXRpbWVzIGogZ29lcyBvdXQgb2YgcmFuZ2U/ICggbnVtZXJpYyBjb2x1bW5zIClcblx0XHRcdFx0XHRpZiAoICggcGFyc2VkIHx8IHBhcnNlci50eXBlID09PSAnbnVtZXJpYycgKSAmJiAhaXNOYU4oIHF1ZXJ5ICkgJiZcblx0XHRcdFx0XHRcdHR5cGVvZiBkYXRhLmNhY2hlICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdFx0XHRcdGNhY2hlZFZhbHVlID0gZGF0YS5jYWNoZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHh0ID0gaXNOYU4oIGRhdGEuaUV4YWN0ICkgPyBkYXRhLmlFeGFjdC5yZXBsYWNlKCB0cy5yZWdleC5ub25kaWdpdCwgJycgKSA6IGRhdGEuaUV4YWN0O1xuXHRcdFx0XHRcdFx0Y2FjaGVkVmFsdWUgPSB0cy5mb3JtYXRGbG9hdCggdHh0LCB0YWJsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHRzZlJlZ2V4Lmd0VGVzdC50ZXN0KCBkYXRhLmlGaWx0ZXIgKSApIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHRzZlJlZ2V4Lmd0ZVRlc3QudGVzdCggZGF0YS5pRmlsdGVyICkgPyBjYWNoZWRWYWx1ZSA+PSBxdWVyeSA6IGNhY2hlZFZhbHVlID4gcXVlcnk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdHNmUmVnZXgubHRUZXN0LnRlc3QoIGRhdGEuaUZpbHRlciApICkge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0gdHNmUmVnZXgubHRlVGVzdC50ZXN0KCBkYXRhLmlGaWx0ZXIgKSA/IGNhY2hlZFZhbHVlIDw9IHF1ZXJ5IDogY2FjaGVkVmFsdWUgPCBxdWVyeTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8ga2VlcCBzaG93aW5nIGFsbCByb3dzIGlmIG5vdGhpbmcgZm9sbG93cyB0aGUgb3BlcmF0b3Jcblx0XHRcdFx0XHRpZiAoICFyZXN1bHQgJiYgc2F2ZWRTZWFyY2ggPT09ICcnICkge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHQvLyBMb29rIGZvciBhIG5vdCBtYXRjaFxuXHRcdFx0bm90TWF0Y2g6IGZ1bmN0aW9uKCBjLCBkYXRhICkge1xuXHRcdFx0XHRpZiAoIHRzZlJlZ2V4Lm5vdFRlc3QudGVzdCggZGF0YS5pRmlsdGVyICkgKSB7XG5cdFx0XHRcdFx0dmFyIGluZHgsXG5cdFx0XHRcdFx0XHR0eHQgPSBkYXRhLmlGaWx0ZXIucmVwbGFjZSggJyEnLCAnJyApLFxuXHRcdFx0XHRcdFx0ZmlsdGVyID0gdHNmLnBhcnNlRmlsdGVyKCBjLCB0eHQsIGRhdGEgKSB8fCAnJztcblx0XHRcdFx0XHRpZiAoIHRzZlJlZ2V4LmV4YWN0LnRlc3QoIGZpbHRlciApICkge1xuXHRcdFx0XHRcdFx0Ly8gbG9vayBmb3IgZXhhY3Qgbm90IG1hdGNoZXMgLSBzZWUgIzYyOFxuXHRcdFx0XHRcdFx0ZmlsdGVyID0gZmlsdGVyLnJlcGxhY2UoIHRzZlJlZ2V4LmV4YWN0LCAnJyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZpbHRlciA9PT0gJycgPyB0cnVlIDogJC50cmltKCBmaWx0ZXIgKSAhPT0gZGF0YS5pRXhhY3Q7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGluZHggPSBkYXRhLmlFeGFjdC5zZWFyY2goICQudHJpbSggZmlsdGVyICkgKTtcblx0XHRcdFx0XHRcdHJldHVybiBmaWx0ZXIgPT09ICcnID8gdHJ1ZSA6XG5cdFx0XHRcdFx0XHRcdC8vIHJldHVybiB0cnVlIGlmIG5vdCBmb3VuZFxuXHRcdFx0XHRcdFx0XHRkYXRhLmFueU1hdGNoID8gaW5keCA8IDAgOlxuXHRcdFx0XHRcdFx0XHQvLyByZXR1cm4gZmFsc2UgaWYgZm91bmRcblx0XHRcdFx0XHRcdFx0ISggYy53aWRnZXRPcHRpb25zLmZpbHRlcl9zdGFydHNXaXRoID8gaW5keCA9PT0gMCA6IGluZHggPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHQvLyBMb29rIGZvciBxdW90ZXMgb3IgZXF1YWxzIHRvIGdldCBhbiBleGFjdCBtYXRjaDsgaWdub3JlIHR5cGUgc2luY2UgaUV4YWN0IGNvdWxkIGJlIG51bWVyaWNcblx0XHRcdGV4YWN0OiBmdW5jdGlvbiggYywgZGF0YSApIHtcblx0XHRcdFx0Lypqc2hpbnQgZXFlcWVxOmZhbHNlICovXG5cdFx0XHRcdGlmICggdHNmUmVnZXguZXhhY3QudGVzdCggZGF0YS5pRmlsdGVyICkgKSB7XG5cdFx0XHRcdFx0dmFyIHR4dCA9IGRhdGEuaUZpbHRlci5yZXBsYWNlKCB0c2ZSZWdleC5leGFjdCwgJycgKSxcblx0XHRcdFx0XHRcdGZpbHRlciA9IHRzZi5wYXJzZUZpbHRlciggYywgdHh0LCBkYXRhICkgfHwgJyc7XG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRcdHJldHVybiBkYXRhLmFueU1hdGNoID8gJC5pbkFycmF5KCBmaWx0ZXIsIGRhdGEucm93QXJyYXkgKSA+PSAwIDogZmlsdGVyID09IGRhdGEuaUV4YWN0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSxcblx0XHRcdC8vIExvb2sgZm9yIGEgcmFuZ2UgKCB1c2luZyAnIHRvICcgb3IgJyAtICcgKSAtIHNlZSBpc3N1ZSAjMTY2OyB0aGFua3MgbWF0emh1IVxuXHRcdFx0cmFuZ2UgOiBmdW5jdGlvbiggYywgZGF0YSApIHtcblx0XHRcdFx0aWYgKCB0c2ZSZWdleC50b1Rlc3QudGVzdCggZGF0YS5pRmlsdGVyICkgKSB7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCwgdG1wLCByYW5nZTEsIHJhbmdlMixcblx0XHRcdFx0XHRcdHRhYmxlID0gYy50YWJsZSxcblx0XHRcdFx0XHRcdGluZGV4ID0gZGF0YS5pbmRleCxcblx0XHRcdFx0XHRcdHBhcnNlZCA9IGRhdGEucGFyc2VkW2luZGV4XSxcblx0XHRcdFx0XHRcdC8vIG1ha2Ugc3VyZSB0aGUgZGFzaCBpcyBmb3IgYSByYW5nZSBhbmQgbm90IGluZGljYXRpbmcgYSBuZWdhdGl2ZSBudW1iZXJcblx0XHRcdFx0XHRcdHF1ZXJ5ID0gZGF0YS5pRmlsdGVyLnNwbGl0KCB0c2ZSZWdleC50b1NwbGl0ICk7XG5cblx0XHRcdFx0XHR0bXAgPSBxdWVyeVswXS5yZXBsYWNlKCB0cy5yZWdleC5ub25kaWdpdCwgJycgKSB8fCAnJztcblx0XHRcdFx0XHRyYW5nZTEgPSB0cy5mb3JtYXRGbG9hdCggdHNmLnBhcnNlRmlsdGVyKCBjLCB0bXAsIGRhdGEgKSwgdGFibGUgKTtcblx0XHRcdFx0XHR0bXAgPSBxdWVyeVsxXS5yZXBsYWNlKCB0cy5yZWdleC5ub25kaWdpdCwgJycgKSB8fCAnJztcblx0XHRcdFx0XHRyYW5nZTIgPSB0cy5mb3JtYXRGbG9hdCggdHNmLnBhcnNlRmlsdGVyKCBjLCB0bXAsIGRhdGEgKSwgdGFibGUgKTtcblx0XHRcdFx0XHQvLyBwYXJzZSBmaWx0ZXIgdmFsdWUgaW4gY2FzZSB3ZSdyZSBjb21wYXJpbmcgbnVtYmVycyAoIGRhdGVzIClcblx0XHRcdFx0XHRpZiAoIHBhcnNlZCB8fCBjLnBhcnNlcnNbIGluZGV4IF0udHlwZSA9PT0gJ251bWVyaWMnICkge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0gYy5wYXJzZXJzWyBpbmRleCBdLmZvcm1hdCggJycgKyBxdWVyeVswXSwgdGFibGUsIGMuJGhlYWRlcnMuZXEoIGluZGV4ICksIGluZGV4ICk7XG5cdFx0XHRcdFx0XHRyYW5nZTEgPSAoIHJlc3VsdCAhPT0gJycgJiYgIWlzTmFOKCByZXN1bHQgKSApID8gcmVzdWx0IDogcmFuZ2UxO1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0gYy5wYXJzZXJzWyBpbmRleCBdLmZvcm1hdCggJycgKyBxdWVyeVsxXSwgdGFibGUsIGMuJGhlYWRlcnMuZXEoIGluZGV4ICksIGluZGV4ICk7XG5cdFx0XHRcdFx0XHRyYW5nZTIgPSAoIHJlc3VsdCAhPT0gJycgJiYgIWlzTmFOKCByZXN1bHQgKSApID8gcmVzdWx0IDogcmFuZ2UyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICggcGFyc2VkIHx8IGMucGFyc2Vyc1sgaW5kZXggXS50eXBlID09PSAnbnVtZXJpYycgKSAmJiAhaXNOYU4oIHJhbmdlMSApICYmICFpc05hTiggcmFuZ2UyICkgKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSBkYXRhLmNhY2hlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0bXAgPSBpc05hTiggZGF0YS5pRXhhY3QgKSA/IGRhdGEuaUV4YWN0LnJlcGxhY2UoIHRzLnJlZ2V4Lm5vbmRpZ2l0LCAnJyApIDogZGF0YS5pRXhhY3Q7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB0cy5mb3JtYXRGbG9hdCggdG1wLCB0YWJsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHJhbmdlMSA+IHJhbmdlMiApIHtcblx0XHRcdFx0XHRcdHRtcCA9IHJhbmdlMTsgcmFuZ2UxID0gcmFuZ2UyOyByYW5nZTIgPSB0bXA7IC8vIHN3YXBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuICggcmVzdWx0ID49IHJhbmdlMSAmJiByZXN1bHQgPD0gcmFuZ2UyICkgfHwgKCByYW5nZTEgPT09ICcnIHx8IHJhbmdlMiA9PT0gJycgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHQvLyBMb29rIGZvciB3aWxkIGNhcmQ6ID8gPSBzaW5nbGUsICogPSBtdWx0aXBsZSwgb3IgfCA9IGxvZ2ljYWwgT1Jcblx0XHRcdHdpbGQgOiBmdW5jdGlvbiggYywgZGF0YSApIHtcblx0XHRcdFx0aWYgKCB0c2ZSZWdleC53aWxkT3JUZXN0LnRlc3QoIGRhdGEuaUZpbHRlciApICkge1xuXHRcdFx0XHRcdHZhciBxdWVyeSA9ICcnICsgKCB0c2YucGFyc2VGaWx0ZXIoIGMsIGRhdGEuaUZpbHRlciwgZGF0YSApIHx8ICcnICk7XG5cdFx0XHRcdFx0Ly8gbG9vayBmb3IgYW4gZXhhY3QgbWF0Y2ggd2l0aCB0aGUgJ29yJyB1bmxlc3MgdGhlICdmaWx0ZXItbWF0Y2gnIGNsYXNzIGlzIGZvdW5kXG5cdFx0XHRcdFx0aWYgKCAhdHNmUmVnZXgud2lsZFRlc3QudGVzdCggcXVlcnkgKSAmJiBkYXRhLm5lc3RlZEZpbHRlcnMgKSB7XG5cdFx0XHRcdFx0XHRxdWVyeSA9IGRhdGEuaXNNYXRjaCA/IHF1ZXJ5IDogJ14oJyArIHF1ZXJ5ICsgJykkJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gcGFyc2luZyB0aGUgZmlsdGVyIG1heSBub3Qgd29yayBwcm9wZXJseSB3aGVuIHVzaW5nIHdpbGRjYXJkcyA9L1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFJlZ0V4cChcblx0XHRcdFx0XHRcdFx0cXVlcnkucmVwbGFjZSggdHNmUmVnZXgud2lsZDAxLCAnXFxcXFN7MX0nICkucmVwbGFjZSggdHNmUmVnZXgud2lsZDBNb3JlLCAnXFxcXFMqJyApLFxuXHRcdFx0XHRcdFx0XHRjLndpZGdldE9wdGlvbnMuZmlsdGVyX2lnbm9yZUNhc2UgPyAnaScgOiAnJ1xuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0LnRlc3QoIGRhdGEuZXhhY3QgKTtcblx0XHRcdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gZnV6enkgdGV4dCBzZWFyY2g7IG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hdHR5b3JrL2Z1enp5ICggTUlUIGxpY2Vuc2UgKVxuXHRcdFx0ZnV6enk6IGZ1bmN0aW9uKCBjLCBkYXRhICkge1xuXHRcdFx0XHRpZiAoIHRzZlJlZ2V4LmZ1enp5VGVzdC50ZXN0KCBkYXRhLmlGaWx0ZXIgKSApIHtcblx0XHRcdFx0XHR2YXIgaW5keCxcblx0XHRcdFx0XHRcdHBhdHRlcm5JbmR4ID0gMCxcblx0XHRcdFx0XHRcdGxlbiA9IGRhdGEuaUV4YWN0Lmxlbmd0aCxcblx0XHRcdFx0XHRcdHR4dCA9IGRhdGEuaUZpbHRlci5zbGljZSggMSApLFxuXHRcdFx0XHRcdFx0cGF0dGVybiA9IHRzZi5wYXJzZUZpbHRlciggYywgdHh0LCBkYXRhICkgfHwgJyc7XG5cdFx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKyApIHtcblx0XHRcdFx0XHRcdGlmICggZGF0YS5pRXhhY3RbIGluZHggXSA9PT0gcGF0dGVyblsgcGF0dGVybkluZHggXSApIHtcblx0XHRcdFx0XHRcdFx0cGF0dGVybkluZHggKz0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm5JbmR4ID09PSBwYXR0ZXJuLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGluaXQ6IGZ1bmN0aW9uKCB0YWJsZSApIHtcblx0XHRcdC8vIGZpbHRlciBsYW5ndWFnZSBvcHRpb25zXG5cdFx0XHR0cy5sYW5ndWFnZSA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwge1xuXHRcdFx0XHR0byAgOiAndG8nLFxuXHRcdFx0XHRvciAgOiAnb3InLFxuXHRcdFx0XHRhbmQgOiAnYW5kJ1xuXHRcdFx0fSwgdHMubGFuZ3VhZ2UgKTtcblxuXHRcdFx0dmFyIG9wdGlvbnMsIHN0cmluZywgdHh0LCAkaGVhZGVyLCBjb2x1bW4sIHZhbCwgZnhuLCBub1NlbGVjdCxcblx0XHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdFx0d28gPSBjLndpZGdldE9wdGlvbnMsXG5cdFx0XHRcdHByb2Nlc3NTdHIgPSBmdW5jdGlvbihwcmVmaXgsIHN0ciwgc3VmZml4KSB7XG5cdFx0XHRcdFx0c3RyID0gc3RyLnRyaW0oKTtcblx0XHRcdFx0XHQvLyBkb24ndCBpbmNsdWRlIHByZWZpeC9zdWZmaXggaWYgc3RyIGlzIGVtcHR5XG5cdFx0XHRcdFx0cmV0dXJuIHN0ciA9PT0gJycgPyAnJyA6IChwcmVmaXggfHwgJycpICsgc3RyICsgKHN1ZmZpeCB8fCAnJyk7XG5cdFx0XHRcdH07XG5cdFx0XHRjLiR0YWJsZS5hZGRDbGFzcyggJ2hhc0ZpbHRlcnMnICk7XG5cdFx0XHRjLmxhc3RTZWFyY2ggPSBbXTtcblxuXHRcdFx0Ly8gZGVmaW5lIHRpbWVycyBzbyB1c2luZyBjbGVhclRpbWVvdXQgd29uJ3QgY2F1c2UgYW4gdW5kZWZpbmVkIGVycm9yXG5cdFx0XHR3by5maWx0ZXJfc2VhcmNoVGltZXIgPSBudWxsO1xuXHRcdFx0d28uZmlsdGVyX2luaXRUaW1lciA9IG51bGw7XG5cdFx0XHR3by5maWx0ZXJfZm9ybWF0dGVyQ291bnQgPSAwO1xuXHRcdFx0d28uZmlsdGVyX2Zvcm1hdHRlckluaXQgPSBbXTtcblx0XHRcdHdvLmZpbHRlcl9hbnlDb2x1bW5TZWxlY3RvciA9ICdbZGF0YS1jb2x1bW49XCJhbGxcIl0sW2RhdGEtY29sdW1uPVwiYW55XCJdJztcblx0XHRcdHdvLmZpbHRlcl9tdWx0aXBsZUNvbHVtblNlbGVjdG9yID0gJ1tkYXRhLWNvbHVtbio9XCItXCJdLFtkYXRhLWNvbHVtbio9XCIsXCJdJztcblxuXHRcdFx0dmFsID0gJ1xcXFx7JyArIHRzZlJlZ2V4LnF1ZXJ5ICsgJ1xcXFx9Jztcblx0XHRcdCQuZXh0ZW5kKCB0c2ZSZWdleCwge1xuXHRcdFx0XHRjaGlsZCA6IG5ldyBSZWdFeHAoIGMuY3NzQ2hpbGRSb3cgKSxcblx0XHRcdFx0ZmlsdGVyZWQgOiBuZXcgUmVnRXhwKCB3by5maWx0ZXJfZmlsdGVyZWRSb3cgKSxcblx0XHRcdFx0YWxyZWFkeUZpbHRlcmVkIDogbmV3IFJlZ0V4cCggJyhcXFxccysoLScgKyBwcm9jZXNzU3RyKCd8JywgdHMubGFuZ3VhZ2Uub3IpICsgcHJvY2Vzc1N0cignfCcsIHRzLmxhbmd1YWdlLnRvKSArICcpXFxcXHMrKScsICdpJyApLFxuXHRcdFx0XHR0b1Rlc3QgOiBuZXcgUmVnRXhwKCAnXFxcXHMrKC0nICsgcHJvY2Vzc1N0cignfCcsIHRzLmxhbmd1YWdlLnRvKSArICcpXFxcXHMrJywgJ2knICksXG5cdFx0XHRcdHRvU3BsaXQgOiBuZXcgUmVnRXhwKCAnKD86XFxcXHMrKD86LScgKyBwcm9jZXNzU3RyKCd8JywgdHMubGFuZ3VhZ2UudG8pICsgJylcXFxccyspJywgJ2dpJyApLFxuXHRcdFx0XHRhbmRUZXN0IDogbmV3IFJlZ0V4cCggJ1xcXFxzKygnICsgcHJvY2Vzc1N0cignJywgdHMubGFuZ3VhZ2UuYW5kLCAnfCcpICsgJyYmKVxcXFxzKycsICdpJyApLFxuXHRcdFx0XHRhbmRTcGxpdCA6IG5ldyBSZWdFeHAoICcoPzpcXFxccysoPzonICsgcHJvY2Vzc1N0cignJywgdHMubGFuZ3VhZ2UuYW5kLCAnfCcpICsgJyYmKVxcXFxzKyknLCAnZ2knICksXG5cdFx0XHRcdG9yVGVzdCA6IG5ldyBSZWdFeHAoICcoXFxcXHwnICsgcHJvY2Vzc1N0cignfFxcXFxzKycsIHRzLmxhbmd1YWdlLm9yLCAnXFxcXHMrJykgKyAnKScsICdpJyApLFxuXHRcdFx0XHRvclNwbGl0IDogbmV3IFJlZ0V4cCggJyg/OlxcXFx8JyArIHByb2Nlc3NTdHIoJ3xcXFxccysoPzonLCB0cy5sYW5ndWFnZS5vciwgJylcXFxccysnKSArICcpJywgJ2dpJyApLFxuXHRcdFx0XHRpUXVlcnkgOiBuZXcgUmVnRXhwKCB2YWwsICdpJyApLFxuXHRcdFx0XHRpZ1F1ZXJ5IDogbmV3IFJlZ0V4cCggdmFsLCAnaWcnICksXG5cdFx0XHRcdG9wZXJUZXN0IDogL15bPD5dPT8vLFxuXHRcdFx0XHRndFRlc3QgIDogLz4vLFxuXHRcdFx0XHRndGVUZXN0IDogLz49Lyxcblx0XHRcdFx0bHRUZXN0ICA6IC88Lyxcblx0XHRcdFx0bHRlVGVzdCA6IC88PS8sXG5cdFx0XHRcdG5vdFRlc3QgOiAvXlxcIS8sXG5cdFx0XHRcdHdpbGRPclRlc3QgOiAvW1xcP1xcKlxcfF0vLFxuXHRcdFx0XHR3aWxkVGVzdCA6IC9cXD9cXCovLFxuXHRcdFx0XHRmdXp6eVRlc3QgOiAvXn4vLFxuXHRcdFx0XHRleGFjdFRlc3QgOiAvWz1cXFwiXFx8IV0vXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gZG9uJ3QgYnVpbGQgZmlsdGVyIHJvdyBpZiBjb2x1bW5GaWx0ZXJzIGlzIGZhbHNlIG9yIGFsbCBjb2x1bW5zIGFyZSBzZXQgdG8gJ2ZpbHRlci1mYWxzZSdcblx0XHRcdC8vIHNlZSBpc3N1ZSAjMTU2XG5cdFx0XHR2YWwgPSBjLiRoZWFkZXJzLmZpbHRlciggJy5maWx0ZXItZmFsc2UsIC5wYXJzZXItZmFsc2UnICkubGVuZ3RoO1xuXHRcdFx0aWYgKCB3by5maWx0ZXJfY29sdW1uRmlsdGVycyAhPT0gZmFsc2UgJiYgdmFsICE9PSBjLiRoZWFkZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0Ly8gYnVpbGQgZmlsdGVyIHJvd1xuXHRcdFx0XHR0c2YuYnVpbGRSb3coIHRhYmxlLCBjLCB3byApO1xuXHRcdFx0fVxuXG5cdFx0XHR0eHQgPSAnYWRkUm93cyB1cGRhdGVDZWxsIHVwZGF0ZSB1cGRhdGVSb3dzIHVwZGF0ZUNvbXBsZXRlIGFwcGVuZENhY2hlIGZpbHRlclJlc2V0ICcgK1xuXHRcdFx0XHQnZmlsdGVyQW5kU29ydFJlc2V0IGZpbHRlclJlc2V0U2F2ZWQgZmlsdGVyRW5kIHNlYXJjaCAnLnNwbGl0KCAnICcgKS5qb2luKCBjLm5hbWVzcGFjZSArICdmaWx0ZXIgJyApO1xuXHRcdFx0Yy4kdGFibGUuYmluZCggdHh0LCBmdW5jdGlvbiggZXZlbnQsIGZpbHRlciApIHtcblx0XHRcdFx0dmFsID0gd28uZmlsdGVyX2hpZGVFbXB0eSAmJlxuXHRcdFx0XHRcdCQuaXNFbXB0eU9iamVjdCggYy5jYWNoZSApICYmXG5cdFx0XHRcdFx0ISggYy5kZWxheUluaXQgJiYgZXZlbnQudHlwZSA9PT0gJ2FwcGVuZENhY2hlJyApO1xuXHRcdFx0XHQvLyBoaWRlIGZpbHRlciByb3cgdXNpbmcgdGhlICdmaWx0ZXJlZCcgY2xhc3MgbmFtZVxuXHRcdFx0XHRjLiR0YWJsZS5maW5kKCAnLicgKyB0c2Nzcy5maWx0ZXJSb3cgKS50b2dnbGVDbGFzcyggd28uZmlsdGVyX2ZpbHRlcmVkUm93LCB2YWwgKTsgLy8gZml4ZXMgIzQ1MFxuXHRcdFx0XHRpZiAoICEvKHNlYXJjaHxmaWx0ZXIpLy50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0dHNmLmJ1aWxkRGVmYXVsdCggdGFibGUsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBBZGQgZmlsdGVyQW5kU29ydFJlc2V0IC0gc2VlICMxMzYxXG5cdFx0XHRcdGlmICggZXZlbnQudHlwZSA9PT0gJ2ZpbHRlclJlc2V0JyB8fCBldmVudC50eXBlID09PSAnZmlsdGVyQW5kU29ydFJlc2V0JyApIHtcblx0XHRcdFx0XHRjLiR0YWJsZS5maW5kKCAnLicgKyB0c2Nzcy5maWx0ZXIgKS5hZGQoIHdvLmZpbHRlcl8kZXh0ZXJuYWxGaWx0ZXJzICkudmFsKCAnJyApO1xuXHRcdFx0XHRcdGlmICggZXZlbnQudHlwZSA9PT0gJ2ZpbHRlckFuZFNvcnRSZXNldCcgKSB7XG5cdFx0XHRcdFx0XHR0cy5zb3J0UmVzZXQoIHRoaXMuY29uZmlnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dHNmLnNlYXJjaGluZyggdGFibGUsIFtdICk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHNmLnNlYXJjaGluZyggdGFibGUsIFtdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBldmVudC50eXBlID09PSAnZmlsdGVyUmVzZXRTYXZlZCcgKSB7XG5cdFx0XHRcdFx0dHMuc3RvcmFnZSggdGFibGUsICd0YWJsZXNvcnRlci1maWx0ZXJzJywgJycgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggZXZlbnQudHlwZSA9PT0gJ2ZpbHRlckVuZCcgKSB7XG5cdFx0XHRcdFx0dHNmLmJ1aWxkRGVmYXVsdCggdGFibGUsIHRydWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBzZW5kIGZhbHNlIGFyZ3VtZW50IHRvIGZvcmNlIGEgbmV3IHNlYXJjaDsgb3RoZXJ3aXNlIGlmIHRoZSBmaWx0ZXIgaGFzbid0IGNoYW5nZWQsXG5cdFx0XHRcdFx0Ly8gaXQgd2lsbCByZXR1cm5cblx0XHRcdFx0XHRmaWx0ZXIgPSBldmVudC50eXBlID09PSAnc2VhcmNoJyA/IGZpbHRlciA6XG5cdFx0XHRcdFx0XHRldmVudC50eXBlID09PSAndXBkYXRlQ29tcGxldGUnID8gYy4kdGFibGUuZGF0YSggJ2xhc3RTZWFyY2gnICkgOiAnJztcblx0XHRcdFx0XHRpZiAoIC8odXBkYXRlfGFkZCkvLnRlc3QoIGV2ZW50LnR5cGUgKSAmJiBldmVudC50eXBlICE9PSAndXBkYXRlQ29tcGxldGUnICkge1xuXHRcdFx0XHRcdFx0Ly8gZm9yY2UgYSBuZXcgc2VhcmNoIHNpbmNlIGNvbnRlbnQgaGFzIGNoYW5nZWRcblx0XHRcdFx0XHRcdGMubGFzdENvbWJpbmVkRmlsdGVyID0gbnVsbDtcblx0XHRcdFx0XHRcdGMubGFzdFNlYXJjaCA9IFtdO1xuXHRcdFx0XHRcdFx0Ly8gdXBkYXRlIGZpbHRlckZvcm1hdHRlcnMgYWZ0ZXIgdXBkYXRlICgmIHNtYWxsIGRlbGF5KSAtIEZpeGVzICMxMjM3XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRjLiR0YWJsZS50cmlnZ2VySGFuZGxlciggJ2ZpbHRlckZvbWF0dGVyVXBkYXRlJyApO1xuXHRcdFx0XHRcdFx0fSwgMTAwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gcGFzcyB0cnVlICggc2tpcEZpcnN0ICkgdG8gcHJldmVudCB0aGUgdGFibGVzb3J0ZXIuc2V0RmlsdGVycyBmdW5jdGlvbiBmcm9tIHNraXBwaW5nIHRoZSBmaXJzdFxuXHRcdFx0XHRcdC8vIGlucHV0IGVuc3VyZXMgYWxsIGlucHV0cyBhcmUgdXBkYXRlZCB3aGVuIGEgc2VhcmNoIGlzIHRyaWdnZXJlZCBvbiB0aGUgdGFibGVcblx0XHRcdFx0XHQvLyAkKCAndGFibGUnICkudHJpZ2dlciggJ3NlYXJjaCcsIFsuLi5dICk7XG5cdFx0XHRcdFx0dHNmLnNlYXJjaGluZyggdGFibGUsIGZpbHRlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyByZXNldCBidXR0b24vbGlua1xuXHRcdFx0aWYgKCB3by5maWx0ZXJfcmVzZXQgKSB7XG5cdFx0XHRcdGlmICggd28uZmlsdGVyX3Jlc2V0IGluc3RhbmNlb2YgJCApIHtcblx0XHRcdFx0XHQvLyByZXNldCBjb250YWlucyBhIGpRdWVyeSBvYmplY3QsIGJpbmQgdG8gaXRcblx0XHRcdFx0XHR3by5maWx0ZXJfcmVzZXQuY2xpY2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoICdmaWx0ZXJSZXNldCcgKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIGlmICggJCggd28uZmlsdGVyX3Jlc2V0ICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdC8vIHJlc2V0IGlzIGEgalF1ZXJ5IHNlbGVjdG9yLCB1c2UgZXZlbnQgZGVsZWdhdGlvblxuXHRcdFx0XHRcdCQoIGRvY3VtZW50IClcblx0XHRcdFx0XHRcdC51bmRlbGVnYXRlKCB3by5maWx0ZXJfcmVzZXQsICdjbGljaycgKyBjLm5hbWVzcGFjZSArICdmaWx0ZXInIClcblx0XHRcdFx0XHRcdC5kZWxlZ2F0ZSggd28uZmlsdGVyX3Jlc2V0LCAnY2xpY2snICsgYy5uYW1lc3BhY2UgKyAnZmlsdGVyJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHRyaWdnZXIgYSByZXNldCBldmVudCwgc28gb3RoZXIgZnVuY3Rpb25zICggZmlsdGVyX2Zvcm1hdHRlciApIGtub3cgd2hlbiB0byByZXNldFxuXHRcdFx0XHRcdFx0XHRjLiR0YWJsZS50cmlnZ2VySGFuZGxlciggJ2ZpbHRlclJlc2V0JyApO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggd28uZmlsdGVyX2Z1bmN0aW9ucyApIHtcblx0XHRcdFx0Zm9yICggY29sdW1uID0gMDsgY29sdW1uIDwgYy5jb2x1bW5zOyBjb2x1bW4rKyApIHtcblx0XHRcdFx0XHRmeG4gPSB0cy5nZXRDb2x1bW5EYXRhKCB0YWJsZSwgd28uZmlsdGVyX2Z1bmN0aW9ucywgY29sdW1uICk7XG5cdFx0XHRcdFx0aWYgKCBmeG4gKSB7XG5cdFx0XHRcdFx0XHQvLyByZW1vdmUgJ2ZpbHRlci1zZWxlY3QnIGZyb20gaGVhZGVyIG90aGVyd2lzZSB0aGUgb3B0aW9ucyBhZGRlZCBoZXJlIGFyZSByZXBsYWNlZCB3aXRoXG5cdFx0XHRcdFx0XHQvLyBhbGwgb3B0aW9uc1xuXHRcdFx0XHRcdFx0JGhlYWRlciA9IGMuJGhlYWRlckluZGV4ZWRbIGNvbHVtbiBdLnJlbW92ZUNsYXNzKCAnZmlsdGVyLXNlbGVjdCcgKTtcblx0XHRcdFx0XHRcdC8vIGRvbid0IGJ1aWxkIHNlbGVjdCBpZiAnZmlsdGVyLWZhbHNlJyBvciAncGFyc2VyLWZhbHNlJyBzZXRcblx0XHRcdFx0XHRcdG5vU2VsZWN0ID0gISggJGhlYWRlci5oYXNDbGFzcyggJ2ZpbHRlci1mYWxzZScgKSB8fCAkaGVhZGVyLmhhc0NsYXNzKCAncGFyc2VyLWZhbHNlJyApICk7XG5cdFx0XHRcdFx0XHRvcHRpb25zID0gJyc7XG5cdFx0XHRcdFx0XHRpZiAoIGZ4biA9PT0gdHJ1ZSAmJiBub1NlbGVjdCApIHtcblx0XHRcdFx0XHRcdFx0dHNmLmJ1aWxkU2VsZWN0KCB0YWJsZSwgY29sdW1uICk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgZnhuID09PSAnb2JqZWN0JyAmJiBub1NlbGVjdCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gYWRkIGN1c3RvbSBkcm9wIGRvd24gbGlzdFxuXHRcdFx0XHRcdFx0XHRmb3IgKCBzdHJpbmcgaW4gZnhuICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zICs9IG9wdGlvbnMgPT09ICcnID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0JzxvcHRpb24gdmFsdWU9XCJcIj4nICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoICRoZWFkZXIuZGF0YSggJ3BsYWNlaG9sZGVyJyApIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkaGVhZGVyLmF0dHIoICdkYXRhLXBsYWNlaG9sZGVyJyApIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3by5maWx0ZXJfcGxhY2Vob2xkZXIuc2VsZWN0IHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQnJ1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCkgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQnPC9vcHRpb24+JyA6ICcnO1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFsID0gc3RyaW5nO1xuXHRcdFx0XHRcdFx0XHRcdFx0dHh0ID0gc3RyaW5nO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzdHJpbmcuaW5kZXhPZiggd28uZmlsdGVyX3NlbGVjdFNvdXJjZVNlcGFyYXRvciApID49IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhbCA9IHN0cmluZy5zcGxpdCggd28uZmlsdGVyX3NlbGVjdFNvdXJjZVNlcGFyYXRvciApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eHQgPSB2YWxbMV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhbCA9IHZhbFswXTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMgKz0gJzxvcHRpb24gJyArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHh0ID09PSB2YWwgPyAnJyA6ICdkYXRhLWZ1bmN0aW9uLW5hbWU9XCInICsgc3RyaW5nICsgJ1wiICcgKSArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCd2YWx1ZT1cIicgKyB2YWwgKyAnXCI+JyArIHR4dCArICc8L29wdGlvbj4nO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjLiR0YWJsZVxuXHRcdFx0XHRcdFx0XHRcdC5maW5kKCAndGhlYWQnIClcblx0XHRcdFx0XHRcdFx0XHQuZmluZCggJ3NlbGVjdC4nICsgdHNjc3MuZmlsdGVyICsgJ1tkYXRhLWNvbHVtbj1cIicgKyBjb2x1bW4gKyAnXCJdJyApXG5cdFx0XHRcdFx0XHRcdFx0LmFwcGVuZCggb3B0aW9ucyApO1xuXHRcdFx0XHRcdFx0XHR0eHQgPSB3by5maWx0ZXJfc2VsZWN0U291cmNlO1xuXHRcdFx0XHRcdFx0XHRmeG4gPSB0eXBlb2YgdHh0ID09PSAnZnVuY3Rpb24nID8gdHJ1ZSA6IHRzLmdldENvbHVtbkRhdGEoIHRhYmxlLCB0eHQsIGNvbHVtbiApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGZ4biApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyB1cGRhdGluZyBzbyB0aGUgZXh0cmEgb3B0aW9ucyBhcmUgYXBwZW5kZWRcblx0XHRcdFx0XHRcdFx0XHR0c2YuYnVpbGRTZWxlY3QoIGMudGFibGUsIGNvbHVtbiwgJycsIHRydWUsICRoZWFkZXIuaGFzQ2xhc3MoIHdvLmZpbHRlcl9vbmx5QXZhaWwgKSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBub3QgcmVhbGx5IHVwZGF0aW5nLCBidXQgaWYgdGhlIGNvbHVtbiBoYXMgYm90aCB0aGUgJ2ZpbHRlci1zZWxlY3QnIGNsYXNzICZcblx0XHRcdC8vIGZpbHRlcl9mdW5jdGlvbnMgc2V0IHRvIHRydWUsIGl0IHdvdWxkIGFwcGVuZCB0aGUgc2FtZSBvcHRpb25zIHR3aWNlLlxuXHRcdFx0dHNmLmJ1aWxkRGVmYXVsdCggdGFibGUsIHRydWUgKTtcblxuXHRcdFx0dHNmLmJpbmRTZWFyY2goIHRhYmxlLCBjLiR0YWJsZS5maW5kKCAnLicgKyB0c2Nzcy5maWx0ZXIgKSwgdHJ1ZSApO1xuXHRcdFx0aWYgKCB3by5maWx0ZXJfZXh0ZXJuYWwgKSB7XG5cdFx0XHRcdHRzZi5iaW5kU2VhcmNoKCB0YWJsZSwgd28uZmlsdGVyX2V4dGVybmFsICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd28uZmlsdGVyX2hpZGVGaWx0ZXJzICkge1xuXHRcdFx0XHR0c2YuaGlkZUZpbHRlcnMoIGMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc2hvdyBwcm9jZXNzaW5nIGljb25cblx0XHRcdGlmICggYy5zaG93UHJvY2Vzc2luZyApIHtcblx0XHRcdFx0dHh0ID0gJ2ZpbHRlclN0YXJ0IGZpbHRlckVuZCAnLnNwbGl0KCAnICcgKS5qb2luKCBjLm5hbWVzcGFjZSArICdmaWx0ZXItc3AgJyApO1xuXHRcdFx0XHRjLiR0YWJsZVxuXHRcdFx0XHRcdC51bmJpbmQoIHR4dC5yZXBsYWNlKCB0cy5yZWdleC5zcGFjZXMsICcgJyApIClcblx0XHRcdFx0XHQuYmluZCggdHh0LCBmdW5jdGlvbiggZXZlbnQsIGNvbHVtbnMgKSB7XG5cdFx0XHRcdFx0Ly8gb25seSBhZGQgcHJvY2Vzc2luZyB0byBjZXJ0YWluIGNvbHVtbnMgdG8gYWxsIGNvbHVtbnNcblx0XHRcdFx0XHQkaGVhZGVyID0gKCBjb2x1bW5zICkgP1xuXHRcdFx0XHRcdFx0Yy4kdGFibGVcblx0XHRcdFx0XHRcdFx0LmZpbmQoICcuJyArIHRzY3NzLmhlYWRlciApXG5cdFx0XHRcdFx0XHRcdC5maWx0ZXIoICdbZGF0YS1jb2x1bW5dJyApXG5cdFx0XHRcdFx0XHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBjb2x1bW5zWyAkKCB0aGlzICkuZGF0YSggJ2NvbHVtbicgKSBdICE9PSAnJztcblx0XHRcdFx0XHRcdFx0fSkgOiAnJztcblx0XHRcdFx0XHR0cy5pc1Byb2Nlc3NpbmcoIHRhYmxlLCBldmVudC50eXBlID09PSAnZmlsdGVyU3RhcnQnLCBjb2x1bW5zID8gJGhlYWRlciA6ICcnICk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZXQgZmlsdGVyZWQgcm93cyBjb3VudCAoIGludGlhbGx5IHVuZmlsdGVyZWQgKVxuXHRcdFx0Yy5maWx0ZXJlZFJvd3MgPSBjLnRvdGFsUm93cztcblxuXHRcdFx0Ly8gYWRkIGRlZmF1bHQgdmFsdWVzXG5cdFx0XHR0eHQgPSAndGFibGVzb3J0ZXItaW5pdGlhbGl6ZWQgcGFnZXJCZWZvcmVJbml0aWFsaXplZCAnLnNwbGl0KCAnICcgKS5qb2luKCBjLm5hbWVzcGFjZSArICdmaWx0ZXIgJyApO1xuXHRcdFx0Yy4kdGFibGVcblx0XHRcdC51bmJpbmQoIHR4dC5yZXBsYWNlKCB0cy5yZWdleC5zcGFjZXMsICcgJyApIClcblx0XHRcdC5iaW5kKCB0eHQsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0c2YuY29tcGxldGVJbml0KCB0aGlzICk7XG5cdFx0XHR9KTtcblx0XHRcdC8vIGlmIGZpbHRlciB3aWRnZXQgaXMgYWRkZWQgYWZ0ZXIgcGFnZXIgaGFzIGluaXRpYWxpemVkOyB0aGVuIHNldCBmaWx0ZXIgaW5pdCBmbGFnXG5cdFx0XHRpZiAoIGMucGFnZXIgJiYgYy5wYWdlci5pbml0aWFsaXplZCAmJiAhd28uZmlsdGVyX2luaXRpYWxpemVkICkge1xuXHRcdFx0XHRjLiR0YWJsZS50cmlnZ2VySGFuZGxlciggJ2ZpbHRlckZvbWF0dGVyVXBkYXRlJyApO1xuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0c2YuZmlsdGVySW5pdENvbXBsZXRlKCBjICk7XG5cdFx0XHRcdH0sIDEwMCApO1xuXHRcdFx0fSBlbHNlIGlmICggIXdvLmZpbHRlcl9pbml0aWFsaXplZCApIHtcblx0XHRcdFx0dHNmLmNvbXBsZXRlSW5pdCggdGFibGUgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGNvbXBsZXRlSW5pdDogZnVuY3Rpb24oIHRhYmxlICkge1xuXHRcdFx0Ly8gcmVkZWZpbmUgJ2MnICYgJ3dvJyBzbyB0aGV5IHVwZGF0ZSBwcm9wZXJseSBpbnNpZGUgdGhpcyBjYWxsYmFja1xuXHRcdFx0dmFyIGMgPSB0YWJsZS5jb25maWcsXG5cdFx0XHRcdHdvID0gYy53aWRnZXRPcHRpb25zLFxuXHRcdFx0XHRmaWx0ZXJzID0gdHNmLnNldERlZmF1bHRzKCB0YWJsZSwgYywgd28gKSB8fCBbXTtcblx0XHRcdGlmICggZmlsdGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdC8vIHByZXZlbnQgZGVsYXlJbml0IGZyb20gdHJpZ2dlcmluZyBhIGNhY2hlIGJ1aWxkIGlmIGZpbHRlcnMgYXJlIGVtcHR5XG5cdFx0XHRcdGlmICggISggYy5kZWxheUluaXQgJiYgZmlsdGVycy5qb2luKCAnJyApID09PSAnJyApICkge1xuXHRcdFx0XHRcdHRzLnNldEZpbHRlcnMoIHRhYmxlLCBmaWx0ZXJzLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAnZmlsdGVyRm9tYXR0ZXJVcGRhdGUnICk7XG5cdFx0XHQvLyB0cmlnZ2VyIGluaXQgYWZ0ZXIgc2V0VGltZW91dCB0byBwcmV2ZW50IG11bHRpcGxlIGZpbHRlclN0YXJ0L0VuZC9Jbml0IHRyaWdnZXJzXG5cdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhd28uZmlsdGVyX2luaXRpYWxpemVkICkge1xuXHRcdFx0XHRcdHRzZi5maWx0ZXJJbml0Q29tcGxldGUoIGMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMTAwICk7XG5cdFx0fSxcblxuXHRcdC8vICRjZWxsIHBhcmFtZXRlciwgYnV0IG5vdCB0aGUgY29uZmlnLCBpcyBwYXNzZWQgdG8gdGhlIGZpbHRlcl9mb3JtYXR0ZXJzLFxuXHRcdC8vIHNvIHdlIGhhdmUgdG8gd29yayB3aXRoIGl0IGluc3RlYWRcblx0XHRmb3JtYXR0ZXJVcGRhdGVkOiBmdW5jdGlvbiggJGNlbGwsIGNvbHVtbiApIHtcblx0XHRcdC8vIHByZXZlbnQgZXJyb3IgaWYgJGNlbGwgaXMgdW5kZWZpbmVkIC0gc2VlICMxMDU2XG5cdFx0XHR2YXIgJHRhYmxlID0gJGNlbGwgJiYgJGNlbGwuY2xvc2VzdCggJ3RhYmxlJyApO1xuXHRcdFx0dmFyIGNvbmZpZyA9ICR0YWJsZS5sZW5ndGggJiYgJHRhYmxlWzBdLmNvbmZpZyxcblx0XHRcdFx0d28gPSBjb25maWcgJiYgY29uZmlnLndpZGdldE9wdGlvbnM7XG5cdFx0XHRpZiAoIHdvICYmICF3by5maWx0ZXJfaW5pdGlhbGl6ZWQgKSB7XG5cdFx0XHRcdC8vIGFkZCB1cGRhdGVzIGJ5IGNvbHVtbiBzaW5jZSB0aGlzIGZ1bmN0aW9uXG5cdFx0XHRcdC8vIG1heSBiZSBjYWxsZWQgbnVtZXJvdXMgdGltZXMgYmVmb3JlIGluaXRpYWxpemF0aW9uXG5cdFx0XHRcdHdvLmZpbHRlcl9mb3JtYXR0ZXJJbml0WyBjb2x1bW4gXSA9IDE7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRmaWx0ZXJJbml0Q29tcGxldGU6IGZ1bmN0aW9uKCBjICkge1xuXHRcdFx0dmFyIGluZHgsIGxlbixcblx0XHRcdFx0d28gPSBjLndpZGdldE9wdGlvbnMsXG5cdFx0XHRcdGNvdW50ID0gMCxcblx0XHRcdFx0Y29tcGxldGVkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0d28uZmlsdGVyX2luaXRpYWxpemVkID0gdHJ1ZTtcblx0XHRcdFx0XHQvLyB1cGRhdGUgbGFzdFNlYXJjaCAtIGl0IGdldHMgY2xlYXJlZCBvZnRlblxuXHRcdFx0XHRcdGMubGFzdFNlYXJjaCA9IGMuJHRhYmxlLmRhdGEoICdsYXN0U2VhcmNoJyApO1xuXHRcdFx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAnZmlsdGVySW5pdCcsIGMgKTtcblx0XHRcdFx0XHR0c2YuZmluZFJvd3MoIGMudGFibGUsIGMubGFzdFNlYXJjaCB8fCBbXSApO1xuXHRcdFx0XHRcdGlmICh0cy5kZWJ1ZyhjLCAnZmlsdGVyJykpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCdGaWx0ZXIgPj4gV2lkZ2V0IGluaXRpYWxpemVkJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0aWYgKCAkLmlzRW1wdHlPYmplY3QoIHdvLmZpbHRlcl9mb3JtYXR0ZXIgKSApIHtcblx0XHRcdFx0Y29tcGxldGVkKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsZW4gPSB3by5maWx0ZXJfZm9ybWF0dGVySW5pdC5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XG5cdFx0XHRcdFx0aWYgKCB3by5maWx0ZXJfZm9ybWF0dGVySW5pdFsgaW5keCBdID09PSAxICkge1xuXHRcdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB3by5maWx0ZXJfaW5pdFRpbWVyICk7XG5cdFx0XHRcdGlmICggIXdvLmZpbHRlcl9pbml0aWFsaXplZCAmJiBjb3VudCA9PT0gd28uZmlsdGVyX2Zvcm1hdHRlckNvdW50ICkge1xuXHRcdFx0XHRcdC8vIGZpbHRlciB3aWRnZXQgaW5pdGlhbGl6ZWRcblx0XHRcdFx0XHRjb21wbGV0ZWQoKTtcblx0XHRcdFx0fSBlbHNlIGlmICggIXdvLmZpbHRlcl9pbml0aWFsaXplZCApIHtcblx0XHRcdFx0XHQvLyBmYWxsIGJhY2sgaW4gY2FzZSBhIGZpbHRlcl9mb3JtYXR0ZXIgZG9lc24ndCBjYWxsXG5cdFx0XHRcdFx0Ly8gJC50YWJsZXNvcnRlci5maWx0ZXIuZm9ybWF0dGVyVXBkYXRlZCggJGNlbGwsIGNvbHVtbiApLCBhbmQgdGhlIGNvdW50IGlzIG9mZlxuXHRcdFx0XHRcdHdvLmZpbHRlcl9pbml0VGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGNvbXBsZXRlZCgpO1xuXHRcdFx0XHRcdH0sIDUwMCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvLyBlbmNvZGUgb3IgZGVjb2RlIGZpbHRlcnMgZm9yIHN0b3JhZ2U7IHNlZSAjMTAyNlxuXHRcdHByb2Nlc3NGaWx0ZXJzOiBmdW5jdGlvbiggZmlsdGVycywgZW5jb2RlICkge1xuXHRcdFx0dmFyIGluZHgsXG5cdFx0XHRcdC8vIGZpeGVzICMxMjM3OyBwcmV2aW91c2x5IHJldHVybmluZyBhbiBlbmNvZGVkIFwiZmlsdGVyc1wiIHZhbHVlXG5cdFx0XHRcdHJlc3VsdCA9IFtdLFxuXHRcdFx0XHRtb2RlID0gZW5jb2RlID8gZW5jb2RlVVJJQ29tcG9uZW50IDogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHRcdFx0XHRsZW4gPSBmaWx0ZXJzLmxlbmd0aDtcblx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XG5cdFx0XHRcdGlmICggZmlsdGVyc1sgaW5keCBdICkge1xuXHRcdFx0XHRcdHJlc3VsdFsgaW5keCBdID0gbW9kZSggZmlsdGVyc1sgaW5keCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXREZWZhdWx0czogZnVuY3Rpb24oIHRhYmxlLCBjLCB3byApIHtcblx0XHRcdHZhciBpc0FycmF5LCBzYXZlZCwgaW5keCwgY29sLCAkZmlsdGVycyxcblx0XHRcdFx0Ly8gZ2V0IGN1cnJlbnQgKCBkZWZhdWx0ICkgZmlsdGVyc1xuXHRcdFx0XHRmaWx0ZXJzID0gdHMuZ2V0RmlsdGVycyggdGFibGUgKSB8fCBbXTtcblx0XHRcdGlmICggd28uZmlsdGVyX3NhdmVGaWx0ZXJzICYmIHRzLnN0b3JhZ2UgKSB7XG5cdFx0XHRcdHNhdmVkID0gdHMuc3RvcmFnZSggdGFibGUsICd0YWJsZXNvcnRlci1maWx0ZXJzJyApIHx8IFtdO1xuXHRcdFx0XHRpc0FycmF5ID0gJC5pc0FycmF5KCBzYXZlZCApO1xuXHRcdFx0XHQvLyBtYWtlIHN1cmUgd2UncmUgbm90IGp1c3QgZ2V0dGluZyBhbiBlbXB0eSBhcnJheVxuXHRcdFx0XHRpZiAoICEoIGlzQXJyYXkgJiYgc2F2ZWQuam9pbiggJycgKSA9PT0gJycgfHwgIWlzQXJyYXkgKSApIHtcblx0XHRcdFx0XHRmaWx0ZXJzID0gdHNmLnByb2Nlc3NGaWx0ZXJzKCBzYXZlZCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiBubyBmaWx0ZXJzIHNhdmVkLCB0aGVuIGNoZWNrIGRlZmF1bHQgc2V0dGluZ3Ncblx0XHRcdGlmICggZmlsdGVycy5qb2luKCAnJyApID09PSAnJyApIHtcblx0XHRcdFx0Ly8gYWxsb3cgYWRkaW5nIGRlZmF1bHQgc2V0dGluZyB0byBleHRlcm5hbCBmaWx0ZXJzXG5cdFx0XHRcdCRmaWx0ZXJzID0gYy4kaGVhZGVycy5hZGQoIHdvLmZpbHRlcl8kZXh0ZXJuYWxGaWx0ZXJzIClcblx0XHRcdFx0XHQuZmlsdGVyKCAnWycgKyB3by5maWx0ZXJfZGVmYXVsdEF0dHJpYiArICddJyApO1xuXHRcdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8PSBjLmNvbHVtbnM7IGluZHgrKyApIHtcblx0XHRcdFx0XHQvLyBpbmNsdWRlIGRhdGEtY29sdW1uPSdhbGwnIGV4dGVybmFsIGZpbHRlcnNcblx0XHRcdFx0XHRjb2wgPSBpbmR4ID09PSBjLmNvbHVtbnMgPyAnYWxsJyA6IGluZHg7XG5cdFx0XHRcdFx0ZmlsdGVyc1sgaW5keCBdID0gJGZpbHRlcnNcblx0XHRcdFx0XHRcdC5maWx0ZXIoICdbZGF0YS1jb2x1bW49XCInICsgY29sICsgJ1wiXScgKVxuXHRcdFx0XHRcdFx0LmF0dHIoIHdvLmZpbHRlcl9kZWZhdWx0QXR0cmliICkgfHwgZmlsdGVyc1tpbmR4XSB8fCAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Yy4kdGFibGUuZGF0YSggJ2xhc3RTZWFyY2gnLCBmaWx0ZXJzICk7XG5cdFx0XHRyZXR1cm4gZmlsdGVycztcblx0XHR9LFxuXHRcdHBhcnNlRmlsdGVyOiBmdW5jdGlvbiggYywgZmlsdGVyLCBkYXRhLCBwYXJzZWQgKSB7XG5cdFx0XHRyZXR1cm4gcGFyc2VkIHx8IGRhdGEucGFyc2VkWyBkYXRhLmluZGV4IF0gP1xuXHRcdFx0XHRjLnBhcnNlcnNbIGRhdGEuaW5kZXggXS5mb3JtYXQoIGZpbHRlciwgYy50YWJsZSwgW10sIGRhdGEuaW5kZXggKSA6XG5cdFx0XHRcdGZpbHRlcjtcblx0XHR9LFxuXHRcdGJ1aWxkUm93OiBmdW5jdGlvbiggdGFibGUsIGMsIHdvICkge1xuXHRcdFx0dmFyICRmaWx0ZXIsIGNvbCwgY29sdW1uLCAkaGVhZGVyLCBtYWtlU2VsZWN0LCBkaXNhYmxlZCwgbmFtZSwgZmZ4biwgdG1wLFxuXHRcdFx0XHQvLyBjLmNvbHVtbnMgZGVmaW5lZCBpbiBjb21wdXRlVGhJbmRleGVzKClcblx0XHRcdFx0Y2VsbEZpbHRlciA9IHdvLmZpbHRlcl9jZWxsRmlsdGVyLFxuXHRcdFx0XHRjb2x1bW5zID0gYy5jb2x1bW5zLFxuXHRcdFx0XHRhcnJ5ID0gJC5pc0FycmF5KCBjZWxsRmlsdGVyICksXG5cdFx0XHRcdGJ1aWxkRmlsdGVyID0gJzx0ciByb2xlPVwic2VhcmNoXCIgY2xhc3M9XCInICsgdHNjc3MuZmlsdGVyUm93ICsgJyAnICsgYy5jc3NJZ25vcmVSb3cgKyAnXCI+Jztcblx0XHRcdGZvciAoIGNvbHVtbiA9IDA7IGNvbHVtbiA8IGNvbHVtbnM7IGNvbHVtbisrICkge1xuXHRcdFx0XHRpZiAoIGMuJGhlYWRlckluZGV4ZWRbIGNvbHVtbiBdLmxlbmd0aCApIHtcblx0XHRcdFx0XHQvLyBhY2NvdW50IGZvciBlbnRpcmUgY29sdW1uIHNldCB3aXRoIGNvbHNwYW4uIFNlZSAjMTA0N1xuXHRcdFx0XHRcdHRtcCA9IGMuJGhlYWRlckluZGV4ZWRbIGNvbHVtbiBdICYmIGMuJGhlYWRlckluZGV4ZWRbIGNvbHVtbiBdWzBdLmNvbFNwYW4gfHwgMDtcblx0XHRcdFx0XHRpZiAoIHRtcCA+IDEgKSB7XG5cdFx0XHRcdFx0XHRidWlsZEZpbHRlciArPSAnPHRkIGRhdGEtY29sdW1uPVwiJyArIGNvbHVtbiArICctJyArICggY29sdW1uICsgdG1wIC0gMSApICsgJ1wiIGNvbHNwYW49XCInICsgdG1wICsgJ1wiJztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YnVpbGRGaWx0ZXIgKz0gJzx0ZCBkYXRhLWNvbHVtbj1cIicgKyBjb2x1bW4gKyAnXCInO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGFycnkgKSB7XG5cdFx0XHRcdFx0XHRidWlsZEZpbHRlciArPSAoIGNlbGxGaWx0ZXJbIGNvbHVtbiBdID8gJyBjbGFzcz1cIicgKyBjZWxsRmlsdGVyWyBjb2x1bW4gXSArICdcIicgOiAnJyApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRidWlsZEZpbHRlciArPSAoIGNlbGxGaWx0ZXIgIT09ICcnID8gJyBjbGFzcz1cIicgKyBjZWxsRmlsdGVyICsgJ1wiJyA6ICcnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJ1aWxkRmlsdGVyICs9ICc+PC90ZD4nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjLiRmaWx0ZXJzID0gJCggYnVpbGRGaWx0ZXIgKz0gJzwvdHI+JyApXG5cdFx0XHRcdC5hcHBlbmRUbyggYy4kdGFibGUuY2hpbGRyZW4oICd0aGVhZCcgKS5lcSggMCApIClcblx0XHRcdFx0LmNoaWxkcmVuKCAndGQnICk7XG5cdFx0XHQvLyBidWlsZCBlYWNoIGZpbHRlciBpbnB1dFxuXHRcdFx0Zm9yICggY29sdW1uID0gMDsgY29sdW1uIDwgY29sdW1uczsgY29sdW1uKysgKSB7XG5cdFx0XHRcdGRpc2FibGVkID0gZmFsc2U7XG5cdFx0XHRcdC8vIGFzc3VtaW5nIGxhc3QgY2VsbCBvZiBhIGNvbHVtbiBpcyB0aGUgbWFpbiBjb2x1bW5cblx0XHRcdFx0JGhlYWRlciA9IGMuJGhlYWRlckluZGV4ZWRbIGNvbHVtbiBdO1xuXHRcdFx0XHRpZiAoICRoZWFkZXIgJiYgJGhlYWRlci5sZW5ndGggKSB7XG5cdFx0XHRcdFx0Ly8gJGZpbHRlciA9IGMuJGZpbHRlcnMuZmlsdGVyKCAnW2RhdGEtY29sdW1uPVwiJyArIGNvbHVtbiArICdcIl0nICk7XG5cdFx0XHRcdFx0JGZpbHRlciA9IHRzZi5nZXRDb2x1bW5FbG0oIGMsIGMuJGZpbHRlcnMsIGNvbHVtbiApO1xuXHRcdFx0XHRcdGZmeG4gPSB0cy5nZXRDb2x1bW5EYXRhKCB0YWJsZSwgd28uZmlsdGVyX2Z1bmN0aW9ucywgY29sdW1uICk7XG5cdFx0XHRcdFx0bWFrZVNlbGVjdCA9ICggd28uZmlsdGVyX2Z1bmN0aW9ucyAmJiBmZnhuICYmIHR5cGVvZiBmZnhuICE9PSAnZnVuY3Rpb24nICkgfHxcblx0XHRcdFx0XHRcdCRoZWFkZXIuaGFzQ2xhc3MoICdmaWx0ZXItc2VsZWN0JyApO1xuXHRcdFx0XHRcdC8vIGdldCBkYXRhIGZyb20galF1ZXJ5IGRhdGEsIG1ldGFkYXRhLCBoZWFkZXJzIG9wdGlvbiBvciBoZWFkZXIgY2xhc3MgbmFtZVxuXHRcdFx0XHRcdGNvbCA9IHRzLmdldENvbHVtbkRhdGEoIHRhYmxlLCBjLmhlYWRlcnMsIGNvbHVtbiApO1xuXHRcdFx0XHRcdGRpc2FibGVkID0gdHMuZ2V0RGF0YSggJGhlYWRlclswXSwgY29sLCAnZmlsdGVyJyApID09PSAnZmFsc2UnIHx8XG5cdFx0XHRcdFx0XHR0cy5nZXREYXRhKCAkaGVhZGVyWzBdLCBjb2wsICdwYXJzZXInICkgPT09ICdmYWxzZSc7XG5cblx0XHRcdFx0XHRpZiAoIG1ha2VTZWxlY3QgKSB7XG5cdFx0XHRcdFx0XHRidWlsZEZpbHRlciA9ICQoICc8c2VsZWN0PicgKS5hcHBlbmRUbyggJGZpbHRlciApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmZnhuID0gdHMuZ2V0Q29sdW1uRGF0YSggdGFibGUsIHdvLmZpbHRlcl9mb3JtYXR0ZXIsIGNvbHVtbiApO1xuXHRcdFx0XHRcdFx0aWYgKCBmZnhuICkge1xuXHRcdFx0XHRcdFx0XHR3by5maWx0ZXJfZm9ybWF0dGVyQ291bnQrKztcblx0XHRcdFx0XHRcdFx0YnVpbGRGaWx0ZXIgPSBmZnhuKCAkZmlsdGVyLCBjb2x1bW4gKTtcblx0XHRcdFx0XHRcdFx0Ly8gbm8gZWxlbWVudCByZXR1cm5lZCwgc28gbGV0cyBnbyBmaW5kIGl0XG5cdFx0XHRcdFx0XHRcdGlmICggYnVpbGRGaWx0ZXIgJiYgYnVpbGRGaWx0ZXIubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdGJ1aWxkRmlsdGVyID0gJGZpbHRlci5jaGlsZHJlbiggJ2lucHV0JyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8vIGVsZW1lbnQgbm90IGluIERPTSwgc28gbGV0cyBhdHRhY2ggaXRcblx0XHRcdFx0XHRcdFx0aWYgKCBidWlsZEZpbHRlciAmJiAoIGJ1aWxkRmlsdGVyLnBhcmVudCgpLmxlbmd0aCA9PT0gMCB8fFxuXHRcdFx0XHRcdFx0XHRcdCggYnVpbGRGaWx0ZXIucGFyZW50KCkubGVuZ3RoICYmIGJ1aWxkRmlsdGVyLnBhcmVudCgpWzBdICE9PSAkZmlsdGVyWzBdICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHQkZmlsdGVyLmFwcGVuZCggYnVpbGRGaWx0ZXIgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YnVpbGRGaWx0ZXIgPSAkKCAnPGlucHV0IHR5cGU9XCJzZWFyY2hcIj4nICkuYXBwZW5kVG8oICRmaWx0ZXIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggYnVpbGRGaWx0ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdHRtcCA9ICRoZWFkZXIuZGF0YSggJ3BsYWNlaG9sZGVyJyApIHx8XG5cdFx0XHRcdFx0XHRcdFx0JGhlYWRlci5hdHRyKCAnZGF0YS1wbGFjZWhvbGRlcicgKSB8fFxuXHRcdFx0XHRcdFx0XHRcdHdvLmZpbHRlcl9wbGFjZWhvbGRlci5zZWFyY2ggfHwgJyc7XG5cdFx0XHRcdFx0XHRcdGJ1aWxkRmlsdGVyLmF0dHIoICdwbGFjZWhvbGRlcicsIHRtcCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGJ1aWxkRmlsdGVyICkge1xuXHRcdFx0XHRcdFx0Ly8gYWRkIGZpbHRlciBjbGFzcyBuYW1lXG5cdFx0XHRcdFx0XHRuYW1lID0gKCAkLmlzQXJyYXkoIHdvLmZpbHRlcl9jc3NGaWx0ZXIgKSA/XG5cdFx0XHRcdFx0XHRcdCggdHlwZW9mIHdvLmZpbHRlcl9jc3NGaWx0ZXJbY29sdW1uXSAhPT0gJ3VuZGVmaW5lZCcgPyB3by5maWx0ZXJfY3NzRmlsdGVyW2NvbHVtbl0gfHwgJycgOiAnJyApIDpcblx0XHRcdFx0XHRcdFx0d28uZmlsdGVyX2Nzc0ZpbHRlciApIHx8ICcnO1xuXHRcdFx0XHRcdFx0Ly8gY29weSBkYXRhLWNvbHVtbiBmcm9tIHRhYmxlIGNlbGwgKGl0IHdpbGwgaW5jbHVkZSBjb2xzcGFuKVxuXHRcdFx0XHRcdFx0YnVpbGRGaWx0ZXIuYWRkQ2xhc3MoIHRzY3NzLmZpbHRlciArICcgJyArIG5hbWUgKTtcblx0XHRcdFx0XHRcdG5hbWUgPSB3by5maWx0ZXJfZmlsdGVyTGFiZWw7XG5cdFx0XHRcdFx0XHR0bXAgPSBuYW1lLm1hdGNoKC97eyhbXn1dKz8pfX0vZyk7XG5cdFx0XHRcdFx0XHRpZiAoIXRtcCkge1xuXHRcdFx0XHRcdFx0XHR0bXAgPSBbICd7e2xhYmVsfX0nIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQkLmVhY2godG1wLCBmdW5jdGlvbihpbmR4LCBhdHRyKSB7XG5cdFx0XHRcdFx0XHRcdHZhciByZWdleCA9IG5ldyBSZWdFeHAoYXR0ciwgJ2cnKSxcblx0XHRcdFx0XHRcdFx0XHRkYXRhID0gJGhlYWRlci5hdHRyKCdkYXRhLScgKyBhdHRyLnJlcGxhY2UoL3t7fH19L2csICcnKSksXG5cdFx0XHRcdFx0XHRcdFx0dGV4dCA9IHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJyA/ICRoZWFkZXIudGV4dCgpIDogZGF0YTtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IG5hbWUucmVwbGFjZSggcmVnZXgsICQudHJpbSggdGV4dCApICk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGJ1aWxkRmlsdGVyLmF0dHIoe1xuXHRcdFx0XHRcdFx0XHQnZGF0YS1jb2x1bW4nOiAkZmlsdGVyLmF0dHIoICdkYXRhLWNvbHVtbicgKSxcblx0XHRcdFx0XHRcdFx0J2FyaWEtbGFiZWwnOiBuYW1lXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGlmICggZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0XHRcdGJ1aWxkRmlsdGVyLmF0dHIoICdwbGFjZWhvbGRlcicsICcnICkuYWRkQ2xhc3MoIHRzY3NzLmZpbHRlckRpc2FibGVkIClbMF0uZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YmluZFNlYXJjaDogZnVuY3Rpb24oIHRhYmxlLCAkZWwsIGludGVybmFsICkge1xuXHRcdFx0dGFibGUgPSAkKCB0YWJsZSApWzBdO1xuXHRcdFx0JGVsID0gJCggJGVsICk7IC8vIGFsbG93IHBhc3NpbmcgYSBzZWxlY3RvciBzdHJpbmdcblx0XHRcdGlmICggISRlbC5sZW5ndGggKSB7IHJldHVybjsgfVxuXHRcdFx0dmFyIHRtcCxcblx0XHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdFx0d28gPSBjLndpZGdldE9wdGlvbnMsXG5cdFx0XHRcdG5hbWVzcGFjZSA9IGMubmFtZXNwYWNlICsgJ2ZpbHRlcicsXG5cdFx0XHRcdCRleHQgPSB3by5maWx0ZXJfJGV4dGVybmFsRmlsdGVycztcblx0XHRcdGlmICggaW50ZXJuYWwgIT09IHRydWUgKSB7XG5cdFx0XHRcdC8vIHNhdmUgYW55TWF0Y2ggZWxlbWVudFxuXHRcdFx0XHR0bXAgPSB3by5maWx0ZXJfYW55Q29sdW1uU2VsZWN0b3IgKyAnLCcgKyB3by5maWx0ZXJfbXVsdGlwbGVDb2x1bW5TZWxlY3Rvcjtcblx0XHRcdFx0d28uZmlsdGVyXyRhbnlNYXRjaCA9ICRlbC5maWx0ZXIoIHRtcCApO1xuXHRcdFx0XHRpZiAoICRleHQgJiYgJGV4dC5sZW5ndGggKSB7XG5cdFx0XHRcdFx0d28uZmlsdGVyXyRleHRlcm5hbEZpbHRlcnMgPSB3by5maWx0ZXJfJGV4dGVybmFsRmlsdGVycy5hZGQoICRlbCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHdvLmZpbHRlcl8kZXh0ZXJuYWxGaWx0ZXJzID0gJGVsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHVwZGF0ZSB2YWx1ZXMgKCBleHRlcm5hbCBmaWx0ZXJzIGFkZGVkIGFmdGVyIHRhYmxlIGluaXRpYWxpemF0aW9uIClcblx0XHRcdFx0dHMuc2V0RmlsdGVycyggdGFibGUsIGMuJHRhYmxlLmRhdGEoICdsYXN0U2VhcmNoJyApIHx8IFtdLCBpbnRlcm5hbCA9PT0gZmFsc2UgKTtcblx0XHRcdH1cblx0XHRcdC8vIHVuYmluZCBldmVudHNcblx0XHRcdHRtcCA9ICggJ2tleXByZXNzIGtleXVwIGtleWRvd24gc2VhcmNoIGNoYW5nZSBpbnB1dCAnLnNwbGl0KCAnICcgKS5qb2luKCBuYW1lc3BhY2UgKyAnICcgKSApO1xuXHRcdFx0JGVsXG5cdFx0XHQvLyB1c2UgZGF0YSBhdHRyaWJ1dGUgaW5zdGVhZCBvZiBqUXVlcnkgZGF0YSBzaW5jZSB0aGUgaGVhZCBpcyBjbG9uZWQgd2l0aG91dCBpbmNsdWRpbmdcblx0XHRcdC8vIHRoZSBkYXRhL2JpbmRpbmdcblx0XHRcdC5hdHRyKCAnZGF0YS1sYXN0U2VhcmNoVGltZScsIG5ldyBEYXRlKCkuZ2V0VGltZSgpIClcblx0XHRcdC51bmJpbmQoIHRtcC5yZXBsYWNlKCB0cy5yZWdleC5zcGFjZXMsICcgJyApIClcblx0XHRcdC5iaW5kKCAna2V5ZG93bicgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCBldmVudC53aGljaCA9PT0gdHNrZXlDb2Rlcy5lc2NhcGUgJiYgIXRhYmxlLmNvbmZpZy53aWRnZXRPcHRpb25zLmZpbHRlcl9yZXNldE9uRXNjICkge1xuXHRcdFx0XHRcdC8vIHByZXZlbnQga2V5cHJlc3MgZXZlbnRcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQuYmluZCggJ2tleXVwJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR3byA9IHRhYmxlLmNvbmZpZy53aWRnZXRPcHRpb25zOyAvLyBtYWtlIHN1cmUgXCJ3b1wiIGlzbid0IGNhY2hlZFxuXHRcdFx0XHR2YXIgY29sdW1uID0gcGFyc2VJbnQoICQoIHRoaXMgKS5hdHRyKCAnZGF0YS1jb2x1bW4nICksIDEwICksXG5cdFx0XHRcdFx0bGl2ZVNlYXJjaCA9IHR5cGVvZiB3by5maWx0ZXJfbGl2ZVNlYXJjaCA9PT0gJ2Jvb2xlYW4nID8gd28uZmlsdGVyX2xpdmVTZWFyY2ggOlxuXHRcdFx0XHRcdFx0dHMuZ2V0Q29sdW1uRGF0YSggdGFibGUsIHdvLmZpbHRlcl9saXZlU2VhcmNoLCBjb2x1bW4gKTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgbGl2ZVNlYXJjaCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdFx0bGl2ZVNlYXJjaCA9IHdvLmZpbHRlcl9saXZlU2VhcmNoLmZhbGxiYWNrIHx8IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQoIHRoaXMgKS5hdHRyKCAnZGF0YS1sYXN0U2VhcmNoVGltZScsIG5ldyBEYXRlKCkuZ2V0VGltZSgpICk7XG5cdFx0XHRcdC8vIGVtdWxhdGUgd2hhdCB3ZWJraXQgZG9lcy4uLi4gZXNjYXBlIGNsZWFycyB0aGUgZmlsdGVyXG5cdFx0XHRcdGlmICggZXZlbnQud2hpY2ggPT09IHRza2V5Q29kZXMuZXNjYXBlICkge1xuXHRcdFx0XHRcdC8vIG1ha2Ugc3VyZSB0byByZXN0b3JlIHRoZSBsYXN0IHZhbHVlIG9uIGVzY2FwZVxuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB3by5maWx0ZXJfcmVzZXRPbkVzYyA/ICcnIDogYy5sYXN0U2VhcmNoW2NvbHVtbl07XG5cdFx0XHRcdFx0Ly8gZG9uJ3QgcmV0dXJuIGlmIHRoZSBzZWFyY2ggdmFsdWUgaXMgZW1wdHkgKCBhbGwgcm93cyBuZWVkIHRvIGJlIHJldmVhbGVkIClcblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy52YWx1ZSAhPT0gJycgJiYgKFxuXHRcdFx0XHRcdC8vIGxpdmVTZWFyY2ggY2FuIGNvbnRhaW4gYSBtaW4gdmFsdWUgbGVuZ3RoOyBpZ25vcmUgYXJyb3cgYW5kIG1ldGEga2V5cywgYnV0IGFsbG93IGJhY2tzcGFjZVxuXHRcdFx0XHRcdCggdHlwZW9mIGxpdmVTZWFyY2ggPT09ICdudW1iZXInICYmIHRoaXMudmFsdWUubGVuZ3RoIDwgbGl2ZVNlYXJjaCApIHx8XG5cdFx0XHRcdFx0Ly8gbGV0IHJldHVybiAmIGJhY2tzcGFjZSBjb250aW51ZSBvbiwgYnV0IGlnbm9yZSBhcnJvd3MgJiBub24tdmFsaWQgY2hhcmFjdGVyc1xuXHRcdFx0XHRcdCggZXZlbnQud2hpY2ggIT09IHRza2V5Q29kZXMuZW50ZXIgJiYgZXZlbnQud2hpY2ggIT09IHRza2V5Q29kZXMuYmFja1NwYWNlICYmXG5cdFx0XHRcdFx0XHQoIGV2ZW50LndoaWNoIDwgdHNrZXlDb2Rlcy5zcGFjZSB8fCAoIGV2ZW50LndoaWNoID49IHRza2V5Q29kZXMubGVmdCAmJiBldmVudC53aGljaCA8PSB0c2tleUNvZGVzLmRvd24gKSApICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0Ly8gbGl2ZSBzZWFyY2hcblx0XHRcdFx0fSBlbHNlIGlmICggbGl2ZVNlYXJjaCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnZhbHVlICE9PSAnJyAmJiBldmVudC53aGljaCAhPT0gdHNrZXlDb2Rlcy5lbnRlciApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gY2hhbmdlIGV2ZW50ID0gbm8gZGVsYXk7IGxhc3QgdHJ1ZSBmbGFnIHRlbGxzIGdldEZpbHRlcnMgdG8gc2tpcCBuZXdlc3QgdGltZWQgaW5wdXRcblx0XHRcdFx0dHNmLnNlYXJjaGluZyggdGFibGUsIHRydWUsIHRydWUsIGNvbHVtbiApO1xuXHRcdFx0fSlcblx0XHRcdC8vIGluY2x1ZGUgY2hhbmdlIGZvciBzZWxlY3QgLSBmaXhlcyAjNDczXG5cdFx0XHQuYmluZCggJ3NlYXJjaCBjaGFuZ2Uga2V5cHJlc3MgaW5wdXQgYmx1ciAnLnNwbGl0KCAnICcgKS5qb2luKCBuYW1lc3BhY2UgKyAnICcgKSwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQvLyBkb24ndCBnZXQgY2FjaGVkIGRhdGEsIGluIGNhc2UgZGF0YS1jb2x1bW4gY2hhbmdlcyBkeW5hbWljYWxseVxuXHRcdFx0XHR2YXIgY29sdW1uID0gcGFyc2VJbnQoICQoIHRoaXMgKS5hdHRyKCAnZGF0YS1jb2x1bW4nICksIDEwICksXG5cdFx0XHRcdFx0ZXZlbnRUeXBlID0gZXZlbnQudHlwZSxcblx0XHRcdFx0XHRsaXZlU2VhcmNoID0gdHlwZW9mIHdvLmZpbHRlcl9saXZlU2VhcmNoID09PSAnYm9vbGVhbicgP1xuXHRcdFx0XHRcdFx0d28uZmlsdGVyX2xpdmVTZWFyY2ggOlxuXHRcdFx0XHRcdFx0dHMuZ2V0Q29sdW1uRGF0YSggdGFibGUsIHdvLmZpbHRlcl9saXZlU2VhcmNoLCBjb2x1bW4gKTtcblx0XHRcdFx0aWYgKCB0YWJsZS5jb25maWcud2lkZ2V0T3B0aW9ucy5maWx0ZXJfaW5pdGlhbGl6ZWQgJiZcblx0XHRcdFx0XHQvLyBpbW1lZGlhdGUgc2VhcmNoIGlmIHVzZXIgcHJlc3NlcyBlbnRlclxuXHRcdFx0XHRcdCggZXZlbnQud2hpY2ggPT09IHRza2V5Q29kZXMuZW50ZXIgfHxcblx0XHRcdFx0XHRcdC8vIGltbWVkaWF0ZSBzZWFyY2ggaWYgYSBcInNlYXJjaFwiIG9yIFwiYmx1clwiIGlzIHRyaWdnZXJlZCBvbiB0aGUgaW5wdXRcblx0XHRcdFx0XHRcdCggZXZlbnRUeXBlID09PSAnc2VhcmNoJyB8fCBldmVudFR5cGUgPT09ICdibHVyJyApIHx8XG5cdFx0XHRcdFx0XHQvLyBjaGFuZ2UgJiBpbnB1dCBldmVudHMgbXVzdCBiZSBpZ25vcmVkIGlmIGxpdmVTZWFyY2ggIT09IHRydWVcblx0XHRcdFx0XHRcdCggZXZlbnRUeXBlID09PSAnY2hhbmdlJyB8fCBldmVudFR5cGUgPT09ICdpbnB1dCcgKSAmJlxuXHRcdFx0XHRcdFx0Ly8gcHJldmVudCBzZWFyY2ggaWYgbGl2ZVNlYXJjaCBpcyBhIG51bWJlclxuXHRcdFx0XHRcdFx0KCBsaXZlU2VhcmNoID09PSB0cnVlIHx8IGxpdmVTZWFyY2ggIT09IHRydWUgJiYgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lICE9PSAnSU5QVVQnICkgJiZcblx0XHRcdFx0XHRcdC8vIGRvbid0IGFsbG93ICdjaGFuZ2UnIG9yICdpbnB1dCcgZXZlbnQgdG8gcHJvY2VzcyBpZiB0aGUgaW5wdXQgdmFsdWVcblx0XHRcdFx0XHRcdC8vIGlzIHRoZSBzYW1lIC0gZml4ZXMgIzY4NVxuXHRcdFx0XHRcdFx0dGhpcy52YWx1ZSAhPT0gYy5sYXN0U2VhcmNoW2NvbHVtbl1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0Ly8gaW5pdCBzZWFyY2ggd2l0aCBubyBkZWxheVxuXHRcdFx0XHRcdCQoIHRoaXMgKS5hdHRyKCAnZGF0YS1sYXN0U2VhcmNoVGltZScsIG5ldyBEYXRlKCkuZ2V0VGltZSgpICk7XG5cdFx0XHRcdFx0dHNmLnNlYXJjaGluZyggdGFibGUsIGV2ZW50VHlwZSAhPT0gJ2tleXByZXNzJywgdHJ1ZSwgY29sdW1uICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0c2VhcmNoaW5nOiBmdW5jdGlvbiggdGFibGUsIGZpbHRlciwgc2tpcEZpcnN0LCBjb2x1bW4gKSB7XG5cdFx0XHR2YXIgbGl2ZVNlYXJjaCxcblx0XHRcdFx0d28gPSB0YWJsZS5jb25maWcud2lkZ2V0T3B0aW9ucztcblx0XHRcdGlmICh0eXBlb2YgY29sdW1uID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHQvLyBubyBkZWxheVxuXHRcdFx0XHRsaXZlU2VhcmNoID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsaXZlU2VhcmNoID0gdHlwZW9mIHdvLmZpbHRlcl9saXZlU2VhcmNoID09PSAnYm9vbGVhbicgP1xuXHRcdFx0XHRcdHdvLmZpbHRlcl9saXZlU2VhcmNoIDpcblx0XHRcdFx0XHQvLyBnZXQgY29sdW1uIHNldHRpbmcsIG9yIHNldCB0byBmYWxsYmFjayB2YWx1ZSwgb3IgZGVmYXVsdCB0byBmYWxzZVxuXHRcdFx0XHRcdHRzLmdldENvbHVtbkRhdGEoIHRhYmxlLCB3by5maWx0ZXJfbGl2ZVNlYXJjaCwgY29sdW1uICk7XG5cdFx0XHRcdGlmICggdHlwZW9mIGxpdmVTZWFyY2ggPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdGxpdmVTZWFyY2ggPSB3by5maWx0ZXJfbGl2ZVNlYXJjaC5mYWxsYmFjayB8fCBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2xlYXJUaW1lb3V0KCB3by5maWx0ZXJfc2VhcmNoVGltZXIgKTtcblx0XHRcdGlmICggdHlwZW9mIGZpbHRlciA9PT0gJ3VuZGVmaW5lZCcgfHwgZmlsdGVyID09PSB0cnVlICkge1xuXHRcdFx0XHQvLyBkZWxheSBmaWx0ZXJpbmdcblx0XHRcdFx0d28uZmlsdGVyX3NlYXJjaFRpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dHNmLmNoZWNrRmlsdGVycyggdGFibGUsIGZpbHRlciwgc2tpcEZpcnN0ICk7XG5cdFx0XHRcdH0sIGxpdmVTZWFyY2ggPyB3by5maWx0ZXJfc2VhcmNoRGVsYXkgOiAxMCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gc2tpcCBkZWxheVxuXHRcdFx0XHR0c2YuY2hlY2tGaWx0ZXJzKCB0YWJsZSwgZmlsdGVyLCBza2lwRmlyc3QgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGVxdWFsRmlsdGVyczogZnVuY3Rpb24gKGMsIGZpbHRlcjEsIGZpbHRlcjIpIHtcblx0XHRcdHZhciBpbmR4LFxuXHRcdFx0XHRmMSA9IFtdLFxuXHRcdFx0XHRmMiA9IFtdLFxuXHRcdFx0XHRsZW4gPSBjLmNvbHVtbnMgKyAxOyAvLyBhZGQgb25lIHRvIGluY2x1ZGUgYW55TWF0Y2ggZmlsdGVyXG5cdFx0XHRmaWx0ZXIxID0gJC5pc0FycmF5KGZpbHRlcjEpID8gZmlsdGVyMSA6IFtdO1xuXHRcdFx0ZmlsdGVyMiA9ICQuaXNBcnJheShmaWx0ZXIyKSA/IGZpbHRlcjIgOiBbXTtcblx0XHRcdGZvciAoaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKykge1xuXHRcdFx0XHRmMVtpbmR4XSA9IGZpbHRlcjFbaW5keF0gfHwgJyc7XG5cdFx0XHRcdGYyW2luZHhdID0gZmlsdGVyMltpbmR4XSB8fCAnJztcblx0XHRcdH1cblx0XHRcdHJldHVybiBmMS5qb2luKCcsJykgPT09IGYyLmpvaW4oJywnKTtcblx0XHR9LFxuXHRcdGNoZWNrRmlsdGVyczogZnVuY3Rpb24oIHRhYmxlLCBmaWx0ZXIsIHNraXBGaXJzdCApIHtcblx0XHRcdHZhciBjID0gdGFibGUuY29uZmlnLFxuXHRcdFx0XHR3byA9IGMud2lkZ2V0T3B0aW9ucyxcblx0XHRcdFx0ZmlsdGVyQXJyYXkgPSAkLmlzQXJyYXkoIGZpbHRlciApLFxuXHRcdFx0XHRmaWx0ZXJzID0gKCBmaWx0ZXJBcnJheSApID8gZmlsdGVyIDogdHMuZ2V0RmlsdGVycyggdGFibGUsIHRydWUgKSxcblx0XHRcdFx0Y3VycmVudEZpbHRlcnMgPSBmaWx0ZXJzIHx8IFtdOyAvLyBjdXJyZW50IGZpbHRlciB2YWx1ZXNcblx0XHRcdC8vIHByZXZlbnQgZXJyb3JzIGlmIGRlbGF5IGluaXQgaXMgc2V0XG5cdFx0XHRpZiAoICQuaXNFbXB0eU9iamVjdCggYy5jYWNoZSApICkge1xuXHRcdFx0XHQvLyB1cGRhdGUgY2FjaGUgaWYgZGVsYXlJbml0IHNldCAmIHBhZ2VyIGhhcyBpbml0aWFsaXplZCAoIGFmdGVyIHVzZXIgaW5pdGlhdGVzIGEgc2VhcmNoIClcblx0XHRcdFx0aWYgKCBjLmRlbGF5SW5pdCAmJiAoICFjLnBhZ2VyIHx8IGMucGFnZXIgJiYgYy5wYWdlci5pbml0aWFsaXplZCApICkge1xuXHRcdFx0XHRcdHRzLnVwZGF0ZUNhY2hlKCBjLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRzZi5jaGVja0ZpbHRlcnMoIHRhYmxlLCBmYWxzZSwgc2tpcEZpcnN0ICk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWRkIGZpbHRlciBhcnJheSBiYWNrIGludG8gaW5wdXRzXG5cdFx0XHRpZiAoIGZpbHRlckFycmF5ICkge1xuXHRcdFx0XHR0cy5zZXRGaWx0ZXJzKCB0YWJsZSwgZmlsdGVycywgZmFsc2UsIHNraXBGaXJzdCAhPT0gdHJ1ZSApO1xuXHRcdFx0XHRpZiAoICF3by5maWx0ZXJfaW5pdGlhbGl6ZWQgKSB7XG5cdFx0XHRcdFx0Yy5sYXN0U2VhcmNoID0gW107XG5cdFx0XHRcdFx0Yy5sYXN0Q29tYmluZWRGaWx0ZXIgPSAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCB3by5maWx0ZXJfaGlkZUZpbHRlcnMgKSB7XG5cdFx0XHRcdC8vIHNob3cvaGlkZSBmaWx0ZXIgcm93IGFzIG5lZWRlZFxuXHRcdFx0XHRjLiR0YWJsZVxuXHRcdFx0XHRcdC5maW5kKCAnLicgKyB0c2Nzcy5maWx0ZXJSb3cgKVxuXHRcdFx0XHRcdC50cmlnZ2VySGFuZGxlciggdHNmLmhpZGVGaWx0ZXJzQ2hlY2soIGMgKSA/ICdtb3VzZWxlYXZlJyA6ICdtb3VzZWVudGVyJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcmV0dXJuIGlmIHRoZSBsYXN0IHNlYXJjaCBpcyB0aGUgc2FtZTsgYnV0IGZpbHRlciA9PT0gZmFsc2Ugd2hlbiB1cGRhdGluZyB0aGUgc2VhcmNoXG5cdFx0XHQvLyBzZWUgZXhhbXBsZS13aWRnZXQtZmlsdGVyLmh0bWwgZmlsdGVyIHRvZ2dsZSBidXR0b25zXG5cdFx0XHRpZiAoIHRzZi5lcXVhbEZpbHRlcnMoYywgYy5sYXN0U2VhcmNoLCBjdXJyZW50RmlsdGVycykgJiYgZmlsdGVyICE9PSBmYWxzZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICggZmlsdGVyID09PSBmYWxzZSApIHtcblx0XHRcdFx0Ly8gZm9yY2UgZmlsdGVyIHJlZnJlc2hcblx0XHRcdFx0Yy5sYXN0Q29tYmluZWRGaWx0ZXIgPSAnJztcblx0XHRcdFx0Yy5sYXN0U2VhcmNoID0gW107XG5cdFx0XHR9XG5cdFx0XHQvLyBkZWZpbmUgZmlsdGVyIGluc2lkZSBpdCBpcyBmYWxzZVxuXHRcdFx0ZmlsdGVycyA9IGZpbHRlcnMgfHwgW107XG5cdFx0XHQvLyBjb252ZXJ0IGZpbHRlcnMgdG8gc3RyaW5ncyAtIHNlZSAjMTA3MFxuXHRcdFx0ZmlsdGVycyA9IEFycmF5LnByb3RvdHlwZS5tYXAgP1xuXHRcdFx0XHRmaWx0ZXJzLm1hcCggU3RyaW5nICkgOlxuXHRcdFx0XHQvLyBmb3IgSUU4ICYgb2xkZXIgYnJvd3NlcnMgLSBtYXliZSBub3QgdGhlIGJlc3QgbWV0aG9kXG5cdFx0XHRcdGZpbHRlcnMuam9pbiggJ1xcdWZmZmQnICkuc3BsaXQoICdcXHVmZmZkJyApO1xuXG5cdFx0XHRpZiAoIHdvLmZpbHRlcl9pbml0aWFsaXplZCApIHtcblx0XHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoICdmaWx0ZXJTdGFydCcsIFsgZmlsdGVycyBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGMuc2hvd1Byb2Nlc3NpbmcgKSB7XG5cdFx0XHRcdC8vIGdpdmUgaXQgdGltZSBmb3IgdGhlIHByb2Nlc3NpbmcgaWNvbiB0byBraWNrIGluXG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRzZi5maW5kUm93cyggdGFibGUsIGZpbHRlcnMsIGN1cnJlbnRGaWx0ZXJzICk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9LCAzMCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHNmLmZpbmRSb3dzKCB0YWJsZSwgZmlsdGVycywgY3VycmVudEZpbHRlcnMgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aGlkZUZpbHRlcnNDaGVjazogZnVuY3Rpb24oIGMgKSB7XG5cdFx0XHRpZiAodHlwZW9mIGMud2lkZ2V0T3B0aW9ucy5maWx0ZXJfaGlkZUZpbHRlcnMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dmFyIHZhbCA9IGMud2lkZ2V0T3B0aW9ucy5maWx0ZXJfaGlkZUZpbHRlcnMoIGMgKTtcblx0XHRcdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cy5nZXRGaWx0ZXJzKCBjLiR0YWJsZSApLmpvaW4oICcnICkgPT09ICcnO1xuXHRcdH0sXG5cdFx0aGlkZUZpbHRlcnM6IGZ1bmN0aW9uKCBjLCAkdGFibGUgKSB7XG5cdFx0XHR2YXIgdGltZXI7XG5cdFx0XHQoICR0YWJsZSB8fCBjLiR0YWJsZSApXG5cdFx0XHRcdC5maW5kKCAnLicgKyB0c2Nzcy5maWx0ZXJSb3cgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIHRzY3NzLmZpbHRlclJvd0hpZGUgKVxuXHRcdFx0XHQuYmluZCggJ21vdXNlZW50ZXIgbW91c2VsZWF2ZScsIGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0XHRcdC8vIHNhdmUgZXZlbnQgb2JqZWN0IC0gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIxNDBcblx0XHRcdFx0XHR2YXIgZXZlbnQgPSBlLFxuXHRcdFx0XHRcdFx0JHJvdyA9ICQoIHRoaXMgKTtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVyICk7XG5cdFx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggL2VudGVyfG92ZXIvLnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdFx0XHRcdFx0JHJvdy5yZW1vdmVDbGFzcyggdHNjc3MuZmlsdGVyUm93SGlkZSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gZG9uJ3QgaGlkZSBpZiBpbnB1dCBoYXMgZm9jdXNcblx0XHRcdFx0XHRcdFx0Ly8gJCggJzpmb2N1cycgKSBuZWVkcyBqUXVlcnkgMS42K1xuXHRcdFx0XHRcdFx0XHRpZiAoICQoIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgKS5jbG9zZXN0KCAndHInIClbMF0gIT09ICRyb3dbMF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gZG9uJ3QgaGlkZSByb3cgaWYgYW55IGZpbHRlciBoYXMgYSB2YWx1ZVxuXHRcdFx0XHRcdFx0XHRcdCRyb3cudG9nZ2xlQ2xhc3MoIHRzY3NzLmZpbHRlclJvd0hpZGUsIHRzZi5oaWRlRmlsdGVyc0NoZWNrKCBjICkgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIDIwMCApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuZmluZCggJ2lucHV0LCBzZWxlY3QnICkuYmluZCggJ2ZvY3VzIGJsdXInLCBmdW5jdGlvbiggZSApIHtcblx0XHRcdFx0XHR2YXIgZXZlbnQgPSBlLFxuXHRcdFx0XHRcdFx0JHJvdyA9ICQoIHRoaXMgKS5jbG9zZXN0KCAndHInICk7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lciApO1xuXHRcdFx0XHRcdHRpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVyICk7XG5cdFx0XHRcdFx0XHQvLyBkb24ndCBoaWRlIHJvdyBpZiBhbnkgZmlsdGVyIGhhcyBhIHZhbHVlXG5cdFx0XHRcdFx0XHQkcm93LnRvZ2dsZUNsYXNzKCB0c2Nzcy5maWx0ZXJSb3dIaWRlLCB0c2YuaGlkZUZpbHRlcnNDaGVjayggYyApICYmIGV2ZW50LnR5cGUgIT09ICdmb2N1cycgKTtcblx0XHRcdFx0XHR9LCAyMDAgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblx0XHRkZWZhdWx0RmlsdGVyOiBmdW5jdGlvbiggZmlsdGVyLCBtYXNrICkge1xuXHRcdFx0aWYgKCBmaWx0ZXIgPT09ICcnICkgeyByZXR1cm4gZmlsdGVyOyB9XG5cdFx0XHR2YXIgcmVnZXggPSB0c2ZSZWdleC5pUXVlcnksXG5cdFx0XHRcdG1hc2tMZW4gPSBtYXNrLm1hdGNoKCB0c2ZSZWdleC5pZ1F1ZXJ5ICkubGVuZ3RoLFxuXHRcdFx0XHRxdWVyeSA9IG1hc2tMZW4gPiAxID8gJC50cmltKCBmaWx0ZXIgKS5zcGxpdCggL1xccy8gKSA6IFsgJC50cmltKCBmaWx0ZXIgKSBdLFxuXHRcdFx0XHRsZW4gPSBxdWVyeS5sZW5ndGggLSAxLFxuXHRcdFx0XHRpbmR4ID0gMCxcblx0XHRcdFx0dmFsID0gbWFzaztcblx0XHRcdGlmICggbGVuIDwgMSAmJiBtYXNrTGVuID4gMSApIHtcblx0XHRcdFx0Ly8gb25seSBvbmUgJ3dvcmQnIGluIHF1ZXJ5IGJ1dCBtYXNrIGhhcyA+MSBzbG90c1xuXHRcdFx0XHRxdWVyeVsxXSA9IHF1ZXJ5WzBdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcmVwbGFjZSBhbGwge3F1ZXJ5fSB3aXRoIHF1ZXJ5IHdvcmRzLi4uXG5cdFx0XHQvLyBpZiBxdWVyeSA9ICdCb2InLCB0aGVuIGNvbnZlcnQgbWFzayBmcm9tICche3F1ZXJ5fScgdG8gJyFCb2InXG5cdFx0XHQvLyBpZiBxdWVyeSA9ICdCb2IgSm9lIEZyYW5rJywgdGhlbiBjb252ZXJ0IG1hc2sgJ3txfSBPUiB7cX0nIHRvICdCb2IgT1IgSm9lIE9SIEZyYW5rJ1xuXHRcdFx0d2hpbGUgKCByZWdleC50ZXN0KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0gdmFsLnJlcGxhY2UoIHJlZ2V4LCBxdWVyeVtpbmR4KytdIHx8ICcnICk7XG5cdFx0XHRcdGlmICggcmVnZXgudGVzdCggdmFsICkgJiYgaW5keCA8IGxlbiAmJiAoIHF1ZXJ5W2luZHhdIHx8ICcnICkgIT09ICcnICkge1xuXHRcdFx0XHRcdHZhbCA9IG1hc2sucmVwbGFjZSggcmVnZXgsIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH0sXG5cdFx0Z2V0TGF0ZXN0U2VhcmNoOiBmdW5jdGlvbiggJGlucHV0ICkge1xuXHRcdFx0aWYgKCAkaW5wdXQgKSB7XG5cdFx0XHRcdHJldHVybiAkaW5wdXQuc29ydCggZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQoIGIgKS5hdHRyKCAnZGF0YS1sYXN0U2VhcmNoVGltZScgKSAtICQoIGEgKS5hdHRyKCAnZGF0YS1sYXN0U2VhcmNoVGltZScgKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJGlucHV0IHx8ICQoKTtcblx0XHR9LFxuXHRcdGZpbmRSYW5nZTogZnVuY3Rpb24oIGMsIHZhbCwgaWdub3JlUmFuZ2VzICkge1xuXHRcdFx0Ly8gbG9vayBmb3IgbXVsdGlwbGUgY29sdW1ucyAnMS0zLDQtNiw4JyBpbiBkYXRhLWNvbHVtblxuXHRcdFx0dmFyIHRlbXAsIHJhbmdlcywgcmFuZ2UsIHN0YXJ0LCBlbmQsIHNpbmdsZXMsIGksIGluZHgsIGxlbixcblx0XHRcdFx0Y29sdW1ucyA9IFtdO1xuXHRcdFx0aWYgKCAvXlswLTldKyQvLnRlc3QoIHZhbCApICkge1xuXHRcdFx0XHQvLyBhbHdheXMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdHJldHVybiBbIHBhcnNlSW50KCB2YWwsIDEwICkgXTtcblx0XHRcdH1cblx0XHRcdC8vIHByb2Nlc3MgY29sdW1uIHJhbmdlXG5cdFx0XHRpZiAoICFpZ25vcmVSYW5nZXMgJiYgLy0vLnRlc3QoIHZhbCApICkge1xuXHRcdFx0XHRyYW5nZXMgPSB2YWwubWF0Y2goIC8oXFxkKylcXHMqLVxccyooXFxkKykvZyApO1xuXHRcdFx0XHRsZW4gPSByYW5nZXMgPyByYW5nZXMubGVuZ3RoIDogMDtcblx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBsZW47IGluZHgrKyApIHtcblx0XHRcdFx0XHRyYW5nZSA9IHJhbmdlc1tpbmR4XS5zcGxpdCggL1xccyotXFxzKi8gKTtcblx0XHRcdFx0XHRzdGFydCA9IHBhcnNlSW50KCByYW5nZVswXSwgMTAgKSB8fCAwO1xuXHRcdFx0XHRcdGVuZCA9IHBhcnNlSW50KCByYW5nZVsxXSwgMTAgKSB8fCAoIGMuY29sdW1ucyAtIDEgKTtcblx0XHRcdFx0XHRpZiAoIHN0YXJ0ID4gZW5kICkge1xuXHRcdFx0XHRcdFx0dGVtcCA9IHN0YXJ0OyBzdGFydCA9IGVuZDsgZW5kID0gdGVtcDsgLy8gc3dhcFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGVuZCA+PSBjLmNvbHVtbnMgKSB7XG5cdFx0XHRcdFx0XHRlbmQgPSBjLmNvbHVtbnMgLSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmb3IgKCA7IHN0YXJ0IDw9IGVuZDsgc3RhcnQrKyApIHtcblx0XHRcdFx0XHRcdGNvbHVtbnNbIGNvbHVtbnMubGVuZ3RoIF0gPSBzdGFydDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIHByb2Nlc3NlZCByYW5nZSBmcm9tIHZhbFxuXHRcdFx0XHRcdHZhbCA9IHZhbC5yZXBsYWNlKCByYW5nZXNbIGluZHggXSwgJycgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gcHJvY2VzcyBzaW5nbGUgY29sdW1uc1xuXHRcdFx0aWYgKCAhaWdub3JlUmFuZ2VzICYmIC8sLy50ZXN0KCB2YWwgKSApIHtcblx0XHRcdFx0c2luZ2xlcyA9IHZhbC5zcGxpdCggL1xccyosXFxzKi8gKTtcblx0XHRcdFx0bGVuID0gc2luZ2xlcy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBzaW5nbGVzWyBpIF0gIT09ICcnICkge1xuXHRcdFx0XHRcdFx0aW5keCA9IHBhcnNlSW50KCBzaW5nbGVzWyBpIF0sIDEwICk7XG5cdFx0XHRcdFx0XHRpZiAoIGluZHggPCBjLmNvbHVtbnMgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbHVtbnNbIGNvbHVtbnMubGVuZ3RoIF0gPSBpbmR4O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gcmV0dXJuIGFsbCBjb2x1bW5zXG5cdFx0XHRpZiAoICFjb2x1bW5zLmxlbmd0aCApIHtcblx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBjLmNvbHVtbnM7IGluZHgrKyApIHtcblx0XHRcdFx0XHRjb2x1bW5zWyBjb2x1bW5zLmxlbmd0aCBdID0gaW5keDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvbHVtbnM7XG5cdFx0fSxcblx0XHRnZXRDb2x1bW5FbG06IGZ1bmN0aW9uKCBjLCAkZWxlbWVudHMsIGNvbHVtbiApIHtcblx0XHRcdC8vIGRhdGEtY29sdW1uIG1heSBjb250YWluIG11bHRpcGxlIGNvbHVtbnMgJzEtMyw1LTYsOCdcblx0XHRcdC8vIHJlcGxhY2VzOiBjLiRmaWx0ZXJzLmZpbHRlciggJ1tkYXRhLWNvbHVtbj1cIicgKyBjb2x1bW4gKyAnXCJdJyApO1xuXHRcdFx0cmV0dXJuICRlbGVtZW50cy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgY29scyA9IHRzZi5maW5kUmFuZ2UoIGMsICQoIHRoaXMgKS5hdHRyKCAnZGF0YS1jb2x1bW4nICkgKTtcblx0XHRcdFx0cmV0dXJuICQuaW5BcnJheSggY29sdW1uLCBjb2xzICkgPiAtMTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0bXVsdGlwbGVDb2x1bW5zOiBmdW5jdGlvbiggYywgJGlucHV0ICkge1xuXHRcdFx0Ly8gbG9vayBmb3IgbXVsdGlwbGUgY29sdW1ucyAnMS0zLDQtNiw4JyBpbiBkYXRhLWNvbHVtblxuXHRcdFx0dmFyIHdvID0gYy53aWRnZXRPcHRpb25zLFxuXHRcdFx0XHQvLyBvbmx5IHRhcmdldCAnYWxsJyBjb2x1bW4gaW5wdXRzIG9uIGluaXRpYWxpemF0aW9uXG5cdFx0XHRcdC8vICYgZG9uJ3QgdGFyZ2V0ICdhbGwnIGNvbHVtbiBpbnB1dHMgaWYgdGhleSBkb24ndCBleGlzdFxuXHRcdFx0XHR0YXJnZXRzID0gd28uZmlsdGVyX2luaXRpYWxpemVkIHx8ICEkaW5wdXQuZmlsdGVyKCB3by5maWx0ZXJfYW55Q29sdW1uU2VsZWN0b3IgKS5sZW5ndGgsXG5cdFx0XHRcdHZhbCA9ICQudHJpbSggdHNmLmdldExhdGVzdFNlYXJjaCggJGlucHV0ICkuYXR0ciggJ2RhdGEtY29sdW1uJyApIHx8ICcnICk7XG5cdFx0XHRyZXR1cm4gdHNmLmZpbmRSYW5nZSggYywgdmFsLCAhdGFyZ2V0cyApO1xuXHRcdH0sXG5cdFx0cHJvY2Vzc1R5cGVzOiBmdW5jdGlvbiggYywgZGF0YSwgdmFycyApIHtcblx0XHRcdHZhciBmZnhuLFxuXHRcdFx0XHRmaWx0ZXJNYXRjaGVkID0gbnVsbCxcblx0XHRcdFx0bWF0Y2hlcyA9IG51bGw7XG5cdFx0XHRmb3IgKCBmZnhuIGluIHRzZi50eXBlcyApIHtcblx0XHRcdFx0aWYgKCAkLmluQXJyYXkoIGZmeG4sIHZhcnMuZXhjbHVkZU1hdGNoICkgPCAwICYmIG1hdGNoZXMgPT09IG51bGwgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IHRzZi50eXBlc1tmZnhuXSggYywgZGF0YSwgdmFycyApO1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlcyAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRhdGEubWF0Y2hlZE9uID0gZmZ4bjtcblx0XHRcdFx0XHRcdGZpbHRlck1hdGNoZWQgPSBtYXRjaGVzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZpbHRlck1hdGNoZWQ7XG5cdFx0fSxcblx0XHRtYXRjaFR5cGU6IGZ1bmN0aW9uKCBjLCBjb2x1bW5JbmRleCApIHtcblx0XHRcdHZhciBpc01hdGNoLFxuXHRcdFx0XHR3byA9IGMud2lkZ2V0T3B0aW9ucyxcblx0XHRcdFx0JGVsID0gYy4kaGVhZGVySW5kZXhlZFsgY29sdW1uSW5kZXggXTtcblx0XHRcdC8vIGZpbHRlci1leGFjdCA+IGZpbHRlci1tYXRjaCA+IGZpbHRlcl9tYXRjaFR5cGUgZm9yIHR5cGVcblx0XHRcdGlmICggJGVsLmhhc0NsYXNzKCAnZmlsdGVyLWV4YWN0JyApICkge1xuXHRcdFx0XHRpc01hdGNoID0gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCAkZWwuaGFzQ2xhc3MoICdmaWx0ZXItbWF0Y2gnICkgKSB7XG5cdFx0XHRcdGlzTWF0Y2ggPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gZmlsdGVyLXNlbGVjdCBpcyBub3QgYXBwbGllZCB3aGVuIGZpbHRlcl9mdW5jdGlvbnMgYXJlIHVzZWQsIHNvIGxvb2sgZm9yIGEgc2VsZWN0XG5cdFx0XHRcdGlmICggd28uZmlsdGVyX2NvbHVtbkZpbHRlcnMgKSB7XG5cdFx0XHRcdFx0JGVsID0gYy4kZmlsdGVyc1xuXHRcdFx0XHRcdFx0LmZpbmQoICcuJyArIHRzY3NzLmZpbHRlciApXG5cdFx0XHRcdFx0XHQuYWRkKCB3by5maWx0ZXJfJGV4dGVybmFsRmlsdGVycyApXG5cdFx0XHRcdFx0XHQuZmlsdGVyKCAnW2RhdGEtY29sdW1uPVwiJyArIGNvbHVtbkluZGV4ICsgJ1wiXScgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggd28uZmlsdGVyXyRleHRlcm5hbEZpbHRlcnMgKSB7XG5cdFx0XHRcdFx0JGVsID0gd28uZmlsdGVyXyRleHRlcm5hbEZpbHRlcnMuZmlsdGVyKCAnW2RhdGEtY29sdW1uPVwiJyArIGNvbHVtbkluZGV4ICsgJ1wiXScgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpc01hdGNoID0gJGVsLmxlbmd0aCA/XG5cdFx0XHRcdFx0Yy53aWRnZXRPcHRpb25zLmZpbHRlcl9tYXRjaFR5cGVbICggJGVsWyAwIF0ubm9kZU5hbWUgfHwgJycgKS50b0xvd2VyQ2FzZSgpIF0gPT09ICdtYXRjaCcgOlxuXHRcdFx0XHRcdC8vIGRlZmF1bHQgdG8gZXhhY3QsIGlmIG5vIGlucHV0cyBmb3VuZFxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGlzTWF0Y2g7XG5cdFx0fSxcblx0XHRwcm9jZXNzUm93OiBmdW5jdGlvbiggYywgZGF0YSwgdmFycyApIHtcblx0XHRcdHZhciByZXN1bHQsIGZpbHRlck1hdGNoZWQsXG5cdFx0XHRcdGZ4biwgZmZ4biwgdHh0LFxuXHRcdFx0XHR3byA9IGMud2lkZ2V0T3B0aW9ucyxcblx0XHRcdFx0c2hvd1JvdyA9IHRydWUsXG5cdFx0XHRcdGhhc0FueU1hdGNoSW5wdXQgPSB3by5maWx0ZXJfJGFueU1hdGNoICYmIHdvLmZpbHRlcl8kYW55TWF0Y2gubGVuZ3RoLFxuXG5cdFx0XHRcdC8vIGlmIHdvLmZpbHRlcl8kYW55TWF0Y2ggZGF0YS1jb2x1bW4gYXR0cmlidXRlIGlzIGNoYW5nZWQgZHluYW1pY2FsbHlcblx0XHRcdFx0Ly8gd2UgZG9uJ3Qgd2FudCB0byBkbyBhbiBcImFueU1hdGNoXCIgc2VhcmNoIG9uIG9uZSBjb2x1bW4gdXNpbmcgZGF0YVxuXHRcdFx0XHQvLyBmb3IgdGhlIGVudGlyZSByb3cgLSBzZWUgIzk5OFxuXHRcdFx0XHRjb2x1bW5JbmRleCA9IHdvLmZpbHRlcl8kYW55TWF0Y2ggJiYgd28uZmlsdGVyXyRhbnlNYXRjaC5sZW5ndGggP1xuXHRcdFx0XHRcdC8vIGxvb2sgZm9yIG11bHRpcGxlIGNvbHVtbnMgJzEtMyw0LTYsOCdcblx0XHRcdFx0XHR0c2YubXVsdGlwbGVDb2x1bW5zKCBjLCB3by5maWx0ZXJfJGFueU1hdGNoICkgOlxuXHRcdFx0XHRcdFtdO1xuXHRcdFx0ZGF0YS4kY2VsbHMgPSBkYXRhLiRyb3cuY2hpbGRyZW4oKTtcblx0XHRcdGRhdGEubWF0Y2hlZE9uID0gbnVsbDtcblx0XHRcdGlmICggZGF0YS5hbnlNYXRjaEZsYWcgJiYgY29sdW1uSW5kZXgubGVuZ3RoID4gMSB8fCAoIGRhdGEuYW55TWF0Y2hGaWx0ZXIgJiYgIWhhc0FueU1hdGNoSW5wdXQgKSApIHtcblx0XHRcdFx0ZGF0YS5hbnlNYXRjaCA9IHRydWU7XG5cdFx0XHRcdGRhdGEuaXNNYXRjaCA9IHRydWU7XG5cdFx0XHRcdGRhdGEucm93QXJyYXkgPSBkYXRhLiRjZWxscy5tYXAoIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGlmICggJC5pbkFycmF5KCBpLCBjb2x1bW5JbmRleCApID4gLTEgfHwgKCBkYXRhLmFueU1hdGNoRmlsdGVyICYmICFoYXNBbnlNYXRjaElucHV0ICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGRhdGEucGFyc2VkWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdHR4dCA9IGRhdGEuY2FjaGVBcnJheVsgaSBdO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHh0ID0gZGF0YS5yYXdBcnJheVsgaSBdO1xuXHRcdFx0XHRcdFx0XHR0eHQgPSAkLnRyaW0oIHdvLmZpbHRlcl9pZ25vcmVDYXNlID8gdHh0LnRvTG93ZXJDYXNlKCkgOiB0eHQgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjLnNvcnRMb2NhbGVDb21wYXJlICkge1xuXHRcdFx0XHRcdFx0XHRcdHR4dCA9IHRzLnJlcGxhY2VBY2NlbnRzKCB0eHQgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHR4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pLmdldCgpO1xuXHRcdFx0XHRkYXRhLmZpbHRlciA9IGRhdGEuYW55TWF0Y2hGaWx0ZXI7XG5cdFx0XHRcdGRhdGEuaUZpbHRlciA9IGRhdGEuaUFueU1hdGNoRmlsdGVyO1xuXHRcdFx0XHRkYXRhLmV4YWN0ID0gZGF0YS5yb3dBcnJheS5qb2luKCAnICcgKTtcblx0XHRcdFx0ZGF0YS5pRXhhY3QgPSB3by5maWx0ZXJfaWdub3JlQ2FzZSA/IGRhdGEuZXhhY3QudG9Mb3dlckNhc2UoKSA6IGRhdGEuZXhhY3Q7XG5cdFx0XHRcdGRhdGEuY2FjaGUgPSBkYXRhLmNhY2hlQXJyYXkuc2xpY2UoIDAsIC0xICkuam9pbiggJyAnICk7XG5cdFx0XHRcdHZhcnMuZXhjbHVkZU1hdGNoID0gdmFycy5ub0FueU1hdGNoO1xuXHRcdFx0XHRmaWx0ZXJNYXRjaGVkID0gdHNmLnByb2Nlc3NUeXBlcyggYywgZGF0YSwgdmFycyApO1xuXHRcdFx0XHRpZiAoIGZpbHRlck1hdGNoZWQgIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0c2hvd1JvdyA9IGZpbHRlck1hdGNoZWQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCB3by5maWx0ZXJfc3RhcnRzV2l0aCApIHtcblx0XHRcdFx0XHRcdHNob3dSb3cgPSBmYWxzZTtcblx0XHRcdFx0XHRcdC8vIGRhdGEucm93QXJyYXkgbWF5IG5vdCBjb250YWluIGFsbCBjb2x1bW5zXG5cdFx0XHRcdFx0XHRjb2x1bW5JbmRleCA9IE1hdGgubWluKCBjLmNvbHVtbnMsIGRhdGEucm93QXJyYXkubGVuZ3RoICk7XG5cdFx0XHRcdFx0XHR3aGlsZSAoICFzaG93Um93ICYmIGNvbHVtbkluZGV4ID4gMCApIHtcblx0XHRcdFx0XHRcdFx0Y29sdW1uSW5kZXgtLTtcblx0XHRcdFx0XHRcdFx0c2hvd1JvdyA9IHNob3dSb3cgfHwgZGF0YS5yb3dBcnJheVsgY29sdW1uSW5kZXggXS5pbmRleE9mKCBkYXRhLmlGaWx0ZXIgKSA9PT0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2hvd1JvdyA9ICggZGF0YS5pRXhhY3QgKyBkYXRhLmNoaWxkUm93VGV4dCApLmluZGV4T2YoIGRhdGEuaUZpbHRlciApID49IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGEuYW55TWF0Y2ggPSBmYWxzZTtcblx0XHRcdFx0Ly8gbm8gb3RoZXIgZmlsdGVycyB0byBwcm9jZXNzXG5cdFx0XHRcdGlmICggZGF0YS5maWx0ZXJzLmpvaW4oICcnICkgPT09IGRhdGEuZmlsdGVyICkge1xuXHRcdFx0XHRcdHJldHVybiBzaG93Um93O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGNvbHVtbkluZGV4ID0gMDsgY29sdW1uSW5kZXggPCBjLmNvbHVtbnM7IGNvbHVtbkluZGV4KysgKSB7XG5cdFx0XHRcdGRhdGEuZmlsdGVyID0gZGF0YS5maWx0ZXJzWyBjb2x1bW5JbmRleCBdO1xuXHRcdFx0XHRkYXRhLmluZGV4ID0gY29sdW1uSW5kZXg7XG5cblx0XHRcdFx0Ly8gZmlsdGVyIHR5cGVzIHRvIGV4Y2x1ZGUsIHBlciBjb2x1bW5cblx0XHRcdFx0dmFycy5leGNsdWRlTWF0Y2ggPSB2YXJzLmV4Y2x1ZGVGaWx0ZXJbIGNvbHVtbkluZGV4IF07XG5cblx0XHRcdFx0Ly8gaWdub3JlIGlmIGZpbHRlciBpcyBlbXB0eSBvciBkaXNhYmxlZFxuXHRcdFx0XHRpZiAoIGRhdGEuZmlsdGVyICkge1xuXHRcdFx0XHRcdGRhdGEuY2FjaGUgPSBkYXRhLmNhY2hlQXJyYXlbIGNvbHVtbkluZGV4IF07XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YS5wYXJzZWRbIGNvbHVtbkluZGV4IF0gPyBkYXRhLmNhY2hlIDogZGF0YS5yYXdBcnJheVsgY29sdW1uSW5kZXggXSB8fCAnJztcblx0XHRcdFx0XHRkYXRhLmV4YWN0ID0gYy5zb3J0TG9jYWxlQ29tcGFyZSA/IHRzLnJlcGxhY2VBY2NlbnRzKCByZXN1bHQgKSA6IHJlc3VsdDsgLy8gaXNzdWUgIzQwNVxuXHRcdFx0XHRcdGRhdGEuaUV4YWN0ID0gIXRzZlJlZ2V4LnR5cGUudGVzdCggdHlwZW9mIGRhdGEuZXhhY3QgKSAmJiB3by5maWx0ZXJfaWdub3JlQ2FzZSA/XG5cdFx0XHRcdFx0XHRkYXRhLmV4YWN0LnRvTG93ZXJDYXNlKCkgOiBkYXRhLmV4YWN0O1xuXHRcdFx0XHRcdGRhdGEuaXNNYXRjaCA9IHRzZi5tYXRjaFR5cGUoIGMsIGNvbHVtbkluZGV4ICk7XG5cblx0XHRcdFx0XHRyZXN1bHQgPSBzaG93Um93OyAvLyBpZiBzaG93Um93IGlzIHRydWUsIHNob3cgdGhhdCByb3dcblxuXHRcdFx0XHRcdC8vIGluIGNhc2Ugc2VsZWN0IGZpbHRlciBvcHRpb24gaGFzIGEgZGlmZmVyZW50IHZhbHVlIHZzIHRleHQgJ2EgLSB6fEEgdGhyb3VnaCBaJ1xuXHRcdFx0XHRcdGZmeG4gPSB3by5maWx0ZXJfY29sdW1uRmlsdGVycyA/XG5cdFx0XHRcdFx0XHRjLiRmaWx0ZXJzLmFkZCggd28uZmlsdGVyXyRleHRlcm5hbEZpbHRlcnMgKVxuXHRcdFx0XHRcdFx0XHQuZmlsdGVyKCAnW2RhdGEtY29sdW1uPVwiJyArIGNvbHVtbkluZGV4ICsgJ1wiXScgKVxuXHRcdFx0XHRcdFx0XHQuZmluZCggJ3NlbGVjdCBvcHRpb246c2VsZWN0ZWQnIClcblx0XHRcdFx0XHRcdFx0LmF0dHIoICdkYXRhLWZ1bmN0aW9uLW5hbWUnICkgfHwgJycgOiAnJztcblx0XHRcdFx0XHQvLyByZXBsYWNlIGFjY2VudHMgLSBzZWUgIzM1N1xuXHRcdFx0XHRcdGlmICggYy5zb3J0TG9jYWxlQ29tcGFyZSApIHtcblx0XHRcdFx0XHRcdGRhdGEuZmlsdGVyID0gdHMucmVwbGFjZUFjY2VudHMoIGRhdGEuZmlsdGVyICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gcmVwbGFjZSBjb2x1bW4gc3BlY2lmaWMgZGVmYXVsdCBmaWx0ZXJzIC0gc2VlICMxMDg4XG5cdFx0XHRcdFx0aWYgKCB3by5maWx0ZXJfZGVmYXVsdEZpbHRlciAmJiB0c2ZSZWdleC5pUXVlcnkudGVzdCggdmFycy5kZWZhdWx0Q29sRmlsdGVyWyBjb2x1bW5JbmRleCBdICkgKSB7XG5cdFx0XHRcdFx0XHRkYXRhLmZpbHRlciA9IHRzZi5kZWZhdWx0RmlsdGVyKCBkYXRhLmZpbHRlciwgdmFycy5kZWZhdWx0Q29sRmlsdGVyWyBjb2x1bW5JbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZGF0YS5pRmlsdGVyID0gY2FzZSBpbnNlbnNpdGl2ZSAoIGlmIHdvLmZpbHRlcl9pZ25vcmVDYXNlIGlzIHRydWUgKSxcblx0XHRcdFx0XHQvLyBkYXRhLmZpbHRlciA9IGNhc2Ugc2Vuc2l0aXZlXG5cdFx0XHRcdFx0ZGF0YS5pRmlsdGVyID0gd28uZmlsdGVyX2lnbm9yZUNhc2UgPyAoIGRhdGEuZmlsdGVyIHx8ICcnICkudG9Mb3dlckNhc2UoKSA6IGRhdGEuZmlsdGVyO1xuXHRcdFx0XHRcdGZ4biA9IHZhcnMuZnVuY3Rpb25zWyBjb2x1bW5JbmRleCBdO1xuXHRcdFx0XHRcdGZpbHRlck1hdGNoZWQgPSBudWxsO1xuXHRcdFx0XHRcdGlmICggZnhuICkge1xuXHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgZnhuID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdFx0XHQvLyBmaWx0ZXIgY2FsbGJhY2soIGV4YWN0IGNlbGwgY29udGVudCwgcGFyc2VyIG5vcm1hbGl6ZWQgY29udGVudCxcblx0XHRcdFx0XHRcdFx0Ly8gZmlsdGVyIGlucHV0IHZhbHVlLCBjb2x1bW4gaW5kZXgsIGpRdWVyeSByb3cgb2JqZWN0IClcblx0XHRcdFx0XHRcdFx0ZmlsdGVyTWF0Y2hlZCA9IGZ4biggZGF0YS5leGFjdCwgZGF0YS5jYWNoZSwgZGF0YS5maWx0ZXIsIGNvbHVtbkluZGV4LCBkYXRhLiRyb3csIGMsIGRhdGEgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBmeG5bIGZmeG4gfHwgZGF0YS5maWx0ZXIgXSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdFx0Ly8gc2VsZWN0b3Igb3B0aW9uIGZ1bmN0aW9uXG5cdFx0XHRcdFx0XHRcdHR4dCA9IGZmeG4gfHwgZGF0YS5maWx0ZXI7XG5cdFx0XHRcdFx0XHRcdGZpbHRlck1hdGNoZWQgPVxuXHRcdFx0XHRcdFx0XHRcdGZ4blsgdHh0IF0oIGRhdGEuZXhhY3QsIGRhdGEuY2FjaGUsIGRhdGEuZmlsdGVyLCBjb2x1bW5JbmRleCwgZGF0YS4kcm93LCBjLCBkYXRhICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggZmlsdGVyTWF0Y2hlZCA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdC8vIGN5Y2xlIHRocm91Z2ggdGhlIGRpZmZlcmVudCBmaWx0ZXJzXG5cdFx0XHRcdFx0XHQvLyBmaWx0ZXJzIHJldHVybiBhIGJvb2xlYW4gb3IgbnVsbCBpZiBub3RoaW5nIG1hdGNoZXNcblx0XHRcdFx0XHRcdGZpbHRlck1hdGNoZWQgPSB0c2YucHJvY2Vzc1R5cGVzKCBjLCBkYXRhLCB2YXJzICk7XG5cdFx0XHRcdFx0XHQvLyBzZWxlY3Qgd2l0aCBleGFjdCBtYXRjaDsgaWdub3JlIFwiYW5kXCIgb3IgXCJvclwiIHdpdGhpbiB0aGUgdGV4dDsgZml4ZXMgIzE0ODZcblx0XHRcdFx0XHRcdHR4dCA9IGZ4biA9PT0gdHJ1ZSAmJiAoZGF0YS5tYXRjaGVkT24gPT09ICdhbmQnIHx8IGRhdGEubWF0Y2hlZE9uID09PSAnb3InKTtcblx0XHRcdFx0XHRcdGlmICggZmlsdGVyTWF0Y2hlZCAhPT0gbnVsbCAmJiAhdHh0KSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdCA9IGZpbHRlck1hdGNoZWQ7XG5cdFx0XHRcdFx0XHQvLyBMb29rIGZvciBtYXRjaCwgYW5kIGFkZCBjaGlsZCByb3cgZGF0YSBmb3IgbWF0Y2hpbmdcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIGNoZWNrIGZ4biAoZmlsdGVyLXNlbGVjdCBpbiBoZWFkZXIpIGFmdGVyIGZpbHRlciB0eXBlcyBhcmUgY2hlY2tlZFxuXHRcdFx0XHRcdFx0XHQvLyB3aXRob3V0IHRoaXMsIHRoZSBmaWx0ZXIgKyBqUXVlcnkgVUkgc2VsZWN0bWVudSBkZW1vIHdhcyBicmVha2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIGZ4biA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBkZWZhdWx0IHNlbGVjdG9yIHVzZXMgZXhhY3QgbWF0Y2ggdW5sZXNzICdmaWx0ZXItbWF0Y2gnIGNsYXNzIGlzIGZvdW5kXG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gZGF0YS5pc01hdGNoID9cblx0XHRcdFx0XHRcdFx0XHRcdC8vIGRhdGEuaUV4YWN0IG1heSBiZSBhIG51bWJlclxuXHRcdFx0XHRcdFx0XHRcdFx0KCAnJyArIGRhdGEuaUV4YWN0ICkuc2VhcmNoKCBkYXRhLmlGaWx0ZXIgKSA+PSAwIDpcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGEuZmlsdGVyID09PSBkYXRhLmV4YWN0O1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHR4dCA9ICggZGF0YS5pRXhhY3QgKyBkYXRhLmNoaWxkUm93VGV4dCApLmluZGV4T2YoIHRzZi5wYXJzZUZpbHRlciggYywgZGF0YS5pRmlsdGVyLCBkYXRhICkgKTtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQgPSAoICggIXdvLmZpbHRlcl9zdGFydHNXaXRoICYmIHR4dCA+PSAwICkgfHwgKCB3by5maWx0ZXJfc3RhcnRzV2l0aCAmJiB0eHQgPT09IDAgKSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IGZpbHRlck1hdGNoZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNob3dSb3cgPSAoIHJlc3VsdCApID8gc2hvd1JvdyA6IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2hvd1Jvdztcblx0XHR9LFxuXHRcdGZpbmRSb3dzOiBmdW5jdGlvbiggdGFibGUsIGZpbHRlcnMsIGN1cnJlbnRGaWx0ZXJzICkge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHR0c2YuZXF1YWxGaWx0ZXJzKHRhYmxlLmNvbmZpZywgdGFibGUuY29uZmlnLmxhc3RTZWFyY2gsIGN1cnJlbnRGaWx0ZXJzKSB8fFxuXHRcdFx0XHQhdGFibGUuY29uZmlnLndpZGdldE9wdGlvbnMuZmlsdGVyX2luaXRpYWxpemVkXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGxlbiwgbm9ybV9yb3dzLCByb3dEYXRhLCAkcm93cywgJHJvdywgcm93SW5kZXgsIHRib2R5SW5kZXgsICR0Ym9keSwgY29sdW1uSW5kZXgsXG5cdFx0XHRcdGlzQ2hpbGQsIGNoaWxkUm93LCBsYXN0U2VhcmNoLCBzaG93Um93LCBzaG93UGFyZW50LCB0aW1lLCB2YWwsIGluZHgsXG5cdFx0XHRcdG5vdEZpbHRlcmVkLCBzZWFyY2hGaWx0ZXJlZCwgcXVlcnksIGluamVjdGVkLCByZXMsIGlkLCB0eHQsXG5cdFx0XHRcdHN0b3JlZEZpbHRlcnMgPSAkLmV4dGVuZCggW10sIGZpbHRlcnMgKSxcblx0XHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdFx0d28gPSBjLndpZGdldE9wdGlvbnMsXG5cdFx0XHRcdGRlYnVnID0gdHMuZGVidWcoYywgJ2ZpbHRlcicpLFxuXHRcdFx0XHQvLyBkYXRhIG9iamVjdCBwYXNzZWQgdG8gZmlsdGVyczsgYW55TWF0Y2ggaXMgYSBmbGFnIGZvciB0aGUgZmlsdGVyc1xuXHRcdFx0XHRkYXRhID0ge1xuXHRcdFx0XHRcdGFueU1hdGNoOiBmYWxzZSxcblx0XHRcdFx0XHRmaWx0ZXJzOiBmaWx0ZXJzLFxuXHRcdFx0XHRcdC8vIHJlZ2V4IGZpbHRlciB0eXBlIGNhY2hlXG5cdFx0XHRcdFx0ZmlsdGVyX3JlZ2V4Q2FjaGUgOiBbXVxuXHRcdFx0XHR9LFxuXHRcdFx0XHR2YXJzID0ge1xuXHRcdFx0XHRcdC8vIGFueU1hdGNoIHJlYWxseSBzY3Jld3MgdXAgd2l0aCB0aGVzZSB0eXBlcyBvZiBmaWx0ZXJzXG5cdFx0XHRcdFx0bm9BbnlNYXRjaDogWyAncmFuZ2UnLCAgJ29wZXJhdG9ycycgXSxcblx0XHRcdFx0XHQvLyBjYWNoZSBmaWx0ZXIgdmFyaWFibGVzIHRoYXQgdXNlIHRzLmdldENvbHVtbkRhdGEgaW4gdGhlIG1haW4gbG9vcFxuXHRcdFx0XHRcdGZ1bmN0aW9ucyA6IFtdLFxuXHRcdFx0XHRcdGV4Y2x1ZGVGaWx0ZXIgOiBbXSxcblx0XHRcdFx0XHRkZWZhdWx0Q29sRmlsdGVyIDogW10sXG5cdFx0XHRcdFx0ZGVmYXVsdEFueUZpbHRlciA6IHRzLmdldENvbHVtbkRhdGEoIHRhYmxlLCB3by5maWx0ZXJfZGVmYXVsdEZpbHRlciwgYy5jb2x1bW5zLCB0cnVlICkgfHwgJydcblx0XHRcdFx0fTtcblx0XHRcdC8vIHBhcnNlIGNvbHVtbnMgYWZ0ZXIgZm9ybWF0dGVyLCBpbiBjYXNlIHRoZSBjbGFzcyBpcyBhZGRlZCBhdCB0aGF0IHBvaW50XG5cdFx0XHRkYXRhLnBhcnNlZCA9IFtdO1xuXHRcdFx0Zm9yICggY29sdW1uSW5kZXggPSAwOyBjb2x1bW5JbmRleCA8IGMuY29sdW1uczsgY29sdW1uSW5kZXgrKyApIHtcblx0XHRcdFx0ZGF0YS5wYXJzZWRbIGNvbHVtbkluZGV4IF0gPSB3by5maWx0ZXJfdXNlUGFyc2VkRGF0YSB8fFxuXHRcdFx0XHRcdC8vIHBhcnNlciBoYXMgYSBcInBhcnNlZFwiIHBhcmFtZXRlclxuXHRcdFx0XHRcdCggYy5wYXJzZXJzICYmIGMucGFyc2Vyc1sgY29sdW1uSW5kZXggXSAmJiBjLnBhcnNlcnNbIGNvbHVtbkluZGV4IF0ucGFyc2VkIHx8XG5cdFx0XHRcdFx0Ly8gZ2V0RGF0YSBtYXkgbm90IHJldHVybiAncGFyc2VkJyBpZiBvdGhlciAnZmlsdGVyLScgY2xhc3MgbmFtZXMgZXhpc3Rcblx0XHRcdFx0XHQvLyAoIGUuZy4gPHRoIGNsYXNzPVwiZmlsdGVyLXNlbGVjdCBmaWx0ZXItcGFyc2VkXCI+IClcblx0XHRcdFx0XHR0cy5nZXREYXRhICYmIHRzLmdldERhdGEoIGMuJGhlYWRlckluZGV4ZWRbIGNvbHVtbkluZGV4IF0sXG5cdFx0XHRcdFx0XHR0cy5nZXRDb2x1bW5EYXRhKCB0YWJsZSwgYy5oZWFkZXJzLCBjb2x1bW5JbmRleCApLCAnZmlsdGVyJyApID09PSAncGFyc2VkJyB8fFxuXHRcdFx0XHRcdGMuJGhlYWRlckluZGV4ZWRbIGNvbHVtbkluZGV4IF0uaGFzQ2xhc3MoICdmaWx0ZXItcGFyc2VkJyApICk7XG5cblx0XHRcdFx0dmFycy5mdW5jdGlvbnNbIGNvbHVtbkluZGV4IF0gPVxuXHRcdFx0XHRcdHRzLmdldENvbHVtbkRhdGEoIHRhYmxlLCB3by5maWx0ZXJfZnVuY3Rpb25zLCBjb2x1bW5JbmRleCApIHx8XG5cdFx0XHRcdFx0Yy4kaGVhZGVySW5kZXhlZFsgY29sdW1uSW5kZXggXS5oYXNDbGFzcyggJ2ZpbHRlci1zZWxlY3QnICk7XG5cdFx0XHRcdHZhcnMuZGVmYXVsdENvbEZpbHRlclsgY29sdW1uSW5kZXggXSA9XG5cdFx0XHRcdFx0dHMuZ2V0Q29sdW1uRGF0YSggdGFibGUsIHdvLmZpbHRlcl9kZWZhdWx0RmlsdGVyLCBjb2x1bW5JbmRleCApIHx8ICcnO1xuXHRcdFx0XHR2YXJzLmV4Y2x1ZGVGaWx0ZXJbIGNvbHVtbkluZGV4IF0gPVxuXHRcdFx0XHRcdCggdHMuZ2V0Q29sdW1uRGF0YSggdGFibGUsIHdvLmZpbHRlcl9leGNsdWRlRmlsdGVyLCBjb2x1bW5JbmRleCwgdHJ1ZSApIHx8ICcnICkuc3BsaXQoIC9cXHMrLyApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGRlYnVnICkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyggJ0ZpbHRlciA+PiBTdGFydGluZyBmaWx0ZXIgd2lkZ2V0IHNlYXJjaCcsIGZpbHRlcnMgKTtcblx0XHRcdFx0dGltZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBmaWx0ZXJlZCByb3dzIGNvdW50XG5cdFx0XHRjLmZpbHRlcmVkUm93cyA9IDA7XG5cdFx0XHRjLnRvdGFsUm93cyA9IDA7XG5cdFx0XHRjdXJyZW50RmlsdGVycyA9ICggc3RvcmVkRmlsdGVycyB8fCBbXSApO1xuXG5cdFx0XHRmb3IgKCB0Ym9keUluZGV4ID0gMDsgdGJvZHlJbmRleCA8IGMuJHRib2RpZXMubGVuZ3RoOyB0Ym9keUluZGV4KysgKSB7XG5cdFx0XHRcdCR0Ym9keSA9IHRzLnByb2Nlc3NUYm9keSggdGFibGUsIGMuJHRib2RpZXMuZXEoIHRib2R5SW5kZXggKSwgdHJ1ZSApO1xuXHRcdFx0XHQvLyBza2lwIGNoaWxkIHJvd3MgJiB3aWRnZXQgYWRkZWQgKCByZW1vdmFibGUgKSByb3dzIC0gZml4ZXMgIzQ0OCB0aGFua3MgdG8gQGhlbXBlbCFcblx0XHRcdFx0Ly8gJHJvd3MgPSAkdGJvZHkuY2hpbGRyZW4oICd0cicgKS5ub3QoIGMuc2VsZWN0b3JSZW1vdmUgKTtcblx0XHRcdFx0Y29sdW1uSW5kZXggPSBjLmNvbHVtbnM7XG5cdFx0XHRcdC8vIGNvbnZlcnQgc3RvcmVkIHJvd3MgaW50byBhIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0bm9ybV9yb3dzID0gYy5jYWNoZVsgdGJvZHlJbmRleCBdLm5vcm1hbGl6ZWQ7XG5cdFx0XHRcdCRyb3dzID0gJCggJC5tYXAoIG5vcm1fcm93cywgZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0XHRcdHJldHVybiBlbFsgY29sdW1uSW5kZXggXS4kcm93LmdldCgpO1xuXHRcdFx0XHR9KSApO1xuXG5cdFx0XHRcdGlmICggY3VycmVudEZpbHRlcnMuam9pbignJykgPT09ICcnIHx8IHdvLmZpbHRlcl9zZXJ2ZXJzaWRlRmlsdGVyaW5nICkge1xuXHRcdFx0XHRcdCRyb3dzXG5cdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIHdvLmZpbHRlcl9maWx0ZXJlZFJvdyApXG5cdFx0XHRcdFx0XHQubm90KCAnLicgKyBjLmNzc0NoaWxkUm93IClcblx0XHRcdFx0XHRcdC5jc3MoICdkaXNwbGF5JywgJycgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBmaWx0ZXIgb3V0IGNoaWxkIHJvd3Ncblx0XHRcdFx0XHQkcm93cyA9ICRyb3dzLm5vdCggJy4nICsgYy5jc3NDaGlsZFJvdyApO1xuXHRcdFx0XHRcdGxlbiA9ICRyb3dzLmxlbmd0aDtcblxuXHRcdFx0XHRcdGlmICggKCB3by5maWx0ZXJfJGFueU1hdGNoICYmIHdvLmZpbHRlcl8kYW55TWF0Y2gubGVuZ3RoICkgfHxcblx0XHRcdFx0XHRcdHR5cGVvZiBmaWx0ZXJzW2MuY29sdW1uc10gIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRcdFx0ZGF0YS5hbnlNYXRjaEZsYWcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0ZGF0YS5hbnlNYXRjaEZpbHRlciA9ICcnICsgKFxuXHRcdFx0XHRcdFx0XHRmaWx0ZXJzWyBjLmNvbHVtbnMgXSB8fFxuXHRcdFx0XHRcdFx0XHR3by5maWx0ZXJfJGFueU1hdGNoICYmIHRzZi5nZXRMYXRlc3RTZWFyY2goIHdvLmZpbHRlcl8kYW55TWF0Y2ggKS52YWwoKSB8fFxuXHRcdFx0XHRcdFx0XHQnJ1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGlmICggd28uZmlsdGVyX2NvbHVtbkFueU1hdGNoICkge1xuXHRcdFx0XHRcdFx0XHQvLyBzcGVjaWZpYyBjb2x1bW5zIHNlYXJjaFxuXHRcdFx0XHRcdFx0XHRxdWVyeSA9IGRhdGEuYW55TWF0Y2hGaWx0ZXIuc3BsaXQoIHRzZlJlZ2V4LmFuZFNwbGl0ICk7XG5cdFx0XHRcdFx0XHRcdGluamVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgcXVlcnkubGVuZ3RoOyBpbmR4KysgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzID0gcXVlcnlbIGluZHggXS5zcGxpdCggJzonICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXMubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIG1ha2UgdGhlIGNvbHVtbiBhIG9uZS1iYXNlZCBpbmRleCAoIG5vbi1kZXZlbG9wZXJzIHN0YXJ0IGNvdW50aW5nIGZyb20gb25lIDpQIClcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNOYU4oIHJlc1swXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQkLmVhY2goIGMuaGVhZGVyQ29udGVudCwgZnVuY3Rpb24oIGksIHR4dCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBtdWx0aXBsZSBtYXRjaGVzIGFyZSBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdHh0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZiggcmVzWzBdICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkID0gaTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpbHRlcnNbIGlkIF0gPSByZXNbMV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkID0gcGFyc2VJbnQoIHJlc1swXSwgMTAgKSAtIDE7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGlkID49IDAgJiYgaWQgPCBjLmNvbHVtbnMgKSB7IC8vIGlmIGlkIGlzIGFuIGludGVnZXJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmlsdGVyc1sgaWQgXSA9IHJlc1sxXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cXVlcnkuc3BsaWNlKCBpbmR4LCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGluZHgtLTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aW5qZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoIGluamVjdGVkICkge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEuYW55TWF0Y2hGaWx0ZXIgPSBxdWVyeS5qb2luKCAnICYmICcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIG9wdGltaXplIHNlYXJjaGluZyBvbmx5IHRocm91Z2ggYWxyZWFkeSBmaWx0ZXJlZCByb3dzIC0gc2VlICMzMTNcblx0XHRcdFx0XHRzZWFyY2hGaWx0ZXJlZCA9IHdvLmZpbHRlcl9zZWFyY2hGaWx0ZXJlZDtcblx0XHRcdFx0XHRsYXN0U2VhcmNoID0gYy5sYXN0U2VhcmNoIHx8IGMuJHRhYmxlLmRhdGEoICdsYXN0U2VhcmNoJyApIHx8IFtdO1xuXHRcdFx0XHRcdGlmICggc2VhcmNoRmlsdGVyZWQgKSB7XG5cdFx0XHRcdFx0XHQvLyBjeWNsZSB0aHJvdWdoIGFsbCBmaWx0ZXJzOyBpbmNsdWRlIGxhc3QgKCBjb2x1bW5JbmRleCArIDEgPSBtYXRjaCBhbnkgY29sdW1uICkuIEZpeGVzICM2Njlcblx0XHRcdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgY29sdW1uSW5kZXggKyAxOyBpbmR4KysgKSB7XG5cdFx0XHRcdFx0XHRcdHZhbCA9IGZpbHRlcnNbaW5keF0gfHwgJyc7XG5cdFx0XHRcdFx0XHRcdC8vIGJyZWFrIG91dCBvZiBsb29wIGlmIHdlJ3ZlIGFscmVhZHkgZGV0ZXJtaW5lZCBub3QgdG8gc2VhcmNoIGZpbHRlcmVkIHJvd3Ncblx0XHRcdFx0XHRcdFx0aWYgKCAhc2VhcmNoRmlsdGVyZWQgKSB7IGluZHggPSBjb2x1bW5JbmRleDsgfVxuXHRcdFx0XHRcdFx0XHQvLyBzZWFyY2ggYWxyZWFkeSBmaWx0ZXJlZCByb3dzIGlmLi4uXG5cdFx0XHRcdFx0XHRcdHNlYXJjaEZpbHRlcmVkID0gc2VhcmNoRmlsdGVyZWQgJiYgbGFzdFNlYXJjaC5sZW5ndGggJiZcblx0XHRcdFx0XHRcdFx0XHQvLyB0aGVyZSBhcmUgbm8gY2hhbmdlcyBmcm9tIGJlZ2lubmluZyBvZiBmaWx0ZXJcblx0XHRcdFx0XHRcdFx0XHR2YWwuaW5kZXhPZiggbGFzdFNlYXJjaFtpbmR4XSB8fCAnJyApID09PSAwICYmXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgTk9UIGEgbG9naWNhbCAnb3InLCBvciByYW5nZSAoICd0bycgb3IgJy0nICkgaW4gdGhlIHN0cmluZ1xuXHRcdFx0XHRcdFx0XHRcdCF0c2ZSZWdleC5hbHJlYWR5RmlsdGVyZWQudGVzdCggdmFsICkgJiZcblx0XHRcdFx0XHRcdFx0XHQvLyBpZiB3ZSBhcmUgbm90IGRvaW5nIGV4YWN0IG1hdGNoZXMsIHVzaW5nICd8JyAoIGxvZ2ljYWwgb3IgKSBvciBub3QgJyEnXG5cdFx0XHRcdFx0XHRcdFx0IXRzZlJlZ2V4LmV4YWN0VGVzdC50ZXN0KCB2YWwgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdC8vIGRvbid0IHNlYXJjaCBvbmx5IGZpbHRlcmVkIGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZVxuXHRcdFx0XHRcdFx0XHRcdC8vICggJz4gLTEwJyA9PiAnPiAtMTAwJyB3aWxsIGlnbm9yZSBoaWRkZW4gcm93cyApXG5cdFx0XHRcdFx0XHRcdFx0ISggdHNmUmVnZXguaXNOZWcxLnRlc3QoIHZhbCApIHx8IHRzZlJlZ2V4LmlzTmVnMi50ZXN0KCB2YWwgKSApICYmXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaWYgZmlsdGVyaW5nIHVzaW5nIGEgc2VsZWN0IHdpdGhvdXQgYSAnZmlsdGVyLW1hdGNoJyBjbGFzcyAoIGV4YWN0IG1hdGNoICkgLSBmaXhlcyAjNTkzXG5cdFx0XHRcdFx0XHRcdFx0ISggdmFsICE9PSAnJyAmJiBjLiRmaWx0ZXJzICYmIGMuJGZpbHRlcnMuZmlsdGVyKCAnW2RhdGEtY29sdW1uPVwiJyArIGluZHggKyAnXCJdJyApLmZpbmQoICdzZWxlY3QnICkubGVuZ3RoICYmXG5cdFx0XHRcdFx0XHRcdFx0XHQhdHNmLm1hdGNoVHlwZSggYywgaW5keCApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5vdEZpbHRlcmVkID0gJHJvd3Mubm90KCAnLicgKyB3by5maWx0ZXJfZmlsdGVyZWRSb3cgKS5sZW5ndGg7XG5cdFx0XHRcdFx0Ly8gY2FuJ3Qgc2VhcmNoIHdoZW4gYWxsIHJvd3MgYXJlIGhpZGRlbiAtIHRoaXMgaGFwcGVucyB3aGVuIGxvb2tpbmcgZm9yIGV4YWN0IG1hdGNoZXNcblx0XHRcdFx0XHRpZiAoIHNlYXJjaEZpbHRlcmVkICYmIG5vdEZpbHRlcmVkID09PSAwICkgeyBzZWFyY2hGaWx0ZXJlZCA9IGZhbHNlOyB9XG5cdFx0XHRcdFx0aWYgKCBkZWJ1ZyApIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCAnRmlsdGVyID4+IFNlYXJjaGluZyB0aHJvdWdoICcgK1xuXHRcdFx0XHRcdFx0XHQoIHNlYXJjaEZpbHRlcmVkICYmIG5vdEZpbHRlcmVkIDwgbGVuID8gbm90RmlsdGVyZWQgOiAnYWxsJyApICsgJyByb3dzJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGRhdGEuYW55TWF0Y2hGbGFnICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjLnNvcnRMb2NhbGVDb21wYXJlICkge1xuXHRcdFx0XHRcdFx0XHQvLyByZXBsYWNlIGFjY2VudHNcblx0XHRcdFx0XHRcdFx0ZGF0YS5hbnlNYXRjaEZpbHRlciA9IHRzLnJlcGxhY2VBY2NlbnRzKCBkYXRhLmFueU1hdGNoRmlsdGVyICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIHdvLmZpbHRlcl9kZWZhdWx0RmlsdGVyICYmIHRzZlJlZ2V4LmlRdWVyeS50ZXN0KCB2YXJzLmRlZmF1bHRBbnlGaWx0ZXIgKSApIHtcblx0XHRcdFx0XHRcdFx0ZGF0YS5hbnlNYXRjaEZpbHRlciA9IHRzZi5kZWZhdWx0RmlsdGVyKCBkYXRhLmFueU1hdGNoRmlsdGVyLCB2YXJzLmRlZmF1bHRBbnlGaWx0ZXIgKTtcblx0XHRcdFx0XHRcdFx0Ly8gY2xlYXIgc2VhcmNoIGZpbHRlcmVkIGZsYWcgYmVjYXVzZSBkZWZhdWx0IGZpbHRlcnMgYXJlIG5vdCBzYXZlZCB0byB0aGUgbGFzdCBzZWFyY2hcblx0XHRcdFx0XHRcdFx0c2VhcmNoRmlsdGVyZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIG1ha2UgaUFueU1hdGNoRmlsdGVyIGxvd2VyY2FzZSB1bmxlc3MgYm90aCBmaWx0ZXIgd2lkZ2V0ICYgY29yZSBpZ25vcmVDYXNlIG9wdGlvbnMgYXJlIHRydWVcblx0XHRcdFx0XHRcdC8vIHdoZW4gYy5pZ25vcmVDYXNlIGlzIHRydWUsIHRoZSBjYWNoZSBjb250YWlucyBhbGwgbG93ZXIgY2FzZSBkYXRhXG5cdFx0XHRcdFx0XHRkYXRhLmlBbnlNYXRjaEZpbHRlciA9ICEoIHdvLmZpbHRlcl9pZ25vcmVDYXNlICYmIGMuaWdub3JlQ2FzZSApID9cblx0XHRcdFx0XHRcdFx0ZGF0YS5hbnlNYXRjaEZpbHRlciA6XG5cdFx0XHRcdFx0XHRcdGRhdGEuYW55TWF0Y2hGaWx0ZXIudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBsb29wIHRocm91Z2ggdGhlIHJvd3Ncblx0XHRcdFx0XHRmb3IgKCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgbGVuOyByb3dJbmRleCsrICkge1xuXG5cdFx0XHRcdFx0XHR0eHQgPSAkcm93c1sgcm93SW5kZXggXS5jbGFzc05hbWU7XG5cdFx0XHRcdFx0XHQvLyB0aGUgZmlyc3Qgcm93IGNhbiBuZXZlciBiZSBhIGNoaWxkIHJvd1xuXHRcdFx0XHRcdFx0aXNDaGlsZCA9IHJvd0luZGV4ICYmIHRzZlJlZ2V4LmNoaWxkLnRlc3QoIHR4dCApO1xuXHRcdFx0XHRcdFx0Ly8gc2tpcCBjaGlsZCByb3dzICYgYWxyZWFkeSBmaWx0ZXJlZCByb3dzXG5cdFx0XHRcdFx0XHRpZiAoIGlzQ2hpbGQgfHwgKCBzZWFyY2hGaWx0ZXJlZCAmJiB0c2ZSZWdleC5maWx0ZXJlZC50ZXN0KCB0eHQgKSApICkge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZGF0YS4kcm93ID0gJHJvd3MuZXEoIHJvd0luZGV4ICk7XG5cdFx0XHRcdFx0XHRkYXRhLnJvd0luZGV4ID0gcm93SW5kZXg7XG5cdFx0XHRcdFx0XHRkYXRhLmNhY2hlQXJyYXkgPSBub3JtX3Jvd3NbIHJvd0luZGV4IF07XG5cdFx0XHRcdFx0XHRyb3dEYXRhID0gZGF0YS5jYWNoZUFycmF5WyBjLmNvbHVtbnMgXTtcblx0XHRcdFx0XHRcdGRhdGEucmF3QXJyYXkgPSByb3dEYXRhLnJhdztcblx0XHRcdFx0XHRcdGRhdGEuY2hpbGRSb3dUZXh0ID0gJyc7XG5cblx0XHRcdFx0XHRcdGlmICggIXdvLmZpbHRlcl9jaGlsZEJ5Q29sdW1uICkge1xuXHRcdFx0XHRcdFx0XHR0eHQgPSAnJztcblx0XHRcdFx0XHRcdFx0Ly8gY2hpbGQgcm93IGNhY2hlZCB0ZXh0XG5cdFx0XHRcdFx0XHRcdGNoaWxkUm93ID0gcm93RGF0YS5jaGlsZDtcblx0XHRcdFx0XHRcdFx0Ly8gc28sIGlmICd0YWJsZS5jb25maWcud2lkZ2V0T3B0aW9ucy5maWx0ZXJfY2hpbGRSb3dzJyBpcyB0cnVlIGFuZCB0aGVyZSBpc1xuXHRcdFx0XHRcdFx0XHQvLyBhIG1hdGNoIGFueXdoZXJlIGluIHRoZSBjaGlsZCByb3csIHRoZW4gaXQgd2lsbCBtYWtlIHRoZSByb3cgdmlzaWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBjaGVja2VkIGhlcmUgc28gdGhlIG9wdGlvbiBjYW4gYmUgY2hhbmdlZCBkeW5hbWljYWxseVxuXHRcdFx0XHRcdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGNoaWxkUm93Lmxlbmd0aDsgaW5keCsrICkge1xuXHRcdFx0XHRcdFx0XHRcdHR4dCArPSAnICcgKyBjaGlsZFJvd1tpbmR4XS5qb2luKCAnICcgKSB8fCAnJztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRkYXRhLmNoaWxkUm93VGV4dCA9IHdvLmZpbHRlcl9jaGlsZFJvd3MgP1xuXHRcdFx0XHRcdFx0XHRcdCggd28uZmlsdGVyX2lnbm9yZUNhc2UgPyB0eHQudG9Mb3dlckNhc2UoKSA6IHR4dCApIDpcblx0XHRcdFx0XHRcdFx0XHQnJztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c2hvd1JvdyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0c2hvd1BhcmVudCA9IHRzZi5wcm9jZXNzUm93KCBjLCBkYXRhLCB2YXJzICk7XG5cdFx0XHRcdFx0XHQkcm93ID0gcm93RGF0YS4kcm93O1xuXG5cdFx0XHRcdFx0XHQvLyBkb24ndCBwYXNzIHJlZmVyZW5jZSB0byB2YWxcblx0XHRcdFx0XHRcdHZhbCA9IHNob3dQYXJlbnQgPyB0cnVlIDogZmFsc2U7XG5cdFx0XHRcdFx0XHRjaGlsZFJvdyA9IHJvd0RhdGEuJHJvdy5maWx0ZXIoICc6Z3QoMCknICk7XG5cdFx0XHRcdFx0XHRpZiAoIHdvLmZpbHRlcl9jaGlsZFJvd3MgJiYgY2hpbGRSb3cubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHdvLmZpbHRlcl9jaGlsZEJ5Q29sdW1uICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIXdvLmZpbHRlcl9jaGlsZFdpdGhTaWJzICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaGlkZSBhbGwgY2hpbGQgcm93c1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2hpbGRSb3cuYWRkQ2xhc3MoIHdvLmZpbHRlcl9maWx0ZXJlZFJvdyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaWYgb25seSBzaG93aW5nIHJlc3VsdGluZyBjaGlsZCByb3csIG9ubHkgaW5jbHVkZSBwYXJlbnRcblx0XHRcdFx0XHRcdFx0XHRcdCRyb3cgPSAkcm93LmVxKCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIGN5Y2xlIHRocm91Z2ggZWFjaCBjaGlsZCByb3dcblx0XHRcdFx0XHRcdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGNoaWxkUm93Lmxlbmd0aDsgaW5keCsrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS4kcm93ID0gY2hpbGRSb3cuZXEoIGluZHggKTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGEuY2FjaGVBcnJheSA9IHJvd0RhdGEuY2hpbGRbIGluZHggXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGEucmF3QXJyYXkgPSBkYXRhLmNhY2hlQXJyYXk7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YWwgPSB0c2YucHJvY2Vzc1JvdyggYywgZGF0YSwgdmFycyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gdXNlIE9SIGNvbXBhcmlzb24gb24gY2hpbGQgcm93c1xuXHRcdFx0XHRcdFx0XHRcdFx0c2hvd1JvdyA9IHNob3dSb3cgfHwgdmFsO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAhd28uZmlsdGVyX2NoaWxkV2l0aFNpYnMgJiYgdmFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjaGlsZFJvdy5lcSggaW5keCApLnJlbW92ZUNsYXNzKCB3by5maWx0ZXJfZmlsdGVyZWRSb3cgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Ly8ga2VlcCBwYXJlbnQgcm93IG1hdGNoIGV2ZW4gaWYgbm8gY2hpbGQgbWF0Y2hlcy4uLiBzZWUgIzEwMjBcblx0XHRcdFx0XHRcdFx0c2hvd1JvdyA9IHNob3dSb3cgfHwgc2hvd1BhcmVudDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNob3dSb3cgPSB2YWw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQkcm93XG5cdFx0XHRcdFx0XHRcdC50b2dnbGVDbGFzcyggd28uZmlsdGVyX2ZpbHRlcmVkUm93LCAhc2hvd1JvdyApWzBdXG5cdFx0XHRcdFx0XHRcdC5kaXNwbGF5ID0gc2hvd1JvdyA/ICcnIDogJ25vbmUnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRjLmZpbHRlcmVkUm93cyArPSAkcm93cy5ub3QoICcuJyArIHdvLmZpbHRlcl9maWx0ZXJlZFJvdyApLmxlbmd0aDtcblx0XHRcdFx0Yy50b3RhbFJvd3MgKz0gJHJvd3MubGVuZ3RoO1xuXHRcdFx0XHR0cy5wcm9jZXNzVGJvZHkoIHRhYmxlLCAkdGJvZHksIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBsYXN0Q29tYmluZWRGaWx0ZXIgaXMgbm8gbG9uZ2VyIHVzZWQgaW50ZXJuYWxseVxuXHRcdFx0Yy5sYXN0Q29tYmluZWRGaWx0ZXIgPSBzdG9yZWRGaWx0ZXJzLmpvaW4oJycpOyAvLyBzYXZlIGxhc3Qgc2VhcmNoXG5cdFx0XHQvLyBkb24ndCBzYXZlICdmaWx0ZXJzJyBkaXJlY3RseSBzaW5jZSBpdCBtYXkgaGF2ZSBhbHRlcmVkICggQW55TWF0Y2ggY29sdW1uIHNlYXJjaGVzIClcblx0XHRcdGMubGFzdFNlYXJjaCA9IHN0b3JlZEZpbHRlcnM7XG5cdFx0XHRjLiR0YWJsZS5kYXRhKCAnbGFzdFNlYXJjaCcsIHN0b3JlZEZpbHRlcnMgKTtcblx0XHRcdGlmICggd28uZmlsdGVyX3NhdmVGaWx0ZXJzICYmIHRzLnN0b3JhZ2UgKSB7XG5cdFx0XHRcdHRzLnN0b3JhZ2UoIHRhYmxlLCAndGFibGVzb3J0ZXItZmlsdGVycycsIHRzZi5wcm9jZXNzRmlsdGVycyggc3RvcmVkRmlsdGVycywgdHJ1ZSApICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGRlYnVnICkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyggJ0ZpbHRlciA+PiBDb21wbGV0ZWQgc2VhcmNoJyArIHRzLmJlbmNobWFyayh0aW1lKSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB3by5maWx0ZXJfaW5pdGlhbGl6ZWQgKSB7XG5cdFx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAnZmlsdGVyQmVmb3JlRW5kJywgYyApO1xuXHRcdFx0XHRjLiR0YWJsZS50cmlnZ2VySGFuZGxlciggJ2ZpbHRlckVuZCcsIGMgKTtcblx0XHRcdH1cblx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0cy5hcHBseVdpZGdldCggYy50YWJsZSApOyAvLyBtYWtlIHN1cmUgemVicmEgd2lkZ2V0IGlzIGFwcGxpZWRcblx0XHRcdH0sIDAgKTtcblx0XHR9LFxuXHRcdGdldE9wdGlvblNvdXJjZTogZnVuY3Rpb24oIHRhYmxlLCBjb2x1bW4sIG9ubHlBdmFpbCApIHtcblx0XHRcdHRhYmxlID0gJCggdGFibGUgKVswXTtcblx0XHRcdHZhciBjID0gdGFibGUuY29uZmlnLFxuXHRcdFx0XHR3byA9IGMud2lkZ2V0T3B0aW9ucyxcblx0XHRcdFx0YXJyeSA9IGZhbHNlLFxuXHRcdFx0XHRzb3VyY2UgPSB3by5maWx0ZXJfc2VsZWN0U291cmNlLFxuXHRcdFx0XHRsYXN0ID0gYy4kdGFibGUuZGF0YSggJ2xhc3RTZWFyY2gnICkgfHwgW10sXG5cdFx0XHRcdGZ4biA9IHR5cGVvZiBzb3VyY2UgPT09ICdmdW5jdGlvbicgPyB0cnVlIDogdHMuZ2V0Q29sdW1uRGF0YSggdGFibGUsIHNvdXJjZSwgY29sdW1uICk7XG5cblx0XHRcdGlmICggb25seUF2YWlsICYmIGxhc3RbY29sdW1uXSAhPT0gJycgKSB7XG5cdFx0XHRcdG9ubHlBdmFpbCA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBmaWx0ZXIgc2VsZWN0IHNvdXJjZSBvcHRpb25cblx0XHRcdGlmICggZnhuID09PSB0cnVlICkge1xuXHRcdFx0XHQvLyBPVkVSQUxMIHNvdXJjZVxuXHRcdFx0XHRhcnJ5ID0gc291cmNlKCB0YWJsZSwgY29sdW1uLCBvbmx5QXZhaWwgKTtcblx0XHRcdH0gZWxzZSBpZiAoIGZ4biBpbnN0YW5jZW9mICQgfHwgKCAkLnR5cGUoIGZ4biApID09PSAnc3RyaW5nJyAmJiBmeG4uaW5kZXhPZiggJzwvb3B0aW9uPicgKSA+PSAwICkgKSB7XG5cdFx0XHRcdC8vIHNlbGVjdFNvdXJjZSBpcyBhIGpRdWVyeSBvYmplY3Qgb3Igc3RyaW5nIG9mIG9wdGlvbnNcblx0XHRcdFx0cmV0dXJuIGZ4bjtcblx0XHRcdH0gZWxzZSBpZiAoICQuaXNBcnJheSggZnhuICkgKSB7XG5cdFx0XHRcdGFycnkgPSBmeG47XG5cdFx0XHR9IGVsc2UgaWYgKCAkLnR5cGUoIHNvdXJjZSApID09PSAnb2JqZWN0JyAmJiBmeG4gKSB7XG5cdFx0XHRcdC8vIGN1c3RvbSBzZWxlY3Qgc291cmNlIGZ1bmN0aW9uIGZvciBhIFNQRUNJRklDIENPTFVNTlxuXHRcdFx0XHRhcnJ5ID0gZnhuKCB0YWJsZSwgY29sdW1uLCBvbmx5QXZhaWwgKTtcblx0XHRcdFx0Ly8gYWJvcnQgLSB1cGRhdGluZyB0aGUgc2VsZWN0cyBmcm9tIGFuIGV4dGVybmFsIG1ldGhvZFxuXHRcdFx0XHRpZiAoYXJyeSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGFycnkgPT09IGZhbHNlICkge1xuXHRcdFx0XHQvLyBmYWxsIGJhY2sgdG8gb3JpZ2luYWwgbWV0aG9kXG5cdFx0XHRcdGFycnkgPSB0c2YuZ2V0T3B0aW9ucyggdGFibGUsIGNvbHVtbiwgb25seUF2YWlsICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0c2YucHJvY2Vzc09wdGlvbnMoIHRhYmxlLCBjb2x1bW4sIGFycnkgKTtcblxuXHRcdH0sXG5cdFx0cHJvY2Vzc09wdGlvbnM6IGZ1bmN0aW9uKCB0YWJsZSwgY29sdW1uLCBhcnJ5ICkge1xuXHRcdFx0aWYgKCAhJC5pc0FycmF5KCBhcnJ5ICkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHRhYmxlID0gJCggdGFibGUgKVswXTtcblx0XHRcdHZhciBjdHMsIHR4dCwgaW5keCwgbGVuLCBwYXJzZWRUeHQsIHN0cixcblx0XHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdFx0dmFsaWRDb2x1bW4gPSB0eXBlb2YgY29sdW1uICE9PSAndW5kZWZpbmVkJyAmJiBjb2x1bW4gIT09IG51bGwgJiYgY29sdW1uID49IDAgJiYgY29sdW1uIDwgYy5jb2x1bW5zLFxuXHRcdFx0XHRkaXJlY3Rpb24gPSB2YWxpZENvbHVtbiA/IGMuJGhlYWRlckluZGV4ZWRbIGNvbHVtbiBdLmhhc0NsYXNzKCAnZmlsdGVyLXNlbGVjdC1zb3J0LWRlc2MnICkgOiBmYWxzZSxcblx0XHRcdFx0cGFyc2VkID0gW107XG5cdFx0XHQvLyBnZXQgdW5pcXVlIGVsZW1lbnRzIGFuZCBzb3J0IHRoZSBsaXN0XG5cdFx0XHQvLyBpZiAkLnRhYmxlc29ydGVyLnNvcnRUZXh0IGV4aXN0cyAoIG5vdCBpbiB0aGUgb3JpZ2luYWwgdGFibGVzb3J0ZXIgKSxcblx0XHRcdC8vIHRoZW4gbmF0dXJhbCBzb3J0IHRoZSBsaXN0IG90aGVyd2lzZSB1c2UgYSBiYXNpYyBzb3J0XG5cdFx0XHRhcnJ5ID0gJC5ncmVwKCBhcnJ5LCBmdW5jdGlvbiggdmFsdWUsIGluZHggKSB7XG5cdFx0XHRcdGlmICggdmFsdWUudGV4dCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gJC5pbkFycmF5KCB2YWx1ZSwgYXJyeSApID09PSBpbmR4O1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoIHZhbGlkQ29sdW1uICYmIGMuJGhlYWRlckluZGV4ZWRbIGNvbHVtbiBdLmhhc0NsYXNzKCAnZmlsdGVyLXNlbGVjdC1ub3NvcnQnICkgKSB7XG5cdFx0XHRcdC8vIHVuc29ydGVkIHNlbGVjdCBvcHRpb25zXG5cdFx0XHRcdHJldHVybiBhcnJ5O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGVuID0gYXJyeS5sZW5ndGg7XG5cdFx0XHRcdC8vIHBhcnNlIHNlbGVjdCBvcHRpb24gdmFsdWVzXG5cdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgbGVuOyBpbmR4KysgKSB7XG5cdFx0XHRcdFx0dHh0ID0gYXJyeVsgaW5keCBdO1xuXHRcdFx0XHRcdC8vIGNoZWNrIGZvciBvYmplY3Rcblx0XHRcdFx0XHRzdHIgPSB0eHQudGV4dCA/IHR4dC50ZXh0IDogdHh0O1xuXHRcdFx0XHRcdC8vIHNvcnROYXR1cmFsIGJyZWFrcyBpZiB5b3UgZG9uJ3QgcGFzcyBpdCBzdHJpbmdzXG5cdFx0XHRcdFx0cGFyc2VkVHh0ID0gKCB2YWxpZENvbHVtbiAmJiBjLnBhcnNlcnMgJiYgYy5wYXJzZXJzLmxlbmd0aCAmJlxuXHRcdFx0XHRcdFx0Yy5wYXJzZXJzWyBjb2x1bW4gXS5mb3JtYXQoIHN0ciwgdGFibGUsIFtdLCBjb2x1bW4gKSB8fCBzdHIgKS50b1N0cmluZygpO1xuXHRcdFx0XHRcdHBhcnNlZFR4dCA9IGMud2lkZ2V0T3B0aW9ucy5maWx0ZXJfaWdub3JlQ2FzZSA/IHBhcnNlZFR4dC50b0xvd2VyQ2FzZSgpIDogcGFyc2VkVHh0O1xuXHRcdFx0XHRcdC8vIHBhcnNlIGFycmF5IGRhdGEgdXNpbmcgc2V0IGNvbHVtbiBwYXJzZXI7IHRoaXMgRE9FUyBOT1QgcGFzcyB0aGUgb3JpZ2luYWxcblx0XHRcdFx0XHQvLyB0YWJsZSBjZWxsIHRvIHRoZSBwYXJzZXIgZm9ybWF0IGZ1bmN0aW9uXG5cdFx0XHRcdFx0aWYgKCB0eHQudGV4dCApIHtcblx0XHRcdFx0XHRcdHR4dC5wYXJzZWQgPSBwYXJzZWRUeHQ7XG5cdFx0XHRcdFx0XHRwYXJzZWRbIHBhcnNlZC5sZW5ndGggXSA9IHR4dDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cGFyc2VkWyBwYXJzZWQubGVuZ3RoIF0gPSB7XG5cdFx0XHRcdFx0XHRcdHRleHQgOiB0eHQsXG5cdFx0XHRcdFx0XHRcdC8vIGNoZWNrIHBhcnNlciBsZW5ndGggLSBmaXhlcyAjOTM0XG5cdFx0XHRcdFx0XHRcdHBhcnNlZCA6IHBhcnNlZFR4dFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc29ydCBwYXJzZWQgc2VsZWN0IG9wdGlvbnNcblx0XHRcdFx0Y3RzID0gYy50ZXh0U29ydGVyIHx8ICcnO1xuXHRcdFx0XHRwYXJzZWQuc29ydCggZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRcdFx0dmFyIHggPSBkaXJlY3Rpb24gPyBiLnBhcnNlZCA6IGEucGFyc2VkLFxuXHRcdFx0XHRcdFx0eSA9IGRpcmVjdGlvbiA/IGEucGFyc2VkIDogYi5wYXJzZWQ7XG5cdFx0XHRcdFx0aWYgKCB2YWxpZENvbHVtbiAmJiB0eXBlb2YgY3RzID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdFx0Ly8gY3VzdG9tIE9WRVJBTEwgdGV4dCBzb3J0ZXJcblx0XHRcdFx0XHRcdHJldHVybiBjdHMoIHgsIHksIHRydWUsIGNvbHVtbiwgdGFibGUgKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB2YWxpZENvbHVtbiAmJiB0eXBlb2YgY3RzID09PSAnb2JqZWN0JyAmJiBjdHMuaGFzT3duUHJvcGVydHkoIGNvbHVtbiApICkge1xuXHRcdFx0XHRcdFx0Ly8gY3VzdG9tIHRleHQgc29ydGVyIGZvciBhIFNQRUNJRklDIENPTFVNTlxuXHRcdFx0XHRcdFx0cmV0dXJuIGN0c1tjb2x1bW5dKCB4LCB5LCB0cnVlLCBjb2x1bW4sIHRhYmxlICk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdHMuc29ydE5hdHVyYWwgKSB7XG5cdFx0XHRcdFx0XHQvLyBmYWxsIGJhY2sgdG8gbmF0dXJhbCBzb3J0XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHMuc29ydE5hdHVyYWwoIHgsIHkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gdXNpbmcgYW4gb2xkZXIgdmVyc2lvbiEgZG8gYSBiYXNpYyBzb3J0XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQvLyByZWJ1aWxkIGFycnkgZnJvbSBzb3J0ZWQgcGFyc2VkIGRhdGFcblx0XHRcdFx0YXJyeSA9IFtdO1xuXHRcdFx0XHRsZW4gPSBwYXJzZWQubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCBpbmR4ID0gMDsgaW5keCA8IGxlbjsgaW5keCsrICkge1xuXHRcdFx0XHRcdGFycnlbIGFycnkubGVuZ3RoIF0gPSBwYXJzZWRbaW5keF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGFycnk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnZXRPcHRpb25zOiBmdW5jdGlvbiggdGFibGUsIGNvbHVtbiwgb25seUF2YWlsICkge1xuXHRcdFx0dGFibGUgPSAkKCB0YWJsZSApWzBdO1xuXHRcdFx0dmFyIHJvd0luZGV4LCB0Ym9keUluZGV4LCBsZW4sIHJvdywgY2FjaGUsIGluZHgsIGNoaWxkLCBjaGlsZExlbixcblx0XHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdFx0d28gPSBjLndpZGdldE9wdGlvbnMsXG5cdFx0XHRcdGFycnkgPSBbXTtcblx0XHRcdGZvciAoIHRib2R5SW5kZXggPSAwOyB0Ym9keUluZGV4IDwgYy4kdGJvZGllcy5sZW5ndGg7IHRib2R5SW5kZXgrKyApIHtcblx0XHRcdFx0Y2FjaGUgPSBjLmNhY2hlW3Rib2R5SW5kZXhdO1xuXHRcdFx0XHRsZW4gPSBjLmNhY2hlW3Rib2R5SW5kZXhdLm5vcm1hbGl6ZWQubGVuZ3RoO1xuXHRcdFx0XHQvLyBsb29wIHRocm91Z2ggdGhlIHJvd3Ncblx0XHRcdFx0Zm9yICggcm93SW5kZXggPSAwOyByb3dJbmRleCA8IGxlbjsgcm93SW5kZXgrKyApIHtcblx0XHRcdFx0XHQvLyBnZXQgY2FjaGVkIHJvdyBmcm9tIGNhY2hlLnJvdyAoIG9sZCApIG9yIHJvdyBkYXRhIG9iamVjdFxuXHRcdFx0XHRcdC8vICggbmV3OyBsYXN0IGl0ZW0gaW4gbm9ybWFsaXplZCBhcnJheSApXG5cdFx0XHRcdFx0cm93ID0gY2FjaGUucm93ID9cblx0XHRcdFx0XHRcdGNhY2hlLnJvd1sgcm93SW5kZXggXSA6XG5cdFx0XHRcdFx0XHRjYWNoZS5ub3JtYWxpemVkWyByb3dJbmRleCBdWyBjLmNvbHVtbnMgXS4kcm93WzBdO1xuXHRcdFx0XHRcdC8vIGNoZWNrIGlmIGhhcyBjbGFzcyBmaWx0ZXJlZFxuXHRcdFx0XHRcdGlmICggb25seUF2YWlsICYmIHJvdy5jbGFzc05hbWUubWF0Y2goIHdvLmZpbHRlcl9maWx0ZXJlZFJvdyApICkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGdldCBub24tbm9ybWFsaXplZCBjZWxsIGNvbnRlbnRcblx0XHRcdFx0XHRpZiAoIHdvLmZpbHRlcl91c2VQYXJzZWREYXRhIHx8XG5cdFx0XHRcdFx0XHRjLnBhcnNlcnNbY29sdW1uXS5wYXJzZWQgfHxcblx0XHRcdFx0XHRcdGMuJGhlYWRlckluZGV4ZWRbY29sdW1uXS5oYXNDbGFzcyggJ2ZpbHRlci1wYXJzZWQnICkgKSB7XG5cdFx0XHRcdFx0XHRhcnJ5WyBhcnJ5Lmxlbmd0aCBdID0gJycgKyBjYWNoZS5ub3JtYWxpemVkWyByb3dJbmRleCBdWyBjb2x1bW4gXTtcblx0XHRcdFx0XHRcdC8vIGNoaWxkIHJvdyBwYXJzZWQgZGF0YVxuXHRcdFx0XHRcdFx0aWYgKCB3by5maWx0ZXJfY2hpbGRSb3dzICYmIHdvLmZpbHRlcl9jaGlsZEJ5Q29sdW1uICkge1xuXHRcdFx0XHRcdFx0XHRjaGlsZExlbiA9IGNhY2hlLm5vcm1hbGl6ZWRbIHJvd0luZGV4IF1bIGMuY29sdW1ucyBdLiRyb3cubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdFx0Zm9yICggaW5keCA9IDA7IGluZHggPCBjaGlsZExlbjsgaW5keCsrICkge1xuXHRcdFx0XHRcdFx0XHRcdGFycnlbIGFycnkubGVuZ3RoIF0gPSAnJyArIGNhY2hlLm5vcm1hbGl6ZWRbIHJvd0luZGV4IF1bIGMuY29sdW1ucyBdLmNoaWxkWyBpbmR4IF1bIGNvbHVtbiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIGdldCByYXcgY2FjaGVkIGRhdGEgaW5zdGVhZCBvZiBjb250ZW50IGRpcmVjdGx5IGZyb20gdGhlIGNlbGxzXG5cdFx0XHRcdFx0XHRhcnJ5WyBhcnJ5Lmxlbmd0aCBdID0gY2FjaGUubm9ybWFsaXplZFsgcm93SW5kZXggXVsgYy5jb2x1bW5zIF0ucmF3WyBjb2x1bW4gXTtcblx0XHRcdFx0XHRcdC8vIGNoaWxkIHJvdyB1bnBhcnNlZCBkYXRhXG5cdFx0XHRcdFx0XHRpZiAoIHdvLmZpbHRlcl9jaGlsZFJvd3MgJiYgd28uZmlsdGVyX2NoaWxkQnlDb2x1bW4gKSB7XG5cdFx0XHRcdFx0XHRcdGNoaWxkTGVuID0gY2FjaGUubm9ybWFsaXplZFsgcm93SW5kZXggXVsgYy5jb2x1bW5zIF0uJHJvdy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGluZHggPSAxOyBpbmR4IDwgY2hpbGRMZW47IGluZHgrKyApIHtcblx0XHRcdFx0XHRcdFx0XHRjaGlsZCA9ICBjYWNoZS5ub3JtYWxpemVkWyByb3dJbmRleCBdWyBjLmNvbHVtbnMgXS4kcm93LmVxKCBpbmR4ICkuY2hpbGRyZW4oKS5lcSggY29sdW1uICk7XG5cdFx0XHRcdFx0XHRcdFx0YXJyeVsgYXJyeS5sZW5ndGggXSA9ICcnICsgdHMuZ2V0RWxlbWVudFRleHQoIGMsIGNoaWxkLCBjb2x1bW4gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFycnk7XG5cdFx0fSxcblx0XHRidWlsZFNlbGVjdDogZnVuY3Rpb24oIHRhYmxlLCBjb2x1bW4sIGFycnksIHVwZGF0aW5nLCBvbmx5QXZhaWwgKSB7XG5cdFx0XHR0YWJsZSA9ICQoIHRhYmxlIClbMF07XG5cdFx0XHRjb2x1bW4gPSBwYXJzZUludCggY29sdW1uLCAxMCApO1xuXHRcdFx0aWYgKCAhdGFibGUuY29uZmlnLmNhY2hlIHx8ICQuaXNFbXB0eU9iamVjdCggdGFibGUuY29uZmlnLmNhY2hlICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGluZHgsIHZhbCwgdHh0LCB0LCAkZmlsdGVycywgJGZpbHRlciwgb3B0aW9uLFxuXHRcdFx0XHRjID0gdGFibGUuY29uZmlnLFxuXHRcdFx0XHR3byA9IGMud2lkZ2V0T3B0aW9ucyxcblx0XHRcdFx0bm9kZSA9IGMuJGhlYWRlckluZGV4ZWRbIGNvbHVtbiBdLFxuXHRcdFx0XHQvLyB0LmRhdGEoICdwbGFjZWhvbGRlcicgKSB3b24ndCB3b3JrIGluIGpRdWVyeSBvbGRlciB0aGFuIDEuNC4zXG5cdFx0XHRcdG9wdGlvbnMgPSAnPG9wdGlvbiB2YWx1ZT1cIlwiPicgK1xuXHRcdFx0XHRcdCggbm9kZS5kYXRhKCAncGxhY2Vob2xkZXInICkgfHxcblx0XHRcdFx0XHRcdG5vZGUuYXR0ciggJ2RhdGEtcGxhY2Vob2xkZXInICkgfHxcblx0XHRcdFx0XHRcdHdvLmZpbHRlcl9wbGFjZWhvbGRlci5zZWxlY3QgfHwgJydcblx0XHRcdFx0XHQpICsgJzwvb3B0aW9uPicsXG5cdFx0XHRcdC8vIEdldCBjdXJlbnQgZmlsdGVyIHZhbHVlXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGMuJHRhYmxlXG5cdFx0XHRcdFx0LmZpbmQoICd0aGVhZCcgKVxuXHRcdFx0XHRcdC5maW5kKCAnc2VsZWN0LicgKyB0c2Nzcy5maWx0ZXIgKyAnW2RhdGEtY29sdW1uPVwiJyArIGNvbHVtbiArICdcIl0nIClcblx0XHRcdFx0XHQudmFsKCk7XG5cblx0XHRcdC8vIG5vdGhpbmcgaW5jbHVkZWQgaW4gYXJyeSAoIGV4dGVybmFsIHNvdXJjZSApLCBzbyBnZXQgdGhlIG9wdGlvbnMgZnJvbVxuXHRcdFx0Ly8gZmlsdGVyX3NlbGVjdFNvdXJjZSBvciBjb2x1bW4gZGF0YVxuXHRcdFx0aWYgKCB0eXBlb2YgYXJyeSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJyeSA9PT0gJycgKSB7XG5cdFx0XHRcdGFycnkgPSB0c2YuZ2V0T3B0aW9uU291cmNlKCB0YWJsZSwgY29sdW1uLCBvbmx5QXZhaWwgKTtcblx0XHRcdFx0Ly8gYWJvcnQsIHNlbGVjdHMgYXJlIHVwZGF0ZWQgYnkgYW4gZXh0ZXJuYWwgbWV0aG9kXG5cdFx0XHRcdGlmIChhcnJ5ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggJC5pc0FycmF5KCBhcnJ5ICkgKSB7XG5cdFx0XHRcdC8vIGJ1aWxkIG9wdGlvbiBsaXN0XG5cdFx0XHRcdGZvciAoIGluZHggPSAwOyBpbmR4IDwgYXJyeS5sZW5ndGg7IGluZHgrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBhcnJ5WyBpbmR4IF07XG5cdFx0XHRcdFx0aWYgKCBvcHRpb24udGV4dCApIHtcblx0XHRcdFx0XHRcdC8vIE9CSkVDVCEhIGFkZCBkYXRhLWZ1bmN0aW9uLW5hbWUgaW4gY2FzZSB0aGUgdmFsdWUgaXMgc2V0IGluIGZpbHRlcl9mdW5jdGlvbnNcblx0XHRcdFx0XHRcdG9wdGlvblsnZGF0YS1mdW5jdGlvbi1uYW1lJ10gPSB0eXBlb2Ygb3B0aW9uLnZhbHVlID09PSAndW5kZWZpbmVkJyA/IG9wdGlvbi50ZXh0IDogb3B0aW9uLnZhbHVlO1xuXG5cdFx0XHRcdFx0XHQvLyBzdXBwb3J0IGpRdWVyeSA8IHYxLjgsIG90aGVyd2lzZSB0aGUgYmVsb3cgY29kZSBjb3VsZCBiZSBzaG9ydGVuZWQgdG9cblx0XHRcdFx0XHRcdC8vIG9wdGlvbnMgKz0gJCggJzxvcHRpb24+Jywgb3B0aW9uIClbIDAgXS5vdXRlckhUTUw7XG5cdFx0XHRcdFx0XHRvcHRpb25zICs9ICc8b3B0aW9uJztcblx0XHRcdFx0XHRcdGZvciAoIHZhbCBpbiBvcHRpb24gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggb3B0aW9uLmhhc093blByb3BlcnR5KCB2YWwgKSAmJiB2YWwgIT09ICd0ZXh0JyApIHtcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zICs9ICcgJyArIHZhbCArICc9XCInICsgb3B0aW9uWyB2YWwgXS5yZXBsYWNlKCB0c2ZSZWdleC5xdW90ZSwgJyZxdW90OycgKSArICdcIic7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggIW9wdGlvbi52YWx1ZSApIHtcblx0XHRcdFx0XHRcdFx0b3B0aW9ucyArPSAnIHZhbHVlPVwiJyArIG9wdGlvbi50ZXh0LnJlcGxhY2UoIHRzZlJlZ2V4LnF1b3RlLCAnJnF1b3Q7JyApICsgJ1wiJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG9wdGlvbnMgKz0gJz4nICsgb3B0aW9uLnRleHQucmVwbGFjZSggdHNmUmVnZXgucXVvdGUsICcmcXVvdDsnICkgKyAnPC9vcHRpb24+Jztcblx0XHRcdFx0XHRcdC8vIGFib3ZlIGNvZGUgaXMgbmVlZGVkIGluIGpRdWVyeSA8IHYxLjhcblxuXHRcdFx0XHRcdFx0Ly8gbWFrZSBzdXJlIHdlIGRvbid0IHR1cm4gYW4gb2JqZWN0IGludG8gYSBzdHJpbmcgKG9iamVjdHMgd2l0aG91dCBhIFwidGV4dFwiIHByb3BlcnR5KVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICcnICsgb3B0aW9uICE9PSAnW29iamVjdCBPYmplY3RdJyApIHtcblx0XHRcdFx0XHRcdHR4dCA9IG9wdGlvbiA9ICggJycgKyBvcHRpb24gKS5yZXBsYWNlKCB0c2ZSZWdleC5xdW90ZSwgJyZxdW90OycgKTtcblx0XHRcdFx0XHRcdHZhbCA9IHR4dDtcblx0XHRcdFx0XHRcdC8vIGFsbG93IGluY2x1ZGluZyBhIHN5bWJvbCBpbiB0aGUgc2VsZWN0U291cmNlIGFycmF5XG5cdFx0XHRcdFx0XHQvLyAnYS16fEEgdGhyb3VnaCBaJyBzbyB0aGF0ICdhLXonIGJlY29tZXMgdGhlIG9wdGlvbiB2YWx1ZVxuXHRcdFx0XHRcdFx0Ly8gYW5kICdBIHRocm91Z2ggWicgYmVjb21lcyB0aGUgb3B0aW9uIHRleHRcblx0XHRcdFx0XHRcdGlmICggdHh0LmluZGV4T2YoIHdvLmZpbHRlcl9zZWxlY3RTb3VyY2VTZXBhcmF0b3IgKSA+PSAwICkge1xuXHRcdFx0XHRcdFx0XHR0ID0gdHh0LnNwbGl0KCB3by5maWx0ZXJfc2VsZWN0U291cmNlU2VwYXJhdG9yICk7XG5cdFx0XHRcdFx0XHRcdHZhbCA9IHRbMF07XG5cdFx0XHRcdFx0XHRcdHR4dCA9IHRbMV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyByZXBsYWNlIHF1b3RlcyAtIGZpeGVzICMyNDIgJiBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRcdFx0Ly8gc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE0OTkwOTcxLzE0NTM0NlxuXHRcdFx0XHRcdFx0b3B0aW9ucyArPSBvcHRpb24gIT09ICcnID9cblx0XHRcdFx0XHRcdFx0JzxvcHRpb24gJyArXG5cdFx0XHRcdFx0XHRcdFx0KCB2YWwgPT09IHR4dCA/ICcnIDogJ2RhdGEtZnVuY3Rpb24tbmFtZT1cIicgKyBvcHRpb24gKyAnXCIgJyApICtcblx0XHRcdFx0XHRcdFx0XHQndmFsdWU9XCInICsgdmFsICsgJ1wiPicgKyB0eHQgK1xuXHRcdFx0XHRcdFx0XHQnPC9vcHRpb24+JyA6ICcnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBjbGVhciBhcnJ5IHNvIGl0IGRvZXNuJ3QgZ2V0IGFwcGVuZGVkIHR3aWNlXG5cdFx0XHRcdGFycnkgPSBbXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdXBkYXRlIGFsbCBzZWxlY3RzIGluIHRoZSBzYW1lIGNvbHVtbiAoIGNsb25lIHRoZWFkIGluIHN0aWNreSBoZWFkZXJzICZcblx0XHRcdC8vIGFueSBleHRlcm5hbCBzZWxlY3RzICkgLSBmaXhlcyA0NzNcblx0XHRcdCRmaWx0ZXJzID0gKCBjLiRmaWx0ZXJzID8gYy4kZmlsdGVycyA6IGMuJHRhYmxlLmNoaWxkcmVuKCAndGhlYWQnICkgKVxuXHRcdFx0XHQuZmluZCggJy4nICsgdHNjc3MuZmlsdGVyICk7XG5cdFx0XHRpZiAoIHdvLmZpbHRlcl8kZXh0ZXJuYWxGaWx0ZXJzICkge1xuXHRcdFx0XHQkZmlsdGVycyA9ICRmaWx0ZXJzICYmICRmaWx0ZXJzLmxlbmd0aCA/XG5cdFx0XHRcdFx0JGZpbHRlcnMuYWRkKCB3by5maWx0ZXJfJGV4dGVybmFsRmlsdGVycyApIDpcblx0XHRcdFx0XHR3by5maWx0ZXJfJGV4dGVybmFsRmlsdGVycztcblx0XHRcdH1cblx0XHRcdCRmaWx0ZXIgPSAkZmlsdGVycy5maWx0ZXIoICdzZWxlY3RbZGF0YS1jb2x1bW49XCInICsgY29sdW1uICsgJ1wiXScgKTtcblxuXHRcdFx0Ly8gbWFrZSBzdXJlIHRoZXJlIGlzIGEgc2VsZWN0IHRoZXJlIVxuXHRcdFx0aWYgKCAkZmlsdGVyLmxlbmd0aCApIHtcblx0XHRcdFx0JGZpbHRlclsgdXBkYXRpbmcgPyAnaHRtbCcgOiAnYXBwZW5kJyBdKCBvcHRpb25zICk7XG5cdFx0XHRcdGlmICggISQuaXNBcnJheSggYXJyeSApICkge1xuXHRcdFx0XHRcdC8vIGFwcGVuZCBvcHRpb25zIGlmIGFycnkgaXMgcHJvdmlkZWQgZXh0ZXJuYWxseSBhcyBhIHN0cmluZyBvciBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0Ly8gb3B0aW9ucyAoIGRlZmF1bHQgdmFsdWUgKSB3YXMgYWxyZWFkeSBhZGRlZFxuXHRcdFx0XHRcdCRmaWx0ZXIuYXBwZW5kKCBhcnJ5ICkudmFsKCBjdXJyZW50VmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkZmlsdGVyLnZhbCggY3VycmVudFZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRidWlsZERlZmF1bHQ6IGZ1bmN0aW9uKCB0YWJsZSwgdXBkYXRpbmcgKSB7XG5cdFx0XHR2YXIgY29sdW1uSW5kZXgsICRoZWFkZXIsIG5vU2VsZWN0LFxuXHRcdFx0XHRjID0gdGFibGUuY29uZmlnLFxuXHRcdFx0XHR3byA9IGMud2lkZ2V0T3B0aW9ucyxcblx0XHRcdFx0Y29sdW1ucyA9IGMuY29sdW1ucztcblx0XHRcdC8vIGJ1aWxkIGRlZmF1bHQgc2VsZWN0IGRyb3Bkb3duXG5cdFx0XHRmb3IgKCBjb2x1bW5JbmRleCA9IDA7IGNvbHVtbkluZGV4IDwgY29sdW1uczsgY29sdW1uSW5kZXgrKyApIHtcblx0XHRcdFx0JGhlYWRlciA9IGMuJGhlYWRlckluZGV4ZWRbY29sdW1uSW5kZXhdO1xuXHRcdFx0XHRub1NlbGVjdCA9ICEoICRoZWFkZXIuaGFzQ2xhc3MoICdmaWx0ZXItZmFsc2UnICkgfHwgJGhlYWRlci5oYXNDbGFzcyggJ3BhcnNlci1mYWxzZScgKSApO1xuXHRcdFx0XHQvLyBsb29rIGZvciB0aGUgZmlsdGVyLXNlbGVjdCBjbGFzczsgYnVpbGQvdXBkYXRlIGl0IGlmIGZvdW5kXG5cdFx0XHRcdGlmICggKCAkaGVhZGVyLmhhc0NsYXNzKCAnZmlsdGVyLXNlbGVjdCcgKSB8fFxuXHRcdFx0XHRcdHRzLmdldENvbHVtbkRhdGEoIHRhYmxlLCB3by5maWx0ZXJfZnVuY3Rpb25zLCBjb2x1bW5JbmRleCApID09PSB0cnVlICkgJiYgbm9TZWxlY3QgKSB7XG5cdFx0XHRcdFx0dHNmLmJ1aWxkU2VsZWN0KCB0YWJsZSwgY29sdW1uSW5kZXgsICcnLCB1cGRhdGluZywgJGhlYWRlci5oYXNDbGFzcyggd28uZmlsdGVyX29ubHlBdmFpbCApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gZmlsdGVyIHJlZ2V4IHZhcmlhYmxlXG5cdHRzZlJlZ2V4ID0gdHNmLnJlZ2V4O1xuXG5cdHRzLmdldEZpbHRlcnMgPSBmdW5jdGlvbiggdGFibGUsIGdldFJhdywgc2V0RmlsdGVycywgc2tpcEZpcnN0ICkge1xuXHRcdHZhciBpLCAkZmlsdGVycywgJGNvbHVtbiwgY29scyxcblx0XHRcdGZpbHRlcnMgPSBbXSxcblx0XHRcdGMgPSB0YWJsZSA/ICQoIHRhYmxlIClbMF0uY29uZmlnIDogJycsXG5cdFx0XHR3byA9IGMgPyBjLndpZGdldE9wdGlvbnMgOiAnJztcblx0XHRpZiAoICggZ2V0UmF3ICE9PSB0cnVlICYmIHdvICYmICF3by5maWx0ZXJfY29sdW1uRmlsdGVycyApIHx8XG5cdFx0XHQvLyBzZXRGaWx0ZXJzIGNhbGxlZCwgYnV0IGxhc3Qgc2VhcmNoIGlzIGV4YWN0bHkgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcblx0XHRcdC8vIGZpeGVzIGlzc3VlICM3MzMgJiAjOTAzIHdoZXJlIGNhbGxpbmcgdXBkYXRlIGNhdXNlcyB0aGUgaW5wdXQgdmFsdWVzIHRvIHJlc2V0XG5cdFx0XHQoICQuaXNBcnJheShzZXRGaWx0ZXJzKSAmJiB0c2YuZXF1YWxGaWx0ZXJzKGMsIHNldEZpbHRlcnMsIGMubGFzdFNlYXJjaCkgKVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuICQoIHRhYmxlICkuZGF0YSggJ2xhc3RTZWFyY2gnICkgfHwgW107XG5cdFx0fVxuXHRcdGlmICggYyApIHtcblx0XHRcdGlmICggYy4kZmlsdGVycyApIHtcblx0XHRcdFx0JGZpbHRlcnMgPSBjLiRmaWx0ZXJzLmZpbmQoICcuJyArIHRzY3NzLmZpbHRlciApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB3by5maWx0ZXJfJGV4dGVybmFsRmlsdGVycyApIHtcblx0XHRcdFx0JGZpbHRlcnMgPSAkZmlsdGVycyAmJiAkZmlsdGVycy5sZW5ndGggP1xuXHRcdFx0XHRcdCRmaWx0ZXJzLmFkZCggd28uZmlsdGVyXyRleHRlcm5hbEZpbHRlcnMgKSA6XG5cdFx0XHRcdFx0d28uZmlsdGVyXyRleHRlcm5hbEZpbHRlcnM7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICRmaWx0ZXJzICYmICRmaWx0ZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0ZmlsdGVycyA9IHNldEZpbHRlcnMgfHwgW107XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgYy5jb2x1bW5zICsgMTsgaSsrICkge1xuXHRcdFx0XHRcdGNvbHMgPSAoIGkgPT09IGMuY29sdW1ucyA/XG5cdFx0XHRcdFx0XHQvLyAnYWxsJyBjb2x1bW5zIGNhbiBub3cgaW5jbHVkZSBhIHJhbmdlIG9yIHNldCBvZiBjb2x1bW1zICggZGF0YS1jb2x1bW49JzAtMiw0LDYtNycgKVxuXHRcdFx0XHRcdFx0d28uZmlsdGVyX2FueUNvbHVtblNlbGVjdG9yICsgJywnICsgd28uZmlsdGVyX211bHRpcGxlQ29sdW1uU2VsZWN0b3IgOlxuXHRcdFx0XHRcdFx0J1tkYXRhLWNvbHVtbj1cIicgKyBpICsgJ1wiXScgKTtcblx0XHRcdFx0XHQkY29sdW1uID0gJGZpbHRlcnMuZmlsdGVyKCBjb2xzICk7XG5cdFx0XHRcdFx0aWYgKCAkY29sdW1uLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdC8vIG1vdmUgdGhlIGxhdGVzdCBzZWFyY2ggdG8gdGhlIGZpcnN0IHNsb3QgaW4gdGhlIGFycmF5XG5cdFx0XHRcdFx0XHQkY29sdW1uID0gdHNmLmdldExhdGVzdFNlYXJjaCggJGNvbHVtbiApO1xuXHRcdFx0XHRcdFx0aWYgKCAkLmlzQXJyYXkoIHNldEZpbHRlcnMgKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gc2tpcCBmaXJzdCAoIGxhdGVzdCBpbnB1dCApIHRvIG1haW50YWluIGN1cnNvciBwb3NpdGlvbiB3aGlsZSB0eXBpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCBza2lwRmlyc3QgJiYgJGNvbHVtbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRcdFx0XHRcdCRjb2x1bW4gPSAkY29sdW1uLnNsaWNlKCAxICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCBpID09PSBjLmNvbHVtbnMgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gcHJldmVudCBkYXRhLWNvbHVtbj0nYWxsJyBmcm9tIGZpbGxpbmcgZGF0YS1jb2x1bW49JzAsMScgKCBldGMgKVxuXHRcdFx0XHRcdFx0XHRcdGNvbHMgPSAkY29sdW1uLmZpbHRlciggd28uZmlsdGVyX2FueUNvbHVtblNlbGVjdG9yICk7XG5cdFx0XHRcdFx0XHRcdFx0JGNvbHVtbiA9IGNvbHMubGVuZ3RoID8gY29scyA6ICRjb2x1bW47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0JGNvbHVtblxuXHRcdFx0XHRcdFx0XHRcdC52YWwoIHNldEZpbHRlcnNbIGkgXSApXG5cdFx0XHRcdFx0XHRcdFx0Ly8gbXVzdCBpbmNsdWRlIGEgbmFtZXNwYWNlIGhlcmU7IGJ1dCBub3QgYy5uYW1lc3BhY2UgKyAnZmlsdGVyJz9cblx0XHRcdFx0XHRcdFx0XHQudHJpZ2dlciggJ2NoYW5nZScgKyBjLm5hbWVzcGFjZSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZmlsdGVyc1tpXSA9ICRjb2x1bW4udmFsKCkgfHwgJyc7XG5cdFx0XHRcdFx0XHRcdC8vIGRvbid0IGNoYW5nZSB0aGUgZmlyc3QuLi4gaXQgd2lsbCBtb3ZlIHRoZSBjdXJzb3Jcblx0XHRcdFx0XHRcdFx0aWYgKCBpID09PSBjLmNvbHVtbnMgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gZG9uJ3QgdXBkYXRlIHJhbmdlIGNvbHVtbnMgZnJvbSAnYWxsJyBzZXR0aW5nXG5cdFx0XHRcdFx0XHRcdFx0JGNvbHVtblxuXHRcdFx0XHRcdFx0XHRcdFx0LnNsaWNlKCAxIClcblx0XHRcdFx0XHRcdFx0XHRcdC5maWx0ZXIoICdbZGF0YS1jb2x1bW4qPVwiJyArICRjb2x1bW4uYXR0ciggJ2RhdGEtY29sdW1uJyApICsgJ1wiXScgKVxuXHRcdFx0XHRcdFx0XHRcdFx0LnZhbCggZmlsdGVyc1sgaSBdICk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0JGNvbHVtblxuXHRcdFx0XHRcdFx0XHRcdFx0LnNsaWNlKCAxIClcblx0XHRcdFx0XHRcdFx0XHRcdC52YWwoIGZpbHRlcnNbIGkgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBzYXZlIGFueSBtYXRjaCBpbnB1dCBkeW5hbWljYWxseVxuXHRcdFx0XHRcdFx0aWYgKCBpID09PSBjLmNvbHVtbnMgJiYgJGNvbHVtbi5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdHdvLmZpbHRlcl8kYW55TWF0Y2ggPSAkY29sdW1uO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmlsdGVycztcblx0fTtcblxuXHR0cy5zZXRGaWx0ZXJzID0gZnVuY3Rpb24oIHRhYmxlLCBmaWx0ZXIsIGFwcGx5LCBza2lwRmlyc3QgKSB7XG5cdFx0dmFyIGMgPSB0YWJsZSA/ICQoIHRhYmxlIClbMF0uY29uZmlnIDogJycsXG5cdFx0XHR2YWxpZCA9IHRzLmdldEZpbHRlcnMoIHRhYmxlLCB0cnVlLCBmaWx0ZXIsIHNraXBGaXJzdCApO1xuXHRcdC8vIGRlZmF1bHQgYXBwbHkgdG8gXCJ0cnVlXCJcblx0XHRpZiAoIHR5cGVvZiBhcHBseSA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRhcHBseSA9IHRydWU7XG5cdFx0fVxuXHRcdGlmICggYyAmJiBhcHBseSApIHtcblx0XHRcdC8vIGVuc3VyZSBuZXcgc2V0IGZpbHRlcnMgYXJlIGFwcGxpZWQsIGV2ZW4gaWYgdGhlIHNlYXJjaCBpcyB0aGUgc2FtZVxuXHRcdFx0Yy5sYXN0Q29tYmluZWRGaWx0ZXIgPSBudWxsO1xuXHRcdFx0Yy5sYXN0U2VhcmNoID0gW107XG5cdFx0XHR0c2Yuc2VhcmNoaW5nKCBjLnRhYmxlLCBmaWx0ZXIsIHNraXBGaXJzdCApO1xuXHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoICdmaWx0ZXJGb21hdHRlclVwZGF0ZScgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbGlkLmxlbmd0aCAhPT0gMDtcblx0fTtcblxufSkoIGpRdWVyeSApO1xuXG4vKiEgV2lkZ2V0OiBzdGlja3lIZWFkZXJzIC0gdXBkYXRlZCA5LzI3LzIwMTcgKHYyLjI5LjApICovLypcbiAqIFJlcXVpcmVzIHRhYmxlc29ydGVyIHYyLjgrIGFuZCBqUXVlcnkgMS40LjMrXG4gKiBieSBSb2IgR2Fycmlzb25cbiAqL1xuOyhmdW5jdGlvbiAoJCwgd2luZG93KSB7XG5cdCd1c2Ugc3RyaWN0Jztcblx0dmFyIHRzID0gJC50YWJsZXNvcnRlciB8fCB7fTtcblxuXHQkLmV4dGVuZCh0cy5jc3MsIHtcblx0XHRzdGlja3kgICAgOiAndGFibGVzb3J0ZXItc3RpY2t5SGVhZGVyJywgLy8gc3RpY2t5SGVhZGVyXG5cdFx0c3RpY2t5VmlzIDogJ3RhYmxlc29ydGVyLXN0aWNreS12aXNpYmxlJyxcblx0XHRzdGlja3lIaWRlOiAndGFibGVzb3J0ZXItc3RpY2t5LWhpZGRlbicsXG5cdFx0c3RpY2t5V3JhcDogJ3RhYmxlc29ydGVyLXN0aWNreS13cmFwcGVyJ1xuXHR9KTtcblxuXHQvLyBBZGQgYSByZXNpemUgZXZlbnQgdG8gdGFibGUgaGVhZGVyc1xuXHR0cy5hZGRIZWFkZXJSZXNpemVFdmVudCA9IGZ1bmN0aW9uKHRhYmxlLCBkaXNhYmxlLCBzZXR0aW5ncykge1xuXHRcdHRhYmxlID0gJCh0YWJsZSlbMF07IC8vIG1ha2Ugc3VyZSB3ZSdyZSB1c2luZyBhIGRvbSBlbGVtZW50XG5cdFx0aWYgKCAhdGFibGUuY29uZmlnICkgeyByZXR1cm47IH1cblx0XHR2YXIgZGVmYXVsdHMgPSB7XG5cdFx0XHRcdHRpbWVyIDogMjUwXG5cdFx0XHR9LFxuXHRcdFx0b3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgc2V0dGluZ3MpLFxuXHRcdFx0YyA9IHRhYmxlLmNvbmZpZyxcblx0XHRcdHdvID0gYy53aWRnZXRPcHRpb25zLFxuXHRcdFx0Y2hlY2tTaXplcyA9IGZ1bmN0aW9uKCB0cmlnZ2VyRXZlbnQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCwgaGVhZGVycywgJGhlYWRlciwgc2l6ZXMsIHdpZHRoLCBoZWlnaHQsXG5cdFx0XHRcdFx0bGVuID0gYy4kaGVhZGVycy5sZW5ndGg7XG5cdFx0XHRcdHdvLnJlc2l6ZV9mbGFnID0gdHJ1ZTtcblx0XHRcdFx0aGVhZGVycyA9IFtdO1xuXHRcdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdCRoZWFkZXIgPSBjLiRoZWFkZXJzLmVxKCBpbmRleCApO1xuXHRcdFx0XHRcdHNpemVzID0gJGhlYWRlci5kYXRhKCAnc2F2ZWRTaXplcycgKSB8fCBbIDAsIDAgXTsgLy8gZml4ZXMgIzM5NFxuXHRcdFx0XHRcdHdpZHRoID0gJGhlYWRlclswXS5vZmZzZXRXaWR0aDtcblx0XHRcdFx0XHRoZWlnaHQgPSAkaGVhZGVyWzBdLm9mZnNldEhlaWdodDtcblx0XHRcdFx0XHRpZiAoIHdpZHRoICE9PSBzaXplc1swXSB8fCBoZWlnaHQgIT09IHNpemVzWzFdICkge1xuXHRcdFx0XHRcdFx0JGhlYWRlci5kYXRhKCAnc2F2ZWRTaXplcycsIFsgd2lkdGgsIGhlaWdodCBdICk7XG5cdFx0XHRcdFx0XHRoZWFkZXJzLnB1c2goICRoZWFkZXJbMF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBoZWFkZXJzLmxlbmd0aCAmJiB0cmlnZ2VyRXZlbnQgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCAncmVzaXplJywgWyBoZWFkZXJzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR3by5yZXNpemVfZmxhZyA9IGZhbHNlO1xuXHRcdFx0fTtcblx0XHRjbGVhckludGVydmFsKHdvLnJlc2l6ZV90aW1lcik7XG5cdFx0aWYgKGRpc2FibGUpIHtcblx0XHRcdHdvLnJlc2l6ZV9mbGFnID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGNoZWNrU2l6ZXMoIGZhbHNlICk7XG5cdFx0d28ucmVzaXplX3RpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAod28ucmVzaXplX2ZsYWcpIHsgcmV0dXJuOyB9XG5cdFx0XHRjaGVja1NpemVzKCk7XG5cdFx0fSwgb3B0aW9ucy50aW1lcik7XG5cdH07XG5cblx0ZnVuY3Rpb24gZ2V0U3RpY2t5T2Zmc2V0KGMsIHdvKSB7XG5cdFx0dmFyICRlbCA9IGlzTmFOKHdvLnN0aWNreUhlYWRlcnNfb2Zmc2V0KSA/ICQod28uc3RpY2t5SGVhZGVyc19vZmZzZXQpIDogW107XG5cdFx0cmV0dXJuICRlbC5sZW5ndGggP1xuXHRcdFx0JGVsLmhlaWdodCgpIHx8IDAgOlxuXHRcdFx0cGFyc2VJbnQod28uc3RpY2t5SGVhZGVyc19vZmZzZXQsIDEwKSB8fCAwO1xuXHR9XG5cblx0Ly8gU3RpY2t5IGhlYWRlcnMgYmFzZWQgb24gdGhpcyBhd2Vzb21lIGFydGljbGU6XG5cdC8vIGh0dHA6Ly9jc3MtdHJpY2tzLmNvbS8xMzQ2NS1wZXJzaXN0ZW50LWhlYWRlcnMvXG5cdC8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vam1vc2JlY2gvU3RpY2t5VGFibGVIZWFkZXJzIGJ5IEpvbmFzIE1vc2JlY2hcblx0Ly8gKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0dHMuYWRkV2lkZ2V0KHtcblx0XHRpZDogJ3N0aWNreUhlYWRlcnMnLFxuXHRcdHByaW9yaXR5OiA1NCwgLy8gc3RpY2t5IHdpZGdldCBtdXN0IGJlIGluaXRpYWxpemVkIGFmdGVyIHRoZSBmaWx0ZXIgJiBiZWZvcmUgcGFnZXIgd2lkZ2V0IVxuXHRcdG9wdGlvbnM6IHtcblx0XHRcdHN0aWNreUhlYWRlcnMgOiAnJywgICAgICAgLy8gZXh0cmEgY2xhc3MgbmFtZSBhZGRlZCB0byB0aGUgc3RpY2t5IGhlYWRlciByb3dcblx0XHRcdHN0aWNreUhlYWRlcnNfYXBwZW5kVG8gOiBudWxsLCAvLyBqUXVlcnkgc2VsZWN0b3Igb3Igb2JqZWN0IHRvIHBoeWNpYWxseSBhdHRhY2ggdGhlIHN0aWNreSBoZWFkZXJzXG5cdFx0XHRzdGlja3lIZWFkZXJzX2F0dGFjaFRvIDogbnVsbCwgLy8galF1ZXJ5IHNlbGVjdG9yIG9yIG9iamVjdCB0byBhdHRhY2ggc2Nyb2xsIGxpc3RlbmVyIHRvIChvdmVycmlkZGVuIGJ5IHhTY3JvbGwgJiB5U2Nyb2xsIHNldHRpbmdzKVxuXHRcdFx0c3RpY2t5SGVhZGVyc194U2Nyb2xsIDogbnVsbCwgLy8galF1ZXJ5IHNlbGVjdG9yIG9yIG9iamVjdCB0byBtb25pdG9yIGhvcml6b250YWwgc2Nyb2xsIHBvc2l0aW9uIChkZWZhdWx0czogeFNjcm9sbCA+IGF0dGFjaFRvID4gd2luZG93KVxuXHRcdFx0c3RpY2t5SGVhZGVyc195U2Nyb2xsIDogbnVsbCwgLy8galF1ZXJ5IHNlbGVjdG9yIG9yIG9iamVjdCB0byBtb25pdG9yIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbiAoZGVmYXVsdHM6IHlTY3JvbGwgPiBhdHRhY2hUbyA+IHdpbmRvdylcblx0XHRcdHN0aWNreUhlYWRlcnNfb2Zmc2V0IDogMCwgLy8gbnVtYmVyIG9yIGpxdWVyeSBzZWxlY3RvciB0YXJnZXRpbmcgdGhlIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRcblx0XHRcdHN0aWNreUhlYWRlcnNfZmlsdGVyZWRUb1RvcDogdHJ1ZSwgLy8gc2Nyb2xsIHRhYmxlIHRvcCBpbnRvIHZpZXcgYWZ0ZXIgZmlsdGVyaW5nXG5cdFx0XHRzdGlja3lIZWFkZXJzX2Nsb25lSWQgOiAnLXN0aWNreScsIC8vIGFkZGVkIHRvIHRhYmxlIElELCBpZiBpdCBleGlzdHNcblx0XHRcdHN0aWNreUhlYWRlcnNfYWRkUmVzaXplRXZlbnQgOiB0cnVlLCAvLyB0cmlnZ2VyICdyZXNpemUnIGV2ZW50IG9uIGhlYWRlcnNcblx0XHRcdHN0aWNreUhlYWRlcnNfaW5jbHVkZUNhcHRpb24gOiB0cnVlLCAvLyBpZiBmYWxzZSBhbmQgYSBjYXB0aW9uIGV4aXN0LCBpdCB3b24ndCBiZSBpbmNsdWRlZCBpbiB0aGUgc3RpY2t5IGhlYWRlclxuXHRcdFx0c3RpY2t5SGVhZGVyc196SW5kZXggOiAyIC8vIFRoZSB6SW5kZXggb2YgdGhlIHN0aWNreUhlYWRlcnMsIGFsbG93cyB0aGUgdXNlciB0byBhZGp1c3QgdGhpcyB0byB0aGVpciBuZWVkc1xuXHRcdH0sXG5cdFx0Zm9ybWF0OiBmdW5jdGlvbih0YWJsZSwgYywgd28pIHtcblx0XHRcdC8vIGZpbHRlciB3aWRnZXQgZG9lc24ndCBpbml0aWFsaXplIG9uIGFuIGVtcHR5IHRhYmxlLiBGaXhlcyAjNDQ5XG5cdFx0XHRpZiAoIGMuJHRhYmxlLmhhc0NsYXNzKCdoYXNTdGlja3lIZWFkZXJzJykgfHwgKCQuaW5BcnJheSgnZmlsdGVyJywgYy53aWRnZXRzKSA+PSAwICYmICFjLiR0YWJsZS5oYXNDbGFzcygnaGFzRmlsdGVycycpKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGluZGV4LCBsZW4sICR0LFxuXHRcdFx0XHQkdGFibGUgPSBjLiR0YWJsZSxcblx0XHRcdFx0Ly8gYWRkIHBvc2l0aW9uOiByZWxhdGl2ZSB0byBhdHRhY2ggZWxlbWVudCwgaG9wZWZ1bGx5IGl0IHdvbid0IGNhdXNlIHRyb3VibGUuXG5cdFx0XHRcdCRhdHRhY2ggPSAkKHdvLnN0aWNreUhlYWRlcnNfYXR0YWNoVG8gfHwgd28uc3RpY2t5SGVhZGVyc19hcHBlbmRUbyksXG5cdFx0XHRcdG5hbWVzcGFjZSA9IGMubmFtZXNwYWNlICsgJ3N0aWNreWhlYWRlcnMgJyxcblx0XHRcdFx0Ly8gZWxlbWVudCB0byB3YXRjaCBmb3IgdGhlIHNjcm9sbCBldmVudFxuXHRcdFx0XHQkeVNjcm9sbCA9ICQod28uc3RpY2t5SGVhZGVyc195U2Nyb2xsIHx8IHdvLnN0aWNreUhlYWRlcnNfYXR0YWNoVG8gfHwgd2luZG93KSxcblx0XHRcdFx0JHhTY3JvbGwgPSAkKHdvLnN0aWNreUhlYWRlcnNfeFNjcm9sbCB8fCB3by5zdGlja3lIZWFkZXJzX2F0dGFjaFRvIHx8IHdpbmRvdyksXG5cdFx0XHRcdCR0aGVhZCA9ICR0YWJsZS5jaGlsZHJlbigndGhlYWQ6Zmlyc3QnKSxcblx0XHRcdFx0JGhlYWRlciA9ICR0aGVhZC5jaGlsZHJlbigndHInKS5ub3QoJy5zdGlja3ktZmFsc2UnKS5jaGlsZHJlbigpLFxuXHRcdFx0XHQkdGZvb3QgPSAkdGFibGUuY2hpbGRyZW4oJ3Rmb290JyksXG5cdFx0XHRcdHN0aWNreU9mZnNldCA9IGdldFN0aWNreU9mZnNldChjLCB3byksXG5cdFx0XHRcdC8vIGlzIHRoaXMgdGFibGUgbmVzdGVkPyBJZiBzbywgZmluZCBwYXJlbnQgc3RpY2t5IGhlYWRlciB3cmFwcGVyIChkaXYsIG5vdCB0YWJsZSlcblx0XHRcdFx0JG5lc3RlZFN0aWNreSA9ICR0YWJsZS5wYXJlbnQoKS5jbG9zZXN0KCcuJyArIHRzLmNzcy50YWJsZSkuaGFzQ2xhc3MoJ2hhc1N0aWNreUhlYWRlcnMnKSA/XG5cdFx0XHRcdFx0JHRhYmxlLnBhcmVudCgpLmNsb3Nlc3QoJ3RhYmxlLnRhYmxlc29ydGVyJylbMF0uY29uZmlnLndpZGdldE9wdGlvbnMuJHN0aWNreS5wYXJlbnQoKSA6IFtdLFxuXHRcdFx0XHRuZXN0ZWRTdGlja3lUb3AgPSAkbmVzdGVkU3RpY2t5Lmxlbmd0aCA/ICRuZXN0ZWRTdGlja3kuaGVpZ2h0KCkgOiAwLFxuXHRcdFx0XHQvLyBjbG9uZSB0YWJsZSwgdGhlbiB3cmFwIHRvIG1ha2Ugc3RpY2t5IGhlYWRlclxuXHRcdFx0XHQkc3RpY2t5VGFibGUgPSB3by4kc3RpY2t5ID0gJHRhYmxlLmNsb25lKClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoJ2NvbnRhaW5zU3RpY2t5SGVhZGVycyAnICsgdHMuY3NzLnN0aWNreSArICcgJyArIHdvLnN0aWNreUhlYWRlcnMgKyAnICcgKyBjLm5hbWVzcGFjZS5zbGljZSgxKSArICdfZXh0cmFfdGFibGUnIClcblx0XHRcdFx0XHQud3JhcCgnPGRpdiBjbGFzcz1cIicgKyB0cy5jc3Muc3RpY2t5V3JhcCArICdcIj4nKSxcblx0XHRcdFx0JHN0aWNreVdyYXAgPSAkc3RpY2t5VGFibGUucGFyZW50KClcblx0XHRcdFx0XHQuYWRkQ2xhc3ModHMuY3NzLnN0aWNreUhpZGUpXG5cdFx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiAgIDogJGF0dGFjaC5sZW5ndGggPyAnYWJzb2x1dGUnIDogJ2ZpeGVkJyxcblx0XHRcdFx0XHRcdHBhZGRpbmcgICAgOiBwYXJzZUludCggJHN0aWNreVRhYmxlLnBhcmVudCgpLnBhcmVudCgpLmNzcygncGFkZGluZy1sZWZ0JyksIDEwICksXG5cdFx0XHRcdFx0XHR0b3AgICAgICAgIDogc3RpY2t5T2Zmc2V0ICsgbmVzdGVkU3RpY2t5VG9wLFxuXHRcdFx0XHRcdFx0bGVmdCAgICAgICA6IDAsXG5cdFx0XHRcdFx0XHR2aXNpYmlsaXR5IDogJ2hpZGRlbicsXG5cdFx0XHRcdFx0XHR6SW5kZXggICAgIDogd28uc3RpY2t5SGVhZGVyc196SW5kZXggfHwgMlxuXHRcdFx0XHRcdH0pLFxuXHRcdFx0XHQkc3RpY2t5VGhlYWQgPSAkc3RpY2t5VGFibGUuY2hpbGRyZW4oJ3RoZWFkOmZpcnN0JyksXG5cdFx0XHRcdCRzdGlja3lDZWxscyxcblx0XHRcdFx0bGFzdHN0YXRlID0gJycsXG5cdFx0XHRcdHNldFdpZHRoID0gZnVuY3Rpb24oJG9yaWcsICRjbG9uZSkge1xuXHRcdFx0XHRcdHZhciBpbmRleCwgd2lkdGgsIGJvcmRlciwgJGNlbGwsICR0aGlzLFxuXHRcdFx0XHRcdFx0JGNlbGxzID0gJG9yaWcuZmlsdGVyKCc6dmlzaWJsZScpLFxuXHRcdFx0XHRcdFx0bGVuID0gJGNlbGxzLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdFx0JGNlbGwgPSAkY2xvbmUuZmlsdGVyKCc6dmlzaWJsZScpLmVxKGluZGV4KTtcblx0XHRcdFx0XHRcdCR0aGlzID0gJGNlbGxzLmVxKGluZGV4KTtcblx0XHRcdFx0XHRcdC8vIGNvZGUgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vam1vc2JlY2gvU3RpY2t5VGFibGVIZWFkZXJzXG5cdFx0XHRcdFx0XHRpZiAoJHRoaXMuY3NzKCdib3gtc2l6aW5nJykgPT09ICdib3JkZXItYm94Jykge1xuXHRcdFx0XHRcdFx0XHR3aWR0aCA9ICR0aGlzLm91dGVyV2lkdGgoKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmICgkY2VsbC5jc3MoJ2JvcmRlci1jb2xsYXBzZScpID09PSAnY29sbGFwc2UnKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR3aWR0aCA9IHBhcnNlRmxvYXQoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCR0aGlzWzBdLCBudWxsKS53aWR0aCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBpZTggb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ym9yZGVyID0gcGFyc2VGbG9hdCggJHRoaXMuY3NzKCdib3JkZXItd2lkdGgnKSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0d2lkdGggPSAkdGhpcy5vdXRlcldpZHRoKCkgLSBwYXJzZUZsb2F0KCAkdGhpcy5jc3MoJ3BhZGRpbmctbGVmdCcpICkgLSBwYXJzZUZsb2F0KCAkdGhpcy5jc3MoJ3BhZGRpbmctcmlnaHQnKSApIC0gYm9yZGVyO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR3aWR0aCA9ICR0aGlzLndpZHRoKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdCRjZWxsLmNzcyh7XG5cdFx0XHRcdFx0XHRcdCd3aWR0aCc6IHdpZHRoLFxuXHRcdFx0XHRcdFx0XHQnbWluLXdpZHRoJzogd2lkdGgsXG5cdFx0XHRcdFx0XHRcdCdtYXgtd2lkdGgnOiB3aWR0aFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXRMZWZ0UG9zaXRpb24gPSBmdW5jdGlvbih5V2luZG93KSB7XG5cdFx0XHRcdFx0aWYgKHlXaW5kb3cgPT09IGZhbHNlICYmICRuZXN0ZWRTdGlja3kubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJHRhYmxlLnBvc2l0aW9uKCkubGVmdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuICRhdHRhY2gubGVuZ3RoID9cblx0XHRcdFx0XHRcdHBhcnNlSW50KCRhdHRhY2guY3NzKCdwYWRkaW5nLWxlZnQnKSwgMTApIHx8IDAgOlxuXHRcdFx0XHRcdFx0JHRhYmxlLm9mZnNldCgpLmxlZnQgLSBwYXJzZUludCgkdGFibGUuY3NzKCdtYXJnaW4tbGVmdCcpLCAxMCkgLSAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZXNpemVIZWFkZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkc3RpY2t5V3JhcC5jc3Moe1xuXHRcdFx0XHRcdFx0bGVmdCA6IGdldExlZnRQb3NpdGlvbigpLFxuXHRcdFx0XHRcdFx0d2lkdGg6ICR0YWJsZS5vdXRlcldpZHRoKClcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRzZXRXaWR0aCggJHRhYmxlLCAkc3RpY2t5VGFibGUgKTtcblx0XHRcdFx0XHRzZXRXaWR0aCggJGhlYWRlciwgJHN0aWNreUNlbGxzICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNjcm9sbFN0aWNreSA9IGZ1bmN0aW9uKCByZXNpemluZyApIHtcblx0XHRcdFx0XHRpZiAoISR0YWJsZS5pcygnOnZpc2libGUnKSkgeyByZXR1cm47IH0gLy8gZml4ZXMgIzI3OFxuXHRcdFx0XHRcdC8vIERldGVjdCBuZXN0ZWQgdGFibGVzIC0gZml4ZXMgIzcyNFxuXHRcdFx0XHRcdG5lc3RlZFN0aWNreVRvcCA9ICRuZXN0ZWRTdGlja3kubGVuZ3RoID8gJG5lc3RlZFN0aWNreS5vZmZzZXQoKS50b3AgLSAkeVNjcm9sbC5zY3JvbGxUb3AoKSArICRuZXN0ZWRTdGlja3kuaGVpZ2h0KCkgOiAwO1xuXHRcdFx0XHRcdHZhciB0bXAsXG5cdFx0XHRcdFx0XHRvZmZzZXQgPSAkdGFibGUub2Zmc2V0KCksXG5cdFx0XHRcdFx0XHRzdGlja3lPZmZzZXQgPSBnZXRTdGlja3lPZmZzZXQoYywgd28pLFxuXHRcdFx0XHRcdFx0eVdpbmRvdyA9ICQuaXNXaW5kb3coICR5U2Nyb2xsWzBdICksIC8vICQuaXNXaW5kb3cgbmVlZHMgalF1ZXJ5IDEuNC4zXG5cdFx0XHRcdFx0XHR5U2Nyb2xsID0geVdpbmRvdyA/XG5cdFx0XHRcdFx0XHRcdCR5U2Nyb2xsLnNjcm9sbFRvcCgpIDpcblx0XHRcdFx0XHRcdFx0Ly8gdXNlIHBhcmVudCBzdGlja3kgcG9zaXRpb24gaWYgbmVzdGVkIEFORCBpbnNpZGUgb2YgYSBzY3JvbGxhYmxlIGVsZW1lbnQgLSBzZWUgIzE1MTJcblx0XHRcdFx0XHRcdFx0JG5lc3RlZFN0aWNreS5sZW5ndGggPyBwYXJzZUludCgkbmVzdGVkU3RpY2t5WzBdLnN0eWxlLnRvcCwgMTApIDogJHlTY3JvbGwub2Zmc2V0KCkudG9wLFxuXHRcdFx0XHRcdFx0YXR0YWNoVG9wID0gJGF0dGFjaC5sZW5ndGggPyB5U2Nyb2xsIDogJHlTY3JvbGwuc2Nyb2xsVG9wKCksXG5cdFx0XHRcdFx0XHRjYXB0aW9uSGVpZ2h0ID0gd28uc3RpY2t5SGVhZGVyc19pbmNsdWRlQ2FwdGlvbiA/IDAgOiAkdGFibGUuY2hpbGRyZW4oICdjYXB0aW9uJyApLmhlaWdodCgpIHx8IDAsXG5cdFx0XHRcdFx0XHRzY3JvbGxUb3AgPSBhdHRhY2hUb3AgKyBzdGlja3lPZmZzZXQgKyBuZXN0ZWRTdGlja3lUb3AgLSBjYXB0aW9uSGVpZ2h0LFxuXHRcdFx0XHRcdFx0dGFibGVIZWlnaHQgPSAkdGFibGUuaGVpZ2h0KCkgLSAoJHN0aWNreVdyYXAuaGVpZ2h0KCkgKyAoJHRmb290LmhlaWdodCgpIHx8IDApKSAtIGNhcHRpb25IZWlnaHQsXG5cdFx0XHRcdFx0XHRpc1Zpc2libGUgPSAoIHNjcm9sbFRvcCA+IG9mZnNldC50b3AgKSAmJiAoIHNjcm9sbFRvcCA8IG9mZnNldC50b3AgKyB0YWJsZUhlaWdodCApID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IGlzVmlzaWJsZSA9PT0gJ3Zpc2libGUnID8gdHMuY3NzLnN0aWNreVZpcyA6IHRzLmNzcy5zdGlja3lIaWRlLFxuXHRcdFx0XHRcdFx0bmVlZHNVcGRhdGluZyA9ICEkc3RpY2t5V3JhcC5oYXNDbGFzcyggc3RhdGUgKSxcblx0XHRcdFx0XHRcdGNzc1NldHRpbmdzID0geyB2aXNpYmlsaXR5IDogaXNWaXNpYmxlIH07XG5cdFx0XHRcdFx0aWYgKCRhdHRhY2gubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQvLyBhdHRhY2hlZCBzdGlja3kgaGVhZGVycyBhbHdheXMgbmVlZCB1cGRhdGluZ1xuXHRcdFx0XHRcdFx0bmVlZHNVcGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHRjc3NTZXR0aW5ncy50b3AgPSB5V2luZG93ID8gc2Nyb2xsVG9wIC0gJGF0dGFjaC5vZmZzZXQoKS50b3AgOiAkYXR0YWNoLnNjcm9sbFRvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBhZGp1c3Qgd2hlbiBzY3JvbGxpbmcgaG9yaXpvbnRhbGx5IC0gZml4ZXMgaXNzdWUgIzE0M1xuXHRcdFx0XHRcdHRtcCA9IGdldExlZnRQb3NpdGlvbih5V2luZG93KTtcblx0XHRcdFx0XHRpZiAodG1wICE9PSBwYXJzZUludCgkc3RpY2t5V3JhcC5jc3MoJ2xlZnQnKSwgMTApKSB7XG5cdFx0XHRcdFx0XHRuZWVkc1VwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGNzc1NldHRpbmdzLmxlZnQgPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNzc1NldHRpbmdzLnRvcCA9ICggY3NzU2V0dGluZ3MudG9wIHx8IDAgKSArXG5cdFx0XHRcdFx0XHQvLyBJZiBuZXN0ZWQgQU5EIGluc2lkZSBvZiBhIHNjcm9sbGFibGUgZWxlbWVudCwgb25seSBhZGQgcGFyZW50IHN0aWNreSBoZWlnaHRcblx0XHRcdFx0XHRcdCgheVdpbmRvdyAmJiAkbmVzdGVkU3RpY2t5Lmxlbmd0aCA/ICRuZXN0ZWRTdGlja3kuaGVpZ2h0KCkgOiBzdGlja3lPZmZzZXQgKyBuZXN0ZWRTdGlja3lUb3ApO1xuXHRcdFx0XHRcdGlmIChuZWVkc1VwZGF0aW5nKSB7XG5cdFx0XHRcdFx0XHQkc3RpY2t5V3JhcFxuXHRcdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIHRzLmNzcy5zdGlja3lWaXMgKyAnICcgKyB0cy5jc3Muc3RpY2t5SGlkZSApXG5cdFx0XHRcdFx0XHRcdC5hZGRDbGFzcyggc3RhdGUgKVxuXHRcdFx0XHRcdFx0XHQuY3NzKGNzc1NldHRpbmdzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGlzVmlzaWJsZSAhPT0gbGFzdHN0YXRlIHx8IHJlc2l6aW5nKSB7XG5cdFx0XHRcdFx0XHQvLyBtYWtlIHN1cmUgdGhlIGNvbHVtbiB3aWR0aHMgbWF0Y2hcblx0XHRcdFx0XHRcdHJlc2l6ZUhlYWRlcigpO1xuXHRcdFx0XHRcdFx0bGFzdHN0YXRlID0gaXNWaXNpYmxlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdC8vIG9ubHkgYWRkIGEgcG9zaXRpb24gcmVsYXRpdmUgaWYgYSBwb3NpdGlvbiBpc24ndCBhbHJlYWR5IGRlZmluZWRcblx0XHRcdGlmICgkYXR0YWNoLmxlbmd0aCAmJiAhJGF0dGFjaC5jc3MoJ3Bvc2l0aW9uJykpIHtcblx0XHRcdFx0JGF0dGFjaC5jc3MoJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBmaXggY2xvbmUgSUQsIGlmIGl0IGV4aXN0cyAtIGZpeGVzICMyNzFcblx0XHRcdGlmICgkc3RpY2t5VGFibGUuYXR0cignaWQnKSkgeyAkc3RpY2t5VGFibGVbMF0uaWQgKz0gd28uc3RpY2t5SGVhZGVyc19jbG9uZUlkOyB9XG5cdFx0XHQvLyBjbGVhciBvdXQgY2xvbmVkIHRhYmxlLCBleGNlcHQgZm9yIHN0aWNreSBoZWFkZXJcblx0XHRcdC8vIGluY2x1ZGUgY2FwdGlvbiAmIGZpbHRlciByb3cgKGZpeGVzICMxMjYgJiAjMjQ5KSAtIGRvbid0IHJlbW92ZSBjZWxscyB0byBnZXQgY29ycmVjdCBjZWxsIGluZGV4aW5nXG5cdFx0XHQkc3RpY2t5VGFibGUuZmluZCgnPiB0aGVhZDpndCgwKSwgdHIuc3RpY2t5LWZhbHNlJykuaGlkZSgpO1xuXHRcdFx0JHN0aWNreVRhYmxlLmZpbmQoJz4gdGJvZHksID4gdGZvb3QnKS5yZW1vdmUoKTtcblx0XHRcdCRzdGlja3lUYWJsZS5maW5kKCdjYXB0aW9uJykudG9nZ2xlKHdvLnN0aWNreUhlYWRlcnNfaW5jbHVkZUNhcHRpb24pO1xuXHRcdFx0Ly8gaXNzdWUgIzE3MiAtIGZpbmQgdGQvdGggaW4gc3RpY2t5IGhlYWRlclxuXHRcdFx0JHN0aWNreUNlbGxzID0gJHN0aWNreVRoZWFkLmNoaWxkcmVuKCkuY2hpbGRyZW4oKTtcblx0XHRcdCRzdGlja3lUYWJsZS5jc3MoeyBoZWlnaHQ6MCwgd2lkdGg6MCwgbWFyZ2luOiAwIH0pO1xuXHRcdFx0Ly8gcmVtb3ZlIHJlc2l6YWJsZSBibG9ja1xuXHRcdFx0JHN0aWNreUNlbGxzLmZpbmQoJy4nICsgdHMuY3NzLnJlc2l6ZXIpLnJlbW92ZSgpO1xuXHRcdFx0Ly8gdXBkYXRlIHN0aWNreSBoZWFkZXIgY2xhc3MgbmFtZXMgdG8gbWF0Y2ggcmVhbCBoZWFkZXIgYWZ0ZXIgc29ydGluZ1xuXHRcdFx0JHRhYmxlXG5cdFx0XHRcdC5hZGRDbGFzcygnaGFzU3RpY2t5SGVhZGVycycpXG5cdFx0XHRcdC5iaW5kKCdwYWdlckNvbXBsZXRlJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmVzaXplSGVhZGVyKCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHR0cy5iaW5kRXZlbnRzKHRhYmxlLCAkc3RpY2t5VGhlYWQuY2hpbGRyZW4oKS5jaGlsZHJlbignLicgKyB0cy5jc3MuaGVhZGVyKSk7XG5cblx0XHRcdGlmICh3by5zdGlja3lIZWFkZXJzX2FwcGVuZFRvKSB7XG5cdFx0XHRcdCQod28uc3RpY2t5SGVhZGVyc19hcHBlbmRUbykuYXBwZW5kKCAkc3RpY2t5V3JhcCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gYWRkIHN0aWNreWhlYWRlcnMgQUZURVIgdGhlIHRhYmxlLiBJZiB0aGUgdGFibGUgaXMgc2VsZWN0ZWQgYnkgSUQsIHRoZSBvcmlnaW5hbCBvbmUgKGZpcnN0KSB3aWxsIGJlIHJldHVybmVkLlxuXHRcdFx0XHQkdGFibGUuYWZ0ZXIoICRzdGlja3lXcmFwICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG9uUmVuZGVySGVhZGVyIGlzIGRlZmluZWQsIHdlIG5lZWQgdG8gZG8gc29tZXRoaW5nIGFib3V0IGl0IChmaXhlcyAjNjQxKVxuXHRcdFx0aWYgKGMub25SZW5kZXJIZWFkZXIpIHtcblx0XHRcdFx0JHQgPSAkc3RpY2t5VGhlYWQuY2hpbGRyZW4oJ3RyJykuY2hpbGRyZW4oKTtcblx0XHRcdFx0bGVuID0gJHQubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdC8vIHNlbmQgc2Vjb25kIHBhcmFtZXRlclxuXHRcdFx0XHRcdGMub25SZW5kZXJIZWFkZXIuYXBwbHkoICR0LmVxKCBpbmRleCApLCBbIGluZGV4LCBjLCAkc3RpY2t5VGFibGUgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBtYWtlIGl0IHN0aWNreSFcblx0XHRcdCR4U2Nyb2xsLmFkZCgkeVNjcm9sbClcblx0XHRcdFx0LnVuYmluZCggKCdzY3JvbGwgcmVzaXplICcuc3BsaXQoJyAnKS5qb2luKCBuYW1lc3BhY2UgKSkucmVwbGFjZSgvXFxzKy9nLCAnICcpIClcblx0XHRcdFx0LmJpbmQoJ3Njcm9sbCByZXNpemUgJy5zcGxpdCgnICcpLmpvaW4oIG5hbWVzcGFjZSApLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0c2Nyb2xsU3RpY2t5KCBldmVudC50eXBlID09PSAncmVzaXplJyApO1xuXHRcdFx0XHR9KTtcblx0XHRcdGMuJHRhYmxlXG5cdFx0XHRcdC51bmJpbmQoJ3N0aWNreUhlYWRlcnNVcGRhdGUnICsgbmFtZXNwYWNlKVxuXHRcdFx0XHQuYmluZCgnc3RpY2t5SGVhZGVyc1VwZGF0ZScgKyBuYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNjcm9sbFN0aWNreSggdHJ1ZSApO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0aWYgKHdvLnN0aWNreUhlYWRlcnNfYWRkUmVzaXplRXZlbnQpIHtcblx0XHRcdFx0dHMuYWRkSGVhZGVyUmVzaXplRXZlbnQodGFibGUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBsb29rIGZvciBmaWx0ZXIgd2lkZ2V0XG5cdFx0XHRpZiAoJHRhYmxlLmhhc0NsYXNzKCdoYXNGaWx0ZXJzJykgJiYgd28uZmlsdGVyX2NvbHVtbkZpbHRlcnMpIHtcblx0XHRcdFx0Ly8gc2Nyb2xsIHRhYmxlIGludG8gdmlldyBhZnRlciBmaWx0ZXJpbmcsIGlmIHN0aWNreSBoZWFkZXIgaXMgYWN0aXZlIC0gIzQ4MlxuXHRcdFx0XHQkdGFibGUuYmluZCgnZmlsdGVyRW5kJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gJCgnOmZvY3VzJykgbmVlZHMgalF1ZXJ5IDEuNitcblx0XHRcdFx0XHR2YXIgJHRkID0gJChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5jbG9zZXN0KCd0ZCcpLFxuXHRcdFx0XHRcdFx0Y29sdW1uID0gJHRkLnBhcmVudCgpLmNoaWxkcmVuKCkuaW5kZXgoJHRkKTtcblx0XHRcdFx0XHQvLyBvbmx5IHNjcm9sbCBpZiBzdGlja3kgaGVhZGVyIGlzIGFjdGl2ZVxuXHRcdFx0XHRcdGlmICgkc3RpY2t5V3JhcC5oYXNDbGFzcyh0cy5jc3Muc3RpY2t5VmlzKSAmJiB3by5zdGlja3lIZWFkZXJzX2ZpbHRlcmVkVG9Ub3ApIHtcblx0XHRcdFx0XHRcdC8vIHNjcm9sbCB0byBvcmlnaW5hbCB0YWJsZSAobm90IHN0aWNreSBjbG9uZSlcblx0XHRcdFx0XHRcdHdpbmRvdy5zY3JvbGxUbygwLCAkdGFibGUucG9zaXRpb24oKS50b3ApO1xuXHRcdFx0XHRcdFx0Ly8gZ2l2ZSBzYW1lIGlucHV0L3NlbGVjdCBmb2N1czsgY2hlY2sgaWYgYy4kZmlsdGVycyBleGlzdHM7IGZpeGVzICM1OTRcblx0XHRcdFx0XHRcdGlmIChjb2x1bW4gPj0gMCAmJiBjLiRmaWx0ZXJzKSB7XG5cdFx0XHRcdFx0XHRcdGMuJGZpbHRlcnMuZXEoY29sdW1uKS5maW5kKCdhLCBzZWxlY3QsIGlucHV0JykuZmlsdGVyKCc6dmlzaWJsZScpLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dHMuZmlsdGVyLmJpbmRTZWFyY2goICR0YWJsZSwgJHN0aWNreUNlbGxzLmZpbmQoJy4nICsgdHMuY3NzLmZpbHRlcikgKTtcblx0XHRcdFx0Ly8gc3VwcG9ydCBoaWRlRmlsdGVyc1xuXHRcdFx0XHRpZiAod28uZmlsdGVyX2hpZGVGaWx0ZXJzKSB7XG5cdFx0XHRcdFx0dHMuZmlsdGVyLmhpZGVGaWx0ZXJzKGMsICRzdGlja3lUYWJsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVzaXplIHRhYmxlIChGaXJlZm94KVxuXHRcdFx0aWYgKHdvLnN0aWNreUhlYWRlcnNfYWRkUmVzaXplRXZlbnQpIHtcblx0XHRcdFx0JHRhYmxlLmJpbmQoJ3Jlc2l6ZScgKyBjLm5hbWVzcGFjZSArICdzdGlja3loZWFkZXJzJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmVzaXplSGVhZGVyKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBtYWtlIHN1cmUgc3RpY2t5IGlzIHZpc2libGUgaWYgcGFnZSBpcyBwYXJ0aWFsbHkgc2Nyb2xsZWRcblx0XHRcdHNjcm9sbFN0aWNreSggdHJ1ZSApO1xuXHRcdFx0JHRhYmxlLnRyaWdnZXJIYW5kbGVyKCdzdGlja3lIZWFkZXJzSW5pdCcpO1xuXG5cdFx0fSxcblx0XHRyZW1vdmU6IGZ1bmN0aW9uKHRhYmxlLCBjLCB3bykge1xuXHRcdFx0dmFyIG5hbWVzcGFjZSA9IGMubmFtZXNwYWNlICsgJ3N0aWNreWhlYWRlcnMgJztcblx0XHRcdGMuJHRhYmxlXG5cdFx0XHRcdC5yZW1vdmVDbGFzcygnaGFzU3RpY2t5SGVhZGVycycpXG5cdFx0XHRcdC51bmJpbmQoICgncGFnZXJDb21wbGV0ZSByZXNpemUgZmlsdGVyRW5kIHN0aWNreUhlYWRlcnNVcGRhdGUgJy5zcGxpdCgnICcpLmpvaW4obmFtZXNwYWNlKSkucmVwbGFjZSgvXFxzKy9nLCAnICcpIClcblx0XHRcdFx0Lm5leHQoJy4nICsgdHMuY3NzLnN0aWNreVdyYXApLnJlbW92ZSgpO1xuXHRcdFx0aWYgKHdvLiRzdGlja3kgJiYgd28uJHN0aWNreS5sZW5ndGgpIHsgd28uJHN0aWNreS5yZW1vdmUoKTsgfSAvLyByZW1vdmUgY2xvbmVkIHRhYmxlXG5cdFx0XHQkKHdpbmRvdylcblx0XHRcdFx0LmFkZCh3by5zdGlja3lIZWFkZXJzX3hTY3JvbGwpXG5cdFx0XHRcdC5hZGQod28uc3RpY2t5SGVhZGVyc195U2Nyb2xsKVxuXHRcdFx0XHQuYWRkKHdvLnN0aWNreUhlYWRlcnNfYXR0YWNoVG8pXG5cdFx0XHRcdC51bmJpbmQoICgnc2Nyb2xsIHJlc2l6ZSAnLnNwbGl0KCcgJykuam9pbihuYW1lc3BhY2UpKS5yZXBsYWNlKC9cXHMrL2csICcgJykgKTtcblx0XHRcdHRzLmFkZEhlYWRlclJlc2l6ZUV2ZW50KHRhYmxlLCB0cnVlKTtcblx0XHR9XG5cdH0pO1xuXG59KShqUXVlcnksIHdpbmRvdyk7XG5cbi8qISBXaWRnZXQ6IHJlc2l6YWJsZSAtIHVwZGF0ZWQgMjAxOC0wMy0yNiAodjIuMzAuMikgKi9cbi8qanNoaW50IGJyb3dzZXI6dHJ1ZSwganF1ZXJ5OnRydWUsIHVudXNlZDpmYWxzZSAqL1xuOyhmdW5jdGlvbiAoJCwgd2luZG93KSB7XG5cdCd1c2Ugc3RyaWN0Jztcblx0dmFyIHRzID0gJC50YWJsZXNvcnRlciB8fCB7fTtcblxuXHQkLmV4dGVuZCh0cy5jc3MsIHtcblx0XHRyZXNpemFibGVDb250YWluZXIgOiAndGFibGVzb3J0ZXItcmVzaXphYmxlLWNvbnRhaW5lcicsXG5cdFx0cmVzaXphYmxlSGFuZGxlICAgIDogJ3RhYmxlc29ydGVyLXJlc2l6YWJsZS1oYW5kbGUnLFxuXHRcdHJlc2l6YWJsZU5vU2VsZWN0ICA6ICd0YWJsZXNvcnRlci1kaXNhYmxlU2VsZWN0aW9uJyxcblx0XHRyZXNpemFibGVTdG9yYWdlICAgOiAndGFibGVzb3J0ZXItcmVzaXphYmxlJ1xuXHR9KTtcblxuXHQvLyBBZGQgZXh0cmEgc2Nyb2xsZXIgY3NzXG5cdCQoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHMgPSAnPHN0eWxlPicgK1xuXHRcdFx0J2JvZHkuJyArIHRzLmNzcy5yZXNpemFibGVOb1NlbGVjdCArICcgeyAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7IC1tb3otdXNlci1zZWxlY3Q6IC1tb3otbm9uZTsnICtcblx0XHRcdFx0Jy1raHRtbC11c2VyLXNlbGVjdDogbm9uZTsgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgdXNlci1zZWxlY3Q6IG5vbmU7IH0nICtcblx0XHRcdCcuJyArIHRzLmNzcy5yZXNpemFibGVDb250YWluZXIgKyAnIHsgcG9zaXRpb246IHJlbGF0aXZlOyBoZWlnaHQ6IDFweDsgfScgK1xuXHRcdFx0Ly8gbWFrZSBoYW5kbGUgei1pbmRleCA+IHRoYW4gc3RpY2t5SGVhZGVyIHotaW5kZXgsIHNvIHRoZSBoYW5kbGUgc3RheXMgYWJvdmUgc3RpY2t5IGhlYWRlclxuXHRcdFx0Jy4nICsgdHMuY3NzLnJlc2l6YWJsZUhhbmRsZSArICcgeyBwb3NpdGlvbjogYWJzb2x1dGU7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgd2lkdGg6IDhweDsnICtcblx0XHRcdFx0J3RvcDogMXB4OyBjdXJzb3I6IGV3LXJlc2l6ZTsgei1pbmRleDogMzsgdXNlci1zZWxlY3Q6IG5vbmU7IC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7IH0nICtcblx0XHRcdCc8L3N0eWxlPic7XG5cdFx0JCgnaGVhZCcpLmFwcGVuZChzKTtcblx0fSk7XG5cblx0dHMucmVzaXphYmxlID0ge1xuXHRcdGluaXQgOiBmdW5jdGlvbiggYywgd28gKSB7XG5cdFx0XHRpZiAoIGMuJHRhYmxlLmhhc0NsYXNzKCAnaGFzUmVzaXphYmxlJyApICkgeyByZXR1cm47IH1cblx0XHRcdGMuJHRhYmxlLmFkZENsYXNzKCAnaGFzUmVzaXphYmxlJyApO1xuXG5cdFx0XHR2YXIgbm9SZXNpemUsICRoZWFkZXIsIGNvbHVtbiwgc3RvcmVkU2l6ZXMsIHRtcCxcblx0XHRcdFx0JHRhYmxlID0gYy4kdGFibGUsXG5cdFx0XHRcdCRwYXJlbnQgPSAkdGFibGUucGFyZW50KCksXG5cdFx0XHRcdG1hcmdpblRvcCA9IHBhcnNlSW50KCAkdGFibGUuY3NzKCAnbWFyZ2luLXRvcCcgKSwgMTAgKSxcblxuXHRcdFx0Ly8gaW50ZXJuYWwgdmFyaWFibGVzXG5cdFx0XHR2YXJzID0gd28ucmVzaXphYmxlX3ZhcnMgPSB7XG5cdFx0XHRcdHVzZVN0b3JhZ2UgOiB0cy5zdG9yYWdlICYmIHdvLnJlc2l6YWJsZSAhPT0gZmFsc2UsXG5cdFx0XHRcdCR3cmFwIDogJHBhcmVudCxcblx0XHRcdFx0bW91c2VYUG9zaXRpb24gOiAwLFxuXHRcdFx0XHQkdGFyZ2V0IDogbnVsbCxcblx0XHRcdFx0JG5leHQgOiBudWxsLFxuXHRcdFx0XHRvdmVyZmxvdyA6ICRwYXJlbnQuY3NzKCdvdmVyZmxvdycpID09PSAnYXV0bycgfHxcblx0XHRcdFx0XHQkcGFyZW50LmNzcygnb3ZlcmZsb3cnKSA9PT0gJ3Njcm9sbCcgfHxcblx0XHRcdFx0XHQkcGFyZW50LmNzcygnb3ZlcmZsb3cteCcpID09PSAnYXV0bycgfHxcblx0XHRcdFx0XHQkcGFyZW50LmNzcygnb3ZlcmZsb3cteCcpID09PSAnc2Nyb2xsJyxcblx0XHRcdFx0c3RvcmVkU2l6ZXMgOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gc2V0IGRlZmF1bHQgd2lkdGhzXG5cdFx0XHR0cy5yZXNpemFibGVSZXNldCggYy50YWJsZSwgdHJ1ZSApO1xuXG5cdFx0XHQvLyBub3cgZ2V0IG1lYXN1cmVtZW50cyFcblx0XHRcdHZhcnMudGFibGVXaWR0aCA9ICR0YWJsZS53aWR0aCgpO1xuXHRcdFx0Ly8gYXR0ZW1wdCB0byBhdXRvZGV0ZWN0XG5cdFx0XHR2YXJzLmZ1bGxXaWR0aCA9IE1hdGguYWJzKCAkcGFyZW50LndpZHRoKCkgLSB2YXJzLnRhYmxlV2lkdGggKSA8IDIwO1xuXG5cdFx0XHQvKlxuXHRcdFx0Ly8gSGFja3kgbWV0aG9kIHRvIGRldGVybWluZSBpZiB0YWJsZSB3aWR0aCBpcyBzZXQgdG8gJ2F1dG8nXG5cdFx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMDg5MjA0OC8xNDUzNDZcblx0XHRcdGlmICggIXZhcnMuZnVsbFdpZHRoICkge1xuXHRcdFx0XHR0bXAgPSAkdGFibGUud2lkdGgoKTtcblx0XHRcdFx0JGhlYWRlciA9ICR0YWJsZS53cmFwKCc8c3Bhbj4nKS5wYXJlbnQoKTsgLy8gdGVtcCB2YXJpYWJsZVxuXHRcdFx0XHRzdG9yZWRTaXplcyA9IHBhcnNlSW50KCAkdGFibGUuY3NzKCAnbWFyZ2luLWxlZnQnICksIDEwICkgfHwgMDtcblx0XHRcdFx0JHRhYmxlLmNzcyggJ21hcmdpbi1sZWZ0Jywgc3RvcmVkU2l6ZXMgKyA1MCApO1xuXHRcdFx0XHR2YXJzLnRhYmxlV2lkdGggPSAkaGVhZGVyLndpZHRoKCkgPiB0bXAgPyAnYXV0bycgOiB0bXA7XG5cdFx0XHRcdCR0YWJsZS5jc3MoICdtYXJnaW4tbGVmdCcsIHN0b3JlZFNpemVzID8gc3RvcmVkU2l6ZXMgOiAnJyApO1xuXHRcdFx0XHQkaGVhZGVyID0gbnVsbDtcblx0XHRcdFx0JHRhYmxlLnVud3JhcCgnPHNwYW4+Jyk7XG5cdFx0XHR9XG5cdFx0XHQqL1xuXG5cdFx0XHRpZiAoIHZhcnMudXNlU3RvcmFnZSAmJiB2YXJzLm92ZXJmbG93ICkge1xuXHRcdFx0XHQvLyBzYXZlIHRhYmxlIHdpZHRoXG5cdFx0XHRcdHRzLnN0b3JhZ2UoIGMudGFibGUsICd0YWJsZXNvcnRlci10YWJsZS1vcmlnaW5hbC1jc3Mtd2lkdGgnLCB2YXJzLnRhYmxlV2lkdGggKTtcblx0XHRcdFx0dG1wID0gdHMuc3RvcmFnZSggYy50YWJsZSwgJ3RhYmxlc29ydGVyLXRhYmxlLXJlc2l6ZWQtd2lkdGgnICkgfHwgJ2F1dG8nO1xuXHRcdFx0XHR0cy5yZXNpemFibGUuc2V0V2lkdGgoICR0YWJsZSwgdG1wLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0XHR3by5yZXNpemFibGVfdmFycy5zdG9yZWRTaXplcyA9IHN0b3JlZFNpemVzID0gKCB2YXJzLnVzZVN0b3JhZ2UgP1xuXHRcdFx0XHR0cy5zdG9yYWdlKCBjLnRhYmxlLCB0cy5jc3MucmVzaXphYmxlU3RvcmFnZSApIDpcblx0XHRcdFx0W10gKSB8fCBbXTtcblx0XHRcdHRzLnJlc2l6YWJsZS5zZXRXaWR0aHMoIGMsIHdvLCBzdG9yZWRTaXplcyApO1xuXHRcdFx0dHMucmVzaXphYmxlLnVwZGF0ZVN0b3JlZFNpemVzKCBjLCB3byApO1xuXG5cdFx0XHR3by4kcmVzaXphYmxlX2NvbnRhaW5lciA9ICQoICc8ZGl2IGNsYXNzPVwiJyArIHRzLmNzcy5yZXNpemFibGVDb250YWluZXIgKyAnXCI+JyApXG5cdFx0XHRcdC5jc3MoeyB0b3AgOiBtYXJnaW5Ub3AgfSlcblx0XHRcdFx0Lmluc2VydEJlZm9yZSggJHRhYmxlICk7XG5cdFx0XHQvLyBhZGQgY29udGFpbmVyXG5cdFx0XHRmb3IgKCBjb2x1bW4gPSAwOyBjb2x1bW4gPCBjLmNvbHVtbnM7IGNvbHVtbisrICkge1xuXHRcdFx0XHQkaGVhZGVyID0gYy4kaGVhZGVySW5kZXhlZFsgY29sdW1uIF07XG5cdFx0XHRcdHRtcCA9IHRzLmdldENvbHVtbkRhdGEoIGMudGFibGUsIGMuaGVhZGVycywgY29sdW1uICk7XG5cdFx0XHRcdG5vUmVzaXplID0gdHMuZ2V0RGF0YSggJGhlYWRlciwgdG1wLCAncmVzaXphYmxlJyApID09PSAnZmFsc2UnO1xuXHRcdFx0XHRpZiAoICFub1Jlc2l6ZSApIHtcblx0XHRcdFx0XHQkKCAnPGRpdiBjbGFzcz1cIicgKyB0cy5jc3MucmVzaXphYmxlSGFuZGxlICsgJ1wiPicgKVxuXHRcdFx0XHRcdFx0LmFwcGVuZFRvKCB3by4kcmVzaXphYmxlX2NvbnRhaW5lciApXG5cdFx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRcdCdkYXRhLWNvbHVtbicgOiBjb2x1bW4sXG5cdFx0XHRcdFx0XHRcdCd1bnNlbGVjdGFibGUnIDogJ29uJ1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5kYXRhKCAnaGVhZGVyJywgJGhlYWRlciApXG5cdFx0XHRcdFx0XHQuYmluZCggJ3NlbGVjdHN0YXJ0JywgZmFsc2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dHMucmVzaXphYmxlLmJpbmRpbmdzKCBjLCB3byApO1xuXHRcdH0sXG5cblx0XHR1cGRhdGVTdG9yZWRTaXplcyA6IGZ1bmN0aW9uKCBjLCB3byApIHtcblx0XHRcdHZhciBjb2x1bW4sICRoZWFkZXIsXG5cdFx0XHRcdGxlbiA9IGMuY29sdW1ucyxcblx0XHRcdFx0dmFycyA9IHdvLnJlc2l6YWJsZV92YXJzO1xuXHRcdFx0dmFycy5zdG9yZWRTaXplcyA9IFtdO1xuXHRcdFx0Zm9yICggY29sdW1uID0gMDsgY29sdW1uIDwgbGVuOyBjb2x1bW4rKyApIHtcblx0XHRcdFx0JGhlYWRlciA9IGMuJGhlYWRlckluZGV4ZWRbIGNvbHVtbiBdO1xuXHRcdFx0XHR2YXJzLnN0b3JlZFNpemVzWyBjb2x1bW4gXSA9ICRoZWFkZXIuaXMoJzp2aXNpYmxlJykgPyAkaGVhZGVyLndpZHRoKCkgOiAwO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXRXaWR0aCA6IGZ1bmN0aW9uKCAkZWwsIHdpZHRoLCBvdmVyZmxvdyApIHtcblx0XHRcdC8vIG92ZXJmbG93IHRhYmxlcyBuZWVkIG1pbiAmIG1heCB3aWR0aCBzZXQgYXMgd2VsbFxuXHRcdFx0JGVsLmNzcyh7XG5cdFx0XHRcdCd3aWR0aCcgOiB3aWR0aCxcblx0XHRcdFx0J21pbi13aWR0aCcgOiBvdmVyZmxvdyA/IHdpZHRoIDogJycsXG5cdFx0XHRcdCdtYXgtd2lkdGgnIDogb3ZlcmZsb3cgPyB3aWR0aCA6ICcnXG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0c2V0V2lkdGhzIDogZnVuY3Rpb24oIGMsIHdvLCBzdG9yZWRTaXplcyApIHtcblx0XHRcdHZhciBjb2x1bW4sICR0ZW1wLFxuXHRcdFx0XHR2YXJzID0gd28ucmVzaXphYmxlX3ZhcnMsXG5cdFx0XHRcdCRleHRyYSA9ICQoIGMubmFtZXNwYWNlICsgJ19leHRyYV9oZWFkZXJzJyApLFxuXHRcdFx0XHQkY29sID0gYy4kdGFibGUuY2hpbGRyZW4oICdjb2xncm91cCcgKS5jaGlsZHJlbiggJ2NvbCcgKTtcblx0XHRcdHN0b3JlZFNpemVzID0gc3RvcmVkU2l6ZXMgfHwgdmFycy5zdG9yZWRTaXplcyB8fCBbXTtcblx0XHRcdC8vIHByb2Nlc3Mgb25seSBpZiB0YWJsZSBJRCBvciB1cmwgbWF0Y2hcblx0XHRcdGlmICggc3RvcmVkU2l6ZXMubGVuZ3RoICkge1xuXHRcdFx0XHRmb3IgKCBjb2x1bW4gPSAwOyBjb2x1bW4gPCBjLmNvbHVtbnM7IGNvbHVtbisrICkge1xuXHRcdFx0XHRcdC8vIHNldCBzYXZlZCByZXNpemFibGUgd2lkdGhzXG5cdFx0XHRcdFx0dHMucmVzaXphYmxlLnNldFdpZHRoKCBjLiRoZWFkZXJJbmRleGVkWyBjb2x1bW4gXSwgc3RvcmVkU2l6ZXNbIGNvbHVtbiBdLCB2YXJzLm92ZXJmbG93ICk7XG5cdFx0XHRcdFx0aWYgKCAkZXh0cmEubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0Ly8gc3RpY2t5SGVhZGVycyBuZWVkcyB0byBtb2RpZnkgbWluICYgbWF4IHdpZHRoIGFzIHdlbGxcblx0XHRcdFx0XHRcdCR0ZW1wID0gJGV4dHJhLmVxKCBjb2x1bW4gKS5hZGQoICRjb2wuZXEoIGNvbHVtbiApICk7XG5cdFx0XHRcdFx0XHR0cy5yZXNpemFibGUuc2V0V2lkdGgoICR0ZW1wLCBzdG9yZWRTaXplc1sgY29sdW1uIF0sIHZhcnMub3ZlcmZsb3cgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0JHRlbXAgPSAkKCBjLm5hbWVzcGFjZSArICdfZXh0cmFfdGFibGUnICk7XG5cdFx0XHRcdGlmICggJHRlbXAubGVuZ3RoICYmICF0cy5oYXNXaWRnZXQoIGMudGFibGUsICdzY3JvbGxlcicgKSApIHtcblx0XHRcdFx0XHR0cy5yZXNpemFibGUuc2V0V2lkdGgoICR0ZW1wLCBjLiR0YWJsZS5vdXRlcldpZHRoKCksIHZhcnMub3ZlcmZsb3cgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXRIYW5kbGVQb3NpdGlvbiA6IGZ1bmN0aW9uKCBjLCB3byApIHtcblx0XHRcdHZhciBzdGFydFBvc2l0aW9uLFxuXHRcdFx0XHR0YWJsZUhlaWdodCA9IGMuJHRhYmxlLmhlaWdodCgpLFxuXHRcdFx0XHQkaGFuZGxlcyA9IHdvLiRyZXNpemFibGVfY29udGFpbmVyLmNoaWxkcmVuKCksXG5cdFx0XHRcdGhhbmRsZUNlbnRlciA9IE1hdGguZmxvb3IoICRoYW5kbGVzLndpZHRoKCkgLyAyICk7XG5cblx0XHRcdGlmICggdHMuaGFzV2lkZ2V0KCBjLnRhYmxlLCAnc2Nyb2xsZXInICkgKSB7XG5cdFx0XHRcdHRhYmxlSGVpZ2h0ID0gMDtcblx0XHRcdFx0Yy4kdGFibGUuY2xvc2VzdCggJy4nICsgdHMuY3NzLnNjcm9sbGVyV3JhcCApLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXHRcdFx0XHRcdC8vIGNlbnRlciB0YWJsZSBoYXMgYSBtYXgtaGVpZ2h0IHNldFxuXHRcdFx0XHRcdHRhYmxlSGVpZ2h0ICs9ICR0aGlzLmZpbHRlcignW3N0eWxlKj1cImhlaWdodFwiXScpLmxlbmd0aCA/ICR0aGlzLmhlaWdodCgpIDogJHRoaXMuY2hpbGRyZW4oJ3RhYmxlJykuaGVpZ2h0KCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICF3by5yZXNpemFibGVfaW5jbHVkZUZvb3RlciAmJiBjLiR0YWJsZS5jaGlsZHJlbigndGZvb3QnKS5sZW5ndGggKSB7XG5cdFx0XHRcdHRhYmxlSGVpZ2h0IC09IGMuJHRhYmxlLmNoaWxkcmVuKCd0Zm9vdCcpLmhlaWdodCgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gc3VidHJhY3Qgb3V0IHRhYmxlIGxlZnQgcG9zaXRpb24gZnJvbSByZXNpemFibGUgaGFuZGxlcy4gRml4ZXMgIzg2NFxuXHRcdFx0Ly8galF1ZXJ5IHYzLjMuMCsgYXBwZWFycyB0byBpbmNsdWRlIHRoZSBzdGFydCBwb3NpdGlvbiB3aXRoIHRoZSAkaGVhZGVyLnBvc2l0aW9uKCkubGVmdDsgc2VlICMxNTQ0XG5cdFx0XHRzdGFydFBvc2l0aW9uID0gcGFyc2VGbG9hdCgkLmZuLmpxdWVyeSkgPj0gMy4zID8gMCA6IGMuJHRhYmxlLnBvc2l0aW9uKCkubGVmdDtcblx0XHRcdCRoYW5kbGVzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgJHRoaXMgPSAkKHRoaXMpLFxuXHRcdFx0XHRcdGNvbHVtbiA9IHBhcnNlSW50KCAkdGhpcy5hdHRyKCAnZGF0YS1jb2x1bW4nICksIDEwICksXG5cdFx0XHRcdFx0Y29sdW1ucyA9IGMuY29sdW1ucyAtIDEsXG5cdFx0XHRcdFx0JGhlYWRlciA9ICR0aGlzLmRhdGEoICdoZWFkZXInICk7XG5cdFx0XHRcdGlmICggISRoZWFkZXIgKSB7IHJldHVybjsgfSAvLyBzZWUgIzg1OVxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ISRoZWFkZXIuaXMoJzp2aXNpYmxlJykgfHxcblx0XHRcdFx0XHQoICF3by5yZXNpemFibGVfYWRkTGFzdENvbHVtbiAmJiB0cy5yZXNpemFibGUuY2hlY2tWaXNpYmxlQ29sdW1ucyhjLCBjb2x1bW4pIClcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0JHRoaXMuaGlkZSgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb2x1bW4gPCBjb2x1bW5zIHx8IGNvbHVtbiA9PT0gY29sdW1ucyAmJiB3by5yZXNpemFibGVfYWRkTGFzdENvbHVtbiApIHtcblx0XHRcdFx0XHQkdGhpcy5jc3Moe1xuXHRcdFx0XHRcdFx0ZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG5cdFx0XHRcdFx0XHRoZWlnaHQgOiB0YWJsZUhlaWdodCxcblx0XHRcdFx0XHRcdGxlZnQgOiAkaGVhZGVyLnBvc2l0aW9uKCkubGVmdCAtIHN0YXJ0UG9zaXRpb24gKyAkaGVhZGVyLm91dGVyV2lkdGgoKSAtIGhhbmRsZUNlbnRlclxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Ly8gRml4ZXMgIzE0ODVcblx0XHRjaGVja1Zpc2libGVDb2x1bW5zOiBmdW5jdGlvbiggYywgY29sdW1uICkge1xuXHRcdFx0dmFyIGksXG5cdFx0XHRcdGxlbiA9IDA7XG5cdFx0XHRmb3IgKCBpID0gY29sdW1uICsgMTsgaSA8IGMuY29sdW1uczsgaSsrICkge1xuXHRcdFx0XHRsZW4gKz0gYy4kaGVhZGVySW5kZXhlZFtpXS5pcyggJzp2aXNpYmxlJyApID8gMSA6IDA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbGVuID09PSAwO1xuXHRcdH0sXG5cblx0XHQvLyBwcmV2ZW50IHRleHQgc2VsZWN0aW9uIHdoaWxlIGRyYWdnaW5nIHJlc2l6ZSBiYXJcblx0XHR0b2dnbGVUZXh0U2VsZWN0aW9uIDogZnVuY3Rpb24oIGMsIHdvLCB0b2dnbGUgKSB7XG5cdFx0XHR2YXIgbmFtZXNwYWNlID0gYy5uYW1lc3BhY2UgKyAndHNyZXNpemUnO1xuXHRcdFx0d28ucmVzaXphYmxlX3ZhcnMuZGlzYWJsZWQgPSB0b2dnbGU7XG5cdFx0XHQkKCAnYm9keScgKS50b2dnbGVDbGFzcyggdHMuY3NzLnJlc2l6YWJsZU5vU2VsZWN0LCB0b2dnbGUgKTtcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHQkKCAnYm9keScgKVxuXHRcdFx0XHRcdC5hdHRyKCAndW5zZWxlY3RhYmxlJywgJ29uJyApXG5cdFx0XHRcdFx0LmJpbmQoICdzZWxlY3RzdGFydCcgKyBuYW1lc3BhY2UsIGZhbHNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkKCAnYm9keScgKVxuXHRcdFx0XHRcdC5yZW1vdmVBdHRyKCAndW5zZWxlY3RhYmxlJyApXG5cdFx0XHRcdFx0LnVuYmluZCggJ3NlbGVjdHN0YXJ0JyArIG5hbWVzcGFjZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiaW5kaW5ncyA6IGZ1bmN0aW9uKCBjLCB3byApIHtcblx0XHRcdHZhciBuYW1lc3BhY2UgPSBjLm5hbWVzcGFjZSArICd0c3Jlc2l6ZSc7XG5cdFx0XHR3by4kcmVzaXphYmxlX2NvbnRhaW5lci5jaGlsZHJlbigpLmJpbmQoICdtb3VzZWRvd24nLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdC8vIHNhdmUgaGVhZGVyIGNlbGwgYW5kIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdHZhciBjb2x1bW4sXG5cdFx0XHRcdFx0dmFycyA9IHdvLnJlc2l6YWJsZV92YXJzLFxuXHRcdFx0XHRcdCRleHRyYXMgPSAkKCBjLm5hbWVzcGFjZSArICdfZXh0cmFfaGVhZGVycycgKSxcblx0XHRcdFx0XHQkaGVhZGVyID0gJCggZXZlbnQudGFyZ2V0ICkuZGF0YSggJ2hlYWRlcicgKTtcblxuXHRcdFx0XHRjb2x1bW4gPSBwYXJzZUludCggJGhlYWRlci5hdHRyKCAnZGF0YS1jb2x1bW4nICksIDEwICk7XG5cdFx0XHRcdHZhcnMuJHRhcmdldCA9ICRoZWFkZXIgPSAkaGVhZGVyLmFkZCggJGV4dHJhcy5maWx0ZXIoJ1tkYXRhLWNvbHVtbj1cIicgKyBjb2x1bW4gKyAnXCJdJykgKTtcblx0XHRcdFx0dmFycy50YXJnZXQgPSBjb2x1bW47XG5cblx0XHRcdFx0Ly8gaWYgdGFibGUgaXMgbm90IGFzIHdpZGUgYXMgaXQncyBwYXJlbnQsIHRoZW4gcmVzaXplIHRoZSB0YWJsZVxuXHRcdFx0XHR2YXJzLiRuZXh0ID0gZXZlbnQuc2hpZnRLZXkgfHwgd28ucmVzaXphYmxlX3RhcmdldExhc3QgP1xuXHRcdFx0XHRcdCRoZWFkZXIucGFyZW50KCkuY2hpbGRyZW4oKS5ub3QoICcucmVzaXphYmxlLWZhbHNlJyApLmZpbHRlciggJzpsYXN0JyApIDpcblx0XHRcdFx0XHQkaGVhZGVyLm5leHRBbGwoICc6bm90KC5yZXNpemFibGUtZmFsc2UpJyApLmVxKCAwICk7XG5cblx0XHRcdFx0Y29sdW1uID0gcGFyc2VJbnQoIHZhcnMuJG5leHQuYXR0ciggJ2RhdGEtY29sdW1uJyApLCAxMCApO1xuXHRcdFx0XHR2YXJzLiRuZXh0ID0gdmFycy4kbmV4dC5hZGQoICRleHRyYXMuZmlsdGVyKCdbZGF0YS1jb2x1bW49XCInICsgY29sdW1uICsgJ1wiXScpICk7XG5cdFx0XHRcdHZhcnMubmV4dCA9IGNvbHVtbjtcblxuXHRcdFx0XHR2YXJzLm1vdXNlWFBvc2l0aW9uID0gZXZlbnQucGFnZVg7XG5cdFx0XHRcdHRzLnJlc2l6YWJsZS51cGRhdGVTdG9yZWRTaXplcyggYywgd28gKTtcblx0XHRcdFx0dHMucmVzaXphYmxlLnRvZ2dsZVRleHRTZWxlY3Rpb24oYywgd28sIHRydWUgKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQkKCBkb2N1bWVudCApXG5cdFx0XHRcdC5iaW5kKCAnbW91c2Vtb3ZlJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdHZhciB2YXJzID0gd28ucmVzaXphYmxlX3ZhcnM7XG5cdFx0XHRcdFx0Ly8gaWdub3JlIG1vdXNlbW92ZSBpZiBubyBtb3VzZWRvd25cblx0XHRcdFx0XHRpZiAoICF2YXJzLmRpc2FibGVkIHx8IHZhcnMubW91c2VYUG9zaXRpb24gPT09IDAgfHwgIXZhcnMuJHRhcmdldCApIHsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0aWYgKCB3by5yZXNpemFibGVfdGhyb3R0bGUgKSB7XG5cdFx0XHRcdFx0XHRjbGVhclRpbWVvdXQoIHZhcnMudGltZXIgKTtcblx0XHRcdFx0XHRcdHZhcnMudGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dHMucmVzaXphYmxlLm1vdXNlTW92ZSggYywgd28sIGV2ZW50ICk7XG5cdFx0XHRcdFx0XHR9LCBpc05hTiggd28ucmVzaXphYmxlX3Rocm90dGxlICkgPyA1IDogd28ucmVzaXphYmxlX3Rocm90dGxlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRzLnJlc2l6YWJsZS5tb3VzZU1vdmUoIGMsIHdvLCBldmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0LmJpbmQoICdtb3VzZXVwJyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCF3by5yZXNpemFibGVfdmFycy5kaXNhYmxlZCkgeyByZXR1cm47IH1cblx0XHRcdFx0XHR0cy5yZXNpemFibGUudG9nZ2xlVGV4dFNlbGVjdGlvbiggYywgd28sIGZhbHNlICk7XG5cdFx0XHRcdFx0dHMucmVzaXphYmxlLnN0b3BSZXNpemUoIGMsIHdvICk7XG5cdFx0XHRcdFx0dHMucmVzaXphYmxlLnNldEhhbmRsZVBvc2l0aW9uKCBjLCB3byApO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmVzaXplRW5kIGV2ZW50IHRyaWdnZXJlZCBieSBzY3JvbGxlciB3aWRnZXRcblx0XHRcdCQoIHdpbmRvdyApLmJpbmQoICdyZXNpemUnICsgbmFtZXNwYWNlICsgJyByZXNpemVFbmQnICsgbmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dHMucmVzaXphYmxlLnNldEhhbmRsZVBvc2l0aW9uKCBjLCB3byApO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHJpZ2h0IGNsaWNrIHRvIHJlc2V0IGNvbHVtbnMgdG8gZGVmYXVsdCB3aWR0aHNcblx0XHRcdGMuJHRhYmxlXG5cdFx0XHRcdC5iaW5kKCAnY29sdW1uVXBkYXRlIHBhZ2VyQ29tcGxldGUgcmVzaXphYmxlVXBkYXRlICcuc3BsaXQoICcgJyApLmpvaW4oIG5hbWVzcGFjZSArICcgJyApLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0cy5yZXNpemFibGUuc2V0SGFuZGxlUG9zaXRpb24oIGMsIHdvICk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5iaW5kKCAncmVzaXphYmxlUmVzZXQnICsgbmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0cy5yZXNpemFibGVSZXNldCggYy50YWJsZSApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuZmluZCggJ3RoZWFkOmZpcnN0JyApXG5cdFx0XHRcdC5hZGQoICQoIGMubmFtZXNwYWNlICsgJ19leHRyYV90YWJsZScgKS5maW5kKCAndGhlYWQ6Zmlyc3QnICkgKVxuXHRcdFx0XHQuYmluZCggJ2NvbnRleHRtZW51JyArIG5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gJC5pc0VtcHR5T2JqZWN0KCkgbmVlZHMgalF1ZXJ5IDEuNCs7IGFsbG93IHJpZ2h0IGNsaWNrIGlmIGFscmVhZHkgcmVzZXRcblx0XHRcdFx0XHR2YXIgYWxsb3dDbGljayA9IHdvLnJlc2l6YWJsZV92YXJzLnN0b3JlZFNpemVzLmxlbmd0aCA9PT0gMDtcblx0XHRcdFx0XHR0cy5yZXNpemFibGVSZXNldCggYy50YWJsZSApO1xuXHRcdFx0XHRcdHRzLnJlc2l6YWJsZS5zZXRIYW5kbGVQb3NpdGlvbiggYywgd28gKTtcblx0XHRcdFx0XHR3by5yZXNpemFibGVfdmFycy5zdG9yZWRTaXplcyA9IFtdO1xuXHRcdFx0XHRcdHJldHVybiBhbGxvd0NsaWNrO1xuXHRcdFx0XHR9KTtcblxuXHRcdH0sXG5cblx0XHRtb3VzZU1vdmUgOiBmdW5jdGlvbiggYywgd28sIGV2ZW50ICkge1xuXHRcdFx0aWYgKCB3by5yZXNpemFibGVfdmFycy5tb3VzZVhQb3NpdGlvbiA9PT0gMCB8fCAhd28ucmVzaXphYmxlX3ZhcnMuJHRhcmdldCApIHsgcmV0dXJuOyB9XG5cdFx0XHQvLyByZXNpemUgY29sdW1uc1xuXHRcdFx0dmFyIGNvbHVtbixcblx0XHRcdFx0dG90YWwgPSAwLFxuXHRcdFx0XHR2YXJzID0gd28ucmVzaXphYmxlX3ZhcnMsXG5cdFx0XHRcdCRuZXh0ID0gdmFycy4kbmV4dCxcblx0XHRcdFx0dGFyID0gdmFycy5zdG9yZWRTaXplc1sgdmFycy50YXJnZXQgXSxcblx0XHRcdFx0bGVmdEVkZ2UgPSBldmVudC5wYWdlWCAtIHZhcnMubW91c2VYUG9zaXRpb247XG5cdFx0XHRpZiAoIHZhcnMub3ZlcmZsb3cgKSB7XG5cdFx0XHRcdGlmICggdGFyICsgbGVmdEVkZ2UgPiAwICkge1xuXHRcdFx0XHRcdHZhcnMuc3RvcmVkU2l6ZXNbIHZhcnMudGFyZ2V0IF0gKz0gbGVmdEVkZ2U7XG5cdFx0XHRcdFx0dHMucmVzaXphYmxlLnNldFdpZHRoKCB2YXJzLiR0YXJnZXQsIHZhcnMuc3RvcmVkU2l6ZXNbIHZhcnMudGFyZ2V0IF0sIHRydWUgKTtcblx0XHRcdFx0XHQvLyB1cGRhdGUgdGhlIGVudGlyZSB0YWJsZSB3aWR0aFxuXHRcdFx0XHRcdGZvciAoIGNvbHVtbiA9IDA7IGNvbHVtbiA8IGMuY29sdW1uczsgY29sdW1uKysgKSB7XG5cdFx0XHRcdFx0XHR0b3RhbCArPSB2YXJzLnN0b3JlZFNpemVzWyBjb2x1bW4gXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHMucmVzaXphYmxlLnNldFdpZHRoKCBjLiR0YWJsZS5hZGQoICQoIGMubmFtZXNwYWNlICsgJ19leHRyYV90YWJsZScgKSApLCB0b3RhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggISRuZXh0Lmxlbmd0aCApIHtcblx0XHRcdFx0XHQvLyBpZiBleHBhbmRpbmcgcmlnaHQtbW9zdCBjb2x1bW4sIHNjcm9sbCB0aGUgd3JhcHBlclxuXHRcdFx0XHRcdHZhcnMuJHdyYXBbMF0uc2Nyb2xsTGVmdCA9IGMuJHRhYmxlLndpZHRoKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHZhcnMuZnVsbFdpZHRoICkge1xuXHRcdFx0XHR2YXJzLnN0b3JlZFNpemVzWyB2YXJzLnRhcmdldCBdICs9IGxlZnRFZGdlO1xuXHRcdFx0XHR2YXJzLnN0b3JlZFNpemVzWyB2YXJzLm5leHQgXSAtPSBsZWZ0RWRnZTtcblx0XHRcdFx0dHMucmVzaXphYmxlLnNldFdpZHRocyggYywgd28gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhcnMuc3RvcmVkU2l6ZXNbIHZhcnMudGFyZ2V0IF0gKz0gbGVmdEVkZ2U7XG5cdFx0XHRcdHRzLnJlc2l6YWJsZS5zZXRXaWR0aHMoIGMsIHdvICk7XG5cdFx0XHR9XG5cdFx0XHR2YXJzLm1vdXNlWFBvc2l0aW9uID0gZXZlbnQucGFnZVg7XG5cdFx0XHQvLyBkeW5hbWljYWxseSB1cGRhdGUgc3RpY2t5IGhlYWRlciB3aWR0aHNcblx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCdzdGlja3lIZWFkZXJzVXBkYXRlJyk7XG5cdFx0fSxcblxuXHRcdHN0b3BSZXNpemUgOiBmdW5jdGlvbiggYywgd28gKSB7XG5cdFx0XHR2YXIgdmFycyA9IHdvLnJlc2l6YWJsZV92YXJzO1xuXHRcdFx0dHMucmVzaXphYmxlLnVwZGF0ZVN0b3JlZFNpemVzKCBjLCB3byApO1xuXHRcdFx0aWYgKCB2YXJzLnVzZVN0b3JhZ2UgKSB7XG5cdFx0XHRcdC8vIHNhdmUgYWxsIGNvbHVtbiB3aWR0aHNcblx0XHRcdFx0dHMuc3RvcmFnZSggYy50YWJsZSwgdHMuY3NzLnJlc2l6YWJsZVN0b3JhZ2UsIHZhcnMuc3RvcmVkU2l6ZXMgKTtcblx0XHRcdFx0dHMuc3RvcmFnZSggYy50YWJsZSwgJ3RhYmxlc29ydGVyLXRhYmxlLXJlc2l6ZWQtd2lkdGgnLCBjLiR0YWJsZS53aWR0aCgpICk7XG5cdFx0XHR9XG5cdFx0XHR2YXJzLm1vdXNlWFBvc2l0aW9uID0gMDtcblx0XHRcdHZhcnMuJHRhcmdldCA9IHZhcnMuJG5leHQgPSBudWxsO1xuXHRcdFx0Ly8gd2lsbCB1cGRhdGUgc3RpY2t5SGVhZGVycywganVzdCBpbiBjYXNlLCBzZWUgIzkxMlxuXHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoJ3N0aWNreUhlYWRlcnNVcGRhdGUnKTtcblx0XHRcdGMuJHRhYmxlLnRyaWdnZXJIYW5kbGVyKCdyZXNpemFibGVDb21wbGV0ZScpO1xuXHRcdH1cblx0fTtcblxuXHQvLyB0aGlzIHdpZGdldCBzYXZlcyB0aGUgY29sdW1uIHdpZHRocyBpZlxuXHQvLyAkLnRhYmxlc29ydGVyLnN0b3JhZ2UgZnVuY3Rpb24gaXMgaW5jbHVkZWRcblx0Ly8gKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0dHMuYWRkV2lkZ2V0KHtcblx0XHRpZDogJ3Jlc2l6YWJsZScsXG5cdFx0cHJpb3JpdHk6IDQwLFxuXHRcdG9wdGlvbnM6IHtcblx0XHRcdHJlc2l6YWJsZSA6IHRydWUsIC8vIHNhdmUgY29sdW1uIHdpZHRocyB0byBzdG9yYWdlXG5cdFx0XHRyZXNpemFibGVfYWRkTGFzdENvbHVtbiA6IGZhbHNlLFxuXHRcdFx0cmVzaXphYmxlX2luY2x1ZGVGb290ZXI6IHRydWUsXG5cdFx0XHRyZXNpemFibGVfd2lkdGhzIDogW10sXG5cdFx0XHRyZXNpemFibGVfdGhyb3R0bGUgOiBmYWxzZSwgLy8gc2V0IHRvIHRydWUgKDVtcykgb3IgYW55IG51bWJlciAwLTEwIHJhbmdlXG5cdFx0XHRyZXNpemFibGVfdGFyZ2V0TGFzdCA6IGZhbHNlXG5cdFx0fSxcblx0XHRpbml0OiBmdW5jdGlvbih0YWJsZSwgdGhpc1dpZGdldCwgYywgd28pIHtcblx0XHRcdHRzLnJlc2l6YWJsZS5pbml0KCBjLCB3byApO1xuXHRcdH0sXG5cdFx0Zm9ybWF0OiBmdW5jdGlvbiggdGFibGUsIGMsIHdvICkge1xuXHRcdFx0dHMucmVzaXphYmxlLnNldEhhbmRsZVBvc2l0aW9uKCBjLCB3byApO1xuXHRcdH0sXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiggdGFibGUsIGMsIHdvLCByZWZyZXNoaW5nICkge1xuXHRcdFx0aWYgKHdvLiRyZXNpemFibGVfY29udGFpbmVyKSB7XG5cdFx0XHRcdHZhciBuYW1lc3BhY2UgPSBjLm5hbWVzcGFjZSArICd0c3Jlc2l6ZSc7XG5cdFx0XHRcdGMuJHRhYmxlLmFkZCggJCggYy5uYW1lc3BhY2UgKyAnX2V4dHJhX3RhYmxlJyApIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoJ2hhc1Jlc2l6YWJsZScpXG5cdFx0XHRcdFx0LmNoaWxkcmVuKCAndGhlYWQnIClcblx0XHRcdFx0XHQudW5iaW5kKCAnY29udGV4dG1lbnUnICsgbmFtZXNwYWNlICk7XG5cblx0XHRcdFx0d28uJHJlc2l6YWJsZV9jb250YWluZXIucmVtb3ZlKCk7XG5cdFx0XHRcdHRzLnJlc2l6YWJsZS50b2dnbGVUZXh0U2VsZWN0aW9uKCBjLCB3bywgZmFsc2UgKTtcblx0XHRcdFx0dHMucmVzaXphYmxlUmVzZXQoIHRhYmxlLCByZWZyZXNoaW5nICk7XG5cdFx0XHRcdCQoIGRvY3VtZW50ICkudW5iaW5kKCAnbW91c2Vtb3ZlJyArIG5hbWVzcGFjZSArICcgbW91c2V1cCcgKyBuYW1lc3BhY2UgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHRzLnJlc2l6YWJsZVJlc2V0ID0gZnVuY3Rpb24oIHRhYmxlLCByZWZyZXNoaW5nICkge1xuXHRcdCQoIHRhYmxlICkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCwgJHQsXG5cdFx0XHRcdGMgPSB0aGlzLmNvbmZpZyxcblx0XHRcdFx0d28gPSBjICYmIGMud2lkZ2V0T3B0aW9ucyxcblx0XHRcdFx0dmFycyA9IHdvLnJlc2l6YWJsZV92YXJzO1xuXHRcdFx0aWYgKCB0YWJsZSAmJiBjICYmIGMuJGhlYWRlckluZGV4ZWQubGVuZ3RoICkge1xuXHRcdFx0XHQvLyByZXN0b3JlIHRoZSBpbml0aWFsIHRhYmxlIHdpZHRoXG5cdFx0XHRcdGlmICggdmFycy5vdmVyZmxvdyAmJiB2YXJzLnRhYmxlV2lkdGggKSB7XG5cdFx0XHRcdFx0dHMucmVzaXphYmxlLnNldFdpZHRoKCBjLiR0YWJsZSwgdmFycy50YWJsZVdpZHRoLCB0cnVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YXJzLnVzZVN0b3JhZ2UgKSB7XG5cdFx0XHRcdFx0XHR0cy5zdG9yYWdlKCB0YWJsZSwgJ3RhYmxlc29ydGVyLXRhYmxlLXJlc2l6ZWQtd2lkdGgnLCB2YXJzLnRhYmxlV2lkdGggKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGMuY29sdW1uczsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHQkdCA9IGMuJGhlYWRlckluZGV4ZWRbIGluZGV4IF07XG5cdFx0XHRcdFx0aWYgKCB3by5yZXNpemFibGVfd2lkdGhzICYmIHdvLnJlc2l6YWJsZV93aWR0aHNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0XHR0cy5yZXNpemFibGUuc2V0V2lkdGgoICR0LCB3by5yZXNpemFibGVfd2lkdGhzWyBpbmRleCBdLCB2YXJzLm92ZXJmbG93ICk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggISR0Lmhhc0NsYXNzKCAncmVzaXphYmxlLWZhbHNlJyApICkge1xuXHRcdFx0XHRcdFx0Ly8gZG9uJ3QgY2xlYXIgdGhlIHdpZHRoIG9mIGFueSBjb2x1bW4gdGhhdCBpcyBub3QgcmVzaXphYmxlXG5cdFx0XHRcdFx0XHR0cy5yZXNpemFibGUuc2V0V2lkdGgoICR0LCAnJywgdmFycy5vdmVyZmxvdyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlc2V0IHN0aWNreUhlYWRlciB3aWR0aHNcblx0XHRcdFx0Yy4kdGFibGUudHJpZ2dlckhhbmRsZXIoICdzdGlja3lIZWFkZXJzVXBkYXRlJyApO1xuXHRcdFx0XHRpZiAoIHRzLnN0b3JhZ2UgJiYgIXJlZnJlc2hpbmcgKSB7XG5cdFx0XHRcdFx0dHMuc3RvcmFnZSggdGhpcywgdHMuY3NzLnJlc2l6YWJsZVN0b3JhZ2UsIFtdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxufSkoIGpRdWVyeSwgd2luZG93ICk7XG5cbi8qISBXaWRnZXQ6IHNhdmVTb3J0IC0gdXBkYXRlZCAyMDE4LTAzLTE5ICh2Mi4zMC4xKSAqLy8qXG4qIFJlcXVpcmVzIHRhYmxlc29ydGVyIHYyLjE2K1xuKiBieSBSb2IgR2Fycmlzb25cbiovXG47KGZ1bmN0aW9uICgkKSB7XG5cdCd1c2Ugc3RyaWN0Jztcblx0dmFyIHRzID0gJC50YWJsZXNvcnRlciB8fCB7fTtcblxuXHRmdW5jdGlvbiBnZXRTdG9yZWRTb3J0TGlzdChjKSB7XG5cdFx0dmFyIHN0b3JlZCA9IHRzLnN0b3JhZ2UoIGMudGFibGUsICd0YWJsZXNvcnRlci1zYXZlc29ydCcgKTtcblx0XHRyZXR1cm4gKHN0b3JlZCAmJiBzdG9yZWQuaGFzT3duUHJvcGVydHkoJ3NvcnRMaXN0JykgJiYgJC5pc0FycmF5KHN0b3JlZC5zb3J0TGlzdCkpID8gc3RvcmVkLnNvcnRMaXN0IDogW107XG5cdH1cblxuXHRmdW5jdGlvbiBzb3J0TGlzdENoYW5nZWQoYywgc29ydExpc3QpIHtcblx0XHRyZXR1cm4gKHNvcnRMaXN0IHx8IGdldFN0b3JlZFNvcnRMaXN0KGMpKS5qb2luKCcsJykgIT09IGMuc29ydExpc3Quam9pbignLCcpO1xuXHR9XG5cblx0Ly8gdGhpcyB3aWRnZXQgc2F2ZXMgdGhlIGxhc3Qgc29ydCBvbmx5IGlmIHRoZVxuXHQvLyBzYXZlU29ydCB3aWRnZXQgb3B0aW9uIGlzIHRydWUgQU5EIHRoZVxuXHQvLyAkLnRhYmxlc29ydGVyLnN0b3JhZ2UgZnVuY3Rpb24gaXMgaW5jbHVkZWRcblx0Ly8gKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0dHMuYWRkV2lkZ2V0KHtcblx0XHRpZDogJ3NhdmVTb3J0Jyxcblx0XHRwcmlvcml0eTogMjAsXG5cdFx0b3B0aW9uczoge1xuXHRcdFx0c2F2ZVNvcnQgOiB0cnVlXG5cdFx0fSxcblx0XHRpbml0OiBmdW5jdGlvbih0YWJsZSwgdGhpc1dpZGdldCwgYywgd28pIHtcblx0XHRcdC8vIHJ1biB3aWRnZXQgZm9ybWF0IGJlZm9yZSBhbGwgb3RoZXIgd2lkZ2V0cyBhcmUgYXBwbGllZCB0byB0aGUgdGFibGVcblx0XHRcdHRoaXNXaWRnZXQuZm9ybWF0KHRhYmxlLCBjLCB3bywgdHJ1ZSk7XG5cdFx0fSxcblx0XHRmb3JtYXQ6IGZ1bmN0aW9uKHRhYmxlLCBjLCB3bywgaW5pdCkge1xuXHRcdFx0dmFyIHRpbWUsXG5cdFx0XHRcdCR0YWJsZSA9IGMuJHRhYmxlLFxuXHRcdFx0XHRzYXZlU29ydCA9IHdvLnNhdmVTb3J0ICE9PSBmYWxzZSwgLy8gbWFrZSBzYXZlU29ydCBhY3RpdmUvaW5hY3RpdmU7IGRlZmF1bHQgdG8gdHJ1ZVxuXHRcdFx0XHRzb3J0TGlzdCA9IHsgJ3NvcnRMaXN0JyA6IGMuc29ydExpc3QgfSxcblx0XHRcdFx0ZGVidWcgPSB0cy5kZWJ1ZyhjLCAnc2F2ZVNvcnQnKTtcblx0XHRcdGlmIChkZWJ1Zykge1xuXHRcdFx0XHR0aW1lID0gbmV3IERhdGUoKTtcblx0XHRcdH1cblx0XHRcdGlmICgkdGFibGUuaGFzQ2xhc3MoJ2hhc1NhdmVTb3J0JykpIHtcblx0XHRcdFx0aWYgKHNhdmVTb3J0ICYmIHRhYmxlLmhhc0luaXRpYWxpemVkICYmIHRzLnN0b3JhZ2UgJiYgc29ydExpc3RDaGFuZ2VkKGMpKSB7XG5cdFx0XHRcdFx0dHMuc3RvcmFnZSggdGFibGUsICd0YWJsZXNvcnRlci1zYXZlc29ydCcsIHNvcnRMaXN0ICk7XG5cdFx0XHRcdFx0aWYgKGRlYnVnKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZygnc2F2ZVNvcnQgPj4gU2F2aW5nIGxhc3Qgc29ydDogJyArIGMuc29ydExpc3QgKyB0cy5iZW5jaG1hcmsodGltZSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gc2V0IHRhYmxlIHNvcnQgb24gaW5pdGlhbCBydW4gb2YgdGhlIHdpZGdldFxuXHRcdFx0XHQkdGFibGUuYWRkQ2xhc3MoJ2hhc1NhdmVTb3J0Jyk7XG5cdFx0XHRcdHNvcnRMaXN0ID0gJyc7XG5cdFx0XHRcdC8vIGdldCBkYXRhXG5cdFx0XHRcdGlmICh0cy5zdG9yYWdlKSB7XG5cdFx0XHRcdFx0c29ydExpc3QgPSBnZXRTdG9yZWRTb3J0TGlzdChjKTtcblx0XHRcdFx0XHRpZiAoZGVidWcpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCdzYXZlU29ydCA+PiBMYXN0IHNvcnQgbG9hZGVkOiBcIicgKyBzb3J0TGlzdCArICdcIicgKyB0cy5iZW5jaG1hcmsodGltZSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQkdGFibGUuYmluZCgnc2F2ZVNvcnRSZXNldCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdHRzLnN0b3JhZ2UoIHRhYmxlLCAndGFibGVzb3J0ZXItc2F2ZXNvcnQnLCAnJyApO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGluaXQgaXMgdHJ1ZSB3aGVuIHdpZGdldCBpbml0IGlzIHJ1biwgdGhpcyB3aWxsIHJ1biB0aGlzIHdpZGdldCBiZWZvcmUgYWxsIG90aGVyIHdpZGdldHMgaGF2ZSBpbml0aWFsaXplZFxuXHRcdFx0XHQvLyB0aGlzIG1ldGhvZCBhbGxvd3MgdXNpbmcgdGhpcyB3aWRnZXQgaW4gdGhlIG9yaWdpbmFsIHRhYmxlc29ydGVyIHBsdWdpbjsgYnV0IHRoZW4gaXQgd2lsbCBydW4gYWxsIHdpZGdldHMgdHdpY2UuXG5cdFx0XHRcdGlmIChpbml0ICYmIHNvcnRMaXN0ICYmIHNvcnRMaXN0Lmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRjLnNvcnRMaXN0ID0gc29ydExpc3Q7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGFibGUuaGFzSW5pdGlhbGl6ZWQgJiYgc29ydExpc3QgJiYgc29ydExpc3QubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdC8vIHVwZGF0ZSBzb3J0IGNoYW5nZVxuXHRcdFx0XHRcdGlmIChzb3J0TGlzdENoYW5nZWQoYywgc29ydExpc3QpKSB7XG5cdFx0XHRcdFx0XHR0cy5zb3J0T24oYywgc29ydExpc3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbih0YWJsZSwgYykge1xuXHRcdFx0Yy4kdGFibGUucmVtb3ZlQ2xhc3MoJ2hhc1NhdmVTb3J0Jyk7XG5cdFx0XHQvLyBjbGVhciBzdG9yYWdlXG5cdFx0XHRpZiAodHMuc3RvcmFnZSkgeyB0cy5zdG9yYWdlKCB0YWJsZSwgJ3RhYmxlc29ydGVyLXNhdmVzb3J0JywgJycgKTsgfVxuXHRcdH1cblx0fSk7XG5cbn0pKGpRdWVyeSk7XG5cbnJldHVybiBqUXVlcnkudGFibGVzb3J0ZXI7XG59KSk7XG4iLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoIChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcbiIsImltcG9ydCAqIGFzICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0ICdib290c3RyYXAnXG5pbXBvcnQgJ3NwYXJrbGluZSdcbmltcG9ydCAnc2VsZWN0aXplJ1xuaW1wb3J0ICd0YWJsZXNvcnRlcidcbmltcG9ydCAnanZlY3Rvcm1hcCdcbmltcG9ydCAnanF1ZXJ5LWNpcmNsZS1wcm9ncmVzcydcbmltcG9ydCAqIGFzIGMzIGZyb20gJ2MzJ1xuaW1wb3J0ICdqcXVlcnktbWFzay1wbHVnaW4nXG5cbndpbmRvdy5jMyA9IGMzXG53aW5kb3cuJCA9ICRcblxuaW1wb3J0ICcuL2NvcmUnXG4iXSwic291cmNlUm9vdCI6IiJ9